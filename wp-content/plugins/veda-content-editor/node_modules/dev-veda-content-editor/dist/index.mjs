var II = Object.defineProperty;
var LI = (e, t, n) => t in e ? II(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var or = (e, t, n) => LI(e, typeof t != "symbol" ? t + "" : t, n);
import * as MI from "react/jsx-runtime";
import { jsx as A, jsxs as Oe, Fragment as Ut } from "react/jsx-runtime";
import * as w from "react";
import T, { createContext as al, useContext as ll, useMemo as Jo, useLayoutEffect as Ko, useEffect as Le, forwardRef as wi, useState as Re, useCallback as Ht, useRef as $e, Suspense as ng, createElement as c5, useReducer as rC, cloneElement as OI, Component as PI, memo as B, useImperativeHandle as _2 } from "react";
import * as Dh from "react-dom";
import iC, { flushSync as DI, createPortal as FI } from "react-dom";
import RI from "focus-trap-react";
import { ReactQueryProvider as $I, VedaUIProvider as VI, DevseedUiThemeProvider as BI, Chart as zI, MapBlock as HI, LegacyGlobalStyles as UI, Chapter as jI, Image as WI, Figure as JI, Caption as KI, Prose as qI, Block as GI } from "@teamimpact/veda-ui";
import { createUITheme as YI } from "@devseed-ui/theme-provider";
import "@teamimpact/veda-ui/lib/main.css";
function XI(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ZI = XI(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const sC = al(null);
function QI(e, t) {
  return { getTheme: function() {
    return t ?? null;
  } };
}
function oC() {
  const e = ll(sC);
  return e == null && ZI(8), e;
}
const b2 = {}, eL = {}, Qf = {}, Sf = {}, u5 = {}, Ql = {}, aC = {}, f5 = {}, ed = {}, td = {}, yo = {}, lC = {}, cC = {}, tL = {}, nL = {}, rL = {}, iL = {}, sL = {}, oL = {}, aL = {}, rg = {}, lL = {}, cL = {}, uL = {}, fL = {}, dL = {}, hL = {}, pL = {}, mL = {}, gL = {}, uC = {}, fC = {}, d5 = {}, vL = {}, yL = {}, xL = {}, Kr = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, wL = Kr && "documentMode" in document ? document.documentMode : null, Nr = Kr && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Ps = Kr && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), nd = !(!Kr || !("InputEvent" in window) || wL) && "getTargetRanges" in new window.InputEvent("input"), Fh = Kr && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), Wc = Kr && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, _L = Kr && /Android/.test(navigator.userAgent), dC = Kr && /^(?=.*Chrome).*/i.test(navigator.userAgent), bL = Kr && _L && dC, C2 = Kr && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !dC, CL = 1, EL = 3, SL = 9, kL = 11, No = 0, hC = 1, Va = 2, TL = 0, AL = 1, NL = 2, rd = 4, id = 8, E2 = 128, IL = 1792 | (112 | (3 | rd | id) | E2), S2 = 1, k2 = 2, T2 = 3, A2 = 4, N2 = 5, I2 = 6, Rh = Fh || Wc || C2 ? " " : "​", Gi = `

`, LL = Ps ? " " : Rh, pC = "֑-߿יִ-﷽ﹰ-ﻼ", mC = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", ML = new RegExp("^[^" + mC + "]*[" + pC + "]"), OL = new RegExp("^[^" + pC + "]*[" + mC + "]"), Io = { bold: 1, capitalize: 1024, code: 16, highlight: E2, italic: 2, lowercase: 256, strikethrough: rd, subscript: 32, superscript: 64, underline: id, uppercase: 512 }, PL = { directionless: 1, unmergeable: 2 }, h5 = { center: k2, end: I2, justify: A2, left: S2, right: T2, start: N2 }, DL = { [k2]: "center", [I2]: "end", [A2]: "justify", [S2]: "left", [T2]: "right", [N2]: "start" }, FL = { normal: 0, segmented: 2, token: 1 }, RL = { [TL]: "normal", [NL]: "segmented", [AL]: "token" };
function $L(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var we = $L(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
function sd(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
const VL = 100;
let ig = !1, L2 = 0;
function BL(e) {
  L2 = e.timeStamp;
}
function l1(e, t, n) {
  const r = e.nodeName === "BR", i = t.__lexicalLineBreak;
  return i && (e === i || r && e.previousSibling === i) || r && Bh(e, n) !== void 0;
}
function zL(e, t, n) {
  const r = Yi(n._window);
  let i = null, s = null;
  r !== null && r.anchorNode === e && (i = r.anchorOffset, s = r.focusOffset);
  const o = e.nodeValue;
  o !== null && F2(t, o, i, s, !1);
}
function HL(e, t, n) {
  if (Ve(e)) {
    const r = e.anchor.getNode();
    if (r.is(n) && e.format !== r.getFormat()) return !1;
  }
  return os(t) && n.isAttached();
}
function UL(e, t, n, r) {
  for (let i = e; i && !rM(i); i = Jc(i)) {
    const s = Bh(i, t);
    if (s !== void 0) {
      const o = un(s, n);
      if (o) return Dt(o) || !Sr(i) ? void 0 : [i, o];
    } else if (i === r) return [r, CC(n)];
  }
}
function gC(e, t, n) {
  ig = !0;
  const r = performance.now() - L2 > VL;
  try {
    hr(e, () => {
      const i = St() || function(d) {
        return d.getEditorState().read(() => {
          const h = St();
          return h !== null ? h.clone() : null;
        });
      }(e), s = /* @__PURE__ */ new Map(), o = e.getRootElement(), a = e._editorState, l = e._blockCursorElement;
      let c = !1, u = "";
      for (let d = 0; d < t.length; d++) {
        const h = t[d], m = h.type, p = h.target, y = UL(p, e, a, o);
        if (!y) continue;
        const [v, g] = y;
        if (m === "characterData") r && ke(g) && os(p) && HL(i, p, g) && zL(p, g, e);
        else if (m === "childList") {
          c = !0;
          const x = h.addedNodes;
          for (let C = 0; C < x.length; C++) {
            const E = x[C], S = _C(E), k = E.parentNode;
            if (k != null && E !== l && S === null && !l1(E, k, e)) {
              if (Ps) {
                const M = (Sr(E) ? E.innerText : null) || E.nodeValue;
                M && (u += M);
              }
              k.removeChild(E);
            }
          }
          const _ = h.removedNodes, b = _.length;
          if (b > 0) {
            let C = 0;
            for (let E = 0; E < b; E++) {
              const S = _[E];
              (l1(S, p, e) || l === S) && (p.appendChild(S), C++);
            }
            b !== C && s.set(v, g);
          }
        }
      }
      if (s.size > 0) for (const [d, h] of s) h.reconcileObservedMutation(d, e);
      const f = n.takeRecords();
      if (f.length > 0) {
        for (let d = 0; d < f.length; d++) {
          const h = f[d], m = h.addedNodes, p = h.target;
          for (let y = 0; y < m.length; y++) {
            const v = m[y], g = v.parentNode;
            g == null || v.nodeName !== "BR" || l1(v, p, e) || g.removeChild(v);
          }
        }
        n.takeRecords();
      }
      i !== null && (c && (i.dirty = !0, $s(i)), Ps && TC(e) && i.insertRawText(u));
    });
  } finally {
    ig = !1;
  }
}
function vC(e) {
  const t = e._observer;
  t !== null && gC(e, t.takeRecords(), t);
}
function yC(e) {
  (function(t) {
    L2 === 0 && Hh(t).addEventListener("textInput", BL, !0);
  })(e), e._observer = new MutationObserver((t, n) => {
    gC(e, t, n);
  });
}
function p5(e, t) {
  const n = e.__mode, r = e.__format, i = e.__style, s = t.__mode, o = t.__format, a = t.__style;
  return !(n !== null && n !== s || r !== null && r !== o || i !== null && i !== a);
}
function m5(e, t) {
  const n = e.mergeWithSibling(t), r = Wt()._normalizedNodes;
  return r.add(e.__key), r.add(t.__key), n;
}
function g5(e) {
  let t, n, r = e;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (t = r.getPreviousSibling()) !== null && ke(t) && t.isSimpleText() && !t.isUnmergeable(); ) {
      if (t.__text !== "") {
        if (p5(t, r)) {
          r = m5(t, r);
          break;
        }
        break;
      }
      t.remove();
    }
    for (; (n = r.getNextSibling()) !== null && ke(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (p5(r, n)) {
          r = m5(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
let jL = 1;
const WL = typeof queueMicrotask == "function" ? queueMicrotask : (e) => {
  Promise.resolve().then(e);
};
function xC(e) {
  const t = document.activeElement;
  if (!Sr(t)) return !1;
  const n = t.nodeName;
  return Dt(O2(e)) && (n === "INPUT" || n === "TEXTAREA" || t.contentEditable === "true" && Vh(t) == null);
}
function $h(e, t, n) {
  const r = e.getRootElement();
  try {
    return r !== null && r.contains(t) && r.contains(n) && t !== null && !xC(t) && wC(t) === e;
  } catch {
    return !1;
  }
}
function M2(e) {
  return e instanceof Yh;
}
function wC(e) {
  let t = e;
  for (; t != null; ) {
    const n = Vh(t);
    if (M2(n)) return n;
    t = Jc(t);
  }
  return null;
}
function Vh(e) {
  return e ? e.__lexicalEditor : null;
}
function fo(e) {
  return e.isToken() || e.isSegmented();
}
function os(e) {
  return qc(e) && e.nodeType === EL;
}
function JL(e) {
  return qc(e) && e.nodeType === SL;
}
function od(e) {
  let t = e;
  for (; t != null; ) {
    if (os(t)) return t;
    t = t.firstChild;
  }
  return null;
}
function ad(e, t, n) {
  const r = Io[t];
  if (n !== null && (e & r) == (n & r)) return e;
  let i = e ^ r;
  return t === "subscript" ? i &= -65 : t === "superscript" ? i &= -33 : t === "lowercase" ? (i &= -513, i &= -1025) : t === "uppercase" ? (i &= -257, i &= -1025) : t === "capitalize" && (i &= -257, i &= -513), i;
}
function KL(e, t) {
  if (t != null) return void (e.__key = t);
  Bn(), eE();
  const n = Wt(), r = Gs(), i = "" + jL++;
  r._nodeMap.set(i, e), ve(e) ? n._dirtyElements.set(i, !0) : n._dirtyLeaves.add(i), n._cloneNotNeeded.add(i), n._dirtyType = hC, e.__key = i;
}
function bo(e) {
  const t = e.getParent();
  if (t !== null) {
    const n = e.getWritable(), r = t.getWritable(), i = e.getPreviousSibling(), s = e.getNextSibling();
    if (i === null) if (s !== null) {
      const o = s.getWritable();
      r.__first = s.__key, o.__prev = null;
    } else r.__first = null;
    else {
      const o = i.getWritable();
      if (s !== null) {
        const a = s.getWritable();
        a.__prev = o.__key, o.__next = a.__key;
      } else o.__next = null;
      n.__prev = null;
    }
    if (s === null) if (i !== null) {
      const o = i.getWritable();
      r.__last = i.__key, o.__next = null;
    } else r.__last = null;
    else {
      const o = s.getWritable();
      if (i !== null) {
        const a = i.getWritable();
        a.__next = o.__key, o.__prev = a.__key;
      } else o.__prev = null;
      n.__next = null;
    }
    r.__size--, n.__parent = null;
  }
}
function ld(e) {
  eE();
  const t = e.getLatest(), n = t.__parent, r = Gs(), i = Wt(), s = r._nodeMap, o = i._dirtyElements;
  n !== null && function(l, c, u) {
    let f = l;
    for (; f !== null; ) {
      if (u.has(f)) return;
      const d = c.get(f);
      if (d === void 0) break;
      u.set(f, !1), f = d.__parent;
    }
  }(n, s, o);
  const a = t.__key;
  i._dirtyType = hC, ve(e) ? o.set(a, !0) : i._dirtyLeaves.add(a);
}
function ln(e) {
  Bn();
  const t = Wt(), n = t._compositionKey;
  if (e !== n) {
    if (t._compositionKey = e, n !== null) {
      const r = un(n);
      r !== null && r.getWritable();
    }
    if (e !== null) {
      const r = un(e);
      r !== null && r.getWritable();
    }
  }
}
function Ts() {
  return Gc() ? null : Wt()._compositionKey;
}
function un(e, t) {
  const n = (t || Gs())._nodeMap.get(e);
  return n === void 0 ? null : n;
}
function _C(e, t) {
  const n = Bh(e, Wt());
  return n !== void 0 ? un(n, t) : null;
}
function Bh(e, t) {
  return e[`__lexicalKey_${t._key}`];
}
function O2(e, t) {
  let n = e;
  for (; n != null; ) {
    const r = _C(n, t);
    if (r !== null) return r;
    n = Jc(n);
  }
  return null;
}
function bC(e) {
  const t = e._decorators, n = Object.assign({}, t);
  return e._pendingDecorators = n, n;
}
function v5(e) {
  return e.read(() => Vr().getTextContent());
}
function Vr() {
  return CC(Gs());
}
function CC(e) {
  return e._nodeMap.get("root");
}
function $s(e) {
  Bn();
  const t = Gs();
  e !== null && (e.dirty = !0, e.setCachedNodes(null)), t._selection = e;
}
function ya(e) {
  const t = Wt(), n = function(r, i) {
    let s = r;
    for (; s != null; ) {
      const o = Bh(s, i);
      if (o !== void 0) return o;
      s = Jc(s);
    }
    return null;
  }(e, t);
  return n === null ? e === t.getRootElement() ? un("root") : null : un(n);
}
function y5(e, t) {
  return t ? e.getTextContentSize() : 0;
}
function EC(e) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(e);
}
function P2(e) {
  const t = [];
  let n = e;
  for (; n !== null; ) t.push(n), n = n._parentEditor;
  return t;
}
function SC() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function kC(e) {
  return os(e) ? e.nodeValue : null;
}
function D2(e, t, n) {
  const r = Yi(t._window);
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: s, focusOffset: o } = r;
  if (i !== null) {
    let a = kC(i);
    const l = O2(i);
    if (a !== null && ke(l)) {
      if (a === Rh && n) {
        const c = n.length;
        a = n, s = c, o = c;
      }
      a !== null && F2(l, a, s, o, e);
    }
  }
}
function F2(e, t, n, r, i) {
  let s = e;
  if (s.isAttached() && (i || !s.isDirty())) {
    const o = s.isComposing();
    let a = t;
    (o || i) && t[t.length - 1] === Rh && (a = t.slice(0, -1));
    const l = s.getTextContent();
    if (i || a !== l) {
      if (a === "") {
        if (ln(null), Fh || Wc || C2) s.remove();
        else {
          const p = Wt();
          setTimeout(() => {
            p.update(() => {
              s.isAttached() && s.remove();
            });
          }, 20);
        }
        return;
      }
      const c = s.getParent(), u = qh(), f = s.getTextContentSize(), d = Ts(), h = s.getKey();
      if (s.isToken() || d !== null && h === d && !o || Ve(u) && (c !== null && !c.canInsertTextBefore() && u.anchor.offset === 0 || u.anchor.key === e.__key && u.anchor.offset === 0 && !s.canInsertTextBefore() && !o || u.focus.key === e.__key && u.focus.offset === f && !s.canInsertTextAfter() && !o)) return void s.markDirty();
      const m = St();
      if (!Ve(m) || n === null || r === null) return void s.setTextContent(a);
      if (m.setTextNodeRange(s, n, s, r), s.isSegmented()) {
        const p = an(s.getTextContent());
        s.replace(p), s = p;
      }
      s.setTextContent(a);
    }
  }
}
function qL(e, t) {
  if (t.isSegmented()) return !0;
  if (!e.isCollapsed()) return !1;
  const n = e.anchor.offset, r = t.getParentOrThrow(), i = t.isToken();
  return n === 0 ? !t.canInsertTextBefore() || !r.canInsertTextBefore() && !t.isComposing() || i || function(s) {
    const o = s.getPreviousSibling();
    return (ke(o) || ve(o) && o.isInline()) && !o.canInsertTextAfter();
  }(t) : n === t.getTextContentSize() && (!t.canInsertTextAfter() || !r.canInsertTextAfter() && !t.isComposing() || i);
}
function x5(e) {
  return e === "ArrowLeft";
}
function w5(e) {
  return e === "ArrowRight";
}
function Wl(e, t) {
  return Nr ? e : t;
}
function _5(e) {
  return e === "Enter";
}
function Ll(e) {
  return e === "Backspace";
}
function Ml(e) {
  return e === "Delete";
}
function b5(e, t, n) {
  return e.toLowerCase() === "a" && Wl(t, n);
}
function Sa(e, t) {
  e.__lexicalClassNameCache === void 0 && (e.__lexicalClassNameCache = {});
  const n = e.__lexicalClassNameCache, r = n[t];
  if (r !== void 0) return r;
  const i = e[t];
  if (typeof i == "string") {
    const s = sd(i);
    return n[t] = s, s;
  }
  return i;
}
function R2(e, t, n, r, i) {
  if (n.size === 0) return;
  const s = r.__type, o = r.__key, a = t.get(s);
  a === void 0 && we(33, s);
  const l = a.klass;
  let c = e.get(l);
  c === void 0 && (c = /* @__PURE__ */ new Map(), e.set(l, c));
  const u = c.get(o), f = u === "destroyed" && i === "created";
  (u === void 0 || f) && c.set(o, f ? "updated" : i);
}
function C5(e, t, n) {
  const r = e.getParent();
  let i = n, s = e;
  return r !== null && (t && n === 0 ? (i = s.getIndexWithinParent(), s = r) : t || n !== s.getChildrenSize() || (i = s.getIndexWithinParent() + 1, s = r)), s.getChildAtIndex(t ? i - 1 : i);
}
function E5(e, t) {
  const n = e.offset;
  if (e.type === "element")
    return C5(e.getNode(), t, n);
  {
    const r = e.getNode();
    if (t && n === 0 || !t && n === r.getTextContentSize()) {
      const i = t ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? C5(r.getParentOrThrow(), t, r.getIndexWithinParent() + (t ? 0 : 1)) : i;
    }
  }
  return null;
}
function TC(e) {
  const t = Hh(e).event, n = t && t.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function Ee(e, t, n) {
  return iE(e, t, n);
}
function zh(e) {
  return !yr(e) && !e.isLastChild() && !e.isInline();
}
function cd(e, t) {
  const n = e._keyToDOMMap.get(t);
  return n === void 0 && we(75, t), n;
}
function Jc(e) {
  const t = e.assignedSlot || e.parentElement;
  return ZL(t) ? t.host : t;
}
function AC(e) {
  return JL(e) ? e : Sr(e) ? e.ownerDocument : null;
}
function ec(e, t) {
  let n = e.getParent();
  for (; n !== null; ) {
    if (n.is(t)) return !0;
    n = n.getParent();
  }
  return !1;
}
function $2(e) {
  const t = AC(e);
  return t ? t.defaultView : null;
}
function Hh(e) {
  const t = e._window;
  return t === null && we(78), t;
}
function GL(e) {
  let t = e.getParentOrThrow();
  for (; t !== null; ) {
    if (Kc(t)) return t;
    t = t.getParentOrThrow();
  }
  return t;
}
function Kc(e) {
  return yr(e) || ve(e) && e.isShadowRoot();
}
function Uh(e) {
  const t = Wt(), n = e.constructor.getType(), r = t._nodes.get(n);
  r === void 0 && we(200, e.constructor.name, n);
  const { replace: i, replaceWithKlass: s } = r;
  if (i !== null) {
    const o = i(e), a = o.constructor;
    return s !== null ? o instanceof s || we(201, s.name, s.getType(), a.name, a.getType(), e.constructor.name, n) : o instanceof e.constructor && a !== e.constructor || we(202, a.name, a.getType(), e.constructor.name, n), o.__key === e.__key && we(203, e.constructor.name, n, a.name, a.getType()), o;
  }
  return e;
}
function c1(e, t) {
  !yr(e.getParent()) || ve(t) || Dt(t) || we(99);
}
function u1(e) {
  return (Dt(e) || ve(e) && !e.canBeEmpty()) && !e.isInline();
}
function V2(e, t, n) {
  n.style.removeProperty("caret-color"), t._blockCursorElement = null;
  const r = e.parentElement;
  r !== null && r.removeChild(e);
}
function YL(e, t, n) {
  let r = e._blockCursorElement;
  if (Ve(n) && n.isCollapsed() && n.anchor.type === "element" && t.contains(document.activeElement)) {
    const i = n.anchor, s = i.getNode(), o = i.offset;
    let a = !1, l = null;
    if (o === s.getChildrenSize())
      u1(s.getChildAtIndex(o - 1)) && (a = !0);
    else {
      const c = s.getChildAtIndex(o);
      if (c !== null && u1(c)) {
        const u = c.getPreviousSibling();
        (u === null || u1(u)) && (a = !0, l = e.getElementByKey(c.__key));
      }
    }
    if (a) {
      const c = e.getElementByKey(s.__key);
      return r === null && (e._blockCursorElement = r = function(u) {
        const f = u.theme, d = document.createElement("div");
        d.contentEditable = "false", d.setAttribute("data-lexical-cursor", "true");
        let h = f.blockCursor;
        if (h !== void 0) {
          if (typeof h == "string") {
            const m = sd(h);
            h = f.blockCursor = m;
          }
          h !== void 0 && d.classList.add(...h);
        }
        return d;
      }(e._config)), t.style.caretColor = "transparent", void (l === null ? c.appendChild(r) : c.insertBefore(r, l));
    }
  }
  r !== null && V2(r, e, t);
}
function Yi(e) {
  return Kr ? (e || window).getSelection() : null;
}
function XL(e) {
  const t = $2(e);
  return t ? t.getSelection() : null;
}
function Sr(e) {
  return qc(e) && e.nodeType === CL;
}
function qc(e) {
  return typeof e == "object" && e !== null && "nodeType" in e && typeof e.nodeType == "number";
}
function ZL(e) {
  return qc(e) && e.nodeType === kL;
}
function QL(e) {
  const t = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return e.nodeName.match(t) !== null;
}
function S5(e) {
  const t = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return e.nodeName.match(t) !== null;
}
function ws(e) {
  if (Dt(e) && !e.isInline()) return !0;
  if (!ve(e) || Kc(e)) return !1;
  const t = e.getFirstChild(), n = t === null || rc(t) || ke(t) || t.isInline();
  return !e.isInline() && e.canBeEmpty() !== !1 && n;
}
function Ol(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
const k5 = /* @__PURE__ */ new WeakMap(), eM = /* @__PURE__ */ new Map();
function T5(e) {
  if (!e._readOnly && e.isEmpty()) return eM;
  e._readOnly || we(192);
  let t = k5.get(e);
  return t || (t = function(n) {
    const r = /* @__PURE__ */ new Map();
    for (const [i, s] of n._nodeMap) {
      const o = s.__type;
      let a = r.get(o);
      a || (a = /* @__PURE__ */ new Map(), r.set(o, a)), a.set(i, s);
    }
    return r;
  }(e), k5.set(e, t)), t;
}
function tM(e) {
  const t = e.constructor.clone(e);
  return t.afterCloneFrom(e), t;
}
function nM(e, t) {
  const n = (parseInt(e.style.paddingInlineStart, 10) || 0) / 40;
  t.setIndent(n);
}
function rM(e) {
  return e.__lexicalUnmanaged === !0;
}
function NC(e, t, n, r, i, s) {
  let o = e.getFirstChild();
  for (; o !== null; ) {
    const a = o.__key;
    o.__parent === t && (ve(o) && NC(o, a, n, r, i, s), n.has(a) || s.delete(a), i.push(a)), o = o.getNextSibling();
  }
}
let Vs, An, yc, jh, sg, og, Lo, Dr, ag, xc, Yt = "", Sn = "", ei = null, Ir = "", $i = "", IC = !1, wc = !1, kf = null;
function ud(e, t) {
  const n = Lo.get(e);
  if (t !== null) {
    const r = ug(e);
    r.parentNode === t && t.removeChild(r);
  }
  if (Dr.has(e) || An._keyToDOMMap.delete(e), ve(n)) {
    const r = dd(n, Lo);
    lg(r, 0, r.length - 1, null);
  }
  n !== void 0 && R2(xc, yc, jh, n, "destroyed");
}
function lg(e, t, n, r) {
  let i = t;
  for (; i <= n; ++i) {
    const s = e[i];
    s !== void 0 && ud(s, r);
  }
}
function oo(e, t) {
  e.setProperty("text-align", t);
}
const iM = "40px";
function LC(e, t) {
  const n = Vs.theme.indent;
  if (typeof n == "string") {
    const i = e.classList.contains(n);
    t > 0 && !i ? e.classList.add(n) : t < 1 && i && e.classList.remove(n);
  }
  const r = getComputedStyle(e).getPropertyValue("--lexical-indent-base-value") || iM;
  e.style.setProperty("padding-inline-start", t === 0 ? "" : `calc(${t} * ${r})`);
}
function MC(e, t) {
  const n = e.style;
  t === 0 ? oo(n, "") : t === S2 ? oo(n, "left") : t === k2 ? oo(n, "center") : t === T2 ? oo(n, "right") : t === A2 ? oo(n, "justify") : t === N2 ? oo(n, "start") : t === I2 && oo(n, "end");
}
function fd(e, t) {
  const n = Dr.get(e);
  n === void 0 && we(60);
  const r = n.createDOM(Vs, An);
  if (function(i, s, o) {
    const a = o._keyToDOMMap;
    (function(l, c, u) {
      l[`__lexicalKey_${c._key}`] = u;
    })(s, o, i), a.set(i, s);
  }(e, r, An), ke(n) ? r.setAttribute("data-lexical-text", "true") : Dt(n) && r.setAttribute("data-lexical-decorator", "true"), ve(n)) {
    const i = n.__indent, s = n.__size;
    if (i !== 0 && LC(r, i), s !== 0) {
      const a = s - 1;
      (function(l, c, u, f) {
        const d = Sn;
        Sn = "", cg(l, u, 0, c, u.getDOMSlot(f)), PC(u, f), Sn = d;
      })(dd(n, Dr), a, n, r);
    }
    const o = n.__format;
    o !== 0 && MC(r, o), n.isInline() || OC(null, n, r), zh(n) && (Yt += Gi, $i += Gi);
  } else {
    const i = n.getTextContent();
    if (Dt(n)) {
      const s = n.decorate(An, Vs);
      s !== null && DC(e, s), r.contentEditable = "false";
    } else ke(n) && (n.isDirectionless() || (Sn += i));
    Yt += i, $i += i;
  }
  return t !== null && t.insertChild(r), R2(xc, yc, jh, n, "created"), r;
}
function cg(e, t, n, r, i) {
  const s = Yt;
  Yt = "";
  let o = n;
  for (; o <= r; ++o) {
    fd(e[o], i);
    const a = Dr.get(e[o]);
    a !== null && ke(a) && (ei === null && (ei = a.getFormat()), Ir === "" && (Ir = a.getStyle()));
  }
  zh(t) && (Yt += Gi), i.element.__lexicalTextContent = Yt, Yt = s + Yt;
}
function A5(e, t) {
  if (e) {
    const n = e.__last;
    if (n) {
      const r = t.get(n);
      if (r) return rc(r) ? "line-break" : Dt(r) && r.isInline() ? "decorator" : null;
    }
    return "empty";
  }
  return null;
}
function OC(e, t, n) {
  const r = A5(e, Lo), i = A5(t, Dr);
  r !== i && t.getDOMSlot(n).setManagedLineBreak(i);
}
function PC(e, t) {
  const n = t.__lexicalDirTextContent || "", r = t.__lexicalDir || "";
  if (n !== Sn || r !== kf) {
    const s = Sn === "", o = s ? kf : (i = Sn, ML.test(i) ? "rtl" : OL.test(i) ? "ltr" : null);
    if (o !== r) {
      const a = t.classList, l = Vs.theme;
      let c = r !== null ? l[r] : void 0, u = o !== null ? l[o] : void 0;
      if (c !== void 0) {
        if (typeof c == "string") {
          const f = sd(c);
          c = l[r] = f;
        }
        a.remove(...c);
      }
      if (o === null || s && o === "ltr") t.removeAttribute("dir");
      else {
        if (u !== void 0) {
          if (typeof u == "string") {
            const f = sd(u);
            u = l[o] = f;
          }
          u !== void 0 && a.add(...u);
        }
        t.dir = o;
      }
      wc || (e.getWritable().__dir = o);
    }
    kf = o, t.__lexicalDirTextContent = Sn, t.__lexicalDir = o;
  }
  var i;
}
function sM(e, t, n) {
  const r = Sn;
  var i;
  Sn = "", ei = null, Ir = "", function(s, o, a) {
    const l = Yt, c = s.__size, u = o.__size;
    Yt = "";
    const f = a.element;
    if (c === 1 && u === 1) {
      const d = s.__first, h = o.__first;
      if (d === h) Jl(d, f);
      else {
        const p = ug(d), y = fd(h, null);
        try {
          f.replaceChild(y, p);
        } catch (v) {
          if (typeof v == "object" && v != null) {
            const g = `${v.toString()} Parent: ${f.tagName}, new child: {tag: ${y.tagName} key: ${h}}, old child: {tag: ${p.tagName}, key: ${d}}.`;
            throw new Error(g);
          }
          throw v;
        }
        ud(d, null);
      }
      const m = Dr.get(h);
      ke(m) && (ei === null && (ei = m.getFormat()), Ir === "" && (Ir = m.getStyle()));
    } else {
      const d = dd(s, Lo), h = dd(o, Dr);
      if (d.length !== c && we(227), h.length !== u && we(228), c === 0) u !== 0 && cg(h, o, 0, u - 1, a);
      else if (u === 0) {
        if (c !== 0) {
          const m = a.after == null && a.before == null && a.element.__lexicalLineBreak == null;
          lg(d, 0, c - 1, m ? null : f), m && (f.textContent = "");
        }
      } else (function(m, p, y, v, g, x) {
        const _ = v - 1, b = g - 1;
        let C, E, S = x.getFirstChild(), k = 0, M = 0;
        for (; k <= _ && M <= b; ) {
          const I = p[k], H = y[M];
          if (I === H) S = f1(Jl(H, x.element)), k++, M++;
          else {
            C === void 0 && (C = new Set(p)), E === void 0 && (E = new Set(y));
            const W = E.has(I), G = C.has(H);
            if (W) if (G) {
              const J = cd(An, H);
              J === S ? S = f1(Jl(H, x.element)) : (x.withBefore(S).insertChild(J), Jl(H, x.element)), k++, M++;
            } else fd(H, x.withBefore(S)), M++;
            else S = f1(ug(I)), ud(I, x.element), k++;
          }
          const P = Dr.get(H);
          P !== null && ke(P) && (ei === null && (ei = P.getFormat()), Ir === "" && (Ir = P.getStyle()));
        }
        const O = k > _, R = M > b;
        if (O && !R) {
          const I = y[b + 1], H = I === void 0 ? null : An.getElementByKey(I);
          cg(y, m, M, b, x.withBefore(H));
        } else R && !O && lg(p, k, _, x.element);
      })(o, d, h, c, u, a);
    }
    zh(o) && (Yt += Gi), f.__lexicalTextContent = Yt, Yt = l + Yt;
  }(e, t, t.getDOMSlot(n)), PC(t, n), i = t, ei == null || ei === i.__textFormat || wc || (i.setTextFormat(ei), i.setTextStyle(Ir)), function(s) {
    Ir === "" || Ir === s.__textStyle || wc || s.setTextStyle(Ir);
  }(t), Sn = r;
}
function dd(e, t) {
  const n = [];
  let r = e.__first;
  for (; r !== null; ) {
    const i = t.get(r);
    i === void 0 && we(101), n.push(r), r = i.__next;
  }
  return n;
}
function Jl(e, t) {
  const n = Lo.get(e);
  let r = Dr.get(e);
  n !== void 0 && r !== void 0 || we(61);
  const i = IC || og.has(e) || sg.has(e), s = cd(An, e);
  if (n === r && !i) {
    if (ve(n)) {
      const o = s.__lexicalTextContent;
      o !== void 0 && (Yt += o, $i += o);
      const a = s.__lexicalDirTextContent;
      a !== void 0 && (Sn += a);
    } else {
      const o = n.getTextContent();
      ke(n) && !n.isDirectionless() && (Sn += o), $i += o, Yt += o;
    }
    return s;
  }
  if (n !== r && i && R2(xc, yc, jh, r, "updated"), r.updateDOM(n, s, Vs)) {
    const o = fd(e, null);
    return t === null && we(62), t.replaceChild(o, s), ud(e, null), o;
  }
  if (ve(n) && ve(r)) {
    const o = r.__indent;
    o !== n.__indent && LC(s, o);
    const a = r.__format;
    a !== n.__format && MC(s, a), i && (sM(n, r, s), yr(r) || r.isInline() || OC(n, r, s)), zh(r) && (Yt += Gi, $i += Gi);
  } else {
    const o = r.getTextContent();
    if (Dt(r)) {
      const a = r.decorate(An, Vs);
      a !== null && DC(e, a);
    } else ke(r) && !r.isDirectionless() && (Sn += o);
    Yt += o, $i += o;
  }
  if (!wc && yr(r) && r.__cachedText !== $i) {
    const o = r.getWritable();
    o.__cachedText = $i, r = o;
  }
  return s;
}
function DC(e, t) {
  let n = An._pendingDecorators;
  const r = An._decorators;
  if (n === null) {
    if (r[e] === t) return;
    n = bC(An);
  }
  n[e] = t;
}
function f1(e) {
  let t = e.nextSibling;
  return t !== null && t === An._blockCursorElement && (t = t.nextSibling), t;
}
function oM(e, t, n, r, i, s) {
  Yt = "", $i = "", Sn = "", IC = r === Va, kf = null, An = n, Vs = n._config, yc = n._nodes, jh = An._listeners.mutation, sg = i, og = s, Lo = e._nodeMap, Dr = t._nodeMap, wc = t._readOnly, ag = new Map(n._keyToDOMMap);
  const o = /* @__PURE__ */ new Map();
  return xc = o, Jl("root", null), An = void 0, yc = void 0, sg = void 0, og = void 0, Lo = void 0, Dr = void 0, Vs = void 0, ag = void 0, xc = void 0, o;
}
function ug(e) {
  const t = ag.get(e);
  return t === void 0 && we(75, e), t;
}
const Ti = Object.freeze({}), fg = 30, dg = [["keydown", function(e, t) {
  if (tc = e.timeStamp, FC = e.key, t.isComposing()) return;
  const { key: n, shiftKey: r, ctrlKey: i, metaKey: s, altKey: o } = e;
  if (!Ee(t, tL, e) && n != null) {
    if (function(a, l, c, u) {
      return w5(a) && !l && !u && !c;
    }(n, i, o, s)) Ee(t, nL, e);
    else if (function(a, l, c, u, f) {
      return w5(a) && !u && !c && (l || f);
    }(n, i, r, o, s)) Ee(t, rL, e);
    else if (function(a, l, c, u) {
      return x5(a) && !l && !u && !c;
    }(n, i, o, s)) Ee(t, iL, e);
    else if (function(a, l, c, u, f) {
      return x5(a) && !u && !c && (l || f);
    }(n, i, r, o, s)) Ee(t, sL, e);
    else if (/* @__PURE__ */ function(a, l, c) {
      return /* @__PURE__ */ function(u) {
        return u === "ArrowUp";
      }(a) && !l && !c;
    }(n, i, s)) Ee(t, oL, e);
    else if (/* @__PURE__ */ function(a, l, c) {
      return /* @__PURE__ */ function(u) {
        return u === "ArrowDown";
      }(a) && !l && !c;
    }(n, i, s)) Ee(t, aL, e);
    else if (function(a, l) {
      return _5(a) && l;
    }(n, r)) nc = !0, Ee(t, rg, e);
    else if (/* @__PURE__ */ function(a) {
      return a === " ";
    }(n)) Ee(t, lL, e);
    else if (function(a, l) {
      return Nr && l && a.toLowerCase() === "o";
    }(n, i)) e.preventDefault(), nc = !0, Ee(t, Sf, !0);
    else if (function(a, l) {
      return _5(a) && !l;
    }(n, r)) nc = !1, Ee(t, rg, e);
    else if (function(a, l, c, u) {
      return Nr ? !l && !c && (Ll(a) || a.toLowerCase() === "h" && u) : !(u || l || c) && Ll(a);
    }(n, o, s, i)) Ll(n) ? Ee(t, cL, e) : (e.preventDefault(), Ee(t, Qf, !0));
    else if (/* @__PURE__ */ function(a) {
      return a === "Escape";
    }(n)) Ee(t, uL, e);
    else if (function(a, l, c, u, f) {
      return Nr ? !(c || u || f) && (Ml(a) || a.toLowerCase() === "d" && l) : !(l || u || f) && Ml(a);
    }(n, i, r, o, s)) Ml(n) ? Ee(t, fL, e) : (e.preventDefault(), Ee(t, Qf, !1));
    else if (function(a, l, c) {
      return Ll(a) && (Nr ? l : c);
    }(n, o, i)) e.preventDefault(), Ee(t, ed, !0);
    else if (function(a, l, c) {
      return Ml(a) && (Nr ? l : c);
    }(n, o, i)) e.preventDefault(), Ee(t, ed, !1);
    else if (function(a, l) {
      return Nr && l && Ll(a);
    }(n, s)) e.preventDefault(), Ee(t, td, !0);
    else if (function(a, l) {
      return Nr && l && Ml(a);
    }(n, s)) e.preventDefault(), Ee(t, td, !1);
    else if (function(a, l, c, u) {
      return a.toLowerCase() === "b" && !l && Wl(c, u);
    }(n, o, s, i)) e.preventDefault(), Ee(t, yo, "bold");
    else if (function(a, l, c, u) {
      return a.toLowerCase() === "u" && !l && Wl(c, u);
    }(n, o, s, i)) e.preventDefault(), Ee(t, yo, "underline");
    else if (function(a, l, c, u) {
      return a.toLowerCase() === "i" && !l && Wl(c, u);
    }(n, o, s, i)) e.preventDefault(), Ee(t, yo, "italic");
    else if (/* @__PURE__ */ function(a, l, c, u) {
      return a === "Tab" && !l && !c && !u;
    }(n, o, i, s)) Ee(t, dL, e);
    else if (function(a, l, c, u) {
      return a.toLowerCase() === "z" && !l && Wl(c, u);
    }(n, r, s, i)) e.preventDefault(), Ee(t, lC, void 0);
    else if (function(a, l, c, u) {
      return Nr ? a.toLowerCase() === "z" && c && l : a.toLowerCase() === "y" && u || a.toLowerCase() === "z" && u && l;
    }(n, r, s, i)) e.preventDefault(), Ee(t, cC, void 0);
    else {
      const a = t._editorState._selection;
      a === null || Ve(a) ? !Ps && b5(n, s, i) && (e.preventDefault(), Ee(t, d5, e)) : function(l, c, u, f) {
        return !c && l.toLowerCase() === "c" && (Nr ? u : f);
      }(n, r, s, i) ? (e.preventDefault(), Ee(t, uC, e)) : function(l, c, u, f) {
        return !c && l.toLowerCase() === "x" && (Nr ? u : f);
      }(n, r, s, i) ? (e.preventDefault(), Ee(t, fC, e)) : b5(n, s, i) && (e.preventDefault(), Ee(t, d5, e));
    }
    /* @__PURE__ */ (function(a, l, c, u) {
      return a || l || c || u;
    })(i, r, o, s) && Ee(t, xL, e);
  }
}], ["pointerdown", function(e, t) {
  const n = e.target, r = e.pointerType;
  qc(n) && r !== "touch" && e.button === 0 && hr(t, () => {
    Dt(O2(n)) || (pg = !0);
  });
}], ["compositionstart", function(e, t) {
  hr(t, () => {
    const n = St();
    if (Ve(n) && !t.isComposing()) {
      const r = n.anchor, i = n.anchor.getNode();
      ln(r.key), (e.timeStamp < tc + fg || r.type === "element" || !n.isCollapsed() || i.getFormat() !== n.format || ke(i) && i.getStyle() !== n.style) && Ee(t, Ql, LL);
    }
  });
}], ["compositionend", function(e, t) {
  Ps ? Pl = !0 : hr(t, () => {
    d1(t, e.data);
  });
}], ["input", function(e, t) {
  e.stopPropagation(), hr(t, () => {
    const n = St(), r = e.data, i = BC(e);
    if (r != null && Ve(n) && VC(n, i, r, e.timeStamp, !1)) {
      Pl && (d1(t, r), Pl = !1);
      const s = n.anchor.getNode(), o = Yi(t._window);
      if (o === null) return;
      const a = n.isBackward(), l = a ? n.anchor.offset : n.focus.offset, c = a ? n.focus.offset : n.anchor.offset;
      nd && !n.isCollapsed() && ke(s) && o.anchorNode !== null && s.getTextContent().slice(0, l) + r + s.getTextContent().slice(l + c) === kC(o.anchorNode) || Ee(t, Ql, r);
      const u = r.length;
      Ps && u > 1 && e.inputType === "insertCompositionText" && !t.isComposing() && (n.anchor.offset -= u), Fh || Wc || C2 || !t.isComposing() || (tc = 0, ln(null));
    } else
      D2(!1, t, r !== null ? r : void 0), Pl && (d1(t, r || void 0), Pl = !1);
    Bn(), vC(Wt());
  }), ma = null;
}], ["click", function(e, t) {
  hr(t, () => {
    const n = St(), r = Yi(t._window), i = qh();
    if (r) {
      if (Ve(n)) {
        const s = n.anchor, o = s.getNode();
        s.type === "element" && s.offset === 0 && n.isCollapsed() && !yr(o) && Vr().getChildrenSize() === 1 && o.getTopLevelElementOrThrow().isEmpty() && i !== null && n.is(i) ? (r.removeAllRanges(), n.dirty = !0) : e.detail === 3 && !n.isCollapsed() && o !== n.focus.getNode() && (ve(o) ? o.select(0) : o.getParentOrThrow().select(0));
      } else if (e.pointerType === "touch") {
        const s = r.anchorNode;
        (Sr(s) || os(s)) && $s(W2(i, r, t, e));
      }
    }
    Ee(t, eL, e);
  });
}], ["cut", Ti], ["copy", Ti], ["dragstart", Ti], ["dragover", Ti], ["dragend", Ti], ["paste", Ti], ["focus", Ti], ["blur", Ti], ["drop", Ti]];
nd && dg.push(["beforeinput", (e, t) => function(n, r) {
  const i = n.inputType, s = BC(n);
  i === "deleteCompositionText" || Ps && TC(r) || i !== "insertCompositionText" && hr(r, () => {
    const o = St();
    if (i === "deleteContentBackward") {
      if (o === null) {
        const h = qh();
        if (!Ve(h)) return;
        $s(h.clone());
      }
      if (Ve(o)) {
        const h = o.anchor.key === o.focus.key;
        if (a = n.timeStamp, FC === "MediaLast" && a < tc + fg && r.isComposing() && h) {
          if (ln(null), tc = 0, setTimeout(() => {
            hr(r, () => {
              ln(null);
            });
          }, fg), Ve(o)) {
            const m = o.anchor.getNode();
            m.markDirty(), o.format = m.getFormat(), ke(m) || we(142), o.style = m.getStyle();
          }
        } else {
          ln(null), n.preventDefault();
          const m = o.anchor.getNode(), p = m.getTextContent(), y = m.canInsertTextAfter(), v = o.anchor.offset === 0 && o.focus.offset === p.length;
          bL && h && !v && y || Ee(r, Qf, !0);
        }
        return;
      }
    }
    var a;
    if (!Ve(o)) return;
    const l = n.data;
    ma !== null && D2(!1, r, ma), o.dirty && ma === null || !o.isCollapsed() || yr(o.anchor.getNode()) || s === null || o.applyDOMRange(s), ma = null;
    const c = o.anchor, u = o.focus, f = c.getNode(), d = u.getNode();
    if (i !== "insertText" && i !== "insertTranspose") switch (n.preventDefault(), i) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText":
        Ee(r, Ql, n);
        break;
      case "insertFromComposition":
        ln(null), Ee(r, Ql, n);
        break;
      case "insertLineBreak":
        ln(null), Ee(r, Sf, !1);
        break;
      case "insertParagraph":
        ln(null), nc && !Wc ? (nc = !1, Ee(r, Sf, !1)) : Ee(r, u5, void 0);
        break;
      case "insertFromPaste":
      case "insertFromPasteAsQuotation":
        Ee(r, aC, n);
        break;
      case "deleteByComposition":
        (function(h, m) {
          return h !== m || ve(h) || ve(m) || !h.isToken() || !m.isToken();
        })(f, d) && Ee(r, f5, n);
        break;
      case "deleteByDrag":
      case "deleteByCut":
        Ee(r, f5, n);
        break;
      case "deleteContent":
        Ee(r, Qf, !1);
        break;
      case "deleteWordBackward":
        Ee(r, ed, !0);
        break;
      case "deleteWordForward":
        Ee(r, ed, !1);
        break;
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward":
        Ee(r, td, !0);
        break;
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward":
        Ee(r, td, !1);
        break;
      case "formatStrikeThrough":
        Ee(r, yo, "strikethrough");
        break;
      case "formatBold":
        Ee(r, yo, "bold");
        break;
      case "formatItalic":
        Ee(r, yo, "italic");
        break;
      case "formatUnderline":
        Ee(r, yo, "underline");
        break;
      case "historyUndo":
        Ee(r, lC, void 0);
        break;
      case "historyRedo":
        Ee(r, cC, void 0);
    }
    else {
      if (l === `
`) n.preventDefault(), Ee(r, Sf, !1);
      else if (l === Gi) n.preventDefault(), Ee(r, u5, void 0);
      else if (l == null && n.dataTransfer) {
        const h = n.dataTransfer.getData("text/plain");
        n.preventDefault(), o.insertRawText(h);
      } else l != null && VC(o, s, l, n.timeStamp, !0) ? (n.preventDefault(), Ee(r, Ql, l)) : ma = l;
      RC = n.timeStamp;
    }
  });
}(e, t)]);
let tc = 0, FC = null, RC = 0, ma = null;
const hd = /* @__PURE__ */ new WeakMap();
let hg = !1, pg = !1, nc = !1, Pl = !1, $C = [0, "", 0, "root", 0];
function VC(e, t, n, r, i) {
  const s = e.anchor, o = e.focus, a = s.getNode(), l = Wt(), c = Yi(l._window), u = c !== null ? c.anchorNode : null, f = s.key, d = l.getElementByKey(f), h = n.length;
  return f !== o.key || !ke(a) || (!i && (!nd || RC < r + 50) || a.isDirty() && h < 2 || EC(n)) && s.offset !== o.offset && !a.isComposing() || fo(a) || a.isDirty() && h > 1 || (i || !nd) && d !== null && !a.isComposing() && u !== od(d) || c !== null && t !== null && (!t.collapsed || t.startContainer !== c.anchorNode || t.startOffset !== c.anchorOffset) || a.getFormat() !== e.format || a.getStyle() !== e.style || qL(e, a);
}
function N5(e, t) {
  return os(e) && e.nodeValue !== null && t !== 0 && t !== e.nodeValue.length;
}
function I5(e, t, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o } = e;
  hg && (hg = !1, N5(r, i) && N5(s, o)) || hr(t, () => {
    if (!n) return void $s(null);
    if (!$h(t, r, s)) return;
    const a = St();
    if (Ve(a)) {
      const l = a.anchor, c = l.getNode();
      if (a.isCollapsed()) {
        e.type === "Range" && e.anchorNode === e.focusNode && (a.dirty = !0);
        const u = Hh(t).event, f = u ? u.timeStamp : performance.now(), [d, h, m, p, y] = $C, v = Vr(), g = t.isComposing() === !1 && v.getTextContent() === "";
        if (f < y + 200 && l.offset === m && l.key === p) a.format = d, a.style = h;
        else if (l.type === "text") ke(c) || we(141), a.format = c.getFormat(), a.style = c.getStyle();
        else if (l.type === "element" && !g) {
          ve(c) || we(259);
          const x = l.getNode();
          a.style = "", x.isEmpty() ? (a.format = x.getTextFormat(), a.style = x.getTextStyle()) : a.format = 0;
        }
      } else {
        const u = l.key, f = a.focus.key, d = a.getNodes(), h = d.length, m = a.isBackward(), p = m ? o : i, y = m ? i : o, v = m ? f : u, g = m ? u : f;
        let x = IL, _ = !1;
        for (let b = 0; b < h; b++) {
          const C = d[b], E = C.getTextContentSize();
          if (ke(C) && E !== 0 && !(b === 0 && C.__key === v && p === E || b === h - 1 && C.__key === g && y === 0) && (_ = !0, x &= C.getFormat(), x === 0)) break;
        }
        a.format = _ ? x : 0;
      }
    }
    Ee(t, b2, void 0);
  });
}
function BC(e) {
  if (!e.getTargetRanges) return null;
  const t = e.getTargetRanges();
  return t.length === 0 ? null : t[0];
}
function d1(e, t) {
  const n = e._compositionKey;
  if (ln(null), n !== null && t != null) {
    if (t === "") {
      const r = un(n), i = od(e.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && ke(r) && F2(r, i.nodeValue, null, null, !0));
    }
    if (t[t.length - 1] === `
`) {
      const r = St();
      if (Ve(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void Ee(e, rg, null);
      }
    }
  }
  D2(!0, e, t);
}
function zC(e) {
  let t = e.__lexicalEventHandles;
  return t === void 0 && (t = [], e.__lexicalEventHandles = t), t;
}
const ka = /* @__PURE__ */ new Map();
function HC(e) {
  const t = XL(e.target);
  if (t === null) return;
  const n = wC(t.anchorNode);
  if (n === null) return;
  pg && (pg = !1, hr(n, () => {
    const l = qh(), c = t.anchorNode;
    (Sr(c) || os(c)) && $s(W2(l, t, n, e));
  }));
  const r = P2(n), i = r[r.length - 1], s = i._key, o = ka.get(s), a = o || i;
  a !== n && I5(t, a, !1), I5(t, n, !0), n !== i ? ka.set(s, n) : o && ka.delete(s);
}
function L5(e) {
  e._lexicalHandled = !0;
}
function M5(e) {
  return e._lexicalHandled === !0;
}
function aM(e) {
  const t = e.ownerDocument, n = hd.get(t);
  n === void 0 && we(162);
  const r = n - 1;
  r >= 0 || we(164), hd.set(t, r), r === 0 && t.removeEventListener("selectionchange", HC);
  const i = Vh(e);
  M2(i) ? (function(o) {
    if (o._parentEditor !== null) {
      const a = P2(o), l = a[a.length - 1]._key;
      ka.get(l) === o && ka.delete(l);
    } else ka.delete(o._key);
  }(i), e.__lexicalEditor = null) : i && we(198);
  const s = zC(e);
  for (let o = 0; o < s.length; o++) s[o]();
  e.__lexicalEventHandles = [];
}
function mg(e, t, n) {
  Bn();
  const r = e.__key, i = e.getParent();
  if (i === null) return;
  const s = function(a) {
    const l = St();
    if (!Ve(l) || !ve(a)) return l;
    const { anchor: c, focus: u } = l, f = c.getNode(), d = u.getNode();
    return ec(f, a) && c.set(a.__key, 0, "element"), ec(d, a) && u.set(a.__key, 0, "element"), l;
  }(e);
  let o = !1;
  if (Ve(s) && t) {
    const a = s.anchor, l = s.focus;
    a.key === r && (md(a, e, i, e.getPreviousSibling(), e.getNextSibling()), o = !0), l.key === r && (md(l, e, i, e.getPreviousSibling(), e.getNextSibling()), o = !0);
  } else j2(s) && t && e.isSelected() && e.selectPrevious();
  if (Ve(s) && t && !o) {
    const a = e.getIndexWithinParent();
    bo(e), pd(s, i, a, -1);
  } else bo(e);
  n || Kc(i) || i.canBeEmpty() || !i.isEmpty() || mg(i, t), t && yr(i) && i.isEmpty() && i.selectEnd();
}
let Wh = class {
  static getType() {
    we(64, this.name);
  }
  static clone(t) {
    we(65, this.name);
  }
  afterCloneFrom(t) {
    this.__parent = t.__parent, this.__next = t.__next, this.__prev = t.__prev;
  }
  constructor(t) {
    this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, KL(this, t);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    we(137, this.constructor.name);
  }
  isAttached() {
    let t = this.__key;
    for (; t !== null; ) {
      if (t === "root") return !0;
      const n = un(t);
      if (n === null) break;
      t = n.__parent;
    }
    return !1;
  }
  isSelected(t) {
    const n = t || St();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    if (ke(this)) return r;
    if (Ve(n) && n.anchor.type === "element" && n.focus.type === "element") {
      if (n.isCollapsed()) return !1;
      const i = this.getParent();
      if (Dt(this) && this.isInline() && i) {
        const s = n.isBackward() ? n.focus : n.anchor, o = s.getNode();
        if (s.offset === o.getChildrenSize() && o.is(i) && o.getLastChildOrThrow().is(this)) return !1;
      }
    }
    return r;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const t = this.getParent();
    if (t === null) return -1;
    let n = t.getFirstChild(), r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, n = n.getNextSibling();
    }
    return -1;
  }
  getParent() {
    const t = this.getLatest().__parent;
    return t === null ? null : un(t);
  }
  getParentOrThrow() {
    const t = this.getParent();
    return t === null && we(66, this.__key), t;
  }
  getTopLevelElement() {
    let t = this;
    for (; t !== null; ) {
      const n = t.getParent();
      if (Kc(n)) return ve(t) || t === this && Dt(t) || we(194), t;
      t = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const t = this.getTopLevelElement();
    return t === null && we(67, this.__key), t;
  }
  getParents() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n), n = n.getParent();
    return t;
  }
  getParentKeys() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n.__key), n = n.getParent();
    return t;
  }
  getPreviousSibling() {
    const t = this.getLatest().__prev;
    return t === null ? null : un(t);
  }
  getPreviousSiblings() {
    const t = [], n = this.getParent();
    if (n === null) return t;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) t.push(r), r = r.getNextSibling();
    return t;
  }
  getNextSibling() {
    const t = this.getLatest().__next;
    return t === null ? null : un(t);
  }
  getNextSiblings() {
    const t = [];
    let n = this.getNextSibling();
    for (; n !== null; ) t.push(n), n = n.getNextSibling();
    return t;
  }
  getCommonAncestor(t) {
    const n = this.getParents(), r = t.getParents();
    ve(this) && n.unshift(this), ve(t) && r.unshift(t);
    const i = n.length, s = r.length;
    if (i === 0 || s === 0 || n[i - 1] !== r[s - 1]) return null;
    const o = new Set(r);
    for (let a = 0; a < i; a++) {
      const l = n[a];
      if (o.has(l)) return l;
    }
    return null;
  }
  is(t) {
    return t != null && this.__key === t.__key;
  }
  isBefore(t) {
    if (this === t) return !1;
    if (t.isParentOf(this)) return !0;
    if (this.isParentOf(t)) return !1;
    const n = this.getCommonAncestor(t);
    let r = 0, i = 0, s = this;
    for (; ; ) {
      const o = s.getParentOrThrow();
      if (o === n) {
        r = s.getIndexWithinParent();
        break;
      }
      s = o;
    }
    for (s = t; ; ) {
      const o = s.getParentOrThrow();
      if (o === n) {
        i = s.getIndexWithinParent();
        break;
      }
      s = o;
    }
    return r < i;
  }
  isParentOf(t) {
    const n = this.__key;
    if (n === t.__key) return !1;
    let r = t;
    for (; r !== null; ) {
      if (r.__key === n) return !0;
      r = r.getParent();
    }
    return !1;
  }
  getNodesBetween(t) {
    const n = this.isBefore(t), r = [], i = /* @__PURE__ */ new Set();
    let s = this;
    for (; s !== null; ) {
      const o = s.__key;
      if (i.has(o) || (i.add(o), r.push(s)), s === t) break;
      const a = ve(s) ? n ? s.getFirstChild() : s.getLastChild() : null;
      if (a !== null) {
        s = a;
        continue;
      }
      const l = n ? s.getNextSibling() : s.getPreviousSibling();
      if (l !== null) {
        s = l;
        continue;
      }
      const c = s.getParentOrThrow();
      if (i.has(c.__key) || r.push(c), c === t) break;
      let u = null, f = c;
      do {
        if (f === null && we(68), u = n ? f.getNextSibling() : f.getPreviousSibling(), f = f.getParent(), f === null) break;
        u !== null || i.has(f.__key) || r.push(f);
      } while (u === null);
      s = u;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const t = Wt()._dirtyLeaves;
    return t !== null && t.has(this.__key);
  }
  getLatest() {
    const t = un(this.__key);
    return t === null && we(113), t;
  }
  getWritable() {
    Bn();
    const t = Gs(), n = Wt(), r = t._nodeMap, i = this.__key, s = this.getLatest(), o = n._cloneNotNeeded, a = St();
    if (a !== null && a.setCachedNodes(null), o.has(i)) return ld(s), s;
    const l = tM(s);
    return o.add(i), ld(l), r.set(i, l), l;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(t, n) {
    we(70);
  }
  updateDOM(t, n, r) {
    we(71);
  }
  exportDOM(t) {
    return { element: this.createDOM(t._config, t) };
  }
  exportJSON() {
    return { type: this.__type, version: 1 };
  }
  static importJSON(t) {
    we(18, this.name);
  }
  updateFromJSON(t) {
    return this;
  }
  static transform() {
    return null;
  }
  remove(t) {
    mg(this, !0, t);
  }
  replace(t, n) {
    Bn();
    let r = St();
    r !== null && (r = r.clone()), c1(this, t);
    const i = this.getLatest(), s = this.__key, o = t.__key, a = t.getWritable(), l = this.getParentOrThrow().getWritable(), c = l.__size;
    bo(a);
    const u = i.getPreviousSibling(), f = i.getNextSibling(), d = i.__prev, h = i.__next, m = i.__parent;
    if (mg(i, !1, !0), u === null ? l.__first = o : u.getWritable().__next = o, a.__prev = d, f === null ? l.__last = o : f.getWritable().__prev = o, a.__next = h, a.__parent = m, l.__size = c, n && (ve(this) && ve(a) || we(139), this.getChildren().forEach((p) => {
      a.append(p);
    })), Ve(r)) {
      $s(r);
      const p = r.anchor, y = r.focus;
      p.key === s && F5(p, a), y.key === s && F5(y, a);
    }
    return Ts() === s && ln(o), a;
  }
  insertAfter(t, n = !0) {
    Bn(), c1(this, t);
    const r = this.getWritable(), i = t.getWritable(), s = i.getParent(), o = St();
    let a = !1, l = !1;
    if (s !== null) {
      const h = t.getIndexWithinParent();
      if (bo(i), Ve(o)) {
        const m = s.__key, p = o.anchor, y = o.focus;
        a = p.type === "element" && p.key === m && p.offset === h + 1, l = y.type === "element" && y.key === m && y.offset === h + 1;
      }
    }
    const c = this.getNextSibling(), u = this.getParentOrThrow().getWritable(), f = i.__key, d = r.__next;
    if (c === null ? u.__last = f : c.getWritable().__prev = f, u.__size++, r.__next = f, i.__next = d, i.__prev = r.__key, i.__parent = r.__parent, n && Ve(o)) {
      const h = this.getIndexWithinParent();
      pd(o, u, h + 1);
      const m = u.__key;
      a && o.anchor.set(m, h + 2, "element"), l && o.focus.set(m, h + 2, "element");
    }
    return t;
  }
  insertBefore(t, n = !0) {
    Bn(), c1(this, t);
    const r = this.getWritable(), i = t.getWritable(), s = i.__key;
    bo(i);
    const o = this.getPreviousSibling(), a = this.getParentOrThrow().getWritable(), l = r.__prev, c = this.getIndexWithinParent();
    o === null ? a.__first = s : o.getWritable().__next = s, a.__size++, r.__prev = s, i.__prev = l, i.__next = r.__key, i.__parent = r.__parent;
    const u = St();
    return n && Ve(u) && pd(u, this.getParentOrThrow(), c), t;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return Ki();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(t, n) {
    Bn();
    const r = this.getPreviousSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (ve(r)) return r.select();
    if (!ke(r)) {
      const s = r.getIndexWithinParent() + 1;
      return i.select(s, s);
    }
    return r.select(t, n);
  }
  selectNext(t, n) {
    Bn();
    const r = this.getNextSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (ve(r)) return r.select(0, 0);
    if (!ke(r)) {
      const s = r.getIndexWithinParent();
      return i.select(s, s);
    }
    return r.select(t, n);
  }
  markDirty() {
    this.getWritable();
  }
  reconcileObservedMutation(t, n) {
    this.markDirty();
  }
}, B2 = class UC extends Wh {
  static getType() {
    return "linebreak";
  }
  static clone(t) {
    return new UC(t.__key);
  }
  constructor(t) {
    super(t);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return { br: (t) => function(n) {
      const r = n.parentElement;
      if (r !== null && S5(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && zu(i)) {
          const s = r.lastChild;
          if (s === n || s.previousSibling === n && zu(s)) return !0;
        }
      }
      return !1;
    }(t) || function(n) {
      const r = n.parentElement;
      if (r !== null && S5(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && zu(i)) return !1;
        const s = r.lastChild;
        if (s === n || s.previousSibling === n && zu(s)) return !0;
      }
      return !1;
    }(t) ? null : { conversion: lM, priority: 0 } };
  }
  static importJSON(t) {
    return _c().updateFromJSON(t);
  }
};
function lM(e) {
  return { node: _c() };
}
function _c() {
  return Uh(new B2());
}
function rc(e) {
  return e instanceof B2;
}
function zu(e) {
  return os(e) && /^( |\t|\r?\n)+$/.test(e.textContent || "");
}
function h1(e, t) {
  return 16 & t ? "code" : t & E2 ? "mark" : 32 & t ? "sub" : 64 & t ? "sup" : null;
}
function p1(e, t) {
  return 1 & t ? "strong" : 2 & t ? "em" : "span";
}
function jC(e, t, n, r, i) {
  const s = r.classList;
  let o = Sa(i, "base");
  o !== void 0 && s.add(...o), o = Sa(i, "underlineStrikethrough");
  let a = !1;
  const l = t & id && t & rd;
  o !== void 0 && (n & id && n & rd ? (a = !0, l || s.add(...o)) : l && s.remove(...o));
  for (const c in Io) {
    const u = Io[c];
    if (o = Sa(i, c), o !== void 0) if (n & u) {
      if (a && (c === "underline" || c === "strikethrough")) {
        t & u && s.remove(...o);
        continue;
      }
      t & u && (!l || c !== "underline") && c !== "strikethrough" || s.add(...o);
    } else t & u && s.remove(...o);
  }
}
function WC(e, t, n) {
  const r = t.firstChild, i = n.isComposing(), s = e + (i ? Rh : "");
  if (r == null) t.textContent = s;
  else {
    const o = r.nodeValue;
    if (o !== s) if (i || Ps) {
      const [a, l, c] = function(u, f) {
        const d = u.length, h = f.length;
        let m = 0, p = 0;
        for (; m < d && m < h && u[m] === f[m]; ) m++;
        for (; p + m < d && p + m < h && u[d - p - 1] === f[h - p - 1]; ) p++;
        return [m, d - m - p, f.slice(m, h - p)];
      }(o, s);
      l !== 0 && r.deleteData(a, l), r.insertData(a, c);
    } else r.nodeValue = s;
  }
}
function O5(e, t, n, r, i, s) {
  WC(i, e, t);
  const o = s.theme.text;
  o !== void 0 && jC(0, 0, r, e, o);
}
function Hu(e, t) {
  const n = document.createElement(t);
  return n.appendChild(e), n;
}
let Jh = class JC extends Wh {
  static getType() {
    return "text";
  }
  static clone(t) {
    return new JC(t.__text, t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__text = t.__text, this.__format = t.__format, this.__style = t.__style, this.__mode = t.__mode, this.__detail = t.__detail;
  }
  constructor(t = "", n) {
    super(n), this.__text = t, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const t = this.getLatest();
    return RL[t.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === Ts();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(t) {
    const n = Io[t];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(t, n) {
    return ad(this.getLatest().__format, t, n);
  }
  canHaveFormat() {
    return !0;
  }
  createDOM(t, n) {
    const r = this.__format, i = h1(0, r), s = p1(0, r), o = i === null ? s : i, a = document.createElement(o);
    let l = a;
    this.hasFormat("code") && a.setAttribute("spellcheck", "false"), i !== null && (l = document.createElement(s), a.appendChild(l)), O5(l, this, 0, r, this.__text, t);
    const c = this.__style;
    return c !== "" && (a.style.cssText = c), a;
  }
  updateDOM(t, n, r) {
    const i = this.__text, s = t.__format, o = this.__format, a = h1(0, s), l = h1(0, o), c = p1(0, s), u = p1(0, o);
    if ((a === null ? c : a) !== (l === null ? u : l)) return !0;
    if (a === l && c !== u) {
      const p = n.firstChild;
      p == null && we(48);
      const y = document.createElement(u);
      return O5(y, this, 0, o, i, r), n.replaceChild(y, p), !1;
    }
    let f = n;
    l !== null && a !== null && (f = n.firstChild, f == null && we(49)), WC(i, f, this);
    const d = r.theme.text;
    d !== void 0 && s !== o && jC(0, s, o, f, d);
    const h = t.__style, m = this.__style;
    return h !== m && (n.style.cssText = m), !1;
  }
  static importDOM() {
    return { "#text": () => ({ conversion: dM, priority: 0 }), b: () => ({ conversion: uM, priority: 0 }), code: () => ({ conversion: ps, priority: 0 }), em: () => ({ conversion: ps, priority: 0 }), i: () => ({ conversion: ps, priority: 0 }), s: () => ({ conversion: ps, priority: 0 }), span: () => ({ conversion: cM, priority: 0 }), strong: () => ({ conversion: ps, priority: 0 }), sub: () => ({ conversion: ps, priority: 0 }), sup: () => ({ conversion: ps, priority: 0 }), u: () => ({ conversion: ps, priority: 0 }) };
  }
  static importJSON(t) {
    return an().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setTextContent(t.text).setFormat(t.format).setDetail(t.detail).setMode(t.mode).setStyle(t.style);
  }
  exportDOM(t) {
    let { element: n } = super.exportDOM(t);
    return Sr(n) || we(132), n.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (n = Hu(n, "b")), this.hasFormat("italic") && (n = Hu(n, "i")), this.hasFormat("strikethrough") && (n = Hu(n, "s")), this.hasFormat("underline") && (n = Hu(n, "u")), { element: n };
  }
  exportJSON() {
    return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), ...super.exportJSON() };
  }
  selectionTransform(t, n) {
  }
  setFormat(t) {
    const n = this.getWritable();
    return n.__format = typeof t == "string" ? Io[t] : t, n;
  }
  setDetail(t) {
    const n = this.getWritable();
    return n.__detail = typeof t == "string" ? PL[t] : t, n;
  }
  setStyle(t) {
    const n = this.getWritable();
    return n.__style = t, n;
  }
  toggleFormat(t) {
    const n = ad(this.getFormat(), t, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const t = this.getWritable();
    return t.__detail ^= 1, t;
  }
  toggleUnmergeable() {
    const t = this.getWritable();
    return t.__detail ^= 2, t;
  }
  setMode(t) {
    const n = FL[t];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return r.__mode = n, r;
  }
  setTextContent(t) {
    if (this.__text === t) return this;
    const n = this.getWritable();
    return n.__text = t, n;
  }
  select(t, n) {
    Bn();
    let r = t, i = n;
    const s = St(), o = this.getTextContent(), a = this.__key;
    if (typeof o == "string") {
      const l = o.length;
      r === void 0 && (r = l), i === void 0 && (i = l);
    } else r = 0, i = 0;
    if (!Ve(s)) return QC(a, r, a, i, "text", "text");
    {
      const l = Ts();
      l !== s.anchor.key && l !== s.focus.key || ln(a), s.setTextNodeRange(this, r, this, i);
    }
    return s;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const t = this.getTextContentSize();
    return this.select(t, t);
  }
  spliceText(t, n, r, i) {
    const s = this.getWritable(), o = s.__text, a = r.length;
    let l = t;
    l < 0 && (l = a + l, l < 0 && (l = 0));
    const c = St();
    if (i && Ve(c)) {
      const f = t + a;
      c.setTextNodeRange(s, f, s, f);
    }
    const u = o.slice(0, l) + r + o.slice(l + n);
    return s.__text = u, s;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...t) {
    Bn();
    const n = this.getLatest(), r = n.getTextContent(), i = n.__key, s = Ts(), o = new Set(t), a = [], l = r.length;
    let c = "";
    for (let b = 0; b < l; b++) c !== "" && o.has(b) && (a.push(c), c = ""), c += r[b];
    c !== "" && a.push(c);
    const u = a.length;
    if (u === 0) return [];
    if (a[0] === r) return [n];
    const f = a[0], d = n.getParent();
    let h;
    const m = n.getFormat(), p = n.getStyle(), y = n.__detail;
    let v = !1;
    n.isSegmented() ? (h = an(f), h.__format = m, h.__style = p, h.__detail = y, v = !0) : (h = n.getWritable(), h.__text = f);
    const g = St(), x = [h];
    let _ = f.length;
    for (let b = 1; b < u; b++) {
      const C = a[b], E = C.length, S = an(C).getWritable();
      S.__format = m, S.__style = p, S.__detail = y;
      const k = S.__key, M = _ + E;
      if (Ve(g)) {
        const O = g.anchor, R = g.focus;
        O.key === i && O.type === "text" && O.offset > _ && O.offset <= M && (O.key = k, O.offset -= _, g.dirty = !0), R.key === i && R.type === "text" && R.offset > _ && R.offset <= M && (R.key = k, R.offset -= _, g.dirty = !0);
      }
      s === i && ln(k), _ = M, x.push(S);
    }
    if (d !== null) {
      (function(E) {
        const S = E.getPreviousSibling(), k = E.getNextSibling();
        S !== null && ld(S), k !== null && ld(k);
      })(this);
      const b = d.getWritable(), C = this.getIndexWithinParent();
      v ? (b.splice(C, 0, x), this.remove()) : b.splice(C, 1, x), Ve(g) && pd(g, d, C, u - 1);
    }
    return x;
  }
  mergeWithSibling(t) {
    const n = t === this.getPreviousSibling();
    n || t === this.getNextSibling() || we(50);
    const r = this.__key, i = t.__key, s = this.__text, o = s.length;
    Ts() === i && ln(r);
    const a = St();
    if (Ve(a)) {
      const f = a.anchor, d = a.focus;
      f !== null && f.key === i && (j5(f, n, r, t, o), a.dirty = !0), d !== null && d.key === i && (j5(d, n, r, t, o), a.dirty = !0);
    }
    const l = t.__text, c = n ? l + s : s + l;
    this.setTextContent(c);
    const u = this.getWritable();
    return t.remove(), u;
  }
  isTextEntity() {
    return !1;
  }
};
function cM(e) {
  return { forChild: z2(e.style), node: null };
}
function uM(e) {
  const t = e, n = t.style.fontWeight === "normal";
  return { forChild: z2(t.style, n ? void 0 : "bold"), node: null };
}
const P5 = /* @__PURE__ */ new WeakMap();
function fM(e) {
  if (!Sr(e)) return !1;
  if (e.nodeName === "PRE") return !0;
  const t = e.style.whiteSpace;
  return typeof t == "string" && t.startsWith("pre");
}
function dM(e) {
  const t = e;
  e.parentElement === null && we(129);
  let n = t.textContent || "";
  if (function(r) {
    let i, s = r.parentNode;
    const o = [r];
    for (; s !== null && (i = P5.get(s)) === void 0 && !fM(s); ) o.push(s), s = s.parentNode;
    const a = i === void 0 ? s : i;
    for (let l = 0; l < o.length; l++) P5.set(o[l], a);
    return a;
  }(t) !== null) {
    const r = n.split(/(\r?\n|\t)/), i = [], s = r.length;
    for (let o = 0; o < s; o++) {
      const a = r[o];
      a === `
` || a === `\r
` ? i.push(_c()) : a === "	" ? i.push(U2()) : a !== "" && i.push(an(a));
    }
    return { node: i };
  }
  if (n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), n === "") return { node: null };
  if (n[0] === " ") {
    let r = t, i = !0;
    for (; r !== null && (r = D5(r, !1)) !== null; ) {
      const s = r.textContent || "";
      if (s.length > 0) {
        /[ \t\n]$/.test(s) && (n = n.slice(1)), i = !1;
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = t, i = !0;
    for (; r !== null && (r = D5(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: an(n) };
}
function D5(e, t) {
  let n = e;
  for (; ; ) {
    let r;
    for (; (r = t ? n.nextSibling : n.previousSibling) === null; ) {
      const s = n.parentElement;
      if (s === null) return null;
      n = s;
    }
    if (n = r, Sr(n)) {
      const s = n.style.display;
      if (s === "" && !QL(n) || s !== "" && !s.startsWith("inline")) return null;
    }
    let i = n;
    for (; (i = t ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (os(n)) return n;
    if (n.nodeName === "BR") return null;
  }
}
const hM = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
function ps(e) {
  const t = hM[e.nodeName.toLowerCase()];
  return t === void 0 ? { node: null } : { forChild: z2(e.style, t), node: null };
}
function an(e = "") {
  return Uh(new Jh(e));
}
function ke(e) {
  return e instanceof Jh;
}
function z2(e, t) {
  const n = e.fontWeight, r = e.textDecoration.split(" "), i = n === "700" || n === "bold", s = r.includes("line-through"), o = e.fontStyle === "italic", a = r.includes("underline"), l = e.verticalAlign;
  return (c) => (ke(c) && (i && !c.hasFormat("bold") && c.toggleFormat("bold"), s && !c.hasFormat("strikethrough") && c.toggleFormat("strikethrough"), o && !c.hasFormat("italic") && c.toggleFormat("italic"), a && !c.hasFormat("underline") && c.toggleFormat("underline"), l !== "sub" || c.hasFormat("subscript") || c.toggleFormat("subscript"), l !== "super" || c.hasFormat("superscript") || c.toggleFormat("superscript"), t && !c.hasFormat(t) && c.toggleFormat(t)), c);
}
let H2 = class KC extends Jh {
  static getType() {
    return "tab";
  }
  static clone(t) {
    return new KC(t.__key);
  }
  constructor(t) {
    super("	", t), this.__detail = 2;
  }
  static importDOM() {
    return null;
  }
  createDOM(t) {
    const n = super.createDOM(t), r = Sa(t.theme, "tab");
    return r !== void 0 && n.classList.add(...r), n;
  }
  static importJSON(t) {
    return U2().updateFromJSON(t);
  }
  setTextContent(t) {
    return t !== "	" && t !== "" && we(126), super.setTextContent(t);
  }
  setDetail(t) {
    return t !== 2 && we(127), this;
  }
  setMode(t) {
    return t !== "normal" && we(128), this;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
};
function U2() {
  return Uh(new H2());
}
function pM(e) {
  return e instanceof H2;
}
let mM = class {
  constructor(t, n, r) {
    this._selection = null, this.key = t, this.offset = n, this.type = r;
  }
  is(t) {
    return this.key === t.key && this.offset === t.offset && this.type === t.type;
  }
  isBefore(t) {
    let n = this.getNode(), r = t.getNode();
    const i = this.offset, s = t.offset;
    if (ve(n)) {
      const o = n.getDescendantByIndex(i);
      n = o ?? n;
    }
    if (ve(r)) {
      const o = r.getDescendantByIndex(s);
      r = o ?? r;
    }
    return n === r ? i < s : n.isBefore(r);
  }
  getNode() {
    const t = un(this.key);
    return t === null && we(20), t;
  }
  set(t, n, r) {
    const i = this._selection, s = this.key;
    this.key = t, this.offset = n, this.type = r, Gc() || (Ts() === s && ln(t), i !== null && (i.setCachedNodes(null), i.dirty = !0));
  }
};
function Bs(e, t, n) {
  return new mM(e, t, n);
}
function m1(e, t) {
  let n = t.__key, r = e.offset, i = "element";
  if (ke(t)) {
    i = "text";
    const s = t.getTextContentSize();
    r > s && (r = s);
  } else if (!ve(t)) {
    const s = t.getNextSibling();
    if (ke(s)) n = s.__key, r = 0, i = "text";
    else {
      const o = t.getParent();
      o && (n = o.__key, r = t.getIndexWithinParent() + 1);
    }
  }
  e.set(n, r, i);
}
function F5(e, t) {
  if (ve(t)) {
    const n = t.getLastDescendant();
    ve(n) || ke(n) ? m1(e, n) : m1(e, t);
  } else m1(e, t);
}
function Ss(e, t, n, r) {
  e.key = t, e.offset = n, e.type = r;
}
let qC = class GC {
  constructor(t) {
    this._cachedNodes = null, this._nodes = t, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    if (!j2(t)) return !1;
    const n = this._nodes, r = t._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(t) {
    this.dirty = !0, this._nodes.add(t), this._cachedNodes = null;
  }
  delete(t) {
    this.dirty = !0, this._nodes.delete(t), this._cachedNodes = null;
  }
  clear() {
    this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
  }
  has(t) {
    return this._nodes.has(t);
  }
  clone() {
    return new GC(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(t) {
  }
  insertText() {
  }
  insertNodes(t) {
    const n = this.getNodes(), r = n.length, i = n[r - 1];
    let s;
    if (ke(i)) s = i.select();
    else {
      const o = i.getIndexWithinParent() + 1;
      s = i.getParentOrThrow().select(o, o);
    }
    s.insertNodes(t);
    for (let o = 0; o < r; o++) n[o].remove();
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this._nodes, r = [];
    for (const i of n) {
      const s = un(i);
      s !== null && r.push(s);
    }
    return Gc() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const t = this.getNodes();
    let n = "";
    for (let r = 0; r < t.length; r++) n += t[r].getTextContent();
    return n;
  }
};
function Ve(e) {
  return e instanceof Kh;
}
let Kh = class YC {
  constructor(t, n, r, i) {
    this.anchor = t, this.focus = n, t._selection = this, n._selection = this, this._cachedNodes = null, this.format = r, this.style = i, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    return !!Ve(t) && this.anchor.is(t.anchor) && this.focus.is(t.focus) && this.format === t.format && this.style === t.style;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this.anchor, r = this.focus, i = n.isBefore(r), s = i ? n : r, o = i ? r : n;
    let a = s.getNode(), l = o.getNode();
    const c = ve(a) && s.offset > 0 && s.offset >= a.getChildrenSize(), u = s.offset, f = o.offset;
    if (ve(a)) {
      const h = a.getDescendantByIndex(u);
      a = h ?? a;
    }
    if (ve(l)) {
      let h = l.getDescendantByIndex(f);
      h !== null && h !== a && l.getChildAtIndex(f) === h && (h = h.getPreviousSibling()), l = h ?? l;
    }
    let d;
    if (a.is(l)) d = ve(a) && a.getChildrenSize() > 0 ? [] : [a];
    else if (d = a.getNodesBetween(l), c) {
      const h = d.findIndex((m) => !m.is(a) && !m.isBefore(a));
      d.splice(0, h);
    }
    return Gc() || (this._cachedNodes = d), d;
  }
  setTextNodeRange(t, n, r, i) {
    Ss(this.anchor, t.__key, n, "text"), Ss(this.focus, r.__key, i, "text"), this._cachedNodes = null, this.dirty = !0;
  }
  getTextContent() {
    const t = this.getNodes();
    if (t.length === 0) return "";
    const n = t[0], r = t[t.length - 1], i = this.anchor, s = this.focus, o = i.isBefore(s), [a, l] = $5(this);
    let c = "", u = !0;
    for (let f = 0; f < t.length; f++) {
      const d = t[f];
      if (ve(d) && !d.isInline()) u || (c += `
`), u = !d.isEmpty();
      else if (u = !1, ke(d)) {
        let h = d.getTextContent();
        d === n ? d === r ? i.type === "element" && s.type === "element" && s.offset !== i.offset || (h = a < l ? h.slice(a, l) : h.slice(l, a)) : h = o ? h.slice(a) : h.slice(l) : d === r && (h = o ? h.slice(0, l) : h.slice(0, a)), c += h;
      } else !Dt(d) && !rc(d) || d === r && this.isCollapsed() || (c += d.getTextContent());
    }
    return c;
  }
  applyDOMRange(t) {
    const n = Wt(), r = n.getEditorState()._selection, i = ZC(t.startContainer, t.startOffset, t.endContainer, t.endOffset, n, r);
    if (i === null) return;
    const [s, o] = i;
    Ss(this.anchor, s.key, s.offset, s.type), Ss(this.focus, o.key, o.offset, o.type), this._cachedNodes = null;
  }
  clone() {
    const t = this.anchor, n = this.focus;
    return new YC(Bs(t.key, t.offset, t.type), Bs(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(t) {
    this.format = ad(this.format, t, null), this.dirty = !0;
  }
  setStyle(t) {
    this.style = t, this.dirty = !0;
  }
  hasFormat(t) {
    const n = Io[t];
    return !!(this.format & n);
  }
  insertRawText(t) {
    const n = t.split(/(\r?\n|\t)/), r = [], i = n.length;
    for (let s = 0; s < i; s++) {
      const o = n[s];
      o === `
` || o === `\r
` ? r.push(_c()) : o === "	" ? r.push(U2()) : r.push(an(o));
    }
    this.insertNodes(r);
  }
  insertText(t) {
    const n = this.anchor, r = this.focus, i = this.format, s = this.style;
    let o = n, a = r;
    !this.isCollapsed() && r.isBefore(n) && (o = r, a = n), o.type === "element" && function(y, v, g, x) {
      const _ = y.getNode(), b = _.getChildAtIndex(y.offset), C = an(), E = yr(_) ? Ki().append(C) : C;
      C.setFormat(g), C.setStyle(x), b === null ? _.append(E) : b.insertBefore(E), y.is(v) && v.set(C.__key, 0, "text"), y.set(C.__key, 0, "text");
    }(o, a, i, s);
    const l = o.offset;
    let c = a.offset;
    const u = this.getNodes(), f = u.length;
    let d = u[0];
    ke(d) || we(26);
    const h = d.getTextContent().length, m = d.getParentOrThrow();
    let p = u[f - 1];
    if (f === 1 && a.type === "element" && (c = h, a.set(o.key, c, "text")), this.isCollapsed() && l === h && (d.isSegmented() || d.isToken() || !d.canInsertTextAfter() || !m.canInsertTextAfter() && d.getNextSibling() === null)) {
      let y = d.getNextSibling();
      if (ke(y) && y.canInsertTextBefore() && !fo(y) || (y = an(), y.setFormat(i), y.setStyle(s), m.canInsertTextAfter() ? d.insertAfter(y) : m.insertAfter(y)), y.select(0, 0), d = y, t !== "") return void this.insertText(t);
    } else if (this.isCollapsed() && l === 0 && (d.isSegmented() || d.isToken() || !d.canInsertTextBefore() || !m.canInsertTextBefore() && d.getPreviousSibling() === null)) {
      let y = d.getPreviousSibling();
      if (ke(y) && !fo(y) || (y = an(), y.setFormat(i), m.canInsertTextBefore() ? d.insertBefore(y) : m.insertBefore(y)), y.select(), d = y, t !== "") return void this.insertText(t);
    } else if (d.isSegmented() && l !== h) {
      const y = an(d.getTextContent());
      y.setFormat(i), d.replace(y), d = y;
    } else if (!this.isCollapsed() && t !== "") {
      const y = p.getParent();
      if (!m.canInsertTextBefore() || !m.canInsertTextAfter() || ve(y) && (!y.canInsertTextBefore() || !y.canInsertTextAfter())) return this.insertText(""), XC(this.anchor, this.focus, null), void this.insertText(t);
    }
    if (f === 1) {
      if (d.isToken()) {
        const x = an(t);
        return x.select(), void d.replace(x);
      }
      const y = d.getFormat(), v = d.getStyle();
      if (l !== c || y === i && v === s) {
        if (pM(d)) {
          const x = an(t);
          return x.setFormat(i), x.setStyle(s), x.select(), void d.replace(x);
        }
      } else {
        if (d.getTextContent() !== "") {
          const x = an(t);
          if (x.setFormat(i), x.setStyle(s), x.select(), l === 0) d.insertBefore(x, !1);
          else {
            const [_] = d.splitText(l);
            _.insertAfter(x, !1);
          }
          return void (x.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length));
        }
        d.setFormat(i), d.setStyle(s);
      }
      const g = c - l;
      d = d.spliceText(l, g, t, !0), d.getTextContent() === "" ? d.remove() : this.anchor.type === "text" && (d.isComposing() ? this.anchor.offset -= t.length : (this.format = y, this.style = v));
    } else {
      const y = /* @__PURE__ */ new Set([...d.getParentKeys(), ...p.getParentKeys()]), v = ve(d) ? d : d.getParentOrThrow();
      let g = ve(p) ? p : p.getParentOrThrow(), x = p;
      if (!v.is(g) && g.isInline()) do
        x = g, g = g.getParentOrThrow();
      while (g.isInline());
      if (a.type === "text" && (c !== 0 || p.getTextContent() === "") || a.type === "element" && p.getIndexWithinParent() < c) if (ke(p) && !p.isToken() && c !== p.getTextContentSize()) {
        if (p.isSegmented()) {
          const S = an(p.getTextContent());
          p.replace(S), p = S;
        }
        yr(a.getNode()) || a.type !== "text" || (p = p.spliceText(0, c, "")), y.add(p.__key);
      } else {
        const S = p.getParentOrThrow();
        S.canBeEmpty() || S.getChildrenSize() !== 1 ? p.remove() : S.remove();
      }
      else y.add(p.__key);
      const _ = g.getChildren(), b = new Set(u), C = v.is(g), E = v.isInline() && d.getNextSibling() === null ? v : d;
      for (let S = _.length - 1; S >= 0; S--) {
        const k = _[S];
        if (k.is(d) || ve(k) && k.isParentOf(d)) break;
        k.isAttached() && (!b.has(k) || k.is(x) ? C || E.insertAfter(k, !1) : k.remove());
      }
      if (!C) {
        let S = g, k = null;
        for (; S !== null; ) {
          const M = S.getChildren(), O = M.length;
          (O === 0 || M[O - 1].is(k)) && (y.delete(S.__key), k = S), S = S.getParent();
        }
      }
      if (d.isToken()) if (l === h) d.select();
      else {
        const S = an(t);
        S.select(), d.replace(S);
      }
      else d = d.spliceText(l, h - l, t, !0), d.getTextContent() === "" ? d.remove() : d.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length);
      for (let S = 1; S < f; S++) {
        const k = u[S], M = k.__key;
        y.has(M) || k.remove();
      }
    }
  }
  removeText() {
    if (this.isCollapsed()) return;
    const { anchor: t, focus: n } = this, r = this.getNodes(), i = this.isBackward() ? n : t, s = this.isBackward() ? t : n;
    let o = i.getNode(), a = s.getNode();
    const l = Ol(o, ws), c = Ol(a, ws);
    ke(o) && o.isToken() && i.offset < o.getTextContentSize() && (i.offset = 0), s.offset > 0 && ke(a) && a.isToken() && (s.offset = a.getTextContentSize());
    for (const f of r) ec(o, f) || ec(a, f) || f.getKey() === o.getKey() || f.getKey() === a.getKey() || f.remove();
    const u = (f, d) => {
      if (f.getTextContent() === "") f.remove();
      else if (d !== 0 && fo(f)) {
        const h = an(f.getTextContent());
        return h.setFormat(f.getFormat()), h.setStyle(f.getStyle()), f.replace(h);
      }
    };
    if (o === a && ke(o)) {
      const f = Math.abs(n.offset - t.offset);
      return o.spliceText(i.offset, f, "", !0), void u(o, f);
    }
    if (ke(o)) {
      const f = o.getTextContentSize() - i.offset;
      o.spliceText(i.offset, f, ""), o = u(o, f) || o;
    }
    ke(a) && (a.spliceText(0, s.offset, ""), a = u(a, s.offset) || a), o.isAttached() && ke(o) ? o.selectEnd() : a.isAttached() && ke(a) && a.selectStart(), ve(l) && ve(c) && l !== c && (l.append(...c.getChildren()), c.remove(), s.set(i.key, i.offset, i.type));
  }
  formatText(t, n = null) {
    if (this.isCollapsed()) return this.toggleFormat(t), void ln(null);
    const r = this.getNodes(), i = [];
    for (const _ of r) ke(_) && i.push(_);
    const s = (_) => {
      r.forEach((b) => {
        if (ve(b)) {
          const C = b.getFormatFlags(t, _);
          b.setTextFormat(C);
        }
      });
    }, o = i.length;
    if (o === 0) return this.toggleFormat(t), ln(null), void s(n);
    const a = this.anchor, l = this.focus, c = this.isBackward(), u = c ? l : a, f = c ? a : l;
    let d = 0, h = i[0], m = u.type === "element" ? 0 : u.offset;
    if (u.type === "text" && m === h.getTextContentSize() && (d = 1, h = i[1], m = 0), h == null) return;
    const p = h.getFormatFlags(t, n);
    s(p);
    const y = o - 1;
    let v = i[y];
    const g = f.type === "text" ? f.offset : v.getTextContentSize();
    if (h.is(v)) {
      if (m === g) return;
      if (fo(h) || m === 0 && g === h.getTextContentSize()) h.setFormat(p);
      else {
        const _ = h.splitText(m, g), b = m === 0 ? _[0] : _[1];
        b.setFormat(p), u.type === "text" && u.set(b.__key, 0, "text"), f.type === "text" && f.set(b.__key, g - m, "text");
      }
      return void (this.format = p);
    }
    m === 0 || fo(h) || ([, h] = h.splitText(m), m = 0), h.setFormat(p);
    const x = v.getFormatFlags(t, p);
    g > 0 && (g === v.getTextContentSize() || fo(v) || ([v] = v.splitText(g)), v.setFormat(x));
    for (let _ = d + 1; _ < y; _++) {
      const b = i[_], C = b.getFormatFlags(t, x);
      b.setFormat(C);
    }
    u.type === "text" && u.set(h.__key, m, "text"), f.type === "text" && f.set(v.__key, g, "text"), this.format = p | x;
  }
  insertNodes(t) {
    if (t.length === 0) return;
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const m = St();
      return Ve(m) || we(134), m.insertNodes(t);
    }
    const n = (this.isBackward() ? this.focus : this.anchor).getNode(), r = Ol(n, ws), i = t[t.length - 1];
    if (ve(r) && "__language" in r) {
      if ("__language" in t[0]) this.insertText(t[0].getTextContent());
      else {
        const m = g1(this);
        r.splice(m, 0, t), i.selectEnd();
      }
      return;
    }
    if (!t.some((m) => (ve(m) || Dt(m)) && !m.isInline())) {
      ve(r) || we(211, n.constructor.name, n.getType());
      const m = g1(this);
      return r.splice(m, 0, t), void i.selectEnd();
    }
    const s = function(m) {
      const p = Ki();
      let y = null;
      for (let v = 0; v < m.length; v++) {
        const g = m[v], x = rc(g);
        if (x || Dt(g) && g.isInline() || ve(g) && g.isInline() || ke(g) || g.isParentRequired()) {
          if (y === null && (y = g.createParentElementNode(), p.append(y), x)) continue;
          y !== null && y.append(g);
        } else p.append(g), y = null;
      }
      return p;
    }(t), o = s.getLastDescendant(), a = s.getChildren(), l = !ve(r) || !r.isEmpty() ? this.insertParagraph() : null, c = a[a.length - 1];
    let u = a[0];
    var f;
    ve(f = u) && ws(f) && !f.isEmpty() && ve(r) && (!r.isEmpty() || r.canMergeWhenEmpty()) && (ve(r) || we(211, n.constructor.name, n.getType()), r.append(...u.getChildren()), u = a[1]), u && (r === null && we(212, n.constructor.name, n.getType()), function(m, p, y) {
      const v = p.getParentOrThrow().getLastChild();
      let g = p;
      const x = [p];
      for (; g !== v; ) g.getNextSibling() || we(140), g = g.getNextSibling(), x.push(g);
      let _ = m;
      for (const b of x) _ = _.insertAfter(b);
    }(r, u));
    const d = Ol(o, ws);
    l && ve(d) && (l.canMergeWhenEmpty() || ws(c)) && (d.append(...l.getChildren()), l.remove()), ve(r) && r.isEmpty() && r.remove(), o.selectEnd();
    const h = ve(r) ? r.getLastChild() : null;
    rc(h) && d !== r && h.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const o = Ki();
      return Vr().splice(this.anchor.offset, 0, [o]), o.select(), o;
    }
    const t = g1(this), n = Ol(this.anchor.getNode(), ws);
    ve(n) || we(213);
    const r = n.getChildAtIndex(t), i = r ? [r, ...r.getNextSiblings()] : [], s = n.insertNewAfter(this, !1);
    return s ? (s.append(...i), s.selectStart(), s) : null;
  }
  insertLineBreak(t) {
    const n = _c();
    if (this.insertNodes([n]), t) {
      const r = n.getParentOrThrow(), i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const t = this.getNodes(), n = t.length, r = n - 1, i = this.anchor, s = this.focus;
    let o = t[0], a = t[r];
    const [l, c] = $5(this);
    if (n === 0) return [];
    if (n === 1) {
      if (ke(o) && !this.isCollapsed()) {
        const f = l > c ? c : l, d = l > c ? l : c, h = o.splitText(f, d), m = f === 0 ? h[0] : h[1];
        return m != null ? [m] : [];
      }
      return [o];
    }
    const u = i.isBefore(s);
    if (ke(o)) {
      const f = u ? l : c;
      f === o.getTextContentSize() ? t.shift() : f !== 0 && ([, o] = o.splitText(f), t[0] = o);
    }
    if (ke(a)) {
      const f = a.getTextContent().length, d = u ? c : l;
      d === 0 ? t.pop() : d !== f && ([a] = a.splitText(d), t[r] = a);
    }
    return t;
  }
  modify(t, n, r) {
    const i = this.focus, s = this.anchor, o = t === "move", a = E5(i, n);
    if (Dt(a) && !a.isIsolated()) {
      if (o && a.isKeyboardSelectable()) {
        const h = H5();
        return h.add(a.__key), void $s(h);
      }
      const d = n ? a.getPreviousSibling() : a.getNextSibling();
      if (ke(d)) {
        const h = d.__key, m = n ? d.getTextContent().length : 0;
        return i.set(h, m, "text"), void (o && s.set(h, m, "text"));
      }
      {
        const h = a.getParentOrThrow();
        let m, p;
        return ve(d) ? (p = d.__key, m = n ? d.getChildrenSize() : 0) : (m = a.getIndexWithinParent(), p = h.__key, n || m++), i.set(p, m, "element"), void (o && s.set(p, m, "element"));
      }
    }
    const l = Wt(), c = Yi(l._window);
    if (!c) return;
    const u = l._blockCursorElement, f = l._rootElement;
    if (f === null || u === null || !ve(a) || a.isInline() || a.canBeEmpty() || V2(u, l, f), function(d, h, m, p) {
      d.modify(h, m, p);
    }(c, t, n ? "backward" : "forward", r), c.rangeCount > 0) {
      const d = c.getRangeAt(0), h = this.anchor.getNode(), m = yr(h) ? h : GL(h);
      if (this.applyDOMRange(d), this.dirty = !0, !o) {
        const p = this.getNodes(), y = [];
        let v = !1;
        for (let g = 0; g < p.length; g++) {
          const x = p[g];
          ec(x, m) ? y.push(x) : v = !0;
        }
        if (v && y.length > 0) if (n) {
          const g = y[0];
          ve(g) ? g.selectStart() : g.getParentOrThrow().selectStart();
        } else {
          const g = y[y.length - 1];
          ve(g) ? g.selectEnd() : g.getParentOrThrow().selectEnd();
        }
        c.anchorNode === d.startContainer && c.anchorOffset === d.startOffset || function(g) {
          const x = g.focus, _ = g.anchor, b = _.key, C = _.offset, E = _.type;
          Ss(_, x.key, x.offset, x.type), Ss(x, b, C, E), g._cachedNodes = null;
        }(this);
      }
    }
  }
  forwardDeletion(t, n, r) {
    if (!r && (t.type === "element" && ve(n) && t.offset === n.getChildrenSize() || t.type === "text" && t.offset === n.getTextContentSize())) {
      const i = n.getParent(), s = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (ve(s) && s.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(t) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, t)) return;
      const s = this.focus, o = E5(s, t);
      if (Dt(o) && !o.isIsolated()) {
        if (o.isKeyboardSelectable() && ve(i) && i.getChildrenSize() === 0) {
          i.remove();
          const a = H5();
          a.add(o.__key), $s(a);
        } else
          o.remove(), Wt().dispatchCommand(b2, void 0);
        return;
      }
      if (!t && ve(o) && ve(i) && i.isEmpty()) return i.remove(), void o.selectStart();
      if (this.modify("extend", t, "character"), this.isCollapsed()) {
        if (t && r.offset === 0 && (r.type === "element" ? r.getNode() : r.getNode().getParentOrThrow()).collapseAtStart(this))
          return;
      } else {
        const a = s.type === "text" ? s.getNode() : null;
        if (i = r.type === "text" ? r.getNode() : null, a !== null && a.isSegmented()) {
          const l = s.offset, c = a.getTextContentSize();
          if (a.is(i) || t && l !== c || !t && l !== 0) return void V5(a, t, l);
        } else if (i !== null && i.isSegmented()) {
          const l = r.offset, c = i.getTextContentSize();
          if (i.is(a) || t && l !== 0 || !t && l !== c) return void V5(i, t, l);
        }
        (function(l, c) {
          const u = l.anchor, f = l.focus, d = u.getNode(), h = f.getNode();
          if (d === h && u.type === "text" && f.type === "text") {
            const m = u.offset, p = f.offset, y = m < p, v = y ? m : p, g = y ? p : m, x = g - 1;
            v !== x && (EC(d.getTextContent().slice(v, g)) || (c ? f.offset = x : u.offset = x));
          }
        })(this, t);
      }
    }
    if (this.removeText(), t && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const r = this.anchor.getNode();
      r.isEmpty() && yr(r.getParent()) && r.getIndexWithinParent() === 0 && r.collapseAtStart(this);
    }
  }
  deleteLine(t) {
    if (this.isCollapsed()) {
      const n = this.anchor.type === "element";
      if (n && this.insertText(" "), this.modify("extend", t, "lineboundary"), this.isCollapsed() && this.anchor.offset === 0 && this.modify("extend", t, "character"), n) {
        const r = t ? this.anchor : this.focus;
        r.set(r.key, r.offset + 1, r.type);
      }
    }
    this.removeText();
  }
  deleteWord(t) {
    if (this.isCollapsed()) {
      const n = this.anchor, r = n.getNode();
      if (this.forwardDeletion(n, r, t)) return;
      this.modify("extend", t, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function j2(e) {
  return e instanceof qC;
}
function R5(e) {
  const t = e.offset;
  if (e.type === "text") return t;
  const n = e.getNode();
  return t === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function $5(e) {
  const t = e.getStartEndPoints();
  if (t === null) return [0, 0];
  const [n, r] = t;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset ? [0, 0] : [R5(n), R5(r)];
}
function V5(e, t, n) {
  const r = e, i = r.getTextContent().split(/(?=\s)/g), s = i.length;
  let o = 0, a = 0;
  for (let c = 0; c < s; c++) {
    const u = c === s - 1;
    if (a = o, o += i[c].length, t && o === n || o > n || u) {
      i.splice(c, 1), u && (a = void 0);
      break;
    }
  }
  const l = i.join("").trim();
  l === "" ? r.remove() : (r.setTextContent(l), r.select(a, a));
}
function B5(e, t, n, r) {
  let i, s = t;
  if (Sr(e)) {
    let o = !1;
    const a = e.childNodes, l = a.length, c = r._blockCursorElement;
    s === l && (o = !0, s = l - 1);
    let u = a[s], f = !1;
    if (u === c) u = a[s + 1], f = !0;
    else if (c !== null) {
      const d = c.parentNode;
      e === d && t > Array.prototype.indexOf.call(d.children, c) && s--;
    }
    if (i = ya(u), ke(i)) s = y5(i, o);
    else {
      let d = ya(e);
      if (d === null) return null;
      if (ve(d)) {
        const h = r.getElementByKey(d.getKey());
        h === null && we(214), [d, s] = d.getDOMSlot(h).resolveChildIndex(d, h, e, t), ve(d) || we(215), o && s >= d.getChildrenSize() && (s = Math.max(0, d.getChildrenSize() - 1));
        let p = d.getChildAtIndex(s);
        if (ve(p) && function(y, v, g) {
          const x = y.getParent();
          return g === null || x === null || !x.canBeEmpty() || x !== g.getNode();
        }(p, 0, n)) {
          const y = o ? p.getLastDescendant() : p.getFirstDescendant();
          y === null ? d = p : (p = y, d = ve(p) ? p : p.getParentOrThrow()), s = 0;
        }
        ke(p) ? (i = p, d = null, s = y5(p, o)) : p !== d && o && !f && (ve(d) || we(216), s = Math.min(d.getChildrenSize(), s + 1));
      } else {
        const h = d.getIndexWithinParent();
        s = t === 0 && Dt(d) && ya(e) === d ? h : h + 1, d = d.getParentOrThrow();
      }
      if (ve(d)) return Bs(d.__key, s, "element");
    }
  } else i = ya(e);
  return ke(i) ? Bs(i.__key, s, "text") : null;
}
function z5(e, t, n) {
  const r = e.offset, i = e.getNode();
  if (r === 0) {
    const s = i.getPreviousSibling(), o = i.getParent();
    if (t) {
      if ((n || !t) && s === null && ve(o) && o.isInline()) {
        const a = o.getPreviousSibling();
        ke(a) && (e.key = a.__key, e.offset = a.getTextContent().length);
      }
    } else ve(s) && !n && s.isInline() ? (e.key = s.__key, e.offset = s.getChildrenSize(), e.type = "element") : ke(s) && (e.key = s.__key, e.offset = s.getTextContent().length);
  } else if (r === i.getTextContent().length) {
    const s = i.getNextSibling(), o = i.getParent();
    if (t && ve(s) && s.isInline()) e.key = s.__key, e.offset = 0, e.type = "element";
    else if ((n || t) && s === null && ve(o) && o.isInline() && !o.canInsertTextAfter()) {
      const a = o.getNextSibling();
      ke(a) && (e.key = a.__key, e.offset = 0);
    }
  }
}
function XC(e, t, n) {
  if (e.type === "text" && t.type === "text") {
    const r = e.isBefore(t), i = e.is(t);
    z5(e, r, i), z5(t, !r, i), i && (t.key = e.key, t.offset = e.offset, t.type = e.type);
    const s = Wt();
    if (s.isComposing() && s._compositionKey !== e.key && Ve(n)) {
      const o = n.anchor, a = n.focus;
      Ss(e, o.key, o.offset, o.type), Ss(t, a.key, a.offset, a.type);
    }
  }
}
function ZC(e, t, n, r, i, s) {
  if (e === null || n === null || !$h(i, e, n)) return null;
  const o = B5(e, t, Ve(s) ? s.anchor : null, i);
  if (o === null) return null;
  const a = B5(n, r, Ve(s) ? s.focus : null, i);
  if (a === null) return null;
  if (o.type === "element" && a.type === "element") {
    const l = ya(e), c = ya(n);
    if (Dt(l) && Dt(c)) return null;
  }
  return XC(o, a, s), [o, a];
}
function QC(e, t, n, r, i, s) {
  const o = Gs(), a = new Kh(Bs(e, t, i), Bs(n, r, s), 0, "");
  return a.dirty = !0, o._selection = a, a;
}
function H5() {
  return new qC(/* @__PURE__ */ new Set());
}
function W2(e, t, n, r) {
  const i = n._window;
  if (i === null) return null;
  const s = r || i.event, o = s ? s.type : void 0, a = o === "selectionchange", l = !ig && (a || o === "beforeinput" || o === "compositionstart" || o === "compositionend" || o === "click" && s && s.detail === 3 || o === "drop" || o === void 0);
  let c, u, f, d;
  if (Ve(e) && !l) return e.clone();
  if (t === null) return null;
  if (c = t.anchorNode, u = t.focusNode, f = t.anchorOffset, d = t.focusOffset, a && Ve(e) && !$h(n, c, u)) return e.clone();
  const h = ZC(c, f, u, d, n, e);
  if (h === null) return null;
  const [m, p] = h;
  return new Kh(m, p, Ve(e) ? e.format : 0, Ve(e) ? e.style : "");
}
function St() {
  return Gs()._selection;
}
function qh() {
  return Wt()._editorState._selection;
}
function pd(e, t, n, r = 1) {
  const i = e.anchor, s = e.focus, o = i.getNode(), a = s.getNode();
  if (!t.is(o) && !t.is(a)) return;
  const l = t.__key;
  if (e.isCollapsed()) {
    const c = i.offset;
    if (n <= c && r > 0 || n < c && r < 0) {
      const u = Math.max(0, c + r);
      i.set(l, u, "element"), s.set(l, u, "element"), U5(e);
    }
  } else {
    const c = e.isBackward(), u = c ? s : i, f = u.getNode(), d = c ? i : s, h = d.getNode();
    if (t.is(f)) {
      const m = u.offset;
      (n <= m && r > 0 || n < m && r < 0) && u.set(l, Math.max(0, m + r), "element");
    }
    if (t.is(h)) {
      const m = d.offset;
      (n <= m && r > 0 || n < m && r < 0) && d.set(l, Math.max(0, m + r), "element");
    }
  }
  U5(e);
}
function U5(e) {
  const t = e.anchor, n = t.offset, r = e.focus, i = r.offset, s = t.getNode(), o = r.getNode();
  if (e.isCollapsed()) {
    if (!ve(s)) return;
    const a = s.getChildrenSize(), l = n >= a, c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(n);
    if (ke(c)) {
      let u = 0;
      l && (u = c.getTextContentSize()), t.set(c.__key, u, "text"), r.set(c.__key, u, "text");
    }
  } else {
    if (ve(s)) {
      const a = s.getChildrenSize(), l = n >= a, c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(n);
      if (ke(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), t.set(c.__key, u, "text");
      }
    }
    if (ve(o)) {
      const a = o.getChildrenSize(), l = i >= a, c = l ? o.getChildAtIndex(a - 1) : o.getChildAtIndex(i);
      if (ke(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), r.set(c.__key, u, "text");
      }
    }
  }
}
function md(e, t, n, r, i) {
  let s = null, o = 0, a = null;
  r !== null ? (s = r.__key, ke(r) ? (o = r.getTextContentSize(), a = "text") : ve(r) && (o = r.getChildrenSize(), a = "element")) : i !== null && (s = i.__key, ke(i) ? a = "text" : ve(i) && (a = "element")), s !== null && a !== null ? e.set(s, o, a) : (o = t.getIndexWithinParent(), o === -1 && (o = n.getChildrenSize()), e.set(n.__key, o, "element"));
}
function j5(e, t, n, r, i) {
  e.type === "text" ? (e.key = n, t || (e.offset += i)) : e.offset > r.getIndexWithinParent() && (e.offset -= 1);
}
function gM(e, t, n, r, i, s, o) {
  const a = r.anchorNode, l = r.focusNode, c = r.anchorOffset, u = r.focusOffset, f = document.activeElement;
  if (i.has("collaboration") && f !== s || f !== null && xC(f)) return;
  if (!Ve(t)) return void (e !== null && $h(n, a, l) && r.removeAllRanges());
  const d = t.anchor, h = t.focus, m = d.key, p = h.key, y = cd(n, m), v = cd(n, p), g = d.offset, x = h.offset, _ = t.format, b = t.style, C = t.isCollapsed();
  let E = y, S = v, k = !1;
  if (d.type === "text") {
    E = od(y);
    const P = d.getNode();
    k = P.getFormat() !== _ || P.getStyle() !== b;
  } else Ve(e) && e.anchor.type === "text" && (k = !0);
  var M, O, R, I, H;
  if (h.type === "text" && (S = od(v)), E !== null && S !== null && (C && (e === null || k || Ve(e) && (e.format !== _ || e.style !== b)) && (M = _, O = b, R = g, I = m, H = performance.now(), $C = [M, O, R, I, H]), c !== g || u !== x || a !== E || l !== S || r.type === "Range" && C || (f !== null && s.contains(f) || s.focus({ preventScroll: !0 }), d.type === "element"))) {
    try {
      r.setBaseAndExtent(E, g, S, x);
    } catch {
    }
    if (!i.has("skip-scroll-into-view") && t.isCollapsed() && s !== null && s === document.activeElement) {
      const P = Ve(t) && t.anchor.type === "element" ? E.childNodes[g] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (P !== null) {
        let W;
        if (P instanceof Text) {
          const G = document.createRange();
          G.selectNode(P), W = G.getBoundingClientRect();
        } else W = P.getBoundingClientRect();
        (function(G, J, X) {
          const N = AC(X), U = $2(N);
          if (N === null || U === null) return;
          let { top: ee, bottom: F } = J, ue = 0, pe = 0, ce = X;
          for (; ce !== null; ) {
            const q = ce === N.body;
            if (q) ue = 0, pe = Hh(G).innerHeight;
            else {
              const oe = ce.getBoundingClientRect();
              ue = oe.top, pe = oe.bottom;
            }
            let Z = 0;
            if (ee < ue ? Z = -(ue - ee) : F > pe && (Z = F - pe), Z !== 0) if (q) U.scrollBy(0, Z);
            else {
              const oe = ce.scrollTop;
              ce.scrollTop += Z;
              const le = ce.scrollTop - oe;
              ee -= le, F -= le;
            }
            if (q) break;
            ce = Jc(ce);
          }
        })(n, W, s);
      }
    }
    hg = !0;
  }
}
function g1(e) {
  let t = e;
  e.isCollapsed() || t.removeText();
  const n = St();
  Ve(n) && (t = n), Ve(t) || we(161);
  const r = t.anchor;
  let i = r.getNode(), s = r.offset;
  for (; !ws(i); ) [i, s] = vM(i, s);
  return s;
}
function vM(e, t) {
  const n = e.getParent();
  if (!n) {
    const i = Ki();
    return Vr().append(i), i.select(), [Vr(), 0];
  }
  if (ke(e)) {
    const i = e.splitText(t);
    if (i.length === 0) return [n, e.getIndexWithinParent()];
    const s = t === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + s];
  }
  if (!ve(e) || t === 0) return [n, e.getIndexWithinParent()];
  const r = e.getChildAtIndex(t);
  if (r) {
    const i = new Kh(Bs(e.__key, t, "element"), Bs(e.__key, t, "element"), 0, ""), s = e.insertNewAfter(i);
    s && s.append(r, ...r.getNextSiblings());
  }
  return [n, e.getIndexWithinParent() + 1];
}
let tn = null, nn = null, Un = !1, v1 = !1, Tf = 0;
const W5 = { characterData: !0, childList: !0, subtree: !0 };
function Gc() {
  return Un || tn !== null && tn._readOnly;
}
function Bn() {
  Un && we(13);
}
function eE() {
  Tf > 99 && we(14);
}
function Gs() {
  return tn === null && we(195, tE()), tn;
}
function Wt() {
  return nn === null && we(196, tE()), nn;
}
function tE() {
  let e = 0;
  const t = /* @__PURE__ */ new Set(), n = Yh.version;
  if (typeof window < "u") for (const i of document.querySelectorAll("[contenteditable]")) {
    const s = Vh(i);
    if (M2(s)) e++;
    else if (s) {
      let o = String(s.constructor.version || "<0.17.1");
      o === n && (o += " (separately built, likely a bundler configuration issue)"), t.add(o);
    }
  }
  let r = ` Detected on the page: ${e} compatible editor(s) with version ${n}`;
  return t.size && (r += ` and incompatible editors with versions ${Array.from(t).join(", ")}`), r;
}
function yM() {
  return nn;
}
function J5(e, t, n) {
  const r = t.__type, i = function(a, l) {
    const c = a._nodes.get(l);
    return c === void 0 && we(30, l), c;
  }(e, r);
  let s = n.get(r);
  s === void 0 && (s = Array.from(i.transforms), n.set(r, s));
  const o = s.length;
  for (let a = 0; a < o && (s[a](t), t.isAttached()); a++) ;
}
function K5(e, t) {
  return e !== void 0 && e.__key !== t && e.isAttached();
}
function nE(e, t) {
  if (!t) return;
  const n = e._updateTags;
  let r = t;
  Array.isArray(t) || (r = [t]);
  for (const i of r) n.add(i);
}
function rE(e, t) {
  const n = e.type, r = t.get(n);
  r === void 0 && we(17, n);
  const i = r.klass;
  e.type !== i.getType() && we(18, i.name);
  const s = i.importJSON(e), o = e.children;
  if (ve(s) && Array.isArray(o)) for (let a = 0; a < o.length; a++) {
    const l = rE(o[a], t);
    s.append(l);
  }
  return s;
}
function q5(e, t, n) {
  const r = tn, i = Un, s = nn;
  tn = t, Un = !0, nn = e;
  try {
    return n();
  } finally {
    tn = r, Un = i, nn = s;
  }
}
function Bi(e, t) {
  const n = e._pendingEditorState, r = e._rootElement, i = e._headless || r === null;
  if (n === null) return;
  const s = e._editorState, o = s._selection, a = n._selection, l = e._dirtyType !== No, c = tn, u = Un, f = nn, d = e._updating, h = e._observer;
  let m = null;
  if (e._pendingEditorState = null, e._editorState = n, !i && l && h !== null) {
    nn = e, tn = n, Un = !1, e._updating = !0;
    try {
      const C = e._dirtyType, E = e._dirtyElements, S = e._dirtyLeaves;
      h.disconnect(), m = oM(s, n, e, C, E, S);
    } catch (C) {
      if (C instanceof Error && e._onError(C), v1) throw C;
      return hE(e, null, r, n), yC(e), e._dirtyType = Va, v1 = !0, Bi(e, s), void (v1 = !1);
    } finally {
      h.observe(r, W5), e._updating = d, tn = c, Un = u, nn = f;
    }
  }
  n._readOnly || (n._readOnly = !0);
  const p = e._dirtyLeaves, y = e._dirtyElements, v = e._normalizedNodes, g = e._updateTags, x = e._deferred;
  l && (e._dirtyType = No, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements = /* @__PURE__ */ new Map(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set()), function(C, E) {
    const S = C._decorators;
    let k = C._pendingDecorators || S;
    const M = E._nodeMap;
    let O;
    for (O in k) M.has(O) || (k === S && (k = bC(C)), delete k[O]);
  }(e, n);
  const _ = i ? null : Yi(e._window);
  if (e._editable && _ !== null && (l || a === null || a.dirty) && r !== null && !g.has("skip-dom-selection")) {
    nn = e, tn = n;
    try {
      if (h !== null && h.disconnect(), l || a === null || a.dirty) {
        const C = e._blockCursorElement;
        C !== null && V2(C, e, r), gM(o, a, e, _, g, r);
      }
      YL(e, r, a), h !== null && h.observe(r, W5);
    } finally {
      nn = f, tn = c;
    }
  }
  m !== null && function(C, E, S, k, M) {
    const O = Array.from(C._listeners.mutation), R = O.length;
    for (let I = 0; I < R; I++) {
      const [H, P] = O[I], W = E.get(P);
      W !== void 0 && H(W, { dirtyLeaves: k, prevEditorState: M, updateTags: S });
    }
  }(e, m, g, p, s), Ve(a) || a === null || o !== null && o.is(a) || e.dispatchCommand(b2, void 0);
  const b = e._pendingDecorators;
  b !== null && (e._decorators = b, e._pendingDecorators = null, ic("decorator", e, !0, b)), function(C, E, S) {
    const k = v5(E), M = v5(S);
    k !== M && ic("textcontent", C, !0, M);
  }(e, t || s, n), ic("update", e, !0, { dirtyElements: y, dirtyLeaves: p, editorState: n, normalizedNodes: v, prevEditorState: t || s, tags: g }), function(C, E) {
    if (C._deferred = [], E.length !== 0) {
      const S = C._updating;
      C._updating = !0;
      try {
        for (let k = 0; k < E.length; k++) E[k]();
      } finally {
        C._updating = S;
      }
    }
  }(e, x), function(C) {
    const E = C._updates;
    if (E.length !== 0) {
      const S = E.shift();
      if (S) {
        const [k, M] = S;
        sE(C, k, M);
      }
    }
  }(e);
}
function ic(e, t, n, ...r) {
  const i = t._updating;
  t._updating = n;
  try {
    const s = Array.from(t._listeners[e]);
    for (let o = 0; o < s.length; o++) s[o].apply(null, r);
  } finally {
    t._updating = i;
  }
}
function iE(e, t, n) {
  if (e._updating === !1 || nn !== e) {
    let i = !1;
    return e.update(() => {
      i = iE(e, t, n);
    }), i;
  }
  const r = P2(e);
  for (let i = 4; i >= 0; i--) for (let s = 0; s < r.length; s++) {
    const o = r[s]._commands.get(t);
    if (o !== void 0) {
      const a = o[i];
      if (a !== void 0) {
        const l = Array.from(a), c = l.length;
        for (let u = 0; u < c; u++) if (l[u](n, e) === !0) return !0;
      }
    }
  }
  return !1;
}
function G5(e, t) {
  const n = e._updates;
  let r = t || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [s, o] = i;
      let a;
      if (o !== void 0) {
        if (a = o.onUpdate, o.skipTransforms && (r = !0), o.discrete) {
          const l = e._pendingEditorState;
          l === null && we(191), l._flushSync = !0;
        }
        a && e._deferred.push(a), nE(e, o.tag);
      }
      s();
    }
  }
  return r;
}
function sE(e, t, n) {
  const r = e._updateTags;
  let i, s = !1, o = !1;
  n !== void 0 && (i = n.onUpdate, nE(e, n.tag), s = n.skipTransforms || !1, o = n.discrete || !1), i && e._deferred.push(i);
  const a = e._editorState;
  let l = e._pendingEditorState, c = !1;
  (l === null || l._readOnly) && (l = e._pendingEditorState = aE(l || a), c = !0), l._flushSync = o;
  const u = tn, f = Un, d = nn, h = e._updating;
  tn = l, Un = !1, e._updating = !0, nn = e;
  try {
    c && (e._headless ? a._selection !== null && (l._selection = a._selection.clone()) : l._selection = function(v) {
      const g = v.getEditorState()._selection, x = Yi(v._window);
      return Ve(g) || g == null ? W2(g, x, v, null) : g.clone();
    }(e));
    const p = e._compositionKey;
    t(), s = G5(e, s), function(v, g) {
      const x = g.getEditorState()._selection, _ = v._selection;
      if (Ve(_)) {
        const b = _.anchor, C = _.focus;
        let E;
        if (b.type === "text" && (E = b.getNode(), E.selectionTransform(x, _)), C.type === "text") {
          const S = C.getNode();
          E !== S && S.selectionTransform(x, _);
        }
      }
    }(l, e), e._dirtyType !== No && (s ? function(v, g) {
      const x = g._dirtyLeaves, _ = v._nodeMap;
      for (const b of x) {
        const C = _.get(b);
        ke(C) && C.isAttached() && C.isSimpleText() && !C.isUnmergeable() && g5(C);
      }
    }(l, e) : function(v, g) {
      const x = g._dirtyLeaves, _ = g._dirtyElements, b = v._nodeMap, C = Ts(), E = /* @__PURE__ */ new Map();
      let S = x, k = S.size, M = _, O = M.size;
      for (; k > 0 || O > 0; ) {
        if (k > 0) {
          g._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const R of S) {
            const I = b.get(R);
            ke(I) && I.isAttached() && I.isSimpleText() && !I.isUnmergeable() && g5(I), I !== void 0 && K5(I, C) && J5(g, I, E), x.add(R);
          }
          if (S = g._dirtyLeaves, k = S.size, k > 0) {
            Tf++;
            continue;
          }
        }
        g._dirtyLeaves = /* @__PURE__ */ new Set(), g._dirtyElements = /* @__PURE__ */ new Map();
        for (const R of M) {
          const I = R[0], H = R[1];
          if (I !== "root" && !H) continue;
          const P = b.get(I);
          P !== void 0 && K5(P, C) && J5(g, P, E), _.set(I, H);
        }
        S = g._dirtyLeaves, k = S.size, M = g._dirtyElements, O = M.size, Tf++;
      }
      g._dirtyLeaves = x, g._dirtyElements = _;
    }(l, e), G5(e), function(v, g, x, _) {
      const b = v._nodeMap, C = g._nodeMap, E = [];
      for (const [S] of _) {
        const k = C.get(S);
        k !== void 0 && (k.isAttached() || (ve(k) && NC(k, S, b, C, E, _), b.has(S) || _.delete(S), E.push(S)));
      }
      for (const S of E) C.delete(S);
      for (const S of x) {
        const k = C.get(S);
        k === void 0 || k.isAttached() || (b.has(S) || x.delete(S), C.delete(S));
      }
    }(a, l, e._dirtyLeaves, e._dirtyElements)), p !== e._compositionKey && (l._flushSync = !0);
    const y = l._selection;
    if (Ve(y)) {
      const v = l._nodeMap, g = y.anchor.key, x = y.focus.key;
      v.get(g) !== void 0 && v.get(x) !== void 0 || we(19);
    } else j2(y) && y._nodes.size === 0 && (l._selection = null);
  } catch (p) {
    return p instanceof Error && e._onError(p), e._pendingEditorState = a, e._dirtyType = Va, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), void Bi(e);
  } finally {
    tn = u, Un = f, nn = d, e._updating = h, Tf = 0;
  }
  e._dirtyType !== No || e._deferred.length > 0 || function(p, y) {
    const v = y.getEditorState()._selection, g = p._selection;
    if (g !== null) {
      if (g.dirty || !g.is(v)) return !0;
    } else if (v !== null) return !0;
    return !1;
  }(l, e) ? l._flushSync ? (l._flushSync = !1, Bi(e)) : c && WL(() => {
    Bi(e);
  }) : (l._flushSync = !1, c && (r.clear(), e._deferred = [], e._pendingEditorState = null));
}
function hr(e, t, n) {
  e._updating ? e._updates.push([t, n]) : sE(e, t, n);
}
let xM = class Af {
  constructor(t, n, r) {
    this.element = t, this.before = n || null, this.after = r || null;
  }
  withBefore(t) {
    return new Af(this.element, t, this.after);
  }
  withAfter(t) {
    return new Af(this.element, this.before, t);
  }
  withElement(t) {
    return new Af(t, this.before, this.after);
  }
  insertChild(t) {
    const n = this.before || this.getManagedLineBreak();
    return n !== null && n.parentElement !== this.element && we(222), this.element.insertBefore(t, n), this;
  }
  removeChild(t) {
    return t.parentElement !== this.element && we(223), this.element.removeChild(t), this;
  }
  replaceChild(t, n) {
    return n.parentElement !== this.element && we(224), this.element.replaceChild(t, n), this;
  }
  getFirstChild() {
    const t = this.after ? this.after.nextSibling : this.element.firstChild;
    return t === this.before || t === this.getManagedLineBreak() ? null : t;
  }
  getManagedLineBreak() {
    return this.element.__lexicalLineBreak || null;
  }
  setManagedLineBreak(t) {
    if (t === null) this.removeManagedLineBreak();
    else {
      const n = t === "decorator" && (Wc || Fh);
      this.insertManagedLineBreak(n);
    }
  }
  removeManagedLineBreak() {
    const t = this.getManagedLineBreak();
    if (t) {
      const n = this.element, r = t.nodeName === "IMG" ? t.nextSibling : null;
      r && n.removeChild(r), n.removeChild(t), n.__lexicalLineBreak = void 0;
    }
  }
  insertManagedLineBreak(t) {
    const n = this.getManagedLineBreak();
    if (n) {
      if (t === (n.nodeName === "IMG")) return;
      this.removeManagedLineBreak();
    }
    const r = this.element, i = this.before, s = document.createElement("br");
    if (r.insertBefore(s, i), t) {
      const o = document.createElement("img");
      o.setAttribute("data-lexical-linebreak", "true"), o.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;", o.alt = "", r.insertBefore(o, s), r.__lexicalLineBreak = o;
    } else r.__lexicalLineBreak = s;
  }
  getFirstChildOffset() {
    let t = 0;
    for (let n = this.after; n !== null; n = n.previousSibling) t++;
    return t;
  }
  resolveChildIndex(t, n, r, i) {
    if (r === this.element) {
      const l = this.getFirstChildOffset();
      return [t, Math.min(l + t.getChildrenSize(), Math.max(l, i))];
    }
    const s = Y5(n, r);
    s.push(i);
    const o = Y5(n, this.element);
    let a = t.getIndexWithinParent();
    for (let l = 0; l < o.length; l++) {
      const c = s[l], u = o[l];
      if (c === void 0 || c < u) break;
      if (c > u) {
        a += 1;
        break;
      }
    }
    return [t.getParentOrThrow(), a];
  }
};
function Y5(e, t) {
  const n = [];
  let r = t;
  for (; r !== e && r !== null; r = t.parentNode) {
    let i = 0;
    for (let s = r.previousSibling; s !== null; s = r.previousSibling) i++;
    n.push(i);
  }
  return r !== e && we(225), n.reverse();
}
let Gh = class extends Wh {
  constructor(t) {
    super(t), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__style = "", this.__indent = 0, this.__dir = null, this.__textFormat = 0, this.__textStyle = "";
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__first = t.__first, this.__last = t.__last, this.__size = t.__size, this.__indent = t.__indent, this.__format = t.__format, this.__style = t.__style, this.__dir = t.__dir, this.__textFormat = t.__textFormat, this.__textStyle = t.__textStyle;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const t = this.getFormat();
    return DL[t] || "";
  }
  getStyle() {
    return this.getLatest().__style;
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n), n = n.getNextSibling();
    return t;
  }
  getChildrenKeys() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n.__key), n = n.getNextSibling();
    return t;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const t = Wt()._dirtyElements;
    return t !== null && t.has(this.__key);
  }
  isLastChild() {
    const t = this.getLatest(), n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(t);
  }
  getAllTextNodes() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if (ke(n) && t.push(n), ve(n)) {
        const r = n.getAllTextNodes();
        t.push(...r);
      }
      n = n.getNextSibling();
    }
    return t;
  }
  getFirstDescendant() {
    let t = this.getFirstChild();
    for (; ve(t); ) {
      const n = t.getFirstChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getLastDescendant() {
    let t = this.getLastChild();
    for (; ve(t); ) {
      const n = t.getLastChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getDescendantByIndex(t) {
    const n = this.getChildren(), r = n.length;
    if (t >= r) {
      const s = n[r - 1];
      return ve(s) && s.getLastDescendant() || s || null;
    }
    const i = n[t];
    return ve(i) && i.getFirstDescendant() || i || null;
  }
  getFirstChild() {
    const t = this.getLatest().__first;
    return t === null ? null : un(t);
  }
  getFirstChildOrThrow() {
    const t = this.getFirstChild();
    return t === null && we(45, this.__key), t;
  }
  getLastChild() {
    const t = this.getLatest().__last;
    return t === null ? null : un(t);
  }
  getLastChildOrThrow() {
    const t = this.getLastChild();
    return t === null && we(96, this.__key), t;
  }
  getChildAtIndex(t) {
    const n = this.getChildrenSize();
    let r, i;
    if (t < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= t; ) {
        if (i === t) return r;
        r = r.getNextSibling(), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= t; ) {
      if (i === t) return r;
      r = r.getPreviousSibling(), i--;
    }
    return null;
  }
  getTextContent() {
    let t = "";
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const s = n[i];
      t += s.getTextContent(), ve(s) && i !== r - 1 && !s.isInline() && (t += Gi);
    }
    return t;
  }
  getTextContentSize() {
    let t = 0;
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const s = n[i];
      t += s.getTextContentSize(), ve(s) && i !== r - 1 && !s.isInline() && (t += Gi.length);
    }
    return t;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  hasFormat(t) {
    if (t !== "") {
      const n = h5[t];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  hasTextFormat(t) {
    const n = Io[t];
    return !!(this.getTextFormat() & n);
  }
  getFormatFlags(t, n) {
    return ad(this.getLatest().__textFormat, t, n);
  }
  getTextStyle() {
    return this.getLatest().__textStyle;
  }
  select(t, n) {
    Bn();
    const r = St();
    let i = t, s = n;
    const o = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (t === 0 && n === 0) {
        const l = this.getFirstChild();
        if (ke(l) || ve(l)) return l.select(0, 0);
      } else if (!(t !== void 0 && t !== o || n !== void 0 && n !== o)) {
        const l = this.getLastChild();
        if (ke(l) || ve(l)) return l.select();
      }
    }
    i === void 0 && (i = o), s === void 0 && (s = o);
    const a = this.__key;
    return Ve(r) ? (r.anchor.set(a, i, "element"), r.focus.set(a, s, "element"), r.dirty = !0, r) : QC(a, i, a, s, "element", "element");
  }
  selectStart() {
    const t = this.getFirstDescendant();
    return t ? t.selectStart() : this.select();
  }
  selectEnd() {
    const t = this.getLastDescendant();
    return t ? t.selectEnd() : this.select();
  }
  clear() {
    const t = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), t;
  }
  append(...t) {
    return this.splice(this.getChildrenSize(), 0, t);
  }
  setDirection(t) {
    const n = this.getWritable();
    return n.__dir = t, n;
  }
  setFormat(t) {
    return this.getWritable().__format = t !== "" ? h5[t] : 0, this;
  }
  setStyle(t) {
    return this.getWritable().__style = t || "", this;
  }
  setTextFormat(t) {
    const n = this.getWritable();
    return n.__textFormat = t, n;
  }
  setTextStyle(t) {
    const n = this.getWritable();
    return n.__textStyle = t, n;
  }
  setIndent(t) {
    return this.getWritable().__indent = t, this;
  }
  splice(t, n, r) {
    const i = r.length, s = this.getChildrenSize(), o = this.getWritable();
    t + n <= s || we(226, String(t), String(n), String(s));
    const a = o.__key, l = [], c = [], u = this.getChildAtIndex(t + n);
    let f = null, d = s - n + i;
    if (t !== 0) if (t === s) f = this.getLastChild();
    else {
      const m = this.getChildAtIndex(t);
      m !== null && (f = m.getPreviousSibling());
    }
    if (n > 0) {
      let m = f === null ? this.getFirstChild() : f.getNextSibling();
      for (let p = 0; p < n; p++) {
        m === null && we(100);
        const y = m.getNextSibling(), v = m.__key;
        bo(m.getWritable()), c.push(v), m = y;
      }
    }
    let h = f;
    for (let m = 0; m < i; m++) {
      const p = r[m];
      h !== null && p.is(h) && (f = h = h.getPreviousSibling());
      const y = p.getWritable();
      y.__parent === a && d--, bo(y);
      const v = p.__key;
      if (h === null) o.__first = v, y.__prev = null;
      else {
        const g = h.getWritable();
        g.__next = v, y.__prev = g.__key;
      }
      p.__key === a && we(76), y.__parent = a, l.push(v), h = p;
    }
    if (t + n === s)
      h !== null && (h.getWritable().__next = null, o.__last = h.__key);
    else if (u !== null) {
      const m = u.getWritable();
      if (h !== null) {
        const p = h.getWritable();
        m.__prev = h.__key, p.__next = u.__key;
      } else m.__prev = null;
    }
    if (o.__size = d, c.length) {
      const m = St();
      if (Ve(m)) {
        const p = new Set(c), y = new Set(l), { anchor: v, focus: g } = m;
        X5(v, p, y) && md(v, v.getNode(), this, f, u), X5(g, p, y) && md(g, g.getNode(), this, f, u), d !== 0 || this.canBeEmpty() || Kc(this) || this.remove();
      }
    }
    return o;
  }
  getDOMSlot(t) {
    return new xM(t);
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (Sr(n)) {
      const r = this.getIndent();
      r > 0 && (n.style.paddingInlineStart = 40 * r + "px");
    }
    return { element: n };
  }
  exportJSON() {
    const t = { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), ...super.exportJSON() }, n = this.getTextFormat(), r = this.getTextStyle();
    return n !== 0 && (t.textFormat = n), r !== "" && (t.textStyle = r), t;
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setFormat(t.format).setIndent(t.indent).setDirection(t.direction).setTextFormat(t.textFormat || 0).setTextStyle(t.textStyle || "");
  }
  insertNewAfter(t, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(t) {
    return !1;
  }
  excludeFromCopy(t) {
    return !1;
  }
  canReplaceWith(t) {
    return !0;
  }
  canInsertAfter(t) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(t) {
    return !1;
  }
  extractWithChild(t, n, r) {
    return !1;
  }
  canMergeWhenEmpty() {
    return !1;
  }
  reconcileObservedMutation(t, n) {
    const r = this.getDOMSlot(t);
    let i = r.getFirstChild();
    for (let s = this.getFirstChild(); s; s = s.getNextSibling()) {
      const o = n.getElementByKey(s.getKey());
      o !== null && (i == null ? (r.insertChild(o), i = o) : i !== o && r.replaceChild(o, i), i = i.nextSibling);
    }
  }
};
function ve(e) {
  return e instanceof Gh;
}
function X5(e, t, n) {
  let r = e.getNode();
  for (; r; ) {
    const i = r.__key;
    if (t.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
let wM = class extends Wh {
  decorate(t, n) {
    we(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
};
function Dt(e) {
  return e instanceof wM;
}
let J2 = class oE extends Gh {
  static getType() {
    return "root";
  }
  static clone() {
    return new oE();
  }
  constructor() {
    super("root"), this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    we(51);
  }
  getTextContent() {
    const t = this.__cachedText;
    return !Gc() && Wt()._dirtyType !== No || t === null ? super.getTextContent() : t;
  }
  remove() {
    we(52);
  }
  replace(t) {
    we(53);
  }
  insertBefore(t) {
    we(54);
  }
  insertAfter(t) {
    we(55);
  }
  updateDOM(t, n) {
    return !1;
  }
  append(...t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      ve(r) || Dt(r) || we(56);
    }
    return super.append(...t);
  }
  static importJSON(t) {
    return Vr().updateFromJSON(t);
  }
  collapseAtStart() {
    return !0;
  }
};
function yr(e) {
  return e instanceof J2;
}
function aE(e) {
  return new cE(new Map(e._nodeMap));
}
function K2() {
  return new cE(/* @__PURE__ */ new Map([["root", new J2()]]));
}
function lE(e) {
  const t = e.exportJSON(), n = e.constructor;
  if (t.type !== n.getType() && we(130, n.name), ve(e)) {
    const r = t.children;
    Array.isArray(r) || we(59, n.name);
    const i = e.getChildren();
    for (let s = 0; s < i.length; s++) {
      const o = lE(i[s]);
      r.push(o);
    }
  }
  return t;
}
let cE = class uE {
  constructor(t, n) {
    this._nodeMap = t, this._selection = n || null, this._flushSync = !1, this._readOnly = !1;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(t, n) {
    return q5(n && n.editor || null, this, t);
  }
  clone(t) {
    const n = new uE(this._nodeMap, t === void 0 ? this._selection : t);
    return n._readOnly = !0, n;
  }
  toJSON() {
    return q5(null, this, () => ({ root: lE(Vr()) }));
  }
}, _M = class extends Gh {
  static getType() {
    return "artificial";
  }
  createDOM(t) {
    return document.createElement("div");
  }
}, fE = class dE extends Gh {
  static getType() {
    return "paragraph";
  }
  static clone(t) {
    return new dE(t.__key);
  }
  createDOM(t) {
    const n = document.createElement("p"), r = Sa(t.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(t, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (t) => ({ conversion: bM, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (Sr(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    return Ki().updateFromJSON(t);
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), textStyle: this.getTextStyle() };
  }
  insertNewAfter(t, n) {
    const r = Ki();
    r.setTextFormat(t.format), r.setTextStyle(t.style);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = this.getChildren();
    if (t.length === 0 || ke(t[0]) && t[0].getTextContent().trim() === "") {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
};
function bM(e) {
  const t = Ki();
  return e.style && (t.setFormat(e.style.textAlign), nM(e, t)), { node: t };
}
function Ki() {
  return Uh(new fE());
}
function hE(e, t, n, r) {
  const i = e._keyToDOMMap;
  i.clear(), e._editorState = K2(), e._pendingEditorState = r, e._compositionKey = null, e._dirtyType = No, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set(), e._updates = [], e._blockCursorElement = null;
  const s = e._observer;
  s !== null && (s.disconnect(), e._observer = null), t !== null && (t.textContent = ""), n !== null && (n.textContent = "", i.set("root", n));
}
function CM(e) {
  const t = e || {}, n = yM(), r = t.theme || {}, i = e === void 0 ? n : t.parentEditor || null, s = t.disableEvents || !1, o = K2(), a = t.namespace || (i !== null ? i._config.namespace : SC()), l = t.editorState, c = [J2, Jh, B2, H2, fE, _M, ...t.nodes || []], { onError: u, html: f } = t, d = t.editable === void 0 || t.editable;
  let h;
  if (e === void 0 && n !== null) h = n._nodes;
  else {
    h = /* @__PURE__ */ new Map();
    for (let p = 0; p < c.length; p++) {
      let y = c[p], v = null, g = null;
      if (typeof y != "function") {
        const C = y;
        y = C.replace, v = C.with, g = C.withKlass || null;
      }
      const x = y.getType(), _ = y.transform(), b = /* @__PURE__ */ new Set();
      _ !== null && b.add(_), h.set(x, { exportDOM: f && f.export ? f.export.get(y) : void 0, klass: y, replace: v, replaceWithKlass: g, transforms: b });
    }
  }
  const m = new Yh(o, i, h, { disableEvents: s, namespace: a, theme: r }, u || console.error, function(p, y) {
    const v = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set(), x = (_) => {
      Object.keys(_).forEach((b) => {
        let C = v.get(b);
        C === void 0 && (C = [], v.set(b, C)), C.push(_[b]);
      });
    };
    return p.forEach((_) => {
      const b = _.klass.importDOM;
      if (b == null || g.has(b)) return;
      g.add(b);
      const C = b.call(_.klass);
      C !== null && x(C);
    }), y && x(y), v;
  }(h, f ? f.import : void 0), d);
  return l !== void 0 && (m._pendingEditorState = l, m._dirtyType = Va), m;
}
let Yh = class {
  constructor(t, n, r, i, s, o, a) {
    this._parentEditor = n, this._rootElement = null, this._editorState = t, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = i, this._nodes = r, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = No, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = SC(), this._onError = s, this._htmlConversions = o, this._editable = a, this._headless = n !== null && n._headless, this._window = null, this._blockCursorElement = null;
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(t) {
    const n = this._listeners.update;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerEditableListener(t) {
    const n = this._listeners.editable;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerDecoratorListener(t) {
    const n = this._listeners.decorator;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerTextContentListener(t) {
    const n = this._listeners.textcontent;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerRootListener(t) {
    const n = this._listeners.root;
    return t(this._rootElement, null), n.add(t), () => {
      t(null, this._rootElement), n.delete(t);
    };
  }
  registerCommand(t, n, r) {
    r === void 0 && we(35);
    const i = this._commands;
    i.has(t) || i.set(t, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    const s = i.get(t);
    s === void 0 && we(36, String(t));
    const o = s[r];
    return o.add(n), () => {
      o.delete(n), s.every((a) => a.size === 0) && i.delete(t);
    };
  }
  registerMutationListener(t, n, r) {
    const i = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(t)).klass, s = this._listeners.mutation;
    s.set(n, i);
    const o = r && r.skipInitialization;
    return o !== void 0 && o || this.initializeMutationListener(n, i), () => {
      s.delete(n);
    };
  }
  getRegisteredNode(t) {
    const n = this._nodes.get(t.getType());
    return n === void 0 && we(37, t.name), n;
  }
  resolveRegisteredNodeAfterReplacements(t) {
    for (; t.replaceWithKlass; ) t = this.getRegisteredNode(t.replaceWithKlass);
    return t;
  }
  initializeMutationListener(t, n) {
    const r = this._editorState, i = T5(r).get(n.getType());
    if (!i) return;
    const s = /* @__PURE__ */ new Map();
    for (const o of i.keys()) s.set(o, "created");
    s.size > 0 && t(s, { dirtyLeaves: /* @__PURE__ */ new Set(), prevEditorState: r, updateTags: /* @__PURE__ */ new Set(["registerMutationListener"]) });
  }
  registerNodeTransformToKlass(t, n) {
    const r = this.getRegisteredNode(t);
    return r.transforms.add(n), r;
  }
  registerNodeTransform(t, n) {
    const r = this.registerNodeTransformToKlass(t, n), i = [r], s = r.replaceWithKlass;
    if (s != null) {
      const o = this.registerNodeTransformToKlass(s, n);
      i.push(o);
    }
    return function(o, a) {
      const l = T5(o.getEditorState()), c = [];
      for (const u of a) {
        const f = l.get(u);
        f && c.push(f);
      }
      c.length !== 0 && o.update(() => {
        for (const u of c) for (const f of u.keys()) {
          const d = un(f);
          d && d.markDirty();
        }
      }, o._pendingEditorState === null ? { tag: "history-merge" } : void 0);
    }(this, i.map((o) => o.klass.getType())), () => {
      i.forEach((o) => o.transforms.delete(n));
    };
  }
  hasNode(t) {
    return this._nodes.has(t.getType());
  }
  hasNodes(t) {
    return t.every(this.hasNode.bind(this));
  }
  dispatchCommand(t, n) {
    return Ee(this, t, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(t) {
    const n = this._rootElement;
    if (t !== n) {
      const r = Sa(this._config.theme, "root"), i = this._pendingEditorState || this._editorState;
      if (this._rootElement = t, hE(this, n, t, i), n !== null && (this._config.disableEvents || aM(n), r != null && n.classList.remove(...r)), t !== null) {
        const s = $2(t), o = t.style;
        o.userSelect = "text", o.whiteSpace = "pre-wrap", o.wordBreak = "break-word", t.setAttribute("data-lexical-editor", "true"), this._window = s, this._dirtyType = Va, yC(this), this._updateTags.add("history-merge"), Bi(this), this._config.disableEvents || function(a, l) {
          const c = a.ownerDocument, u = hd.get(c);
          (u === void 0 || u < 1) && c.addEventListener("selectionchange", HC), hd.set(c, (u || 0) + 1), a.__lexicalEditor = l;
          const f = zC(a);
          for (let d = 0; d < dg.length; d++) {
            const [h, m] = dg[d], p = typeof m == "function" ? (y) => {
              M5(y) || (L5(y), (l.isEditable() || h === "click") && m(y, l));
            } : (y) => {
              if (M5(y)) return;
              L5(y);
              const v = l.isEditable();
              switch (h) {
                case "cut":
                  return v && Ee(l, fC, y);
                case "copy":
                  return Ee(l, uC, y);
                case "paste":
                  return v && Ee(l, aC, y);
                case "dragstart":
                  return v && Ee(l, pL, y);
                case "dragover":
                  return v && Ee(l, mL, y);
                case "dragend":
                  return v && Ee(l, gL, y);
                case "focus":
                  return v && Ee(l, vL, y);
                case "blur":
                  return v && Ee(l, yL, y);
                case "drop":
                  return v && Ee(l, hL, y);
              }
            };
            a.addEventListener(h, p), f.push(() => {
              a.removeEventListener(h, p);
            });
          }
        }(t, this), r != null && t.classList.add(...r);
      } else this._window = null, this._updateTags.add("history-merge"), Bi(this);
      ic("root", this, !1, t, n);
    }
  }
  getElementByKey(t) {
    return this._keyToDOMMap.get(t) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(t, n) {
    t.isEmpty() && we(38);
    let r = t;
    r._readOnly && (r = aE(t), r._selection = t._selection ? t._selection.clone() : null), vC(this);
    const i = this._pendingEditorState, s = this._updateTags, o = n !== void 0 ? n.tag : null;
    i === null || i.isEmpty() || (o != null && s.add(o), Bi(this)), this._pendingEditorState = r, this._dirtyType = Va, this._dirtyElements.set("root", !1), this._compositionKey = null, o != null && s.add(o), this._updating || Bi(this);
  }
  parseEditorState(t, n) {
    return function(r, i, s) {
      const o = K2(), a = tn, l = Un, c = nn, u = i._dirtyElements, f = i._dirtyLeaves, d = i._cloneNotNeeded, h = i._dirtyType;
      i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, tn = o, Un = !1, nn = i;
      try {
        const m = i._nodes;
        rE(r.root, m), s && s(), o._readOnly = !0;
      } catch (m) {
        m instanceof Error && i._onError(m);
      } finally {
        i._dirtyElements = u, i._dirtyLeaves = f, i._cloneNotNeeded = d, i._dirtyType = h, tn = a, Un = l, nn = c;
      }
      return o;
    }(typeof t == "string" ? JSON.parse(t) : t, this, n);
  }
  read(t) {
    return Bi(this), this.getEditorState().read(t, { editor: this });
  }
  update(t, n) {
    hr(this, t, n);
  }
  focus(t, n = {}) {
    const r = this._rootElement;
    r !== null && (r.setAttribute("autocapitalize", "off"), hr(this, () => {
      const i = St(), s = Vr();
      i !== null ? i.dirty = !0 : s.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? s.selectStart() : s.selectEnd());
    }, { onUpdate: () => {
      r.removeAttribute("autocapitalize"), t && t();
    }, tag: "focus" }), this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const t = this._rootElement;
    t !== null && t.blur();
    const n = Yi(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(t) {
    this._editable !== t && (this._editable = t, ic("editable", this, !0, t));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
};
Yh.version = "0.23.1+prod.esm";
const pE = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, EM = pE ? Ko : Le, Uu = { tag: "history-merge" };
function SM({ initialConfig: e, children: t }) {
  const n = Jo(() => {
    const { theme: r, namespace: i, nodes: s, onError: o, editorState: a, html: l } = e, c = QI(null, r), u = CM({ editable: e.editable, html: l, namespace: i, nodes: s, onError: (f) => o(f, u), theme: r });
    return function(f, d) {
      if (d !== null) {
        if (d === void 0) f.update(() => {
          const h = Vr();
          if (h.isEmpty()) {
            const m = Ki();
            h.append(m);
            const p = pE ? document.activeElement : null;
            (St() !== null || p !== null && p === f.getRootElement()) && m.select();
          }
        }, Uu);
        else if (d !== null) switch (typeof d) {
          case "string": {
            const h = f.parseEditorState(d);
            f.setEditorState(h, Uu);
            break;
          }
          case "object":
            f.setEditorState(d, Uu);
            break;
          case "function":
            f.update(() => {
              Vr().isEmpty() && d(f);
            }, Uu);
        }
      }
    }(u, a), [u, c];
  }, []);
  return EM(() => {
    const r = e.editable, [i] = n;
    i.setEditable(r === void 0 || r);
  }, []), A(sC.Provider, { value: n, children: t });
}
var kM = Object.defineProperty, TM = (e, t, n) => t in e ? kM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, _s = (e, t, n) => TM(e, typeof t != "symbol" ? t + "" : t, n);
let AM = class mE {
  constructor(t = /* @__PURE__ */ new Map()) {
    this.map = t;
  }
  clone() {
    return new mE(new Map(this.map));
  }
  increment(t) {
    const n = this.map.get(t) ?? 0;
    this.map.set(t, n + 1);
  }
  decrement(t, n) {
    let r = this.map.get(t);
    r !== void 0 && (r -= 1, this.map.set(t, r), r === 0 && n());
  }
}, ju = class {
  constructor() {
    _s(this, "map", /* @__PURE__ */ new Map());
  }
  getOrCreate(t) {
    let n = this.map.get(t);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), this.map.set(t, n)), n;
  }
  get(t) {
    return this.map.get(t);
  }
  use(t, n) {
    const r = this.get(t);
    r !== void 0 && n(r);
  }
  delete(t) {
    return this.map.delete(t);
  }
};
function xo(e, t) {
  return t(e), e;
}
function q2() {
}
const gE = "cell";
function Z5(e, t) {
  return e === t;
}
const Xh = /* @__PURE__ */ new Map();
let NM = class {
  /**
   * Creates a new realm.
   * @param initialValues - the initial cell values that will populate the realm.
   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
   */
  constructor(t = {}) {
    _s(this, "subscriptions", new ju()), _s(this, "singletonSubscriptions", /* @__PURE__ */ new Map()), _s(this, "graph", new ju()), _s(this, "state", /* @__PURE__ */ new Map()), _s(this, "distinctNodes", /* @__PURE__ */ new Map()), _s(this, "executionMaps", /* @__PURE__ */ new Map()), _s(this, "definitionRegistry", /* @__PURE__ */ new Set());
    for (const n of Object.getOwnPropertySymbols(t))
      this.state.set(n, t[n]);
  }
  /**
   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the cell.
   * @param value - the initial value of the cell
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  cellInstance(t, n = !0, r = Symbol()) {
    return this.state.has(r) || this.state.set(r, t), n !== !1 && !this.distinctNodes.has(r) && this.distinctNodes.set(r, n === !0 ? Z5 : n), r;
  }
  /**
   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the signal.
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  signalInstance(t = !0, n = Symbol()) {
    return t !== !1 && this.distinctNodes.set(n, t === !0 ? Z5 : t), n;
  }
  /**
   * Subscribes to the values published in the referred node.
   * @param node - the cell/signal to subscribe to.
   * @param subscription - the callback to execute when the node receives a new value.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * const unsub = r.sub(signal$, console.log)
   * r.pub(signal$, 2)
   * unsub()
   * r.pub(signal$, 3)
   * ```
   */
  sub(t, n) {
    this.register(t);
    const r = this.subscriptions.getOrCreate(t);
    return r.add(n), () => r.delete(n);
  }
  /**
   * Subscribes exclusively to values in the referred node.
   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
   * Subscriptions created through `sub` are not affected.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * // console.log will run only once.
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.pub(signal$, 2)
   * ```
   */
  singletonSub(t, n) {
    return this.register(t), n === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, n), () => this.singletonSubscriptions.delete(t);
  }
  /**
   * Clears all exclusive subscriptions.
   */
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  // biome-ignore lint/suspicious/noExplicitAny: I know why we need any here
  subMultiple(t, n) {
    const r = this.signalInstance();
    return this.connect({
      map: (i) => (...s) => {
        i(s);
      },
      sink: r,
      sources: t
    }), this.sub(r, n);
  }
  /**
   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
   * @param values - a record of node references and their values.
   *
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   * const bar$ = Cell('bar')
   *
   * const r = new Realm()
   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
   * ```
   */
  pubIn(t) {
    var n;
    const r = Reflect.ownKeys(t), i = this.getExecutionMap(r), s = i.refCount.clone(), o = i.participatingNodes.slice(), a = new Map(this.state), l = (c) => {
      this.graph.use(c, (u) => {
        for (const { sources: f, sink: d } of u)
          f.has(c) && s.decrement(d, () => {
            o.splice(o.indexOf(d), 1), l(d);
          });
      });
    };
    for (; ; ) {
      const c = o.shift();
      if (c === void 0)
        break;
      const u = c;
      let f = !1;
      const d = (h) => {
        const m = this.distinctNodes.get(u);
        if (m != null && m(a.get(u), h)) {
          f = !1;
          return;
        }
        f = !0, a.set(u, h), this.state.has(u) && this.state.set(u, h);
      };
      if (Object.prototype.hasOwnProperty.call(t, u) ? d(t[u]) : i.projections.use(u, (h) => {
        for (const m of h) {
          const p = [...Array.from(m.sources), ...Array.from(m.pulls)].map((y) => a.get(y));
          m.map(d)(...p);
        }
      }), f) {
        const h = a.get(u);
        this.inContext(() => {
          this.subscriptions.use(u, (m) => {
            for (const p of m)
              p(h);
          });
        }), (n = this.singletonSubscriptions.get(u)) == null || n(h);
      } else
        l(u);
    }
  }
  /**
   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
   * The nodes can be active (sources) or passive (pulls).
   */
  connect({
    sources: t,
    pulls: n = [],
    map: r,
    sink: i
  }) {
    const s = {
      map: r,
      pulls: new Set(n),
      sink: this.register(i),
      sources: new Set(t)
    };
    for (const o of [...t, ...n])
      this.register(o), this.graph.getOrCreate(o).add(s);
    this.executionMaps.clear();
  }
  pub(t, n) {
    this.pubIn({ [t]: n });
  }
  pipe(t, ...n) {
    return this.combineOperators(...n)(t);
  }
  transformer(...t) {
    return (n) => xo(this.signalInstance(), (r) => (this.link(this.pipe(r, ...t), n), r));
  }
  /**
   * Links the output of a node to the input of another node.
   */
  link(t, n) {
    this.connect({
      map: (r) => (i) => {
        r(i);
      },
      sink: n,
      sources: [t]
    });
  }
  // prettier-ignore
  combine(...t) {
    return xo(this.signalInstance(), (n) => {
      this.connect({
        map: (r) => (...i) => {
          r(i);
        },
        sink: n,
        sources: t
      });
    });
  }
  // prettier-ignore
  combineCells(...t) {
    return xo(
      this.cellInstance(
        t.map((n) => this.getValue(n)),
        !0
      ),
      (n) => {
        this.connect({
          map: (r) => (...i) => {
            r(i);
          },
          sink: n,
          sources: t
        });
      }
    );
  }
  /**
   * Gets the current value of a node. The node must be stateful.
   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
   * which means that if you call it within a computational cycle, you may not get the correct value.
   * @param node - the node instance.
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   *
   * const r = new Realm()
   * r.getValue(foo$) // 'foo'
   * r.pub(foo$, 'bar')
   * //...
   * r.getValue(foo$) // 'bar'
   * ```
   */
  getValue(t) {
    return this.register(t), this.state.get(t);
  }
  getValues(t) {
    return t.map((n) => this.getValue(n));
  }
  /**
   * Explicitly includes the specified cell/signal reference in the realm.
   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
   */
  register(t) {
    const n = Xh.get(t);
    return n === void 0 || this.definitionRegistry.has(t) ? t : (this.definitionRegistry.add(t), xo(
      n.type === gE ? this.cellInstance(n.initial, n.distinct, t) : this.signalInstance(n.distinct, t),
      (r) => {
        this.inContext(() => {
          n.init(this, r);
        });
      }
    ));
  }
  inContext(t) {
    return t();
  }
  /**
   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
   * the map parameter gets called with the current value of the cell and the value published through the source.
   * @typeParam T - the type of the cell value.
   * @typeParam K - the type of the value published through the source.
   * @example
   * ```ts
   * const items$ = Cell<string[]([])
   * const addItem$ = Signal<string>(false, (r) => {
   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
   * })
   * const r = new Realm()
   * r.pub(addItem$, 'foo')
   * r.pub(addItem$, 'bar')
   * r.getValue(items$) // ['foo', 'bar']
   * ```
   */
  changeWith(t, n, r) {
    this.connect({
      sources: [n],
      pulls: [t],
      sink: t,
      map: (i) => (s, o) => {
        i(r(o, s));
      }
    });
  }
  calculateExecutionMap(t) {
    const n = [], r = /* @__PURE__ */ new Set(), i = new ju(), s = new AM(), o = new ju(), a = (l, c = 0) => {
      s.increment(l), !r.has(l) && (this.register(l), i.use(l, (u) => {
        c = Math.max(...Array.from(u).map((f) => n.indexOf(f))) + 1;
      }), this.graph.use(l, (u) => {
        for (const f of u)
          f.sources.has(l) ? (o.getOrCreate(f.sink).add(f), a(f.sink, c)) : i.getOrCreate(f.sink).add(l);
      }), r.add(l), n.splice(c, 0, l));
    };
    return t.forEach(a), { participatingNodes: n, pendingPulls: i, projections: o, refCount: s };
  }
  getExecutionMap(t) {
    let n = t;
    if (t.length === 1) {
      n = t[0];
      const i = this.executionMaps.get(n);
      if (i !== void 0)
        return i;
    } else
      for (const [i, s] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === t.length && i.every((o) => t.includes(o)))
          return s;
    const r = this.calculateExecutionMap(t);
    return this.executionMaps.set(n, r), r;
  }
  combineOperators(...t) {
    return (n) => {
      for (const r of t)
        n = r(n, this);
      return n;
    };
  }
};
function Te(e, t = q2, n = !0) {
  return xo(Symbol(), (r) => {
    Xh.set(r, { type: gE, distinct: n, initial: e, init: t });
  });
}
function Bt(e = q2, t = !1) {
  return xo(Symbol(), (n) => {
    Xh.set(n, { type: "signal", distinct: t, init: e });
  });
}
function _i(e = q2) {
  return xo(Symbol(), (t) => {
    Xh.set(t, { type: "signal", distinct: !1, init: e });
  });
}
const vE = w.createContext(null);
function Yc() {
  const e = w.useContext(vE);
  if (e === null)
    throw new Error("useRealm must be used within a RealmContextProvider");
  return e;
}
function mn(e) {
  const t = Yc();
  t.register(e);
  const n = w.useCallback((r) => t.sub(e, r), [t, e]);
  return w.useSyncExternalStore(
    n,
    () => t.getValue(e),
    () => t.getValue(e)
  );
}
function On(...e) {
  const t = Yc();
  return mn(t.combineCells.apply(t, e));
}
function It(e) {
  const t = Yc();
  return t.register(e), w.useCallback(
    (n) => {
      t.pub(e, n);
    },
    [t, e]
  );
}
function Ds(e) {
  return (t, n) => {
    const r = n.signalInstance();
    return n.connect({
      map: (i) => (s) => {
        i(e(s));
      },
      sink: r,
      sources: [t]
    }), r;
  };
}
function Tt(...e) {
  return (t, n) => {
    const r = n.signalInstance();
    return n.connect({
      map: (i) => (...s) => {
        i(s);
      },
      pulls: e,
      sink: r,
      sources: [t]
    }), r;
  };
}
function yE(e) {
  return (t, n) => {
    const r = n.signalInstance();
    return n.connect({
      map: (i) => () => {
        i(e);
      },
      sink: r,
      sources: [t]
    }), r;
  };
}
function Xc(e) {
  return (t, n) => {
    const r = n.signalInstance();
    return n.connect({
      map: (i) => (s) => {
        e(s) && i(s);
      },
      sink: r,
      sources: [t]
    }), r;
  };
}
function xE(e, t) {
  return (n, r) => {
    const i = r.signalInstance();
    return r.connect({
      map: (s) => (o) => {
        s(t = e(t, o));
      },
      sink: i,
      sources: [n]
    }), i;
  };
}
function IM(e, t) {
  return t(e), e;
}
function Ta() {
}
function Jn(e) {
  return function(t) {
    return {
      init: (n) => {
        var r;
        return (r = e.init) == null ? void 0 : r.call(e, n, t);
      },
      postInit: (n) => {
        var r;
        return (r = e.postInit) == null ? void 0 : r.call(e, n, t);
      },
      update: (n) => {
        var r;
        return (r = e.update) == null ? void 0 : r.call(e, n, t);
      }
    };
  };
}
function LM({ children: e, plugins: t }) {
  const n = T.useMemo(() => IM(new NM(), (r) => {
    var i, s;
    for (const o of t)
      (i = o.init) == null || i.call(o, r);
    for (const o of t)
      (s = o.postInit) == null || s.call(o, r);
  }), []);
  return T.useEffect(() => {
    var r;
    for (const i of t)
      (r = i.update) == null || r.call(i, n);
  }), /* @__PURE__ */ T.createElement(vE.Provider, { value: n }, e);
}
const gd = al(null);
function wE(e, t) {
  let n = null;
  return e != null && (n = e[1]), { getTheme: function() {
    return t ?? (n != null ? n.getTheme() : null);
  } };
}
function vn() {
  const e = ll(gd);
  return e == null && function(t, ...n) {
    const r = new URL("https://lexical.dev/docs/error"), i = new URLSearchParams();
    i.append("code", t);
    for (const s of n) i.append("v", s);
    throw r.search = i.toString(), Error(`Minified Lexical error #${t}; visit ${r.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(8), e;
}
function me(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const qr = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, MM = qr && "documentMode" in document ? document.documentMode : null, ii = qr && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Mo = qr && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), vd = !(!qr || !("InputEvent" in window) || MM) && "getTargetRanges" in new window.InputEvent("input"), bc = qr && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), Ba = qr && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, OM = qr && /Android/.test(navigator.userAgent), _E = qr && /^(?=.*Chrome).*/i.test(navigator.userAgent), Q5 = qr && OM && _E, yd = qr && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !_E;
function xd(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
const PM = 1, DM = 3, FM = 9, RM = 11, Oo = 0, bE = 1, za = 2, $M = 0, VM = 1, BM = 2, wd = 4, _d = 8, G2 = 128, zM = 1792 | (112 | (3 | wd | _d) | G2), Y2 = 1, X2 = 2, Z2 = 3, Q2 = 4, ev = 5, tv = 6, Zh = bc || Ba || yd ? " " : "​", Xi = `

`, HM = Mo ? " " : Zh, CE = "֑-߿יִ-﷽ﹰ-ﻼ", EE = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", UM = new RegExp("^[^" + EE + "]*[" + CE + "]"), jM = new RegExp("^[^" + CE + "]*[" + EE + "]"), Po = { bold: 1, capitalize: 1024, code: 16, highlight: G2, italic: 2, lowercase: 256, strikethrough: wd, subscript: 32, superscript: 64, underline: _d, uppercase: 512 }, WM = { directionless: 1, unmergeable: 2 }, ew = { center: X2, end: tv, justify: Q2, left: Y2, right: Z2, start: ev }, JM = { [X2]: "center", [tv]: "end", [Q2]: "justify", [Y2]: "left", [Z2]: "right", [ev]: "start" }, KM = { normal: 0, segmented: 2, token: 1 }, qM = { [$M]: "normal", [BM]: "segmented", [VM]: "token" }, tw = "$config";
function SE(e, t, n, r, i, s) {
  let o = e.getFirstChild();
  for (; o !== null; ) {
    const a = o.__key;
    o.__parent === t && (te(o) && SE(o, a, n, r, i, s), n.has(a) || s.delete(a), i.push(a)), o = o.getNextSibling();
  }
}
const GM = 100;
let gg = !1, nv = 0;
function YM(e) {
  nv = e.timeStamp;
}
function y1(e, t, n) {
  const r = e.nodeName === "BR", i = t.__lexicalLineBreak;
  return i && (e === i || r && e.previousSibling === i) || r && dp(e, n) !== void 0;
}
function XM(e, t, n) {
  const r = Hr(_r(n));
  let i = null, s = null;
  r !== null && r.anchorNode === e && (i = r.anchorOffset, s = r.focusOffset);
  const o = e.nodeValue;
  o !== null && Lv(t, o, i, s, !1);
}
function ZM(e, t, n) {
  if (fe(e)) {
    const r = e.anchor.getNode();
    if (r.is(n) && e.format !== r.getFormat()) return !1;
  }
  return as(t) && n.isAttached();
}
function QM(e, t, n, r) {
  for (let i = e; i && !HO(i); i = su(i)) {
    const s = dp(i, t);
    if (s !== void 0) {
      const o = wt(s, n);
      if (o) return it(o) || !At(i) ? void 0 : [i, o];
    } else if (i === r) return [r, w9(n)];
  }
}
function kE(e, t, n) {
  gg = !0;
  const r = performance.now() - nv > GM;
  try {
    Zn(e, () => {
      const i = ge() || function(d) {
        return d.getEditorState().read(() => {
          const h = ge();
          return h !== null ? h.clone() : null;
        });
      }(e), s = /* @__PURE__ */ new Map(), o = e.getRootElement(), a = e._editorState, l = e._blockCursorElement;
      let c = !1, u = "";
      for (let d = 0; d < t.length; d++) {
        const h = t[d], m = h.type, p = h.target, y = QM(p, e, a, o);
        if (!y) continue;
        const [v, g] = y;
        if (m === "characterData") r && ye(g) && as(p) && ZM(i, p, g) && XM(p, g, e);
        else if (m === "childList") {
          c = !0;
          const x = h.addedNodes;
          for (let C = 0; C < x.length; C++) {
            const E = x[C], S = y9(E), k = E.parentNode;
            if (k != null && E !== l && S === null && !y1(E, k, e)) {
              if (Mo) {
                const M = (At(E) ? E.innerText : null) || E.nodeValue;
                M && (u += M);
              }
              k.removeChild(E);
            }
          }
          const _ = h.removedNodes, b = _.length;
          if (b > 0) {
            let C = 0;
            for (let E = 0; E < b; E++) {
              const S = _[E];
              (y1(S, p, e) || l === S) && (p.appendChild(S), C++);
            }
            b !== C && s.set(v, g);
          }
        }
      }
      if (s.size > 0) for (const [d, h] of s) h.reconcileObservedMutation(d, e);
      const f = n.takeRecords();
      if (f.length > 0) {
        for (let d = 0; d < f.length; d++) {
          const h = f[d], m = h.addedNodes, p = h.target;
          for (let y = 0; y < m.length; y++) {
            const v = m[y], g = v.parentNode;
            g == null || v.nodeName !== "BR" || y1(v, p, e) || g.removeChild(v);
          }
        }
        n.takeRecords();
      }
      i !== null && (c && Ot(i), Mo && E9(e) && i.insertRawText(u));
    });
  } finally {
    gg = !1;
  }
}
function TE(e) {
  const t = e._observer;
  t !== null && kE(e, t.takeRecords(), t);
}
function AE(e) {
  (function(t) {
    nv === 0 && _r(t).addEventListener("textInput", YM, !0);
  })(e), e._observer = new MutationObserver((t, n) => {
    kE(e, t, n);
  });
}
function vg(e) {
  const t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set();
  for (let r = typeof e == "function" ? e : e.replace; r.prototype && r.prototype.getType !== void 0; r = Object.getPrototypeOf(r)) {
    const { ownNodeConfig: i } = Rv(r);
    if (i && i.stateConfigs) for (const s of i.stateConfigs) {
      let o;
      "stateConfig" in s ? (o = s.stateConfig, s.flat && n.add(o.key)) : o = s, t.set(o.key, o);
    }
  }
  return { flatKeys: n, sharedConfigMap: t };
}
let eO = class NE {
  constructor(t, n, r = void 0, i = /* @__PURE__ */ new Map(), s = void 0) {
    this.node = t, this.sharedNodeState = n, this.unknownState = r, this.knownState = i;
    const { sharedConfigMap: o } = this.sharedNodeState, a = s !== void 0 ? s : function(l, c, u) {
      let f = u.size;
      if (c) for (const d in c) {
        const h = l.get(d);
        h && u.has(h) || f++;
      }
      return f;
    }(o, r, i);
    this.size = a;
  }
  getValue(t) {
    const n = this.knownState.get(t);
    if (n !== void 0) return n;
    this.sharedNodeState.sharedConfigMap.set(t.key, t);
    let r = t.defaultValue;
    if (this.unknownState && t.key in this.unknownState) {
      const i = this.unknownState[t.key];
      i !== void 0 && (r = t.parse(i)), this.updateFromKnown(t, r);
    }
    return r;
  }
  getInternalState() {
    return [this.unknownState, this.knownState];
  }
  toJSON() {
    const t = { ...this.unknownState }, n = {};
    for (const [r, i] of this.knownState) r.isEqual(i, r.defaultValue) ? delete t[r.key] : t[r.key] = r.unparse(i);
    for (const r of this.sharedNodeState.flatKeys) r in t && (n[r] = t[r], delete t[r]);
    return nw(t) && (n.$ = t), n;
  }
  getWritable(t) {
    if (this.node === t) return this;
    const { sharedNodeState: n, unknownState: r } = this, i = new Map(this.knownState);
    return new NE(t, n, function(s, o, a) {
      let l;
      if (a) for (const [c, u] of Object.entries(a)) {
        const f = s.get(c);
        f ? o.has(f) || o.set(f, f.parse(u)) : (l = l || {}, l[c] = u);
      }
      return l;
    }(n.sharedConfigMap, i, r), i, this.size);
  }
  updateFromKnown(t, n) {
    const r = t.key;
    this.sharedNodeState.sharedConfigMap.set(r, t);
    const { knownState: i, unknownState: s } = this;
    i.has(t) || s && r in s || (s && (delete s[r], this.unknownState = nw(s)), this.size++), i.set(t, n);
  }
  updateFromUnknown(t, n) {
    const r = this.sharedNodeState.sharedConfigMap.get(t);
    r ? this.updateFromKnown(r, r.parse(n)) : (this.unknownState = this.unknownState || {}, t in this.unknownState || this.size++, this.unknownState[t] = n);
  }
  updateFromJSON(t) {
    const { knownState: n } = this;
    for (const r of n.keys()) n.set(r, r.defaultValue);
    if (this.size = n.size, this.unknownState = void 0, t) for (const [r, i] of Object.entries(t)) this.updateFromUnknown(r, i);
  }
};
function tO(e) {
  const t = e.getWritable(), n = t.__state ? t.__state.getWritable(t) : new eO(t, IE(t));
  return t.__state = n, n;
}
function IE(e) {
  return e.__state ? e.__state.sharedNodeState : m9(Pv(), e.getType()).sharedNodeState;
}
function nw(e) {
  if (e) for (const t in e) return e;
}
function rw(e, t, n) {
  for (const [r, i] of t.knownState) {
    if (e.has(r.key)) continue;
    e.add(r.key);
    const s = n ? n.getValue(r) : r.defaultValue;
    if (s !== i && !r.isEqual(s, i)) return !0;
  }
  return !1;
}
function iw(e, t, n) {
  const { unknownState: r } = t, i = n ? n.unknownState : void 0;
  if (r) {
    for (const [s, o] of Object.entries(r))
      if (!e.has(s) && (e.add(s), o !== (i ? i[s] : void 0)))
        return !0;
  }
  return !1;
}
function sw(e, t) {
  const n = e.__state;
  return n && n.node === e ? n.getWritable(t) : n;
}
function ow(e, t) {
  const n = e.__mode, r = e.__format, i = e.__style, s = t.__mode, o = t.__format, a = t.__style, l = e.__state, c = t.__state;
  return (n === null || n === s) && (r === null || r === o) && (i === null || i === a) && (e.__state === null || l === c || function(u, f) {
    if (u === f) return !0;
    if (u && f && u.size !== f.size) return !1;
    const d = /* @__PURE__ */ new Set();
    return !(u && rw(d, u, f) || f && rw(d, f, u) || u && iw(d, u, f) || f && iw(d, f, u));
  }(l, c));
}
function aw(e, t) {
  const n = e.mergeWithSibling(t), r = Lt()._normalizedNodes;
  return r.add(e.__key), r.add(t.__key), n;
}
function lw(e) {
  let t, n, r = e;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (t = r.getPreviousSibling()) !== null && ye(t) && t.isSimpleText() && !t.isUnmergeable(); ) {
      if (t.__text !== "") {
        if (ow(t, r)) {
          r = aw(t, r);
          break;
        }
        break;
      }
      t.remove();
    }
    for (; (n = r.getNextSibling()) !== null && ye(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (ow(r, n)) {
          r = aw(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
function Do(e) {
  return cw(e.anchor), cw(e.focus), e;
}
function cw(e) {
  for (; e.type === "element"; ) {
    const t = e.getNode(), n = e.offset;
    let r, i;
    if (n === t.getChildrenSize() ? (r = t.getChildAtIndex(n - 1), i = !0) : (r = t.getChildAtIndex(n), i = !1), ye(r)) {
      e.set(r.__key, i ? r.getTextContentSize() : 0, "text", !0);
      break;
    }
    if (!te(r)) break;
    e.set(r.__key, i ? r.getChildrenSize() : 0, "element", !0);
  }
}
let zs, Nn, Cc, Qh, yg, xg, Fo, Fr, wg, Ec, Xt = "", kn = "", ti = null, ni = "", Vi = "", LE = !1, Sc = !1, Nf = null;
function bd(e, t) {
  const n = Fo.get(e);
  if (t !== null) {
    const r = Cg(e);
    r.parentNode === t && t.removeChild(r);
  }
  if (Fr.has(e) || Nn._keyToDOMMap.delete(e), te(n)) {
    const r = Ed(n, Fo);
    _g(r, 0, r.length - 1, null);
  }
  n !== void 0 && Mv(Ec, Cc, Qh, n, "destroyed");
}
function _g(e, t, n, r) {
  let i = t;
  for (; i <= n; ++i) {
    const s = e[i];
    s !== void 0 && bd(s, r);
  }
}
function ao(e, t) {
  e.setProperty("text-align", t);
}
const nO = "40px";
function ME(e, t) {
  const n = zs.theme.indent;
  if (typeof n == "string") {
    const i = e.classList.contains(n);
    t > 0 && !i ? e.classList.add(n) : t < 1 && i && e.classList.remove(n);
  }
  const r = getComputedStyle(e).getPropertyValue("--lexical-indent-base-value") || nO;
  e.style.setProperty("padding-inline-start", t === 0 ? "" : `calc(${t} * ${r})`);
}
function OE(e, t) {
  const n = e.style;
  t === 0 ? ao(n, "") : t === Y2 ? ao(n, "left") : t === X2 ? ao(n, "center") : t === Z2 ? ao(n, "right") : t === Q2 ? ao(n, "justify") : t === ev ? ao(n, "start") : t === tv && ao(n, "end");
}
function Cd(e, t) {
  const n = Fr.get(e);
  n === void 0 && me(60);
  const r = n.createDOM(zs, Nn);
  if (function(i, s, o) {
    const a = o._keyToDOMMap;
    (function(l, c, u) {
      const f = `__lexicalKey_${c._key}`;
      l[f] = u;
    })(s, o, i), a.set(i, s);
  }(e, r, Nn), ye(n) ? r.setAttribute("data-lexical-text", "true") : it(n) && r.setAttribute("data-lexical-decorator", "true"), te(n)) {
    const i = n.__indent, s = n.__size;
    if (i !== 0 && ME(r, i), s !== 0) {
      const a = s - 1;
      (function(l, c, u, f) {
        const d = kn;
        kn = "", bg(l, u, 0, c, u.getDOMSlot(f)), DE(u, f), kn = d;
      })(Ed(n, Fr), a, n, r);
    }
    const o = n.__format;
    o !== 0 && OE(r, o), n.isInline() || PE(null, n, r), hp(n) && (Xt += Xi, Vi += Xi);
  } else {
    const i = n.getTextContent();
    if (it(n)) {
      const s = n.decorate(Nn, zs);
      s !== null && FE(e, s), r.contentEditable = "false";
    } else ye(n) && (n.isDirectionless() || (kn += i));
    Xt += i, Vi += i;
  }
  return t !== null && t.insertChild(r), Mv(Ec, Cc, Qh, n, "created"), r;
}
function bg(e, t, n, r, i) {
  const s = Xt;
  Xt = "";
  let o = n;
  for (; o <= r; ++o) {
    Cd(e[o], i);
    const a = Fr.get(e[o]);
    a !== null && ye(a) && (ti === null && (ti = a.getFormat()), ni === "" && (ni = a.getStyle()));
  }
  hp(t) && (Xt += Xi), i.element.__lexicalTextContent = Xt, Xt = s + Xt;
}
function uw(e, t) {
  if (e) {
    const n = e.__last;
    if (n) {
      const r = t.get(n);
      if (r) return Rr(r) ? "line-break" : it(r) && r.isInline() ? "decorator" : null;
    }
    return "empty";
  }
  return null;
}
function PE(e, t, n) {
  const r = uw(e, Fo), i = uw(t, Fr);
  r !== i && t.getDOMSlot(n).setManagedLineBreak(i);
}
function DE(e, t) {
  const n = t.__lexicalDirTextContent || "", r = t.__lexicalDir || "";
  if (n !== kn || r !== Nf) {
    const i = kn === "", s = i ? Nf : function(o) {
      return UM.test(o) ? "rtl" : jM.test(o) ? "ltr" : null;
    }(kn);
    if (s !== r) {
      const o = t.classList, a = zs.theme;
      let l = r !== null ? a[r] : void 0, c = s !== null ? a[s] : void 0;
      if (l !== void 0) {
        if (typeof l == "string") {
          const u = xd(l);
          l = a[r] = u;
        }
        o.remove(...l);
      }
      if (s === null || i && s === "ltr") t.removeAttribute("dir");
      else {
        if (c !== void 0) {
          if (typeof c == "string") {
            const u = xd(c);
            c = a[s] = u;
          }
          c !== void 0 && o.add(...c);
        }
        t.dir = s;
      }
      Sc || (e.getWritable().__dir = s);
    }
    Nf = s, t.__lexicalDirTextContent = kn, t.__lexicalDir = s;
  }
}
function rO(e, t, n) {
  const r = kn;
  var i;
  kn = "", ti = null, ni = "", function(s, o, a) {
    const l = Xt, c = s.__size, u = o.__size;
    Xt = "";
    const f = a.element;
    if (c === 1 && u === 1) {
      const d = s.__first, h = o.__first;
      if (d === h) Kl(d, f);
      else {
        const p = Cg(d), y = Cd(h, null);
        try {
          f.replaceChild(y, p);
        } catch (v) {
          if (typeof v == "object" && v != null) {
            const g = `${v.toString()} Parent: ${f.tagName}, new child: {tag: ${y.tagName} key: ${h}}, old child: {tag: ${p.tagName}, key: ${d}}.`;
            throw new Error(g);
          }
          throw v;
        }
        bd(d, null);
      }
      const m = Fr.get(h);
      ye(m) && (ti === null && (ti = m.getFormat()), ni === "" && (ni = m.getStyle()));
    } else {
      const d = Ed(s, Fo), h = Ed(o, Fr);
      if (d.length !== c && me(227), h.length !== u && me(228), c === 0) u !== 0 && bg(h, o, 0, u - 1, a);
      else if (u === 0) {
        if (c !== 0) {
          const m = a.after == null && a.before == null && a.element.__lexicalLineBreak == null;
          _g(d, 0, c - 1, m ? null : f), m && (f.textContent = "");
        }
      } else (function(m, p, y, v, g, x) {
        const _ = v - 1, b = g - 1;
        let C, E, S = x.getFirstChild(), k = 0, M = 0;
        for (; k <= _ && M <= b; ) {
          const I = p[k], H = y[M];
          if (I === H) S = x1(Kl(H, x.element)), k++, M++;
          else {
            C === void 0 && (C = new Set(p)), E === void 0 && (E = new Set(y));
            const W = E.has(I), G = C.has(H);
            if (W) if (G) {
              const J = Ua(Nn, H);
              J === S ? S = x1(Kl(H, x.element)) : (x.withBefore(S).insertChild(J), Kl(H, x.element)), k++, M++;
            } else Cd(H, x.withBefore(S)), M++;
            else S = x1(Cg(I)), bd(I, x.element), k++;
          }
          const P = Fr.get(H);
          P !== null && ye(P) && (ti === null && (ti = P.getFormat()), ni === "" && (ni = P.getStyle()));
        }
        const O = k > _, R = M > b;
        if (O && !R) {
          const I = y[b + 1], H = I === void 0 ? null : Nn.getElementByKey(I);
          bg(y, m, M, b, x.withBefore(H));
        } else R && !O && _g(p, k, _, x.element);
      })(o, d, h, c, u, a);
    }
    hp(o) && (Xt += Xi), f.__lexicalTextContent = Xt, Xt = l + Xt;
  }(e, t, t.getDOMSlot(n)), DE(t, n), i = t, ti == null || ti === i.__textFormat || Sc || i.setTextFormat(ti), function(s) {
    ni === "" || ni === s.__textStyle || Sc || s.setTextStyle(ni);
  }(t), kn = r;
}
function Ed(e, t) {
  const n = [];
  let r = e.__first;
  for (; r !== null; ) {
    const i = t.get(r);
    i === void 0 && me(101), n.push(r), r = i.__next;
  }
  return n;
}
function Kl(e, t) {
  const n = Fo.get(e);
  let r = Fr.get(e);
  n !== void 0 && r !== void 0 || me(61);
  const i = LE || xg.has(e) || yg.has(e), s = Ua(Nn, e);
  if (n === r && !i) {
    if (te(n)) {
      const o = s.__lexicalTextContent;
      o !== void 0 && (Xt += o, Vi += o);
      const a = s.__lexicalDirTextContent;
      a !== void 0 && (kn += a);
    } else {
      const o = n.getTextContent();
      ye(n) && !n.isDirectionless() && (kn += o), Vi += o, Xt += o;
    }
    return s;
  }
  if (n !== r && i && Mv(Ec, Cc, Qh, r, "updated"), r.updateDOM(n, s, zs)) {
    const o = Cd(e, null);
    return t === null && me(62), t.replaceChild(o, s), bd(e, null), o;
  }
  if (te(n) && te(r)) {
    const o = r.__indent;
    o !== n.__indent && ME(s, o);
    const a = r.__format;
    a !== n.__format && OE(s, a), i && (rO(n, r, s), on(r) || r.isInline() || PE(n, r, s)), hp(r) && (Xt += Xi, Vi += Xi);
  } else {
    const o = r.getTextContent();
    if (it(r)) {
      const a = r.decorate(Nn, zs);
      a !== null && FE(e, a);
    } else ye(r) && !r.isDirectionless() && (kn += o);
    Xt += o, Vi += o;
  }
  if (!Sc && on(r) && r.__cachedText !== Vi) {
    const o = r.getWritable();
    o.__cachedText = Vi, r = o;
  }
  return s;
}
function FE(e, t) {
  let n = Nn._pendingDecorators;
  const r = Nn._decorators;
  if (n === null) {
    if (r[e] === t) return;
    n = x9(Nn);
  }
  n[e] = t;
}
function x1(e) {
  let t = e.nextSibling;
  return t !== null && t === Nn._blockCursorElement && (t = t.nextSibling), t;
}
function iO(e, t, n, r, i, s) {
  Xt = "", Vi = "", kn = "", LE = r === za, Nf = null, Nn = n, zs = n._config, Cc = n._nodes, Qh = Nn._listeners.mutation, yg = i, xg = s, Fo = e._nodeMap, Fr = t._nodeMap, Sc = t._readOnly, wg = new Map(n._keyToDOMMap);
  const o = /* @__PURE__ */ new Map();
  return Ec = o, Kl("root", null), Nn = void 0, Cc = void 0, yg = void 0, xg = void 0, Fo = void 0, Fr = void 0, zs = void 0, wg = void 0, Ec = void 0, o;
}
function Cg(e) {
  const t = wg.get(e);
  return t === void 0 && me(75, e), t;
}
function Pe(e) {
  return { type: e };
}
const Zc = Pe("SELECTION_CHANGE_COMMAND"), sO = Pe("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND"), ep = Pe("CLICK_COMMAND"), Co = Pe("DELETE_CHARACTER_COMMAND"), Aa = Pe("INSERT_LINE_BREAK_COMMAND"), kc = Pe("INSERT_PARAGRAPH_COMMAND"), Na = Pe("CONTROLLED_TEXT_INSERTION_COMMAND"), Qc = Pe("PASTE_COMMAND"), Eg = Pe("REMOVE_TEXT_COMMAND"), Tc = Pe("DELETE_WORD_COMMAND"), Ac = Pe("DELETE_LINE_COMMAND"), Ui = Pe("FORMAT_TEXT_COMMAND"), tp = Pe("UNDO_COMMAND"), np = Pe("REDO_COMMAND"), rv = Pe("KEYDOWN_COMMAND"), RE = Pe("KEY_ARROW_RIGHT_COMMAND"), oO = Pe("MOVE_TO_END"), iv = Pe("KEY_ARROW_LEFT_COMMAND"), aO = Pe("MOVE_TO_START"), sv = Pe("KEY_ARROW_UP_COMMAND"), ov = Pe("KEY_ARROW_DOWN_COMMAND"), Nc = Pe("KEY_ENTER_COMMAND"), av = Pe("KEY_SPACE_COMMAND"), rp = Pe("KEY_BACKSPACE_COMMAND"), eu = Pe("KEY_ESCAPE_COMMAND"), lv = Pe("KEY_DELETE_COMMAND"), cv = Pe("KEY_TAB_COMMAND"), $E = Pe("INSERT_TAB_COMMAND"), Sd = Pe("INDENT_CONTENT_COMMAND"), Sg = Pe("OUTDENT_CONTENT_COMMAND"), uv = Pe("DROP_COMMAND"), lO = Pe("FORMAT_ELEMENT_COMMAND"), ip = Pe("DRAGSTART_COMMAND"), fv = Pe("DRAGOVER_COMMAND"), cO = Pe("DRAGEND_COMMAND"), sp = Pe("COPY_COMMAND"), dv = Pe("CUT_COMMAND"), kg = Pe("SELECT_ALL_COMMAND"), uO = Pe("CLEAR_EDITOR_COMMAND"), fO = Pe("CLEAR_HISTORY_COMMAND"), ql = Pe("CAN_REDO_COMMAND"), Gl = Pe("CAN_UNDO_COMMAND"), hv = Pe("FOCUS_COMMAND"), pv = Pe("BLUR_COMMAND"), VE = Pe("KEY_MODIFIER_COMMAND"), Ai = Object.freeze({}), Tg = 30, Ag = [["keydown", function(e, t) {
  if (sc = e.timeStamp, BE = e.key, !t.isComposing() && !Se(t, rv, e) && e.key != null) {
    if (w1 && $w(e)) return Zn(t, () => {
      Wu(t, _1);
    }), w1 = !1, void (_1 = "");
    if (function(n) {
      return ct(n, "ArrowRight", { shiftKey: "any" });
    }(e)) Se(t, RE, e);
    else if (function(n) {
      return ct(n, "ArrowRight", Oi);
    }(e)) Se(t, oO, e);
    else if (function(n) {
      return ct(n, "ArrowLeft", { shiftKey: "any" });
    }(e)) Se(t, iv, e);
    else if (function(n) {
      return ct(n, "ArrowLeft", Oi);
    }(e)) Se(t, aO, e);
    else if (function(n) {
      return ct(n, "ArrowUp", { altKey: "any", shiftKey: "any" });
    }(e)) Se(t, sv, e);
    else if (function(n) {
      return ct(n, "ArrowDown", { altKey: "any", shiftKey: "any" });
    }(e)) Se(t, ov, e);
    else if (function(n) {
      return ct(n, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any", shiftKey: !0 });
    }(e)) oc = !0, Se(t, Nc, e);
    else if (function(n) {
      return n.key === " ";
    }(e)) Se(t, av, e);
    else if (function(n) {
      return ii && ct(n, "o", { ctrlKey: !0 });
    }(e)) e.preventDefault(), oc = !0, Se(t, Aa, !0);
    else if (function(n) {
      return ct(n, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any" });
    }(e)) oc = !1, Se(t, Nc, e);
    else if (function(n) {
      return ct(n, "Backspace", { shiftKey: "any" }) || ii && ct(n, "h", { ctrlKey: !0 });
    }(e)) $w(e) ? Se(t, rp, e) : (e.preventDefault(), Se(t, Co, !0));
    else if (function(n) {
      return n.key === "Escape";
    }(e)) Se(t, eu, e);
    else if (function(n) {
      return ct(n, "Delete", {}) || ii && ct(n, "d", { ctrlKey: !0 });
    }(e)) (function(n) {
      return n.key === "Delete";
    })(e) ? Se(t, lv, e) : (e.preventDefault(), Se(t, Co, !1));
    else if (function(n) {
      return ct(n, "Backspace", Rw);
    }(e)) e.preventDefault(), Se(t, Tc, !0);
    else if (function(n) {
      return ct(n, "Delete", Rw);
    }(e)) e.preventDefault(), Se(t, Tc, !1);
    else if (function(n) {
      return ii && ct(n, "Backspace", { metaKey: !0 });
    }(e)) e.preventDefault(), Se(t, Ac, !0);
    else if (function(n) {
      return ii && (ct(n, "Delete", { metaKey: !0 }) || ct(n, "k", { ctrlKey: !0 }));
    }(e)) e.preventDefault(), Se(t, Ac, !1);
    else if (function(n) {
      return ct(n, "b", Oi);
    }(e)) e.preventDefault(), Se(t, Ui, "bold");
    else if (function(n) {
      return ct(n, "u", Oi);
    }(e)) e.preventDefault(), Se(t, Ui, "underline");
    else if (function(n) {
      return ct(n, "i", Oi);
    }(e)) e.preventDefault(), Se(t, Ui, "italic");
    else if (function(n) {
      return ct(n, "Tab", { shiftKey: "any" });
    }(e)) Se(t, cv, e);
    else if (function(n) {
      return ct(n, "z", Oi);
    }(e)) e.preventDefault(), Se(t, tp, void 0);
    else if (function(n) {
      return ii ? ct(n, "z", { metaKey: !0, shiftKey: !0 }) : ct(n, "y", { ctrlKey: !0 }) || ct(n, "z", { ctrlKey: !0, shiftKey: !0 });
    }(e)) e.preventDefault(), Se(t, np, void 0);
    else {
      const n = t._editorState._selection;
      n === null || fe(n) ? Vw(e) && (e.preventDefault(), Se(t, kg, e)) : function(r) {
        return ct(r, "c", Oi);
      }(e) ? (e.preventDefault(), Se(t, sp, e)) : function(r) {
        return ct(r, "x", Oi);
      }(e) ? (e.preventDefault(), Se(t, dv, e)) : Vw(e) && (e.preventDefault(), Se(t, kg, e));
    }
    (function(n) {
      return n.ctrlKey || n.shiftKey || n.altKey || n.metaKey;
    })(e) && Se(t, VE, e);
  }
}], ["pointerdown", function(e, t) {
  const n = e.target, r = e.pointerType;
  hl(n) && r !== "touch" && r !== "pen" && e.button === 0 && Zn(t, () => {
    Pw(n) || (Ig = !0);
  });
}], ["compositionstart", function(e, t) {
  Zn(t, () => {
    const n = ge();
    if (fe(n) && !t.isComposing()) {
      const r = n.anchor, i = n.anchor.getNode();
      cn(r.key), (e.timeStamp < sc + Tg || r.type === "element" || !n.isCollapsed() || i.getFormat() !== n.format || ye(i) && i.getStyle() !== n.style) && Se(t, Na, HM);
    }
  });
}], ["compositionend", function(e, t) {
  Mo ? Dl = !0 : Ba || !bc && !yd ? Zn(t, () => {
    Wu(t, e.data);
  }) : (w1 = !0, _1 = e.data);
}], ["input", function(e, t) {
  e.stopPropagation(), Zn(t, () => {
    if (At(e.target) && Pw(e.target)) return;
    const n = ge(), r = e.data, i = WE(e);
    if (r != null && fe(n) && UE(n, i, r, e.timeStamp, !1)) {
      Dl && (Wu(t, r), Dl = !1);
      const s = n.anchor.getNode(), o = Hr(_r(t));
      if (o === null) return;
      const a = n.isBackward(), l = a ? n.anchor.offset : n.focus.offset, c = a ? n.focus.offset : n.anchor.offset;
      vd && !n.isCollapsed() && ye(s) && o.anchorNode !== null && s.getTextContent().slice(0, l) + r + s.getTextContent().slice(l + c) === C9(o.anchorNode) || Se(t, Na, r);
      const u = r.length;
      Mo && u > 1 && e.inputType === "insertCompositionText" && !t.isComposing() && (n.anchor.offset -= u), bc || Ba || yd || !t.isComposing() || (sc = 0, cn(null));
    } else
      Iv(!1, t, r !== null ? r : void 0), Dl && (Wu(t, r || void 0), Dl = !1);
    (function() {
      hn();
      const s = Lt();
      TE(s);
    })();
  }, { event: e }), ga = null;
}], ["click", function(e, t) {
  Zn(t, () => {
    const n = ge(), r = Hr(_r(t)), i = qo();
    if (r) {
      if (fe(n)) {
        const s = n.anchor, o = s.getNode();
        if (s.type === "element" && s.offset === 0 && n.isCollapsed() && !on(o) && Xe().getChildrenSize() === 1 && o.getTopLevelElementOrThrow().isEmpty() && i !== null && n.is(i)) r.removeAllRanges(), n.dirty = !0;
        else if (e.detail === 3 && !n.isCollapsed() && o !== n.focus.getNode()) {
          const a = function(l, c) {
            let u = l;
            for (; u !== Xe() && u != null; ) {
              if (c(u)) return u;
              u = u.getParent();
            }
            return null;
          }(o, (l) => te(l) && !l.isInline());
          te(a) && a.select(0);
        }
      } else if (e.pointerType === "touch" || e.pointerType === "pen") {
        const s = r.anchorNode;
        (At(s) || as(s)) && Ot(yv(i, r, t, e));
      }
    }
    Se(t, ep, e);
  });
}], ["cut", Ai], ["copy", Ai], ["dragstart", Ai], ["dragover", Ai], ["dragend", Ai], ["paste", Ai], ["focus", Ai], ["blur", Ai], ["drop", Ai]];
vd && Ag.push(["beforeinput", (e, t) => function(n, r) {
  const i = n.inputType, s = WE(n);
  i === "deleteCompositionText" || Mo && E9(r) || i !== "insertCompositionText" && Zn(r, () => {
    const o = ge();
    if (i === "deleteContentBackward") {
      if (o === null) {
        const h = qo();
        if (!fe(h)) return;
        Ot(h.clone());
      }
      if (fe(o)) {
        const h = o.anchor.key === o.focus.key;
        if (a = n.timeStamp, BE === "MediaLast" && a < sc + Tg && r.isComposing() && h) {
          if (cn(null), sc = 0, setTimeout(() => {
            Zn(r, () => {
              cn(null);
            });
          }, Tg), fe(o)) {
            const m = o.anchor.getNode();
            m.markDirty(), ye(m) || me(142), jE(o, m);
          }
        } else {
          cn(null), n.preventDefault();
          const m = o.anchor.getNode(), p = m.getTextContent(), y = m.canInsertTextAfter(), v = o.anchor.offset === 0 && o.focus.offset === p.length;
          let g = Q5 && h && !v && y;
          if (g && o.isCollapsed() && (g = !it(Pg(o.anchor, !0))), !g) {
            Se(r, Co, !0);
            const x = ge();
            Q5 && fe(x) && x.isCollapsed() && (po = x, setTimeout(() => po = null));
          }
        }
        return;
      }
    }
    var a;
    if (!fe(o)) return;
    const l = n.data;
    ga !== null && Iv(!1, r, ga), o.dirty && ga === null || !o.isCollapsed() || on(o.anchor.getNode()) || s === null || o.applyDOMRange(s), ga = null;
    const c = o.anchor, u = o.focus, f = c.getNode(), d = u.getNode();
    if (i !== "insertText" && i !== "insertTranspose") switch (n.preventDefault(), i) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText":
        Se(r, Na, n);
        break;
      case "insertFromComposition":
        cn(null), Se(r, Na, n);
        break;
      case "insertLineBreak":
        cn(null), Se(r, Aa, !1);
        break;
      case "insertParagraph":
        cn(null), oc && !Ba ? (oc = !1, Se(r, Aa, !1)) : Se(r, kc, void 0);
        break;
      case "insertFromPaste":
      case "insertFromPasteAsQuotation":
        Se(r, Qc, n);
        break;
      case "deleteByComposition":
        (function(h, m) {
          return h !== m || te(h) || te(m) || !Eo(h) || !Eo(m);
        })(f, d) && Se(r, Eg, n);
        break;
      case "deleteByDrag":
      case "deleteByCut":
        Se(r, Eg, n);
        break;
      case "deleteContent":
        Se(r, Co, !1);
        break;
      case "deleteWordBackward":
        Se(r, Tc, !0);
        break;
      case "deleteWordForward":
        Se(r, Tc, !1);
        break;
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward":
        Se(r, Ac, !0);
        break;
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward":
        Se(r, Ac, !1);
        break;
      case "formatStrikeThrough":
        Se(r, Ui, "strikethrough");
        break;
      case "formatBold":
        Se(r, Ui, "bold");
        break;
      case "formatItalic":
        Se(r, Ui, "italic");
        break;
      case "formatUnderline":
        Se(r, Ui, "underline");
        break;
      case "historyUndo":
        Se(r, tp, void 0);
        break;
      case "historyRedo":
        Se(r, np, void 0);
    }
    else {
      if (l === `
`) n.preventDefault(), Se(r, Aa, !1);
      else if (l === Xi) n.preventDefault(), Se(r, kc, void 0);
      else if (l == null && n.dataTransfer) {
        const h = n.dataTransfer.getData("text/plain");
        n.preventDefault(), o.insertRawText(h);
      } else l != null && UE(o, s, l, n.timeStamp, !0) ? (n.preventDefault(), Se(r, Na, l)) : ga = l;
      zE = n.timeStamp;
    }
  });
}(e, t)]);
let sc = 0, BE = null, zE = 0, ga = null;
const kd = /* @__PURE__ */ new WeakMap();
let Ng = !1, Ig = !1, oc = !1, Dl = !1, w1 = !1, _1 = "", po = null, HE = [0, "", 0, "root", 0];
function UE(e, t, n, r, i) {
  const s = e.anchor, o = e.focus, a = s.getNode(), l = Lt(), c = Hr(_r(l)), u = c !== null ? c.anchorNode : null, f = s.key, d = l.getElementByKey(f), h = n.length;
  return f !== o.key || !ye(a) || (!i && (!vd || zE < r + 50) || a.isDirty() && h < 2 || _9(n)) && s.offset !== o.offset && !a.isComposing() || Ri(a) || a.isDirty() && h > 1 || (i || !vd) && d !== null && !a.isComposing() && u !== Ha(d) || c !== null && t !== null && (!t.collapsed || t.startContainer !== c.anchorNode || t.startOffset !== c.anchorOffset) || a.getFormat() !== e.format || a.getStyle() !== e.style || function(m, p) {
    if (p.isSegmented()) return !0;
    if (!m.isCollapsed()) return !1;
    const y = m.anchor.offset, v = p.getParentOrThrow(), g = Eo(p);
    return y === 0 ? !p.canInsertTextBefore() || !v.canInsertTextBefore() && !p.isComposing() || g || function(x) {
      const _ = x.getPreviousSibling();
      return (ye(_) || te(_) && _.isInline()) && !_.canInsertTextAfter();
    }(p) : y === p.getTextContentSize() && (!p.canInsertTextAfter() || !v.canInsertTextAfter() && !p.isComposing() || g);
  }(e, a);
}
function fw(e, t) {
  return as(e) && e.nodeValue !== null && t !== 0 && t !== e.nodeValue.length;
}
function dw(e, t, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o } = e;
  Ng && (Ng = !1, fw(r, i) && fw(s, o) && !po) || Zn(t, () => {
    if (!n) return void Ot(null);
    if (!iu(t, r, s)) return;
    let a = ge();
    if (po && fe(a) && a.isCollapsed()) {
      const l = a.anchor, c = po.anchor;
      (l.key === c.key && l.offset === c.offset + 1 || l.offset === 1 && c.getNode().is(l.getNode().getPreviousSibling())) && (a = po.clone(), Ot(a));
    }
    if (po = null, fe(a)) {
      const l = a.anchor, c = l.getNode();
      if (a.isCollapsed()) {
        e.type === "Range" && e.anchorNode === e.focusNode && (a.dirty = !0);
        const u = _r(t).event, f = u ? u.timeStamp : performance.now(), [d, h, m, p, y] = HE, v = Xe(), g = t.isComposing() === !1 && v.getTextContent() === "";
        if (f < y + 200 && l.offset === m && l.key === p) If(a, d, h);
        else if (l.type === "text") ye(c) || me(141), jE(a, c);
        else if (l.type === "element" && !g) {
          te(c) || me(259);
          const x = l.getNode();
          x.isEmpty() ? function(_, b) {
            const C = b.getTextFormat(), E = b.getTextStyle();
            If(_, C, E);
          }(a, x) : If(a, 0, "");
        }
      } else {
        const u = l.key, f = a.focus.key, d = a.getNodes(), h = d.length, m = a.isBackward(), p = m ? o : i, y = m ? i : o, v = m ? f : u, g = m ? u : f;
        let x = zM, _ = !1;
        for (let b = 0; b < h; b++) {
          const C = d[b], E = C.getTextContentSize();
          if (ye(C) && E !== 0 && !(b === 0 && C.__key === v && p === E || b === h - 1 && C.__key === g && y === 0) && (_ = !0, x &= C.getFormat(), x === 0)) break;
        }
        a.format = _ ? x : 0;
      }
    }
    Se(t, Zc, void 0);
  });
}
function If(e, t, n) {
  e.format === t && e.style === n || (e.format = t, e.style = n, e.dirty = !0);
}
function jE(e, t) {
  If(e, t.getFormat(), t.getStyle());
}
function WE(e) {
  if (!e.getTargetRanges) return null;
  const t = e.getTargetRanges();
  return t.length === 0 ? null : t[0];
}
function Wu(e, t) {
  const n = e._compositionKey;
  if (cn(null), n !== null && t != null) {
    if (t === "") {
      const r = wt(n), i = Ha(e.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && ye(r) && Lv(r, i.nodeValue, null, null, !0));
    }
    if (t[t.length - 1] === `
`) {
      const r = ge();
      if (fe(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void Se(e, Nc, null);
      }
    }
  }
  Iv(!0, e, t);
}
function JE(e) {
  let t = e.__lexicalEventHandles;
  return t === void 0 && (t = [], e.__lexicalEventHandles = t), t;
}
const Ia = /* @__PURE__ */ new Map();
function KE(e) {
  const t = BO(e.target);
  if (t === null) return;
  const n = Av(t.anchorNode);
  if (n === null) return;
  Ig && (Ig = !1, Zn(n, () => {
    const l = qo(), c = t.anchorNode;
    (At(c) || as(c)) && Ot(yv(l, t, n, e));
  }));
  const r = Nv(n), i = r[r.length - 1], s = i._key, o = Ia.get(s), a = o || i;
  a !== n && dw(t, a, !1), dw(t, n, !0), n !== i ? Ia.set(s, n) : o && Ia.delete(s);
}
function hw(e) {
  e._lexicalHandled = !0;
}
function pw(e) {
  return e._lexicalHandled === !0;
}
function dO(e) {
  const t = e.ownerDocument, n = kd.get(t);
  if (n === void 0) return;
  const r = n - 1;
  r >= 0 || me(164), kd.set(t, r), r === 0 && t.removeEventListener("selectionchange", KE);
  const i = fp(e);
  Tv(i) ? (function(o) {
    if (o._parentEditor !== null) {
      const a = Nv(o), l = a[a.length - 1]._key;
      Ia.get(l) === o && Ia.delete(l);
    } else Ia.delete(o._key);
  }(i), e.__lexicalEditor = null) : i && me(198);
  const s = JE(e);
  for (let o = 0; o < s.length; o++) s[o]();
  e.__lexicalEventHandles = [];
}
function Lg(e, t, n) {
  hn();
  const r = e.__key, i = e.getParent();
  if (i === null) return;
  const s = function(a) {
    const l = ge();
    if (!fe(l) || !te(a)) return l;
    const { anchor: c, focus: u } = l, f = c.getNode(), d = u.getNode();
    return Dg(f, a) && c.set(a.__key, 0, "element"), Dg(d, a) && u.set(a.__key, 0, "element"), l;
  }(e);
  let o = !1;
  if (fe(s) && t) {
    const a = s.anchor, l = s.focus;
    a.key === r && (Nd(a, e, i, e.getPreviousSibling(), e.getNextSibling()), o = !0), l.key === r && (Nd(l, e, i, e.getPreviousSibling(), e.getNextSibling()), o = !0);
  } else Nt(s) && t && e.isSelected() && e.selectPrevious();
  if (fe(s) && t && !o) {
    const a = e.getIndexWithinParent();
    So(e), Ad(s, i, a, -1);
  } else So(e);
  n || Jt(i) || i.canBeEmpty() || !i.isEmpty() || Lg(i, t), t && s && on(i) && i.isEmpty() && i.selectEnd();
}
let cl = class {
  static getType() {
    const { ownNodeType: t } = Rv(this);
    return t === void 0 && me(64, this.name), t;
  }
  static clone(t) {
    me(65, this.name);
  }
  $config() {
    return {};
  }
  config(t, n) {
    const r = n.extends || Object.getPrototypeOf(this.constructor);
    return Object.assign(n, { extends: r, type: t }), { [t]: n };
  }
  afterCloneFrom(t) {
    this.__key === t.__key ? (this.__parent = t.__parent, this.__next = t.__next, this.__prev = t.__prev, this.__state = t.__state) : t.__state && (this.__state = t.__state.getWritable(this));
  }
  constructor(t) {
    this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Object.defineProperty(this, "__state", { configurable: !0, enumerable: !1, value: void 0, writable: !0 }), v9(this, t);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    me(137, this.constructor.name);
  }
  isAttached() {
    let t = this.__key;
    for (; t !== null; ) {
      if (t === "root") return !0;
      const n = wt(t);
      if (n === null) break;
      t = n.__parent;
    }
    return !1;
  }
  isSelected(t) {
    const n = t || ge();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    if (ye(this)) return r;
    if (fe(n) && n.anchor.type === "element" && n.focus.type === "element") {
      if (n.isCollapsed()) return !1;
      const i = this.getParent();
      if (it(this) && this.isInline() && i) {
        const s = n.isBackward() ? n.focus : n.anchor;
        if (i.is(s.getNode()) && s.offset === i.getChildrenSize() && this.is(i.getLastChild())) return !1;
      }
    }
    return r;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const t = this.getParent();
    if (t === null) return -1;
    let n = t.getFirstChild(), r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, n = n.getNextSibling();
    }
    return -1;
  }
  getParent() {
    const t = this.getLatest().__parent;
    return t === null ? null : wt(t);
  }
  getParentOrThrow() {
    const t = this.getParent();
    return t === null && me(66, this.__key), t;
  }
  getTopLevelElement() {
    let t = this;
    for (; t !== null; ) {
      const n = t.getParent();
      if (Jt(n)) return te(t) || t === this && it(t) || me(194), t;
      t = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const t = this.getTopLevelElement();
    return t === null && me(67, this.__key), t;
  }
  getParents() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n), n = n.getParent();
    return t;
  }
  getParentKeys() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n.__key), n = n.getParent();
    return t;
  }
  getPreviousSibling() {
    const t = this.getLatest().__prev;
    return t === null ? null : wt(t);
  }
  getPreviousSiblings() {
    const t = [], n = this.getParent();
    if (n === null) return t;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) t.push(r), r = r.getNextSibling();
    return t;
  }
  getNextSibling() {
    const t = this.getLatest().__next;
    return t === null ? null : wt(t);
  }
  getNextSiblings() {
    const t = [];
    let n = this.getNextSibling();
    for (; n !== null; ) t.push(n), n = n.getNextSibling();
    return t;
  }
  getCommonAncestor(t) {
    const n = te(this) ? this : this.getParent(), r = te(t) ? t : t.getParent(), i = n && r ? Pf(n, r) : null;
    return i ? i.commonAncestor : null;
  }
  is(t) {
    return t != null && this.__key === t.__key;
  }
  isBefore(t) {
    const n = Pf(this, t);
    return n !== null && (n.type === "descendant" || (n.type === "branch" ? O9(n) === -1 : (n.type !== "same" && n.type !== "ancestor" && me(279), !1)));
  }
  isParentOf(t) {
    const n = Pf(this, t);
    return n !== null && n.type === "ancestor";
  }
  getNodesBetween(t) {
    const n = this.isBefore(t), r = [], i = /* @__PURE__ */ new Set();
    let s = this;
    for (; s !== null; ) {
      const o = s.__key;
      if (i.has(o) || (i.add(o), r.push(s)), s === t) break;
      const a = te(s) ? n ? s.getFirstChild() : s.getLastChild() : null;
      if (a !== null) {
        s = a;
        continue;
      }
      const l = n ? s.getNextSibling() : s.getPreviousSibling();
      if (l !== null) {
        s = l;
        continue;
      }
      const c = s.getParentOrThrow();
      if (i.has(c.__key) || r.push(c), c === t) break;
      let u = null, f = c;
      do {
        if (f === null && me(68), u = n ? f.getNextSibling() : f.getPreviousSibling(), f = f.getParent(), f === null) break;
        u !== null || i.has(f.__key) || r.push(f);
      } while (u === null);
      s = u;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const t = Lt()._dirtyLeaves;
    return t !== null && t.has(this.__key);
  }
  getLatest() {
    const t = wt(this.__key);
    return t === null && me(113), t;
  }
  getWritable() {
    hn();
    const t = Xs(), n = Lt(), r = t._nodeMap, i = this.__key, s = this.getLatest(), o = n._cloneNotNeeded, a = ge();
    if (a !== null && a.setCachedNodes(null), o.has(i)) return Od(s), s;
    const l = Dv(s);
    return o.add(i), Od(l), r.set(i, l), l;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(t, n) {
    me(70);
  }
  updateDOM(t, n, r) {
    me(71);
  }
  exportDOM(t) {
    return { element: this.createDOM(t._config, t) };
  }
  exportJSON() {
    const t = this.__state ? this.__state.toJSON() : void 0;
    return { type: this.__type, version: 1, ...t };
  }
  static importJSON(t) {
    me(18, this.name);
  }
  updateFromJSON(t) {
    return function(n, r) {
      const i = n.getWritable(), s = r.$;
      let o = s;
      for (const a of IE(i).flatKeys) a in r && (o !== void 0 && o !== s || (o = { ...s }), o[a] = r[a]);
      return (i.__state || o) && tO(n).updateFromJSON(o), i;
    }(this, t);
  }
  static transform() {
    return null;
  }
  remove(t) {
    Lg(this, !0, t);
  }
  replace(t, n) {
    hn();
    let r = ge();
    r !== null && (r = r.clone()), T1(this, t);
    const i = this.getLatest(), s = this.__key, o = t.__key, a = t.getWritable(), l = this.getParentOrThrow().getWritable(), c = l.__size;
    So(a);
    const u = i.getPreviousSibling(), f = i.getNextSibling(), d = i.__prev, h = i.__next, m = i.__parent;
    if (Lg(i, !1, !0), u === null ? l.__first = o : u.getWritable().__next = o, a.__prev = d, f === null ? l.__last = o : f.getWritable().__prev = o, a.__next = h, a.__parent = m, l.__size = c, n && (te(this) && te(a) || me(139), this.getChildren().forEach((p) => {
      a.append(p);
    })), fe(r)) {
      Ot(r);
      const p = r.anchor, y = r.focus;
      p.key === s && yw(p, a), y.key === s && yw(y, a);
    }
    return As() === s && cn(o), a;
  }
  insertAfter(t, n = !0) {
    hn(), T1(this, t);
    const r = this.getWritable(), i = t.getWritable(), s = i.getParent(), o = ge();
    let a = !1, l = !1;
    if (s !== null) {
      const h = t.getIndexWithinParent();
      if (So(i), fe(o)) {
        const m = s.__key, p = o.anchor, y = o.focus;
        a = p.type === "element" && p.key === m && p.offset === h + 1, l = y.type === "element" && y.key === m && y.offset === h + 1;
      }
    }
    const c = this.getNextSibling(), u = this.getParentOrThrow().getWritable(), f = i.__key, d = r.__next;
    if (c === null ? u.__last = f : c.getWritable().__prev = f, u.__size++, r.__next = f, i.__next = d, i.__prev = r.__key, i.__parent = r.__parent, n && fe(o)) {
      const h = this.getIndexWithinParent();
      Ad(o, u, h + 1);
      const m = u.__key;
      a && o.anchor.set(m, h + 2, "element"), l && o.focus.set(m, h + 2, "element");
    }
    return t;
  }
  insertBefore(t, n = !0) {
    hn(), T1(this, t);
    const r = this.getWritable(), i = t.getWritable(), s = i.__key;
    So(i);
    const o = this.getPreviousSibling(), a = this.getParentOrThrow().getWritable(), l = r.__prev, c = this.getIndexWithinParent();
    o === null ? a.__first = s : o.getWritable().__next = s, a.__size++, r.__prev = s, i.__prev = l, i.__next = r.__key, i.__parent = r.__parent;
    const u = ge();
    return n && fe(u) && Ad(u, this.getParentOrThrow(), c), t;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return st();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(t, n) {
    hn();
    const r = this.getPreviousSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (te(r)) return r.select();
    if (!ye(r)) {
      const s = r.getIndexWithinParent() + 1;
      return i.select(s, s);
    }
    return r.select(t, n);
  }
  selectNext(t, n) {
    hn();
    const r = this.getNextSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (te(r)) return r.select(0, 0);
    if (!ye(r)) {
      const s = r.getIndexWithinParent();
      return i.select(s, s);
    }
    return r.select(t, n);
  }
  markDirty() {
    this.getWritable();
  }
  reconcileObservedMutation(t, n) {
    this.markDirty();
  }
}, mv = class qE extends cl {
  static getType() {
    return "linebreak";
  }
  static clone(t) {
    return new qE(t.__key);
  }
  constructor(t) {
    super(t);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  isInline() {
    return !0;
  }
  static importDOM() {
    return { br: (t) => function(n) {
      const r = n.parentElement;
      if (r !== null && Pd(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && Ju(i)) {
          const s = r.lastChild;
          if (s === n || s.previousSibling === n && Ju(s)) return !0;
        }
      }
      return !1;
    }(t) || function(n) {
      const r = n.parentElement;
      if (r !== null && Pd(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && Ju(i)) return !1;
        const s = r.lastChild;
        if (s === n || s.previousSibling === n && Ju(s)) return !0;
      }
      return !1;
    }(t) ? null : { conversion: hO, priority: 0 } };
  }
  static importJSON(t) {
    return Br().updateFromJSON(t);
  }
};
function hO(e) {
  return { node: Br() };
}
function Br() {
  return Pn(new mv());
}
function Rr(e) {
  return e instanceof mv;
}
function Ju(e) {
  return as(e) && /^( |\t|\r?\n)+$/.test(e.textContent || "");
}
function b1(e, t) {
  return 16 & t ? "code" : t & G2 ? "mark" : 32 & t ? "sub" : 64 & t ? "sup" : null;
}
function C1(e, t) {
  return 1 & t ? "strong" : 2 & t ? "em" : "span";
}
function GE(e, t, n, r, i) {
  const s = r.classList;
  let o = La(i, "base");
  o !== void 0 && s.add(...o), o = La(i, "underlineStrikethrough");
  let a = !1;
  const l = t & _d && t & wd;
  o !== void 0 && (n & _d && n & wd ? (a = !0, l || s.add(...o)) : l && s.remove(...o));
  for (const c in Po) {
    const u = Po[c];
    if (o = La(i, c), o !== void 0) if (n & u) {
      if (a && (c === "underline" || c === "strikethrough")) {
        t & u && s.remove(...o);
        continue;
      }
      t & u && (!l || c !== "underline") && c !== "strikethrough" || s.add(...o);
    } else t & u && s.remove(...o);
  }
}
function YE(e, t, n) {
  const r = t.firstChild, i = n.isComposing(), s = e + (i ? Zh : "");
  if (r == null) t.textContent = s;
  else {
    const o = r.nodeValue;
    if (o !== s) if (i || Mo) {
      const [a, l, c] = function(u, f) {
        const d = u.length, h = f.length;
        let m = 0, p = 0;
        for (; m < d && m < h && u[m] === f[m]; ) m++;
        for (; p + m < d && p + m < h && u[d - p - 1] === f[h - p - 1]; ) p++;
        return [m, d - m - p, f.slice(m, h - p)];
      }(o, s);
      l !== 0 && r.deleteData(a, l), r.insertData(a, c);
    } else r.nodeValue = s;
  }
}
function mw(e, t, n, r, i, s) {
  YE(i, e, t);
  const o = s.theme.text;
  o !== void 0 && GE(0, 0, r, e, o);
}
function Ku(e, t) {
  const n = document.createElement(t);
  return n.appendChild(e), n;
}
let Ys = class XE extends cl {
  static getType() {
    return "text";
  }
  static clone(t) {
    return new XE(t.__text, t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__text = t.__text, this.__format = t.__format, this.__style = t.__style, this.__mode = t.__mode, this.__detail = t.__detail;
  }
  constructor(t = "", n) {
    super(n), this.__text = t, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const t = this.getLatest();
    return qM[t.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === As();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(t) {
    const n = Po[t];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(t, n) {
    return Md(this.getLatest().__format, t, n);
  }
  canHaveFormat() {
    return !0;
  }
  isInline() {
    return !0;
  }
  createDOM(t, n) {
    const r = this.__format, i = b1(0, r), s = C1(0, r), o = i === null ? s : i, a = document.createElement(o);
    let l = a;
    this.hasFormat("code") && a.setAttribute("spellcheck", "false"), i !== null && (l = document.createElement(s), a.appendChild(l)), mw(l, this, 0, r, this.__text, t);
    const c = this.__style;
    return c !== "" && (a.style.cssText = c), a;
  }
  updateDOM(t, n, r) {
    const i = this.__text, s = t.__format, o = this.__format, a = b1(0, s), l = b1(0, o), c = C1(0, s), u = C1(0, o);
    if ((a === null ? c : a) !== (l === null ? u : l)) return !0;
    if (a === l && c !== u) {
      const p = n.firstChild;
      p == null && me(48);
      const y = document.createElement(u);
      return mw(y, this, 0, o, i, r), n.replaceChild(y, p), !1;
    }
    let f = n;
    l !== null && a !== null && (f = n.firstChild, f == null && me(49)), YE(i, f, this);
    const d = r.theme.text;
    d !== void 0 && s !== o && GE(0, s, o, f, d);
    const h = t.__style, m = this.__style;
    return h !== m && (n.style.cssText = m), !1;
  }
  static importDOM() {
    return { "#text": () => ({ conversion: vO, priority: 0 }), b: () => ({ conversion: mO, priority: 0 }), code: () => ({ conversion: Ni, priority: 0 }), em: () => ({ conversion: Ni, priority: 0 }), i: () => ({ conversion: Ni, priority: 0 }), mark: () => ({ conversion: Ni, priority: 0 }), s: () => ({ conversion: Ni, priority: 0 }), span: () => ({ conversion: pO, priority: 0 }), strong: () => ({ conversion: Ni, priority: 0 }), sub: () => ({ conversion: Ni, priority: 0 }), sup: () => ({ conversion: Ni, priority: 0 }), u: () => ({ conversion: Ni, priority: 0 }) };
  }
  static importJSON(t) {
    return yt().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setTextContent(t.text).setFormat(t.format).setDetail(t.detail).setMode(t.mode).setStyle(t.style);
  }
  exportDOM(t) {
    let { element: n } = super.exportDOM(t);
    return At(n) || me(132), n.style.whiteSpace = "pre-wrap", this.hasFormat("lowercase") ? n.style.textTransform = "lowercase" : this.hasFormat("uppercase") ? n.style.textTransform = "uppercase" : this.hasFormat("capitalize") && (n.style.textTransform = "capitalize"), this.hasFormat("bold") && (n = Ku(n, "b")), this.hasFormat("italic") && (n = Ku(n, "i")), this.hasFormat("strikethrough") && (n = Ku(n, "s")), this.hasFormat("underline") && (n = Ku(n, "u")), { element: n };
  }
  exportJSON() {
    return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), ...super.exportJSON() };
  }
  selectionTransform(t, n) {
  }
  setFormat(t) {
    const n = this.getWritable();
    return n.__format = typeof t == "string" ? Po[t] : t, n;
  }
  setDetail(t) {
    const n = this.getWritable();
    return n.__detail = typeof t == "string" ? WM[t] : t, n;
  }
  setStyle(t) {
    const n = this.getWritable();
    return n.__style = t, n;
  }
  toggleFormat(t) {
    const n = Md(this.getFormat(), t, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const t = this.getWritable();
    return t.__detail ^= 1, t;
  }
  toggleUnmergeable() {
    const t = this.getWritable();
    return t.__detail ^= 2, t;
  }
  setMode(t) {
    const n = KM[t];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return r.__mode = n, r;
  }
  setTextContent(t) {
    if (this.__text === t) return this;
    const n = this.getWritable();
    return n.__text = t, n;
  }
  select(t, n) {
    hn();
    let r = t, i = n;
    const s = ge(), o = this.getTextContent(), a = this.__key;
    if (typeof o == "string") {
      const l = o.length;
      r === void 0 && (r = l), i === void 0 && (i = l);
    } else r = 0, i = 0;
    if (!fe(s)) return t9(a, r, a, i, "text", "text");
    {
      const l = As();
      l !== s.anchor.key && l !== s.focus.key || cn(a), s.setTextNodeRange(this, r, this, i);
    }
    return s;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const t = this.getTextContentSize();
    return this.select(t, t);
  }
  spliceText(t, n, r, i) {
    const s = this.getWritable(), o = s.__text, a = r.length;
    let l = t;
    l < 0 && (l = a + l, l < 0 && (l = 0));
    const c = ge();
    if (i && fe(c)) {
      const f = t + a;
      c.setTextNodeRange(s, f, s, f);
    }
    const u = o.slice(0, l) + r + o.slice(l + n);
    return s.__text = u, s;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...t) {
    hn();
    const n = this.getLatest(), r = n.getTextContent();
    if (r === "") return [];
    const i = n.__key, s = As(), o = r.length;
    t.sort((S, k) => S - k), t.push(o);
    const a = [], l = t.length;
    for (let S = 0, k = 0; S < o && k <= l; k++) {
      const M = t[k];
      M > S && (a.push(r.slice(S, M)), S = M);
    }
    const c = a.length;
    if (c === 1) return [n];
    const u = a[0], f = n.getParent();
    let d;
    const h = n.getFormat(), m = n.getStyle(), p = n.__detail;
    let y = !1, v = null, g = null;
    const x = ge();
    if (fe(x)) {
      const [S, k] = x.isBackward() ? [x.focus, x.anchor] : [x.anchor, x.focus];
      S.type === "text" && S.key === i && (v = S), k.type === "text" && k.key === i && (g = k);
    }
    n.isSegmented() ? (d = yt(u), d.__format = h, d.__style = m, d.__detail = p, d.__state = sw(n, d), y = !0) : d = n.setTextContent(u);
    const _ = [d];
    for (let S = 1; S < c; S++) {
      const k = yt(a[S]);
      k.__format = h, k.__style = m, k.__detail = p, k.__state = sw(n, k);
      const M = k.__key;
      s === i && cn(M), _.push(k);
    }
    const b = v ? v.offset : null, C = g ? g.offset : null;
    let E = 0;
    for (const S of _) {
      if (!v && !g) break;
      const k = E + S.getTextContentSize();
      if (v !== null && b !== null && b <= k && b >= E && (v.set(S.getKey(), b - E, "text"), b < k && (v = null)), g !== null && C !== null && C <= k && C >= E) {
        g.set(S.getKey(), C - E, "text");
        break;
      }
      E = k;
    }
    if (f !== null) {
      (function(M) {
        const O = M.getPreviousSibling(), R = M.getNextSibling();
        O !== null && Od(O), R !== null && Od(R);
      })(this);
      const S = f.getWritable(), k = this.getIndexWithinParent();
      y ? (S.splice(k, 0, _), this.remove()) : S.splice(k, 1, _), fe(x) && Ad(x, f, k, c - 1);
    }
    return _;
  }
  mergeWithSibling(t) {
    const n = t === this.getPreviousSibling();
    n || t === this.getNextSibling() || me(50);
    const r = this.__key, i = t.__key, s = this.__text, o = s.length;
    As() === i && cn(r);
    const a = ge();
    if (fe(a)) {
      const f = a.anchor, d = a.focus;
      f !== null && f.key === i && Sw(f, n, r, t, o), d !== null && d.key === i && Sw(d, n, r, t, o);
    }
    const l = t.__text, c = n ? l + s : s + l;
    this.setTextContent(c);
    const u = this.getWritable();
    return t.remove(), u;
  }
  isTextEntity() {
    return !1;
  }
};
function pO(e) {
  return { forChild: gv(e.style), node: null };
}
function mO(e) {
  const t = e, n = t.style.fontWeight === "normal";
  return { forChild: gv(t.style, n ? void 0 : "bold"), node: null };
}
const gw = /* @__PURE__ */ new WeakMap();
function gO(e) {
  if (!At(e)) return !1;
  if (e.nodeName === "PRE") return !0;
  const t = e.style.whiteSpace;
  return typeof t == "string" && t.startsWith("pre");
}
function vO(e) {
  const t = e;
  e.parentElement === null && me(129);
  let n = t.textContent || "";
  if (function(r) {
    let i, s = r.parentNode;
    const o = [r];
    for (; s !== null && (i = gw.get(s)) === void 0 && !gO(s); ) o.push(s), s = s.parentNode;
    const a = i === void 0 ? s : i;
    for (let l = 0; l < o.length; l++) gw.set(o[l], a);
    return a;
  }(t) !== null) {
    const r = n.split(/(\r?\n|\t)/), i = [], s = r.length;
    for (let o = 0; o < s; o++) {
      const a = r[o];
      a === `
` || a === `\r
` ? i.push(Br()) : a === "	" ? i.push(ul()) : a !== "" && i.push(yt(a));
    }
    return { node: i };
  }
  if (n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), n === "") return { node: null };
  if (n[0] === " ") {
    let r = t, i = !0;
    for (; r !== null && (r = vw(r, !1)) !== null; ) {
      const s = r.textContent || "";
      if (s.length > 0) {
        /[ \t\n]$/.test(s) && (n = n.slice(1)), i = !1;
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = t, i = !0;
    for (; r !== null && (r = vw(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: yt(n) };
}
function vw(e, t) {
  let n = e;
  for (; ; ) {
    let r;
    for (; (r = t ? n.nextSibling : n.previousSibling) === null; ) {
      const s = n.parentElement;
      if (s === null) return null;
      n = s;
    }
    if (n = r, At(n)) {
      const s = n.style.display;
      if (s === "" && !$g(n) || s !== "" && !s.startsWith("inline")) return null;
    }
    let i = n;
    for (; (i = t ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (as(n)) return n;
    if (n.nodeName === "BR") return null;
  }
}
const yO = { code: "code", em: "italic", i: "italic", mark: "highlight", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
function Ni(e) {
  const t = yO[e.nodeName.toLowerCase()];
  return t === void 0 ? { node: null } : { forChild: gv(e.style, t), node: null };
}
function yt(e = "") {
  return Pn(new Ys(e));
}
function ye(e) {
  return e instanceof Ys;
}
function gv(e, t) {
  const n = e.fontWeight, r = e.textDecoration.split(" "), i = n === "700" || n === "bold", s = r.includes("line-through"), o = e.fontStyle === "italic", a = r.includes("underline"), l = e.verticalAlign;
  return (c) => (ye(c) && (i && !c.hasFormat("bold") && c.toggleFormat("bold"), s && !c.hasFormat("strikethrough") && c.toggleFormat("strikethrough"), o && !c.hasFormat("italic") && c.toggleFormat("italic"), a && !c.hasFormat("underline") && c.toggleFormat("underline"), l !== "sub" || c.hasFormat("subscript") || c.toggleFormat("subscript"), l !== "super" || c.hasFormat("superscript") || c.toggleFormat("superscript"), t && !c.hasFormat(t) && c.toggleFormat(t)), c);
}
class tu extends Ys {
  static getType() {
    return "tab";
  }
  static clone(t) {
    return new tu(t.__key);
  }
  constructor(t) {
    super("	", t), this.__detail = 2;
  }
  static importDOM() {
    return null;
  }
  createDOM(t) {
    const n = super.createDOM(t), r = La(t.theme, "tab");
    return r !== void 0 && n.classList.add(...r), n;
  }
  static importJSON(t) {
    return ul().updateFromJSON(t);
  }
  setTextContent(t) {
    return t !== "	" && t !== "" && me(126), super.setTextContent("	");
  }
  spliceText(t, n, r, i) {
    return r === "" && n === 0 || r === "	" && n === 1 || me(286), this;
  }
  setDetail(t) {
    return t !== 2 && me(127), this;
  }
  setMode(t) {
    return t !== "normal" && me(128), this;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
}
function ul() {
  return Pn(new tu());
}
function op(e) {
  return e instanceof tu;
}
class xO {
  constructor(t, n, r) {
    this._selection = null, this.key = t, this.offset = n, this.type = r;
  }
  is(t) {
    return this.key === t.key && this.offset === t.offset && this.type === t.type;
  }
  isBefore(t) {
    return this.key === t.key ? this.offset < t.offset : M9(tr(yi(this, "next")), tr(yi(t, "next"))) < 0;
  }
  getNode() {
    const t = wt(this.key);
    return t === null && me(20), t;
  }
  set(t, n, r, i) {
    const s = this._selection, o = this.key;
    i && this.key === t && this.offset === n && this.type === r || (this.key = t, this.offset = n, this.type = r, ru() || (As() === o && cn(t), s !== null && (s.setCachedNodes(null), s.dirty = !0)));
  }
}
function gi(e, t, n) {
  return new xO(e, t, n);
}
function E1(e, t) {
  let n = t.__key, r = e.offset, i = "element";
  if (ye(t)) {
    i = "text";
    const s = t.getTextContentSize();
    r > s && (r = s);
  } else if (!te(t)) {
    const s = t.getNextSibling();
    if (ye(s)) n = s.__key, r = 0, i = "text";
    else {
      const o = t.getParent();
      o && (n = o.__key, r = t.getIndexWithinParent() + 1);
    }
  }
  e.set(n, r, i);
}
function yw(e, t) {
  if (te(t)) {
    const n = t.getLastDescendant();
    te(n) || ye(n) ? E1(e, n) : E1(e, t);
  } else E1(e, t);
}
class ap {
  constructor(t) {
    this._cachedNodes = null, this._nodes = t, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    if (!Nt(t)) return !1;
    const n = this._nodes, r = t._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(t) {
    this.dirty = !0, this._nodes.add(t), this._cachedNodes = null;
  }
  delete(t) {
    this.dirty = !0, this._nodes.delete(t), this._cachedNodes = null;
  }
  clear() {
    this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
  }
  has(t) {
    return this._nodes.has(t);
  }
  clone() {
    return new ap(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(t) {
  }
  insertText() {
  }
  insertNodes(t) {
    const n = this.getNodes(), r = n.length, i = n[r - 1];
    let s;
    if (ye(i)) s = i.select();
    else {
      const o = i.getIndexWithinParent() + 1;
      s = i.getParentOrThrow().select(o, o);
    }
    s.insertNodes(t);
    for (let o = 0; o < r; o++) n[o].remove();
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this._nodes, r = [];
    for (const i of n) {
      const s = wt(i);
      s !== null && r.push(s);
    }
    return ru() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const t = this.getNodes();
    let n = "";
    for (let r = 0; r < t.length; r++) n += t[r].getTextContent();
    return n;
  }
  deleteNodes() {
    const t = this.getNodes();
    if ((ge() || qo()) === this && t[0]) {
      const n = Kt(t[0], "next");
      P9(Hs(n, n));
    }
    for (const n of t) n.remove();
  }
}
function fe(e) {
  return e instanceof nu;
}
let nu = class ZE {
  constructor(t, n, r, i) {
    this.anchor = t, this.focus = n, t._selection = this, n._selection = this, this._cachedNodes = null, this.format = r, this.style = i, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    return !!fe(t) && this.anchor.is(t.anchor) && this.focus.is(t.focus) && this.format === t.format && this.style === t.style;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = function(r) {
      const i = [], [s, o] = r.getTextSlices();
      s && i.push(s.caret.origin);
      const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
      for (const c of r) if (wr(c)) {
        const { origin: u } = c;
        i.length === 0 ? a.add(u) : (l.add(u), i.push(u));
      } else {
        const { origin: u } = c;
        te(u) && l.has(u) || i.push(u);
      }
      if (o && i.push(o.caret.origin), ja(r.focus) && te(r.focus.origin) && r.focus.getNodeAtCaret() === null) for (let c = br(r.focus.origin, "previous"); wr(c) && a.has(c.origin) && !c.origin.isEmpty() && c.origin.is(i[i.length - 1]); c = pp(c)) a.delete(c.origin), i.pop();
      for (; i.length > 1; ) {
        const c = i[i.length - 1];
        if (!te(c) || l.has(c) || c.isEmpty() || a.has(c)) break;
        i.pop();
      }
      if (i.length === 0 && r.isCollapsed()) {
        const c = tr(r.anchor), u = tr(r.anchor.getFlipped()), f = (h) => di(h) ? h.origin : h.getNodeAtCaret(), d = f(c) || f(u) || (r.anchor.getNodeAtCaret() ? c.origin : u.origin);
        i.push(d);
      }
      return i;
    }(F9(Ww(this), "next"));
    return ru() || (this._cachedNodes = n), n;
  }
  setTextNodeRange(t, n, r, i) {
    this.anchor.set(t.__key, n, "text"), this.focus.set(r.__key, i, "text");
  }
  getTextContent() {
    const t = this.getNodes();
    if (t.length === 0) return "";
    const n = t[0], r = t[t.length - 1], i = this.anchor, s = this.focus, o = i.isBefore(s), [a, l] = Mg(this);
    let c = "", u = !0;
    for (let f = 0; f < t.length; f++) {
      const d = t[f];
      if (te(d) && !d.isInline()) u || (c += `
`), u = !d.isEmpty();
      else if (u = !1, ye(d)) {
        let h = d.getTextContent();
        d === n ? d === r ? i.type === "element" && s.type === "element" && s.offset !== i.offset || (h = a < l ? h.slice(a, l) : h.slice(l, a)) : h = o ? h.slice(a) : h.slice(l) : d === r && (h = o ? h.slice(0, l) : h.slice(0, a)), c += h;
      } else !it(d) && !Rr(d) || d === r && this.isCollapsed() || (c += d.getTextContent());
    }
    return c;
  }
  applyDOMRange(t) {
    const n = Lt(), r = n.getEditorState()._selection, i = e9(t.startContainer, t.startOffset, t.endContainer, t.endOffset, n, r);
    if (i === null) return;
    const [s, o] = i;
    this.anchor.set(s.key, s.offset, s.type, !0), this.focus.set(o.key, o.offset, o.type, !0), Do(this);
  }
  clone() {
    const t = this.anchor, n = this.focus;
    return new ZE(gi(t.key, t.offset, t.type), gi(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(t) {
    this.format = Md(this.format, t, null), this.dirty = !0;
  }
  setFormat(t) {
    this.format = t, this.dirty = !0;
  }
  setStyle(t) {
    this.style = t, this.dirty = !0;
  }
  hasFormat(t) {
    const n = Po[t];
    return !!(this.format & n);
  }
  insertRawText(t) {
    const n = t.split(/(\r?\n|\t)/), r = [], i = n.length;
    for (let s = 0; s < i; s++) {
      const o = n[s];
      o === `
` || o === `\r
` ? r.push(Br()) : o === "	" ? r.push(ul()) : r.push(yt(o));
    }
    this.insertNodes(r);
  }
  insertText(t) {
    const n = this.anchor, r = this.focus, i = this.format, s = this.style;
    let o = n, a = r;
    !this.isCollapsed() && r.isBefore(n) && (o = r, a = n), o.type === "element" && function(y, v, g, x) {
      const _ = y.getNode(), b = _.getChildAtIndex(y.offset), C = yt(), E = on(_) ? st().append(C) : C;
      C.setFormat(g), C.setStyle(x), b === null ? _.append(E) : b.insertBefore(E), y.is(v) && v.set(C.__key, 0, "text"), y.set(C.__key, 0, "text");
    }(o, a, i, s), a.type === "element" && $o(a, tr(yi(a, "next")));
    const l = o.offset;
    let c = a.offset;
    const u = this.getNodes(), f = u.length;
    let d = u[0];
    ye(d) || me(26);
    const h = d.getTextContent().length, m = d.getParentOrThrow();
    let p = u[f - 1];
    if (f === 1 && a.type === "element" && (c = h, a.set(o.key, c, "text")), this.isCollapsed() && l === h && (Ri(d) || !d.canInsertTextAfter() || !m.canInsertTextAfter() && d.getNextSibling() === null)) {
      let y = d.getNextSibling();
      if (ye(y) && y.canInsertTextBefore() && !Ri(y) || (y = yt(), y.setFormat(i), y.setStyle(s), m.canInsertTextAfter() ? d.insertAfter(y) : m.insertAfter(y)), y.select(0, 0), d = y, t !== "") return void this.insertText(t);
    } else if (this.isCollapsed() && l === 0 && (Ri(d) || !d.canInsertTextBefore() || !m.canInsertTextBefore() && d.getPreviousSibling() === null)) {
      let y = d.getPreviousSibling();
      if (ye(y) && !Ri(y) || (y = yt(), y.setFormat(i), m.canInsertTextBefore() ? d.insertBefore(y) : m.insertBefore(y)), y.select(), d = y, t !== "") return void this.insertText(t);
    } else if (d.isSegmented() && l !== h) {
      const y = yt(d.getTextContent());
      y.setFormat(i), d.replace(y), d = y;
    } else if (!this.isCollapsed() && t !== "") {
      const y = p.getParent();
      if (!m.canInsertTextBefore() || !m.canInsertTextAfter() || te(y) && (!y.canInsertTextBefore() || !y.canInsertTextAfter())) return this.insertText(""), QE(this.anchor, this.focus, null), void this.insertText(t);
    }
    if (f === 1) {
      if (Eo(d)) {
        const x = yt(t);
        return x.select(), void d.replace(x);
      }
      const y = d.getFormat(), v = d.getStyle();
      if (l !== c || y === i && v === s) {
        if (op(d)) {
          const x = yt(t);
          return x.setFormat(i), x.setStyle(s), x.select(), void d.replace(x);
        }
      } else {
        if (d.getTextContent() !== "") {
          const x = yt(t);
          if (x.setFormat(i), x.setStyle(s), x.select(), l === 0) d.insertBefore(x, !1);
          else {
            const [_] = d.splitText(l);
            _.insertAfter(x, !1);
          }
          return void (x.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length));
        }
        d.setFormat(i), d.setStyle(s);
      }
      const g = c - l;
      d = d.spliceText(l, g, t, !0), d.getTextContent() === "" ? d.remove() : this.anchor.type === "text" && (d.isComposing() ? this.anchor.offset -= t.length : (this.format = y, this.style = v));
    } else {
      const y = /* @__PURE__ */ new Set([...d.getParentKeys(), ...p.getParentKeys()]), v = te(d) ? d : d.getParentOrThrow();
      let g = te(p) ? p : p.getParentOrThrow(), x = p;
      if (!v.is(g) && g.isInline()) do
        x = g, g = g.getParentOrThrow();
      while (g.isInline());
      if (a.type === "text" && (c !== 0 || p.getTextContent() === "") || a.type === "element" && p.getIndexWithinParent() < c) if (ye(p) && !Eo(p) && c !== p.getTextContentSize()) {
        if (p.isSegmented()) {
          const S = yt(p.getTextContent());
          p.replace(S), p = S;
        }
        on(a.getNode()) || a.type !== "text" || (p = p.spliceText(0, c, "")), y.add(p.__key);
      } else {
        const S = p.getParentOrThrow();
        S.canBeEmpty() || S.getChildrenSize() !== 1 ? p.remove() : S.remove();
      }
      else y.add(p.__key);
      const _ = g.getChildren(), b = new Set(u), C = v.is(g), E = v.isInline() && d.getNextSibling() === null ? v : d;
      for (let S = _.length - 1; S >= 0; S--) {
        const k = _[S];
        if (k.is(d) || te(k) && k.isParentOf(d)) break;
        k.isAttached() && (!b.has(k) || k.is(x) ? C || E.insertAfter(k, !1) : k.remove());
      }
      if (!C) {
        let S = g, k = null;
        for (; S !== null; ) {
          const M = S.getChildren(), O = M.length;
          (O === 0 || M[O - 1].is(k)) && (y.delete(S.__key), k = S), S = S.getParent();
        }
      }
      if (Eo(d)) if (l === h) d.select();
      else {
        const S = yt(t);
        S.select(), d.replace(S);
      }
      else d = d.spliceText(l, h - l, t, !0), d.getTextContent() === "" ? d.remove() : d.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length);
      for (let S = 1; S < f; S++) {
        const k = u[S], M = k.__key;
        y.has(M) || k.remove();
      }
    }
  }
  removeText() {
    const t = ge() === this;
    Df(this, XO(Ww(this))), t && ge() !== this && Ot(this);
  }
  formatText(t, n = null) {
    if (this.isCollapsed()) return this.toggleFormat(t), void cn(null);
    const r = this.getNodes(), i = [];
    for (const _ of r) ye(_) && i.push(_);
    const s = (_) => {
      r.forEach((b) => {
        if (te(b)) {
          const C = b.getFormatFlags(t, _);
          b.setTextFormat(C);
        }
      });
    }, o = i.length;
    if (o === 0) return this.toggleFormat(t), cn(null), void s(n);
    const a = this.anchor, l = this.focus, c = this.isBackward(), u = c ? l : a, f = c ? a : l;
    let d = 0, h = i[0], m = u.type === "element" ? 0 : u.offset;
    if (u.type === "text" && m === h.getTextContentSize() && (d = 1, h = i[1], m = 0), h == null) return;
    const p = h.getFormatFlags(t, n);
    s(p);
    const y = o - 1;
    let v = i[y];
    const g = f.type === "text" ? f.offset : v.getTextContentSize();
    if (h.is(v)) {
      if (m === g) return;
      if (Ri(h) || m === 0 && g === h.getTextContentSize()) h.setFormat(p);
      else {
        const _ = h.splitText(m, g), b = m === 0 ? _[0] : _[1];
        b.setFormat(p), u.type === "text" && u.set(b.__key, 0, "text"), f.type === "text" && f.set(b.__key, g - m, "text");
      }
      return void (this.format = p);
    }
    m === 0 || Ri(h) || ([, h] = h.splitText(m), m = 0), h.setFormat(p);
    const x = v.getFormatFlags(t, p);
    g > 0 && (g === v.getTextContentSize() || Ri(v) || ([v] = v.splitText(g)), v.setFormat(x));
    for (let _ = d + 1; _ < y; _++) {
      const b = i[_], C = b.getFormatFlags(t, x);
      b.setFormat(C);
    }
    u.type === "text" && u.set(h.__key, m, "text"), f.type === "text" && f.set(v.__key, g, "text"), this.format = p | x;
  }
  insertNodes(t) {
    if (t.length === 0) return;
    if (this.isCollapsed() || this.removeText(), this.anchor.key === "root") {
      this.insertParagraph();
      const m = ge();
      return fe(m) || me(134), m.insertNodes(t);
    }
    const n = (this.isBackward() ? this.focus : this.anchor).getNode(), r = N1(n, pr), i = t[t.length - 1];
    if (te(r) && "__language" in r) {
      if ("__language" in t[0]) this.insertText(t[0].getTextContent());
      else {
        const m = S1(this);
        r.splice(m, 0, t), i.selectEnd();
      }
      return;
    }
    if (!t.some((m) => (te(m) || it(m)) && !m.isInline())) {
      te(r) || me(211, n.constructor.name, n.getType());
      const m = S1(this);
      return r.splice(m, 0, t), void i.selectEnd();
    }
    const s = function(m) {
      const p = st();
      let y = null;
      for (let v = 0; v < m.length; v++) {
        const g = m[v], x = Rr(g);
        if (x || it(g) && g.isInline() || te(g) && g.isInline() || ye(g) || g.isParentRequired()) {
          if (y === null && (y = g.createParentElementNode(), p.append(y), x)) continue;
          y !== null && y.append(g);
        } else p.append(g), y = null;
      }
      return p;
    }(t), o = s.getLastDescendant(), a = s.getChildren(), l = !te(r) || !r.isEmpty() ? this.insertParagraph() : null, c = a[a.length - 1];
    let u = a[0];
    var f;
    te(f = u) && pr(f) && !f.isEmpty() && te(r) && (!r.isEmpty() || r.canMergeWhenEmpty()) && (te(r) || me(211, n.constructor.name, n.getType()), r.append(...u.getChildren()), u = a[1]), u && (r === null && me(212, n.constructor.name, n.getType()), function(m, p, y) {
      const v = p.getParentOrThrow().getLastChild();
      let g = p;
      const x = [p];
      for (; g !== v; ) g.getNextSibling() || me(140), g = g.getNextSibling(), x.push(g);
      let _ = m;
      for (const b of x) _ = _.insertAfter(b);
    }(r, u));
    const d = N1(o, pr);
    l && te(d) && (l.canMergeWhenEmpty() || pr(c)) && (d.append(...l.getChildren()), l.remove()), te(r) && r.isEmpty() && r.remove(), o.selectEnd();
    const h = te(r) ? r.getLastChild() : null;
    Rr(h) && d !== r && h.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const o = st();
      return Xe().splice(this.anchor.offset, 0, [o]), o.select(), o;
    }
    const t = S1(this), n = N1(this.anchor.getNode(), pr);
    te(n) || me(213);
    const r = n.getChildAtIndex(t), i = r ? [r, ...r.getNextSiblings()] : [], s = n.insertNewAfter(this, !1);
    return s ? (s.append(...i), s.selectStart(), s) : null;
  }
  insertLineBreak(t) {
    const n = Br();
    if (this.insertNodes([n]), t) {
      const r = n.getParentOrThrow(), i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const t = this.getNodes(), n = t.length, r = n - 1, i = this.anchor, s = this.focus;
    let o = t[0], a = t[r];
    const [l, c] = Mg(this);
    if (n === 0) return [];
    if (n === 1) {
      if (ye(o) && !this.isCollapsed()) {
        const f = l > c ? c : l, d = l > c ? l : c, h = o.splitText(f, d), m = f === 0 ? h[0] : h[1];
        return m != null ? [m] : [];
      }
      return [o];
    }
    const u = i.isBefore(s);
    if (ye(o)) {
      const f = u ? l : c;
      f === o.getTextContentSize() ? t.shift() : f !== 0 && ([, o] = o.splitText(f), t[0] = o);
    }
    if (ye(a)) {
      const f = a.getTextContent().length, d = u ? c : l;
      d === 0 ? t.pop() : d !== f && ([a] = a.splitText(d), t[r] = a);
    }
    return t;
  }
  modify(t, n, r) {
    if (kw(this, t, n, r)) return;
    const i = t === "move", s = Lt(), o = Hr(_r(s));
    if (!o) return;
    const a = s._blockCursorElement, l = s._rootElement, c = this.focus.getNode();
    if (l === null || a === null || !te(c) || c.isInline() || c.canBeEmpty() || Fg(a, s, l), this.dirty) {
      let u = Ua(s, this.anchor.key), f = Ua(s, this.focus.key);
      this.anchor.type === "text" && (u = Ha(u)), this.focus.type === "text" && (f = Ha(f)), u && f && n9(o, u, this.anchor.offset, f, this.focus.offset);
    }
    if (function(u, f, d, h) {
      u.modify(f, d, h);
    }(o, t, n ? "backward" : "forward", r), o.rangeCount > 0) {
      const u = o.getRangeAt(0), f = this.anchor.getNode(), d = on(f) ? f : RO(f);
      if (this.applyDOMRange(u), this.dirty = !0, !i) {
        const h = this.getNodes(), m = [];
        let p = !1;
        for (let y = 0; y < h.length; y++) {
          const v = h[y];
          Dg(v, d) ? m.push(v) : p = !0;
        }
        if (p && m.length > 0) if (n) {
          const y = m[0];
          te(y) ? y.selectStart() : y.getParentOrThrow().selectStart();
        } else {
          const y = m[m.length - 1];
          te(y) ? y.selectEnd() : y.getParentOrThrow().selectEnd();
        }
        o.anchorNode === u.startContainer && o.anchorOffset === u.startOffset || function(y) {
          const v = y.focus, g = y.anchor, x = g.key, _ = g.offset, b = g.type;
          g.set(v.key, v.offset, v.type, !0), v.set(x, _, b, !0);
        }(this);
      }
    }
    r === "lineboundary" && kw(this, t, n, r, "decorators");
  }
  forwardDeletion(t, n, r) {
    if (!r && (t.type === "element" && te(n) && t.offset === n.getChildrenSize() || t.type === "text" && t.offset === n.getTextContentSize())) {
      const i = n.getParent(), s = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (te(s) && s.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(t) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, t)) return;
      const s = Bv(yi(r, t ? "previous" : "next"));
      if (s.getTextSlices().every((a) => a === null || a.distance === 0)) {
        let a = { type: "initial" };
        for (const l of s.iterNodeCarets("shadowRoot")) if (wr(l)) {
          if (!l.origin.isInline()) {
            if (l.origin.isShadowRoot()) {
              if (a.type === "merge-block") break;
              if (te(s.anchor.origin) && s.anchor.origin.isEmpty()) {
                const c = tr(l);
                Df(this, Hs(c, c)), s.anchor.origin.remove();
              }
              return;
            }
            a.type !== "merge-next-block" && a.type !== "merge-block" || (a = { block: a.block, caret: l, type: "merge-block" });
          }
        } else {
          if (a.type === "merge-block") break;
          if (ja(l)) {
            if (te(l.origin)) {
              if (l.origin.isInline()) {
                if (!l.origin.isParentOf(s.anchor.origin)) break;
              } else a = { block: l.origin, type: "merge-next-block" };
              continue;
            }
            if (it(l.origin)) {
              if (!l.origin.isIsolated()) if (a.type === "merge-next-block" && (l.origin.isKeyboardSelectable() || !l.origin.isInline()) && te(s.anchor.origin) && s.anchor.origin.isEmpty()) {
                s.anchor.origin.remove();
                const c = vv();
                c.add(l.origin.getKey()), Ot(c);
              } else l.origin.remove();
              return;
            }
            break;
          }
        }
        if (a.type === "merge-block") {
          const { caret: l, block: c } = a;
          return Df(this, Hs(!l.origin.isEmpty() && c.isEmpty() ? ou(Kt(c, l.direction)) : s.anchor, l)), this.removeText();
        }
      }
      const o = this.focus;
      if (this.modify("extend", t, "character"), this.isCollapsed()) {
        if (t && r.offset === 0 && ww(this, r.getNode())) return;
      } else {
        const a = o.type === "text" ? o.getNode() : null;
        if (i = r.type === "text" ? r.getNode() : null, a !== null && a.isSegmented()) {
          const l = o.offset, c = a.getTextContentSize();
          if (a.is(i) || t && l !== c || !t && l !== 0) return void _w(a, t, l);
        } else if (i !== null && i.isSegmented()) {
          const l = r.offset, c = i.getTextContentSize();
          if (i.is(a) || t && l !== 0 || !t && l !== c) return void _w(i, t, l);
        }
        (function(l, c) {
          const u = l.anchor, f = l.focus, d = u.getNode(), h = f.getNode();
          if (d === h && u.type === "text" && f.type === "text") {
            const m = u.offset, p = f.offset, y = m < p, v = y ? m : p, g = y ? p : m, x = g - 1;
            v !== x && function(_) {
              return !(_9(_) || wO(_));
            }(d.getTextContent().slice(v, g)) && (c ? f.set(f.key, x, f.type) : u.set(u.key, x, u.type));
          }
        })(this, t);
      }
    }
    if (this.removeText(), t && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const r = this.anchor.getNode();
      r.isEmpty() && on(r.getParent()) && r.getPreviousSibling() === null && ww(this, r);
    }
  }
  deleteLine(t) {
    this.isCollapsed() && this.modify("extend", t, "lineboundary"), this.isCollapsed() ? this.deleteCharacter(t) : this.removeText();
  }
  deleteWord(t) {
    if (this.isCollapsed()) {
      const n = this.anchor, r = n.getNode();
      if (this.forwardDeletion(n, r, t)) return;
      this.modify("extend", t, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function Nt(e) {
  return e instanceof ap;
}
function xw(e) {
  const t = e.offset;
  if (e.type === "text") return t;
  const n = e.getNode();
  return t === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function Mg(e) {
  const t = e.getStartEndPoints();
  if (t === null) return [0, 0];
  const [n, r] = t;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset ? [0, 0] : [xw(n), xw(r)];
}
function ww(e, t) {
  for (let n = t; n; n = n.getParent()) {
    if (te(n)) {
      if (n.collapseAtStart(e)) return !0;
      if (Jt(n)) break;
    }
    if (n.getPreviousSibling()) break;
  }
  return !1;
}
const wO = (() => {
  try {
    const e = new RegExp("\\p{Emoji}", "u"), t = e.test.bind(e);
    if (t("❤️") && t("#️⃣") && t("👍")) return t;
  } catch {
  }
  return () => !1;
})();
function _w(e, t, n) {
  const r = e, i = r.getTextContent().split(/(?=\s)/g), s = i.length;
  let o = 0, a = 0;
  for (let c = 0; c < s; c++) {
    const u = c === s - 1;
    if (a = o, o += i[c].length, t && o === n || o > n || u) {
      i.splice(c, 1), u && (a = void 0);
      break;
    }
  }
  const l = i.join("").trim();
  l === "" ? r.remove() : (r.setTextContent(l), r.select(a, a));
}
function bw(e, t, n, r) {
  let i, s = t;
  if (At(e)) {
    let o = !1;
    const a = e.childNodes, l = a.length, c = r._blockCursorElement;
    s === l && (o = !0, s = l - 1);
    let u = a[s], f = !1;
    if (u === c) u = a[s + 1], f = !0;
    else if (c !== null) {
      const d = c.parentNode;
      e === d && t > Array.prototype.indexOf.call(d.children, c) && s--;
    }
    if (i = xa(u), ye(i)) s = Fw(i, o);
    else {
      let d = xa(e);
      if (d === null) return null;
      if (te(d)) {
        const h = r.getElementByKey(d.getKey());
        h === null && me(214), [d, s] = d.getDOMSlot(h).resolveChildIndex(d, h, e, t), te(d) || me(215), o && s >= d.getChildrenSize() && (s = Math.max(0, d.getChildrenSize() - 1));
        let p = d.getChildAtIndex(s);
        if (te(p) && function(y, v, g) {
          const x = y.getParent();
          return g === null || x === null || !x.canBeEmpty() || x !== g.getNode();
        }(p, 0, n)) {
          const y = o ? p.getLastDescendant() : p.getFirstDescendant();
          y === null ? d = p : (p = y, d = te(p) ? p : p.getParentOrThrow()), s = 0;
        }
        ye(p) ? (i = p, d = null, s = Fw(p, o)) : p !== d && o && !f && (te(d) || me(216), s = Math.min(d.getChildrenSize(), s + 1));
      } else {
        const h = d.getIndexWithinParent();
        s = t === 0 && it(d) && xa(e) === d ? h : h + 1, d = d.getParentOrThrow();
      }
      if (te(d)) return gi(d.__key, s, "element");
    }
  } else i = xa(e);
  return ye(i) ? gi(i.__key, s, "text") : null;
}
function Cw(e, t, n) {
  const r = e.offset, i = e.getNode();
  if (r === 0) {
    const s = i.getPreviousSibling(), o = i.getParent();
    if (t) {
      if ((n || !t) && s === null && te(o) && o.isInline()) {
        const a = o.getPreviousSibling();
        ye(a) && e.set(a.__key, a.getTextContent().length, "text");
      }
    } else te(s) && !n && s.isInline() ? e.set(s.__key, s.getChildrenSize(), "element") : ye(s) && e.set(s.__key, s.getTextContent().length, "text");
  } else if (r === i.getTextContent().length) {
    const s = i.getNextSibling(), o = i.getParent();
    if (t && te(s) && s.isInline()) e.set(s.__key, 0, "element");
    else if ((n || t) && s === null && te(o) && o.isInline() && !o.canInsertTextAfter()) {
      const a = o.getNextSibling();
      ye(a) && e.set(a.__key, 0, "text");
    }
  }
}
function QE(e, t, n) {
  if (e.type === "text" && t.type === "text") {
    const r = e.isBefore(t), i = e.is(t);
    Cw(e, r, i), Cw(t, !r, i), i && t.set(e.key, e.offset, e.type);
    const s = Lt();
    if (s.isComposing() && s._compositionKey !== e.key && fe(n)) {
      const o = n.anchor, a = n.focus;
      e.set(o.key, o.offset, o.type, !0), t.set(a.key, a.offset, a.type, !0);
    }
  }
}
function e9(e, t, n, r, i, s) {
  if (e === null || n === null || !iu(i, e, n)) return null;
  const o = bw(e, t, fe(s) ? s.anchor : null, i);
  if (o === null) return null;
  const a = bw(n, r, fe(s) ? s.focus : null, i);
  if (a === null) return null;
  if (o.type === "element" && a.type === "element") {
    const l = xa(e), c = xa(n);
    if (it(l) && it(c)) return null;
  }
  return QE(o, a, s), [o, a];
}
function Td(e) {
  return te(e) && !e.isInline();
}
function t9(e, t, n, r, i, s) {
  const o = Xs(), a = new nu(gi(e, t, i), gi(n, r, s), 0, "");
  return a.dirty = !0, o._selection = a, a;
}
function fl() {
  const e = gi("root", 0, "element"), t = gi("root", 0, "element");
  return new nu(e, t, 0, "");
}
function vv() {
  return new ap(/* @__PURE__ */ new Set());
}
function yv(e, t, n, r) {
  const i = n._window;
  if (i === null) return null;
  const s = r || i.event, o = s ? s.type : void 0, a = o === "selectionchange", l = !gg && (a || o === "beforeinput" || o === "compositionstart" || o === "compositionend" || o === "click" && s && s.detail === 3 || o === "drop" || o === void 0);
  let c, u, f, d;
  if (fe(e) && !l) return e.clone();
  if (t === null) return null;
  if (c = t.anchorNode, u = t.focusNode, f = t.anchorOffset, d = t.focusOffset, a && fe(e) && !iu(n, c, u)) return e.clone();
  const h = e9(c, f, u, d, n, e);
  if (h === null) return null;
  const [m, p] = h;
  return new nu(m, p, fe(e) ? e.format : 0, fe(e) ? e.style : "");
}
function ge() {
  return Xs()._selection;
}
function qo() {
  return Lt()._editorState._selection;
}
function Ad(e, t, n, r = 1) {
  const i = e.anchor, s = e.focus, o = i.getNode(), a = s.getNode();
  if (!t.is(o) && !t.is(a)) return;
  const l = t.__key;
  if (e.isCollapsed()) {
    const c = i.offset;
    if (n <= c && r > 0 || n < c && r < 0) {
      const u = Math.max(0, c + r);
      i.set(l, u, "element"), s.set(l, u, "element"), Ew(e);
    }
  } else {
    const c = e.isBackward(), u = c ? s : i, f = u.getNode(), d = c ? i : s, h = d.getNode();
    if (t.is(f)) {
      const m = u.offset;
      (n <= m && r > 0 || n < m && r < 0) && u.set(l, Math.max(0, m + r), "element");
    }
    if (t.is(h)) {
      const m = d.offset;
      (n <= m && r > 0 || n < m && r < 0) && d.set(l, Math.max(0, m + r), "element");
    }
  }
  Ew(e);
}
function Ew(e) {
  const t = e.anchor, n = t.offset, r = e.focus, i = r.offset, s = t.getNode(), o = r.getNode();
  if (e.isCollapsed()) {
    if (!te(s)) return;
    const a = s.getChildrenSize(), l = n >= a, c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(n);
    if (ye(c)) {
      let u = 0;
      l && (u = c.getTextContentSize()), t.set(c.__key, u, "text"), r.set(c.__key, u, "text");
    }
  } else {
    if (te(s)) {
      const a = s.getChildrenSize(), l = n >= a, c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(n);
      if (ye(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), t.set(c.__key, u, "text");
      }
    }
    if (te(o)) {
      const a = o.getChildrenSize(), l = i >= a, c = l ? o.getChildAtIndex(a - 1) : o.getChildAtIndex(i);
      if (ye(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), r.set(c.__key, u, "text");
      }
    }
  }
}
function Nd(e, t, n, r, i) {
  let s = null, o = 0, a = null;
  r !== null ? (s = r.__key, ye(r) ? (o = r.getTextContentSize(), a = "text") : te(r) && (o = r.getChildrenSize(), a = "element")) : i !== null && (s = i.__key, ye(i) ? a = "text" : te(i) && (a = "element")), s !== null && a !== null ? e.set(s, o, a) : (o = t.getIndexWithinParent(), o === -1 && (o = n.getChildrenSize()), e.set(n.__key, o, "element"));
}
function Sw(e, t, n, r, i) {
  e.type === "text" ? e.set(n, e.offset + (t ? 0 : i), "text") : e.offset > r.getIndexWithinParent() && e.set(e.key, e.offset - 1, "element");
}
function n9(e, t, n, r, i) {
  try {
    e.setBaseAndExtent(t, n, r, i);
  } catch {
  }
}
function _O(e, t, n, r, i, s, o) {
  const a = r.anchorNode, l = r.focusNode, c = r.anchorOffset, u = r.focusOffset, f = document.activeElement;
  if (i.has(f9) && f !== s || f !== null && kv(f)) return;
  if (!fe(t)) return void (e !== null && iu(n, a, l) && r.removeAllRanges());
  const d = t.anchor, h = t.focus, m = d.key, p = h.key, y = Ua(n, m), v = Ua(n, p), g = d.offset, x = h.offset, _ = t.format, b = t.style, C = t.isCollapsed();
  let E = y, S = v, k = !1;
  if (d.type === "text") {
    E = Ha(y);
    const P = d.getNode();
    k = P.getFormat() !== _ || P.getStyle() !== b;
  } else fe(e) && e.anchor.type === "text" && (k = !0);
  var M, O, R, I, H;
  if (h.type === "text" && (S = Ha(v)), E !== null && S !== null && (C && (e === null || k || fe(e) && (e.format !== _ || e.style !== b)) && (M = _, O = b, R = g, I = m, H = performance.now(), HE = [M, O, R, I, H]), c !== g || u !== x || a !== E || l !== S || r.type === "Range" && C || (f !== null && s.contains(f) || s.focus({ preventScroll: !0 }), d.type === "element"))) {
    if (n9(r, E, g, S, x), !i.has(AO) && t.isCollapsed() && s !== null && s === document.activeElement) {
      const P = fe(t) && t.anchor.type === "element" ? E.childNodes[g] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (P !== null) {
        let W;
        if (P instanceof Text) {
          const G = document.createRange();
          G.selectNode(P), W = G.getBoundingClientRect();
        } else W = P.getBoundingClientRect();
        (function(G, J, X) {
          const N = S9(X), U = Ov(N);
          if (N === null || U === null) return;
          let { top: ee, bottom: F } = J, ue = 0, pe = 0, ce = X;
          for (; ce !== null; ) {
            const q = ce === N.body;
            if (q) ue = 0, pe = _r(G).innerHeight;
            else {
              const oe = ce.getBoundingClientRect();
              ue = oe.top, pe = oe.bottom;
            }
            let Z = 0;
            if (ee < ue ? Z = -(ue - ee) : F > pe && (Z = F - pe), Z !== 0) if (q) U.scrollBy(0, Z);
            else {
              const oe = ce.scrollTop;
              ce.scrollTop += Z;
              const le = ce.scrollTop - oe;
              ee -= le, F -= le;
            }
            if (q) break;
            ce = su(ce);
          }
        })(n, W, s);
      }
    }
    Ng = !0;
  }
}
function dl(e) {
  let t = ge() || qo();
  t === null && (t = Xe().selectEnd()), t.insertNodes(e);
}
function S1(e) {
  let t = e;
  e.isCollapsed() || t.removeText();
  const n = ge();
  fe(n) && (t = n), fe(t) || me(161);
  const r = t.anchor;
  let i = r.getNode(), s = r.offset;
  for (; !pr(i); ) {
    const o = i;
    if ([i, s] = bO(i, s), o.is(i)) break;
  }
  return s;
}
function bO(e, t) {
  const n = e.getParent();
  if (!n) {
    const i = st();
    return Xe().append(i), i.select(), [Xe(), 0];
  }
  if (ye(e)) {
    const i = e.splitText(t);
    if (i.length === 0) return [n, e.getIndexWithinParent()];
    const s = t === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + s];
  }
  if (!te(e) || t === 0) return [n, e.getIndexWithinParent()];
  const r = e.getChildAtIndex(t);
  if (r) {
    const i = new nu(gi(e.__key, t, "element"), gi(e.__key, t, "element"), 0, ""), s = e.insertNewAfter(i);
    s && s.append(r, ...r.getNextSiblings());
  }
  return [n, e.getIndexWithinParent() + 1];
}
function kw(e, t, n, r, i = "decorators-and-blocks") {
  if (t === "move" && r === "character" && !e.isCollapsed()) {
    const [u, f] = n === e.isBackward() ? [e.focus, e.anchor] : [e.anchor, e.focus];
    return f.set(u.key, u.offset, u.type), !0;
  }
  const s = yi(e.focus, n ? "previous" : "next"), o = r === "lineboundary", a = t === "move";
  let l = s, c = i === "decorators-and-blocks";
  if (!D9(l)) {
    for (const u of l) {
      c = !1;
      const { origin: f } = u;
      if (!it(f) || f.isIsolated() || (l = u, !o || !f.isInline())) break;
    }
    if (c) for (const u of Bv(s).iterNodeCarets(t === "extend" ? "shadowRoot" : "root")) {
      if (wr(u)) u.origin.isInline() || (l = u);
      else {
        if (te(u.origin)) continue;
        it(u.origin) && !u.origin.isInline() && (l = u);
      }
      break;
    }
  }
  if (l === s) return !1;
  if (a && !o && it(l.origin) && l.origin.isKeyboardSelectable()) {
    const u = vv();
    return u.add(l.origin.getKey()), Ot(u), !0;
  }
  return l = tr(l), a && $o(e.anchor, l), $o(e.focus, l), c || !o;
}
let rn = null, sn = null, jn = !1, k1 = !1, Lf = 0;
const Tw = { characterData: !0, childList: !0, subtree: !0 };
function ru() {
  return jn || rn !== null && rn._readOnly;
}
function hn() {
  jn && me(13);
}
function r9() {
  Lf > 99 && me(14);
}
function Xs() {
  return rn === null && me(195, i9()), rn;
}
function Lt() {
  return sn === null && me(196, i9()), sn;
}
function i9() {
  let e = 0;
  const t = /* @__PURE__ */ new Set(), n = cp.version;
  if (typeof window < "u") for (const i of document.querySelectorAll("[contenteditable]")) {
    const s = fp(i);
    if (Tv(s)) e++;
    else if (s) {
      let o = String(s.constructor.version || "<0.17.1");
      o === n && (o += " (separately built, likely a bundler configuration issue)"), t.add(o);
    }
  }
  let r = ` Detected on the page: ${e} compatible editor(s) with version ${n}`;
  return t.size && (r += ` and incompatible editors with versions ${Array.from(t).join(", ")}`), r;
}
function CO() {
  return sn;
}
function Aw(e, t, n) {
  const r = t.__type, i = m9(e, r);
  let s = n.get(r);
  s === void 0 && (s = Array.from(i.transforms), n.set(r, s));
  const o = s.length;
  for (let a = 0; a < o && (s[a](t), t.isAttached()); a++) ;
}
function Nw(e, t) {
  return e !== void 0 && e.__key !== t && e.isAttached();
}
function s9(e, t) {
  if (!t) return;
  const n = e._updateTags;
  let r = t;
  Array.isArray(t) || (r = [t]);
  for (const i of r) n.add(i);
}
function EO(e) {
  return xv(e, Lt()._nodes);
}
function xv(e, t) {
  const n = e.type, r = t.get(n);
  r === void 0 && me(17, n);
  const i = r.klass;
  e.type !== i.getType() && me(18, i.name);
  const s = i.importJSON(e), o = e.children;
  if (te(s) && Array.isArray(o)) for (let a = 0; a < o.length; a++) {
    const l = xv(o[a], t);
    s.append(l);
  }
  return s;
}
function Iw(e, t, n) {
  const r = rn, i = jn, s = sn;
  rn = t, jn = !0, sn = e;
  try {
    return n();
  } finally {
    rn = r, jn = i, sn = s;
  }
}
function zi(e, t) {
  const n = e._pendingEditorState, r = e._rootElement, i = e._headless || r === null;
  if (n === null) return;
  const s = e._editorState, o = s._selection, a = n._selection, l = e._dirtyType !== Oo, c = rn, u = jn, f = sn, d = e._updating, h = e._observer;
  let m = null;
  if (e._pendingEditorState = null, e._editorState = n, !i && l && h !== null) {
    sn = e, rn = n, jn = !1, e._updating = !0;
    try {
      const C = e._dirtyType, E = e._dirtyElements, S = e._dirtyLeaves;
      h.disconnect(), m = iO(s, n, e, C, E, S);
    } catch (C) {
      if (C instanceof Error && e._onError(C), k1) throw C;
      return h9(e, null, r, n), AE(e), e._dirtyType = za, k1 = !0, zi(e, s), void (k1 = !1);
    } finally {
      h.observe(r, Tw), e._updating = d, rn = c, jn = u, sn = f;
    }
  }
  n._readOnly || (n._readOnly = !0);
  const p = e._dirtyLeaves, y = e._dirtyElements, v = e._normalizedNodes, g = e._updateTags, x = e._deferred;
  l && (e._dirtyType = Oo, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements = /* @__PURE__ */ new Map(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set()), function(C, E) {
    const S = C._decorators;
    let k = C._pendingDecorators || S;
    const M = E._nodeMap;
    let O;
    for (O in k) M.has(O) || (k === S && (k = x9(C)), delete k[O]);
  }(e, n);
  const _ = i ? null : Hr(_r(e));
  if (e._editable && _ !== null && (l || a === null || a.dirty) && r !== null && !g.has(NO)) {
    sn = e, rn = n;
    try {
      if (h !== null && h.disconnect(), l || a === null || a.dirty) {
        const C = e._blockCursorElement;
        C !== null && Fg(C, e, r), _O(o, a, e, _, g, r);
      }
      (function(C, E, S) {
        let k = C._blockCursorElement;
        if (fe(S) && S.isCollapsed() && S.anchor.type === "element" && E.contains(document.activeElement)) {
          const M = S.anchor, O = M.getNode(), R = M.offset;
          let I = !1, H = null;
          if (R === O.getChildrenSize())
            A1(O.getChildAtIndex(R - 1)) && (I = !0);
          else {
            const P = O.getChildAtIndex(R);
            if (P !== null && A1(P)) {
              const W = P.getPreviousSibling();
              (W === null || A1(W)) && (I = !0, H = C.getElementByKey(P.__key));
            }
          }
          if (I) {
            const P = C.getElementByKey(O.__key);
            return k === null && (C._blockCursorElement = k = function(W) {
              const G = W.theme, J = document.createElement("div");
              J.contentEditable = "false", J.setAttribute("data-lexical-cursor", "true");
              let X = G.blockCursor;
              if (X !== void 0) {
                if (typeof X == "string") {
                  const N = xd(X);
                  X = G.blockCursor = N;
                }
                X !== void 0 && J.classList.add(...X);
              }
              return J;
            }(C._config)), E.style.caretColor = "transparent", void (H === null ? P.appendChild(k) : P.insertBefore(k, H));
          }
        }
        k !== null && Fg(k, C, E);
      })(e, r, a);
    } finally {
      h !== null && h.observe(r, Tw), sn = f, rn = c;
    }
  }
  m !== null && function(C, E, S, k, M) {
    const O = Array.from(C._listeners.mutation), R = O.length;
    for (let I = 0; I < R; I++) {
      const [H, P] = O[I];
      for (const W of P) {
        const G = E.get(W);
        G !== void 0 && H(G, { dirtyLeaves: k, prevEditorState: M, updateTags: S });
      }
    }
  }(e, m, g, p, s), fe(a) || a === null || o !== null && o.is(a) || e.dispatchCommand(Zc, void 0);
  const b = e._pendingDecorators;
  b !== null && (e._decorators = b, e._pendingDecorators = null, ac("decorator", e, !0, b)), function(C, E, S) {
    const k = Dw(E), M = Dw(S);
    k !== M && ac("textcontent", C, !0, M);
  }(e, t || s, n), ac("update", e, !0, { dirtyElements: y, dirtyLeaves: p, editorState: n, mutatedNodes: m, normalizedNodes: v, prevEditorState: t || s, tags: g }), function(C, E) {
    if (C._deferred = [], E.length !== 0) {
      const S = C._updating;
      C._updating = !0;
      try {
        for (let k = 0; k < E.length; k++) E[k]();
      } finally {
        C._updating = S;
      }
    }
  }(e, x), function(C) {
    const E = C._updates;
    if (E.length !== 0) {
      const S = E.shift();
      if (S) {
        const [k, M] = S;
        wv(C, k, M);
      }
    }
  }(e);
}
function ac(e, t, n, ...r) {
  const i = t._updating;
  t._updating = n;
  try {
    const s = Array.from(t._listeners[e]);
    for (let o = 0; o < s.length; o++) s[o].apply(null, r);
  } finally {
    t._updating = i;
  }
}
function Lw(e, t) {
  const n = e._updates;
  let r = t || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [s, o] = i;
      let a;
      if (o !== void 0) {
        if (a = o.onUpdate, o.skipTransforms && (r = !0), o.discrete) {
          const l = e._pendingEditorState;
          l === null && me(191), l._flushSync = !0;
        }
        a && e._deferred.push(a), s9(e, o.tag);
      }
      s();
    }
  }
  return r;
}
function wv(e, t, n) {
  const r = e._updateTags;
  let i, s = !1, o = !1;
  n !== void 0 && (i = n.onUpdate, s9(e, n.tag), s = n.skipTransforms || !1, o = n.discrete || !1), i && e._deferred.push(i);
  const a = e._editorState;
  let l = e._pendingEditorState, c = !1;
  (l === null || l._readOnly) && (l = e._pendingEditorState = a9(l || a), c = !0), l._flushSync = o;
  const u = rn, f = jn, d = sn, h = e._updating;
  rn = l, jn = !1, e._updating = !0, sn = e;
  const m = e._headless || e.getRootElement() === null;
  Sv(null);
  try {
    c && (m ? a._selection !== null && (l._selection = a._selection.clone()) : l._selection = function(g, x) {
      const _ = g.getEditorState()._selection, b = Hr(_r(g));
      return fe(_) || _ == null ? yv(_, b, g, x) : _.clone();
    }(e, n && n.event || null));
    const y = e._compositionKey;
    t(), s = Lw(e, s), function(g, x) {
      const _ = x.getEditorState()._selection, b = g._selection;
      if (fe(b)) {
        const C = b.anchor, E = b.focus;
        let S;
        if (C.type === "text" && (S = C.getNode(), S.selectionTransform(_, b)), E.type === "text") {
          const k = E.getNode();
          S !== k && k.selectionTransform(_, b);
        }
      }
    }(l, e), e._dirtyType !== Oo && (s ? function(g, x) {
      const _ = x._dirtyLeaves, b = g._nodeMap;
      for (const C of _) {
        const E = b.get(C);
        ye(E) && E.isAttached() && E.isSimpleText() && !E.isUnmergeable() && lw(E);
      }
    }(l, e) : function(g, x) {
      const _ = x._dirtyLeaves, b = x._dirtyElements, C = g._nodeMap, E = As(), S = /* @__PURE__ */ new Map();
      let k = _, M = k.size, O = b, R = O.size;
      for (; M > 0 || R > 0; ) {
        if (M > 0) {
          x._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const I of k) {
            const H = C.get(I);
            ye(H) && H.isAttached() && H.isSimpleText() && !H.isUnmergeable() && lw(H), H !== void 0 && Nw(H, E) && Aw(x, H, S), _.add(I);
          }
          if (k = x._dirtyLeaves, M = k.size, M > 0) {
            Lf++;
            continue;
          }
        }
        x._dirtyLeaves = /* @__PURE__ */ new Set(), x._dirtyElements = /* @__PURE__ */ new Map(), O.delete("root") && O.set("root", !0);
        for (const I of O) {
          const H = I[0], P = I[1];
          if (b.set(H, P), !P) continue;
          const W = C.get(H);
          W !== void 0 && Nw(W, E) && Aw(x, W, S);
        }
        k = x._dirtyLeaves, M = k.size, O = x._dirtyElements, R = O.size, Lf++;
      }
      x._dirtyLeaves = _, x._dirtyElements = b;
    }(l, e), Lw(e), function(g, x, _, b) {
      const C = g._nodeMap, E = x._nodeMap, S = [];
      for (const [k] of b) {
        const M = E.get(k);
        M !== void 0 && (M.isAttached() || (te(M) && SE(M, k, C, E, S, b), C.has(k) || b.delete(k), S.push(k)));
      }
      for (const k of S) E.delete(k);
      for (const k of _) {
        const M = E.get(k);
        M === void 0 || M.isAttached() || (C.has(k) || _.delete(k), E.delete(k));
      }
    }(a, l, e._dirtyLeaves, e._dirtyElements)), y !== e._compositionKey && (l._flushSync = !0);
    const v = l._selection;
    if (fe(v)) {
      const g = l._nodeMap, x = v.anchor.key, _ = v.focus.key;
      g.get(x) !== void 0 && g.get(_) !== void 0 || me(19);
    } else Nt(v) && v._nodes.size === 0 && (l._selection = null);
  } catch (y) {
    return y instanceof Error && e._onError(y), e._pendingEditorState = a, e._dirtyType = za, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), void zi(e);
  } finally {
    rn = u, jn = f, sn = d, e._updating = h, Lf = 0;
  }
  e._dirtyType !== Oo || e._deferred.length > 0 || function(y, v) {
    const g = v.getEditorState()._selection, x = y._selection;
    if (x !== null) {
      if (x.dirty || !x.is(g)) return !0;
    } else if (g !== null) return !0;
    return !1;
  }(l, e) ? l._flushSync ? (l._flushSync = !1, zi(e)) : c && MO(() => {
    zi(e);
  }) : (l._flushSync = !1, c && (r.clear(), e._deferred = [], e._pendingEditorState = null));
}
function Zn(e, t, n) {
  sn === e && n === void 0 ? t() : wv(e, t, n);
}
let SO = class Mf {
  constructor(t, n, r) {
    this.element = t, this.before = n || null, this.after = r || null;
  }
  withBefore(t) {
    return new Mf(this.element, t, this.after);
  }
  withAfter(t) {
    return new Mf(this.element, this.before, t);
  }
  withElement(t) {
    return this.element === t ? this : new Mf(t, this.before, this.after);
  }
  insertChild(t) {
    const n = this.before || this.getManagedLineBreak();
    return n !== null && n.parentElement !== this.element && me(222), this.element.insertBefore(t, n), this;
  }
  removeChild(t) {
    return t.parentElement !== this.element && me(223), this.element.removeChild(t), this;
  }
  replaceChild(t, n) {
    return n.parentElement !== this.element && me(224), this.element.replaceChild(t, n), this;
  }
  getFirstChild() {
    const t = this.after ? this.after.nextSibling : this.element.firstChild;
    return t === this.before || t === this.getManagedLineBreak() ? null : t;
  }
  getManagedLineBreak() {
    return this.element.__lexicalLineBreak || null;
  }
  setManagedLineBreak(t) {
    if (t === null) this.removeManagedLineBreak();
    else {
      const n = t === "decorator" && (Ba || bc);
      this.insertManagedLineBreak(n);
    }
  }
  removeManagedLineBreak() {
    const t = this.getManagedLineBreak();
    if (t) {
      const n = this.element, r = t.nodeName === "IMG" ? t.nextSibling : null;
      r && n.removeChild(r), n.removeChild(t), n.__lexicalLineBreak = void 0;
    }
  }
  insertManagedLineBreak(t) {
    const n = this.getManagedLineBreak();
    if (n) {
      if (t === (n.nodeName === "IMG")) return;
      this.removeManagedLineBreak();
    }
    const r = this.element, i = this.before, s = document.createElement("br");
    if (r.insertBefore(s, i), t) {
      const o = document.createElement("img");
      o.setAttribute("data-lexical-linebreak", "true"), o.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;", o.alt = "", r.insertBefore(o, s), r.__lexicalLineBreak = o;
    } else r.__lexicalLineBreak = s;
  }
  getFirstChildOffset() {
    let t = 0;
    for (let n = this.after; n !== null; n = n.previousSibling) t++;
    return t;
  }
  resolveChildIndex(t, n, r, i) {
    if (r === this.element) {
      const l = this.getFirstChildOffset();
      return [t, Math.min(l + t.getChildrenSize(), Math.max(l, i))];
    }
    const s = Mw(n, r);
    s.push(i);
    const o = Mw(n, this.element);
    let a = t.getIndexWithinParent();
    for (let l = 0; l < o.length; l++) {
      const c = s[l], u = o[l];
      if (c === void 0 || c < u) break;
      if (c > u) {
        a += 1;
        break;
      }
    }
    return [t.getParentOrThrow(), a];
  }
};
function Mw(e, t) {
  const n = [];
  let r = t;
  for (; r !== e && r !== null; r = r.parentNode) {
    let i = 0;
    for (let s = r.previousSibling; s !== null; s = s.previousSibling) i++;
    n.push(i);
  }
  return r !== e && me(225), n.reverse();
}
let Wn = class extends cl {
  constructor(t) {
    super(t), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__style = "", this.__indent = 0, this.__dir = null, this.__textFormat = 0, this.__textStyle = "";
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__key === t.__key && (this.__first = t.__first, this.__last = t.__last, this.__size = t.__size), this.__indent = t.__indent, this.__format = t.__format, this.__style = t.__style, this.__dir = t.__dir, this.__textFormat = t.__textFormat, this.__textStyle = t.__textStyle;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const t = this.getFormat();
    return JM[t] || "";
  }
  getStyle() {
    return this.getLatest().__style;
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n), n = n.getNextSibling();
    return t;
  }
  getChildrenKeys() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n.__key), n = n.getNextSibling();
    return t;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const t = Lt()._dirtyElements;
    return t !== null && t.has(this.__key);
  }
  isLastChild() {
    const t = this.getLatest(), n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(t);
  }
  getAllTextNodes() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if (ye(n) && t.push(n), te(n)) {
        const r = n.getAllTextNodes();
        t.push(...r);
      }
      n = n.getNextSibling();
    }
    return t;
  }
  getFirstDescendant() {
    let t = this.getFirstChild();
    for (; te(t); ) {
      const n = t.getFirstChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getLastDescendant() {
    let t = this.getLastChild();
    for (; te(t); ) {
      const n = t.getLastChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getDescendantByIndex(t) {
    const n = this.getChildren(), r = n.length;
    if (t >= r) {
      const s = n[r - 1];
      return te(s) && s.getLastDescendant() || s || null;
    }
    const i = n[t];
    return te(i) && i.getFirstDescendant() || i || null;
  }
  getFirstChild() {
    const t = this.getLatest().__first;
    return t === null ? null : wt(t);
  }
  getFirstChildOrThrow() {
    const t = this.getFirstChild();
    return t === null && me(45, this.__key), t;
  }
  getLastChild() {
    const t = this.getLatest().__last;
    return t === null ? null : wt(t);
  }
  getLastChildOrThrow() {
    const t = this.getLastChild();
    return t === null && me(96, this.__key), t;
  }
  getChildAtIndex(t) {
    const n = this.getChildrenSize();
    let r, i;
    if (t < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= t; ) {
        if (i === t) return r;
        r = r.getNextSibling(), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= t; ) {
      if (i === t) return r;
      r = r.getPreviousSibling(), i--;
    }
    return null;
  }
  getTextContent() {
    let t = "";
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const s = n[i];
      t += s.getTextContent(), te(s) && i !== r - 1 && !s.isInline() && (t += Xi);
    }
    return t;
  }
  getTextContentSize() {
    let t = 0;
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const s = n[i];
      t += s.getTextContentSize(), te(s) && i !== r - 1 && !s.isInline() && (t += Xi.length);
    }
    return t;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  hasFormat(t) {
    if (t !== "") {
      const n = ew[t];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  hasTextFormat(t) {
    const n = Po[t];
    return !!(this.getTextFormat() & n);
  }
  getFormatFlags(t, n) {
    return Md(this.getLatest().__textFormat, t, n);
  }
  getTextStyle() {
    return this.getLatest().__textStyle;
  }
  select(t, n) {
    hn();
    const r = ge();
    let i = t, s = n;
    const o = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (t === 0 && n === 0) {
        const l = this.getFirstChild();
        if (ye(l) || te(l)) return l.select(0, 0);
      } else if (!(t !== void 0 && t !== o || n !== void 0 && n !== o)) {
        const l = this.getLastChild();
        if (ye(l) || te(l)) return l.select();
      }
    }
    i === void 0 && (i = o), s === void 0 && (s = o);
    const a = this.__key;
    return fe(r) ? (r.anchor.set(a, i, "element"), r.focus.set(a, s, "element"), r.dirty = !0, r) : t9(a, i, a, s, "element", "element");
  }
  selectStart() {
    const t = this.getFirstDescendant();
    return t ? t.selectStart() : this.select();
  }
  selectEnd() {
    const t = this.getLastDescendant();
    return t ? t.selectEnd() : this.select();
  }
  clear() {
    const t = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), t;
  }
  append(...t) {
    return this.splice(this.getChildrenSize(), 0, t);
  }
  setDirection(t) {
    const n = this.getWritable();
    return n.__dir = t, n;
  }
  setFormat(t) {
    return this.getWritable().__format = t !== "" ? ew[t] : 0, this;
  }
  setStyle(t) {
    return this.getWritable().__style = t || "", this;
  }
  setTextFormat(t) {
    const n = this.getWritable();
    return n.__textFormat = t, n;
  }
  setTextStyle(t) {
    const n = this.getWritable();
    return n.__textStyle = t, n;
  }
  setIndent(t) {
    return this.getWritable().__indent = t, this;
  }
  splice(t, n, r) {
    const i = r.length, s = this.getChildrenSize(), o = this.getWritable();
    t + n <= s || me(226, String(t), String(n), String(s));
    const a = o.__key, l = [], c = [], u = this.getChildAtIndex(t + n);
    let f = null, d = s - n + i;
    if (t !== 0) if (t === s) f = this.getLastChild();
    else {
      const m = this.getChildAtIndex(t);
      m !== null && (f = m.getPreviousSibling());
    }
    if (n > 0) {
      let m = f === null ? this.getFirstChild() : f.getNextSibling();
      for (let p = 0; p < n; p++) {
        m === null && me(100);
        const y = m.getNextSibling(), v = m.__key;
        So(m.getWritable()), c.push(v), m = y;
      }
    }
    let h = f;
    for (let m = 0; m < i; m++) {
      const p = r[m];
      h !== null && p.is(h) && (f = h = h.getPreviousSibling());
      const y = p.getWritable();
      y.__parent === a && d--, So(y);
      const v = p.__key;
      if (h === null) o.__first = v, y.__prev = null;
      else {
        const g = h.getWritable();
        g.__next = v, y.__prev = g.__key;
      }
      p.__key === a && me(76), y.__parent = a, l.push(v), h = p;
    }
    if (t + n === s)
      h !== null && (h.getWritable().__next = null, o.__last = h.__key);
    else if (u !== null) {
      const m = u.getWritable();
      if (h !== null) {
        const p = h.getWritable();
        m.__prev = h.__key, p.__next = u.__key;
      } else m.__prev = null;
    }
    if (o.__size = d, c.length) {
      const m = ge();
      if (fe(m)) {
        const p = new Set(c), y = new Set(l), { anchor: v, focus: g } = m;
        Ow(v, p, y) && Nd(v, v.getNode(), this, f, u), Ow(g, p, y) && Nd(g, g.getNode(), this, f, u), d !== 0 || this.canBeEmpty() || Jt(this) || this.remove();
      }
    }
    return o;
  }
  getDOMSlot(t) {
    return new SO(t);
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (At(n)) {
      const r = this.getIndent();
      r > 0 && (n.style.paddingInlineStart = 40 * r + "px");
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  exportJSON() {
    const t = { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), ...super.exportJSON() }, n = this.getTextFormat(), r = this.getTextStyle();
    return n !== 0 && (t.textFormat = n), r !== "" && (t.textStyle = r), t;
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setFormat(t.format).setIndent(t.indent).setDirection(t.direction).setTextFormat(t.textFormat || 0).setTextStyle(t.textStyle || "");
  }
  insertNewAfter(t, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(t) {
    return !1;
  }
  excludeFromCopy(t) {
    return !1;
  }
  canReplaceWith(t) {
    return !0;
  }
  canInsertAfter(t) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(t) {
    return !1;
  }
  extractWithChild(t, n, r) {
    return !1;
  }
  canMergeWhenEmpty() {
    return !1;
  }
  reconcileObservedMutation(t, n) {
    const r = this.getDOMSlot(t);
    let i = r.getFirstChild();
    for (let s = this.getFirstChild(); s; s = s.getNextSibling()) {
      const o = n.getElementByKey(s.getKey());
      o !== null && (i == null ? (r.insertChild(o), i = o) : i !== o && r.replaceChild(o, i), i = i.nextSibling);
    }
  }
};
function te(e) {
  return e instanceof Wn;
}
function Ow(e, t, n) {
  let r = e.getNode();
  for (; r; ) {
    const i = r.__key;
    if (t.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
let bi = class extends cl {
  decorate(t, n) {
    me(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
};
function it(e) {
  return e instanceof bi;
}
let _v = class o9 extends Wn {
  static getType() {
    return "root";
  }
  static clone() {
    return new o9();
  }
  constructor() {
    super("root"), this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    me(51);
  }
  getTextContent() {
    const t = this.__cachedText;
    return !ru() && Lt()._dirtyType !== Oo || t === null ? super.getTextContent() : t;
  }
  remove() {
    me(52);
  }
  replace(t) {
    me(53);
  }
  insertBefore(t) {
    me(54);
  }
  insertAfter(t) {
    me(55);
  }
  updateDOM(t, n) {
    return !1;
  }
  splice(t, n, r) {
    for (const i of r) te(i) || it(i) || me(282);
    return super.splice(t, n, r);
  }
  static importJSON(t) {
    return Xe().updateFromJSON(t);
  }
  collapseAtStart() {
    return !0;
  }
};
function on(e) {
  return e instanceof _v;
}
function a9(e) {
  return new c9(new Map(e._nodeMap));
}
function bv() {
  return new c9(/* @__PURE__ */ new Map([["root", new _v()]]));
}
function l9(e) {
  const t = e.exportJSON(), n = e.constructor;
  if (t.type !== n.getType() && me(130, n.name), te(e)) {
    const r = t.children;
    Array.isArray(r) || me(59, n.name);
    const i = e.getChildren();
    for (let s = 0; s < i.length; s++) {
      const o = l9(i[s]);
      r.push(o);
    }
  }
  return t;
}
let c9 = class u9 {
  constructor(t, n) {
    this._nodeMap = t, this._selection = n || null, this._flushSync = !1, this._readOnly = !1;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(t, n) {
    return Iw(n && n.editor || null, this, t);
  }
  clone(t) {
    const n = new u9(this._nodeMap, t === void 0 ? this._selection : t);
    return n._readOnly = !0, n;
  }
  toJSON() {
    return Iw(null, this, () => ({ root: l9(Xe()) }));
  }
};
const Id = "historic", kO = "history-push", Of = "history-merge", TO = "paste", f9 = "collaboration", AO = "skip-scroll-into-view", NO = "skip-dom-selection";
let Cv = class extends Wn {
  static getType() {
    return "artificial";
  }
  createDOM(t) {
    return document.createElement("div");
  }
}, lp = class d9 extends Wn {
  static getType() {
    return "paragraph";
  }
  static clone(t) {
    return new d9(t.__key);
  }
  createDOM(t) {
    const n = document.createElement("p"), r = La(t.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(t, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (t) => ({ conversion: IO, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (At(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
    }
    return { element: n };
  }
  static importJSON(t) {
    return st().updateFromJSON(t);
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), textStyle: this.getTextStyle() };
  }
  insertNewAfter(t, n) {
    const r = st();
    r.setTextFormat(t.format), r.setTextStyle(t.style);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), r.setStyle(this.getStyle()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = this.getChildren();
    if (t.length === 0 || ye(t[0]) && t[0].getTextContent().trim() === "") {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
};
function IO(e) {
  const t = st();
  return e.style && (t.setFormat(e.style.textAlign), Fv(e, t)), { node: t };
}
function st() {
  return Pn(new lp());
}
function Ev(e) {
  return e instanceof lp;
}
const qe = 0, xt = 1, Ld = 3, zr = 4;
function h9(e, t, n, r) {
  const i = e._keyToDOMMap;
  i.clear(), e._editorState = bv(), e._pendingEditorState = r, e._compositionKey = null, e._dirtyType = Oo, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set(), e._updates = [], e._blockCursorElement = null;
  const s = e._observer;
  s !== null && (s.disconnect(), e._observer = null), t !== null && (t.textContent = ""), n !== null && (n.textContent = "", i.set("root", n));
}
function p9(e) {
  const t = e || {}, n = CO(), r = t.theme || {}, i = e === void 0 ? n : t.parentEditor || null, s = t.disableEvents || !1, o = bv(), a = t.namespace || (i !== null ? i._config.namespace : b9()), l = t.editorState, c = [_v, Ys, mv, tu, lp, Cv, ...t.nodes || []], { onError: u, html: f } = t, d = t.editable === void 0 || t.editable;
  let h;
  if (e === void 0 && n !== null) h = n._nodes;
  else {
    h = /* @__PURE__ */ new Map();
    for (let p = 0; p < c.length; p++) {
      let y = c[p], v = null, g = null;
      if (typeof y != "function") {
        const E = y;
        y = E.replace, v = E.with, g = E.withKlass || null;
      }
      const { ownNodeConfig: x } = Rv(y), _ = y.getType(), b = y.transform(), C = /* @__PURE__ */ new Set();
      x && x.$transform && C.add(x.$transform), b !== null && C.add(b), h.set(_, { exportDOM: f && f.export ? f.export.get(y) : void 0, klass: y, replace: v, replaceWithKlass: g, sharedNodeState: vg(c[p]), transforms: C });
    }
  }
  const m = new cp(o, i, h, { disableEvents: s, namespace: a, theme: r }, u || console.error, function(p, y) {
    const v = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set(), x = (_) => {
      Object.keys(_).forEach((b) => {
        let C = v.get(b);
        C === void 0 && (C = [], v.set(b, C)), C.push(_[b]);
      });
    };
    return p.forEach((_) => {
      const b = _.klass.importDOM;
      if (b == null || g.has(b)) return;
      g.add(b);
      const C = b.call(_.klass);
      C !== null && x(C);
    }), y && x(y), v;
  }(h, f ? f.import : void 0), d, e);
  return l !== void 0 && (m._pendingEditorState = l, m._dirtyType = za), m;
}
let cp = class {
  constructor(t, n, r, i, s, o, a, l) {
    this._createEditorArgs = l, this._parentEditor = n, this._rootElement = null, this._editorState = t, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = i, this._nodes = r, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = Oo, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = b9(), this._onError = s, this._htmlConversions = o, this._editable = a, this._headless = n !== null && n._headless, this._window = null, this._blockCursorElement = null;
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(t) {
    const n = this._listeners.update;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerEditableListener(t) {
    const n = this._listeners.editable;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerDecoratorListener(t) {
    const n = this._listeners.decorator;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerTextContentListener(t) {
    const n = this._listeners.textcontent;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerRootListener(t) {
    const n = this._listeners.root;
    return t(this._rootElement, null), n.add(t), () => {
      t(null, this._rootElement), n.delete(t);
    };
  }
  registerCommand(t, n, r) {
    r === void 0 && me(35);
    const i = this._commands;
    i.has(t) || i.set(t, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    const s = i.get(t);
    s === void 0 && me(36, String(t));
    const o = s[r];
    return o.add(n), () => {
      o.delete(n), s.every((a) => a.size === 0) && i.delete(t);
    };
  }
  registerMutationListener(t, n, r) {
    const i = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(t)).klass, s = this._listeners.mutation;
    let o = s.get(n);
    o === void 0 && (o = /* @__PURE__ */ new Set(), s.set(n, o)), o.add(i);
    const a = r && r.skipInitialization;
    return a !== void 0 && a || this.initializeMutationListener(n, i), () => {
      o.delete(i), o.size === 0 && s.delete(n);
    };
  }
  getRegisteredNode(t) {
    const n = this._nodes.get(t.getType());
    return n === void 0 && me(37, t.name), n;
  }
  resolveRegisteredNodeAfterReplacements(t) {
    for (; t.replaceWithKlass; ) t = this.getRegisteredNode(t.replaceWithKlass);
    return t;
  }
  initializeMutationListener(t, n) {
    const r = this._editorState, i = Hw(r).get(n.getType());
    if (!i) return;
    const s = /* @__PURE__ */ new Map();
    for (const o of i.keys()) s.set(o, "created");
    s.size > 0 && t(s, { dirtyLeaves: /* @__PURE__ */ new Set(), prevEditorState: r, updateTags: /* @__PURE__ */ new Set(["registerMutationListener"]) });
  }
  registerNodeTransformToKlass(t, n) {
    const r = this.getRegisteredNode(t);
    return r.transforms.add(n), r;
  }
  registerNodeTransform(t, n) {
    const r = this.registerNodeTransformToKlass(t, n), i = [r], s = r.replaceWithKlass;
    if (s != null) {
      const o = this.registerNodeTransformToKlass(s, n);
      i.push(o);
    }
    return function(o, a) {
      const l = Hw(o.getEditorState()), c = [];
      for (const u of a) {
        const f = l.get(u);
        f && c.push(f);
      }
      c.length !== 0 && o.update(() => {
        for (const u of c) for (const f of u.keys()) {
          const d = wt(f);
          d && d.markDirty();
        }
      }, o._pendingEditorState === null ? { tag: Of } : void 0);
    }(this, i.map((o) => o.klass.getType())), () => {
      i.forEach((o) => o.transforms.delete(n));
    };
  }
  hasNode(t) {
    return this._nodes.has(t.getType());
  }
  hasNodes(t) {
    return t.every(this.hasNode.bind(this));
  }
  dispatchCommand(t, n) {
    return Se(this, t, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(t) {
    const n = this._rootElement;
    if (t !== n) {
      const r = La(this._config.theme, "root"), i = this._pendingEditorState || this._editorState;
      if (this._rootElement = t, h9(this, n, t, i), n !== null && (this._config.disableEvents || dO(n), r != null && n.classList.remove(...r)), t !== null) {
        const s = Ov(t), o = t.style;
        o.userSelect = "text", o.whiteSpace = "pre-wrap", o.wordBreak = "break-word", t.setAttribute("data-lexical-editor", "true"), this._window = s, this._dirtyType = za, AE(this), this._updateTags.add(Of), zi(this), this._config.disableEvents || function(a, l) {
          const c = a.ownerDocument, u = kd.get(c);
          (u === void 0 || u < 1) && c.addEventListener("selectionchange", KE), kd.set(c, (u || 0) + 1), a.__lexicalEditor = l;
          const f = JE(a);
          for (let d = 0; d < Ag.length; d++) {
            const [h, m] = Ag[d], p = typeof m == "function" ? (y) => {
              pw(y) || (hw(y), (l.isEditable() || h === "click") && m(y, l));
            } : (y) => {
              if (pw(y)) return;
              hw(y);
              const v = l.isEditable();
              switch (h) {
                case "cut":
                  return v && Se(l, dv, y);
                case "copy":
                  return Se(l, sp, y);
                case "paste":
                  return v && Se(l, Qc, y);
                case "dragstart":
                  return v && Se(l, ip, y);
                case "dragover":
                  return v && Se(l, fv, y);
                case "dragend":
                  return v && Se(l, cO, y);
                case "focus":
                  return v && Se(l, hv, y);
                case "blur":
                  return v && Se(l, pv, y);
                case "drop":
                  return v && Se(l, uv, y);
              }
            };
            a.addEventListener(h, p), f.push(() => {
              a.removeEventListener(h, p);
            });
          }
        }(t, this), r != null && t.classList.add(...r);
      } else this._window = null, this._updateTags.add(Of), zi(this);
      ac("root", this, !1, t, n);
    }
  }
  getElementByKey(t) {
    return this._keyToDOMMap.get(t) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(t, n) {
    t.isEmpty() && me(38);
    let r = t;
    r._readOnly && (r = a9(t), r._selection = t._selection ? t._selection.clone() : null), TE(this);
    const i = this._pendingEditorState, s = this._updateTags, o = n !== void 0 ? n.tag : null;
    i === null || i.isEmpty() || (o != null && s.add(o), zi(this)), this._pendingEditorState = r, this._dirtyType = za, this._dirtyElements.set("root", !1), this._compositionKey = null, o != null && s.add(o), this._updating || zi(this);
  }
  parseEditorState(t, n) {
    return function(r, i, s) {
      const o = bv(), a = rn, l = jn, c = sn, u = i._dirtyElements, f = i._dirtyLeaves, d = i._cloneNotNeeded, h = i._dirtyType;
      i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, rn = o, jn = !1, sn = i, Sv(null);
      try {
        const m = i._nodes;
        xv(r.root, m), s && s(), o._readOnly = !0;
      } catch (m) {
        m instanceof Error && i._onError(m);
      } finally {
        i._dirtyElements = u, i._dirtyLeaves = f, i._cloneNotNeeded = d, i._dirtyType = h, rn = a, jn = l, sn = c;
      }
      return o;
    }(typeof t == "string" ? JSON.parse(t) : t, this, n);
  }
  read(t) {
    return zi(this), this.getEditorState().read(t, { editor: this });
  }
  update(t, n) {
    (function(r, i, s) {
      r._updating ? r._updates.push([i, s]) : wv(r, i, s);
    })(this, t, n);
  }
  focus(t, n = {}) {
    const r = this._rootElement;
    r !== null && (r.setAttribute("autocapitalize", "off"), Zn(this, () => {
      const i = ge(), s = Xe();
      i !== null ? i.dirty || Ot(i.clone()) : s.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? s.selectStart() : s.selectEnd()), k9("focus"), FO(() => {
        r.removeAttribute("autocapitalize"), t && t();
      });
    }), this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const t = this._rootElement;
    t !== null && t.blur();
    const n = Hr(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(t) {
    this._editable !== t && (this._editable = t, ac("editable", this, !0, t));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
};
cp.version = "0.33.1+prod.esm";
let Og = null;
function Sv(e) {
  Og = e;
}
let LO = 1;
function m9(e, t) {
  const n = up(e, t);
  return n === void 0 && me(30, t), n;
}
function up(e, t) {
  return e._nodes.get(t);
}
const MO = typeof queueMicrotask == "function" ? queueMicrotask : (e) => {
  Promise.resolve().then(e);
};
function Pw(e) {
  return it(vi(e));
}
function kv(e) {
  const t = document.activeElement;
  if (!At(t)) return !1;
  const n = t.nodeName;
  return it(vi(e)) && (n === "INPUT" || n === "TEXTAREA" || t.contentEditable === "true" && fp(t) == null);
}
function iu(e, t, n) {
  const r = e.getRootElement();
  try {
    return r !== null && r.contains(t) && r.contains(n) && t !== null && !kv(t) && Av(t) === e;
  } catch {
    return !1;
  }
}
function Tv(e) {
  return e instanceof cp;
}
function Av(e) {
  let t = e;
  for (; t != null; ) {
    const n = fp(t);
    if (Tv(n)) return n;
    t = su(t);
  }
  return null;
}
function fp(e) {
  return e ? e.__lexicalEditor : null;
}
function Eo(e) {
  return op(e) || e.isToken();
}
function Ri(e) {
  return Eo(e) || e.isSegmented();
}
function as(e) {
  return hl(e) && e.nodeType === DM;
}
function OO(e) {
  return hl(e) && e.nodeType === FM;
}
function Ha(e) {
  let t = e;
  for (; t != null; ) {
    if (as(t)) return t;
    t = t.firstChild;
  }
  return null;
}
function Md(e, t, n) {
  const r = Po[t];
  if (n !== null && (e & r) == (n & r)) return e;
  let i = e ^ r;
  return t === "subscript" ? i &= -65 : t === "superscript" ? i &= -33 : t === "lowercase" ? (i &= -513, i &= -1025) : t === "uppercase" ? (i &= -257, i &= -1025) : t === "capitalize" && (i &= -257, i &= -513), i;
}
function g9(e) {
  return ye(e) || Rr(e) || it(e);
}
function v9(e, t) {
  const n = function() {
    const o = Og;
    return Og = null, o;
  }();
  if ((t = t || n && n.__key) != null) return void (e.__key = t);
  hn(), r9();
  const r = Lt(), i = Xs(), s = "" + LO++;
  i._nodeMap.set(s, e), te(e) ? r._dirtyElements.set(s, !0) : r._dirtyLeaves.add(s), r._cloneNotNeeded.add(s), r._dirtyType = bE, e.__key = s;
}
function So(e) {
  const t = e.getParent();
  if (t !== null) {
    const n = e.getWritable(), r = t.getWritable(), i = e.getPreviousSibling(), s = e.getNextSibling(), o = s !== null ? s.__key : null, a = i !== null ? i.__key : null, l = i !== null ? i.getWritable() : null, c = s !== null ? s.getWritable() : null;
    i === null && (r.__first = o), s === null && (r.__last = a), l !== null && (l.__next = o), c !== null && (c.__prev = a), n.__prev = null, n.__next = null, n.__parent = null, r.__size--;
  }
}
function Od(e) {
  r9();
  const t = e.getLatest(), n = t.__parent, r = Xs(), i = Lt(), s = r._nodeMap, o = i._dirtyElements;
  n !== null && function(l, c, u) {
    let f = l;
    for (; f !== null; ) {
      if (u.has(f)) return;
      const d = c.get(f);
      if (d === void 0) break;
      u.set(f, !1), f = d.__parent;
    }
  }(n, s, o);
  const a = t.__key;
  i._dirtyType = bE, te(e) ? o.set(a, !0) : i._dirtyLeaves.add(a);
}
function cn(e) {
  hn();
  const t = Lt(), n = t._compositionKey;
  if (e !== n) {
    if (t._compositionKey = e, n !== null) {
      const r = wt(n);
      r !== null && r.getWritable();
    }
    if (e !== null) {
      const r = wt(e);
      r !== null && r.getWritable();
    }
  }
}
function As() {
  return ru() ? null : Lt()._compositionKey;
}
function wt(e, t) {
  const n = (t || Xs())._nodeMap.get(e);
  return n === void 0 ? null : n;
}
function y9(e, t) {
  const n = dp(e, Lt());
  return n !== void 0 ? wt(n, t) : null;
}
function dp(e, t) {
  return e[`__lexicalKey_${t._key}`];
}
function vi(e, t) {
  let n = e;
  for (; n != null; ) {
    const r = y9(n, t);
    if (r !== null) return r;
    n = su(n);
  }
  return null;
}
function x9(e) {
  const t = e._decorators, n = Object.assign({}, t);
  return e._pendingDecorators = n, n;
}
function Dw(e) {
  return e.read(() => Xe().getTextContent());
}
function Xe() {
  return w9(Xs());
}
function w9(e) {
  return e._nodeMap.get("root");
}
function Ot(e) {
  hn();
  const t = Xs();
  e !== null && (e.dirty = !0, e.setCachedNodes(null)), t._selection = e;
}
function xa(e) {
  const t = Lt(), n = function(r, i) {
    let s = r;
    for (; s != null; ) {
      const o = dp(s, i);
      if (o !== void 0) return o;
      s = su(s);
    }
    return null;
  }(e, t);
  return n === null ? e === t.getRootElement() ? wt("root") : null : wt(n);
}
function Fw(e, t) {
  return t ? e.getTextContentSize() : 0;
}
function _9(e) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(e);
}
function Nv(e) {
  const t = [];
  let n = e;
  for (; n !== null; ) t.push(n), n = n._parentEditor;
  return t;
}
function b9() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 5);
}
function C9(e) {
  return as(e) ? e.nodeValue : null;
}
function Iv(e, t, n) {
  const r = Hr(_r(t));
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: s, focusOffset: o } = r;
  if (i !== null) {
    let a = C9(i);
    const l = vi(i);
    if (a !== null && ye(l)) {
      if (a === Zh && n) {
        const c = n.length;
        a = n, s = c, o = c;
      }
      a !== null && Lv(l, a, s, o, e);
    }
  }
}
function Lv(e, t, n, r, i) {
  let s = e;
  if (s.isAttached() && (i || !s.isDirty())) {
    const o = s.isComposing();
    let a = t;
    (o || i) && t[t.length - 1] === Zh && (a = t.slice(0, -1));
    const l = s.getTextContent();
    if (i || a !== l) {
      if (a === "") {
        if (cn(null), bc || Ba || yd) s.remove();
        else {
          const p = Lt();
          setTimeout(() => {
            p.update(() => {
              s.isAttached() && s.remove();
            });
          }, 20);
        }
        return;
      }
      const c = s.getParent(), u = qo(), f = s.getTextContentSize(), d = As(), h = s.getKey();
      if (s.isToken() || d !== null && h === d && !o || fe(u) && (c !== null && !c.canInsertTextBefore() && u.anchor.offset === 0 || u.anchor.key === e.__key && u.anchor.offset === 0 && !s.canInsertTextBefore() && !o || u.focus.key === e.__key && u.focus.offset === f && !s.canInsertTextAfter() && !o)) return void s.markDirty();
      const m = ge();
      if (!fe(m) || n === null || r === null) return void s.setTextContent(a);
      if (m.setTextNodeRange(s, n, s, r), s.isSegmented()) {
        const p = yt(s.getTextContent());
        s.replace(p), s = p;
      }
      s.setTextContent(a);
    }
  }
}
function qu(e, t, n) {
  const r = t[n] || !1;
  return r === "any" || r === e[n];
}
function PO(e, t) {
  return qu(e, t, "altKey") && qu(e, t, "ctrlKey") && qu(e, t, "shiftKey") && qu(e, t, "metaKey");
}
function ct(e, t, n) {
  return PO(e, n) && e.key.toLowerCase() === t.toLowerCase();
}
const Oi = { ctrlKey: !ii, metaKey: ii }, Rw = { altKey: ii, ctrlKey: !ii };
function $w(e) {
  return e.key === "Backspace";
}
function Vw(e) {
  return ct(e, "a", Oi);
}
function DO(e) {
  const t = Xe();
  if (fe(e)) {
    const n = e.anchor, r = e.focus, i = n.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    return n.set(i.getKey(), 0, "element"), r.set(i.getKey(), i.getChildrenSize(), "element"), Do(e), e;
  }
  {
    const n = t.select(0, t.getChildrenSize());
    return Ot(Do(n)), n;
  }
}
function La(e, t) {
  e.__lexicalClassNameCache === void 0 && (e.__lexicalClassNameCache = {});
  const n = e.__lexicalClassNameCache, r = n[t];
  if (r !== void 0) return r;
  const i = e[t];
  if (typeof i == "string") {
    const s = xd(i);
    return n[t] = s, s;
  }
  return i;
}
function Mv(e, t, n, r, i) {
  if (n.size === 0) return;
  const s = r.__type, o = r.__key, a = t.get(s);
  a === void 0 && me(33, s);
  const l = a.klass;
  let c = e.get(l);
  c === void 0 && (c = /* @__PURE__ */ new Map(), e.set(l, c));
  const u = c.get(o), f = u === "destroyed" && i === "created";
  (u === void 0 || f) && c.set(o, f ? "updated" : i);
}
function Bw(e, t, n) {
  const r = e.getParent();
  let i = n, s = e;
  return r !== null && (t && n === 0 ? (i = s.getIndexWithinParent(), s = r) : t || n !== s.getChildrenSize() || (i = s.getIndexWithinParent() + 1, s = r)), s.getChildAtIndex(t ? i - 1 : i);
}
function Pg(e, t) {
  const n = e.offset;
  if (e.type === "element")
    return Bw(e.getNode(), t, n);
  {
    const r = e.getNode();
    if (t && n === 0 || !t && n === r.getTextContentSize()) {
      const i = t ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? Bw(r.getParentOrThrow(), t, r.getIndexWithinParent() + (t ? 0 : 1)) : i;
    }
  }
  return null;
}
function E9(e) {
  const t = _r(e).event, n = t && t.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function Se(e, t, n) {
  return function(r, i, s) {
    const o = Nv(r);
    for (let a = 4; a >= 0; a--) for (let l = 0; l < o.length; l++) {
      const c = o[l], u = c._commands.get(i);
      if (u !== void 0) {
        const f = u[a];
        if (f !== void 0) {
          const d = Array.from(f), h = d.length;
          let m = !1;
          if (Zn(c, () => {
            for (let p = 0; p < h; p++) if (d[p](s, r)) return void (m = !0);
          }), m) return m;
        }
      }
    }
    return !1;
  }(e, t, n);
}
function hp(e) {
  return !on(e) && !e.isLastChild() && !e.isInline();
}
function Ua(e, t) {
  const n = e._keyToDOMMap.get(t);
  return n === void 0 && me(75, t), n;
}
function su(e) {
  const t = e.assignedSlot || e.parentElement;
  return Rg(t) ? t.host : t;
}
function S9(e) {
  return OO(e) ? e : At(e) ? e.ownerDocument : null;
}
function k9(e) {
  hn(), Lt()._updateTags.add(e);
}
function FO(e) {
  hn(), Lt()._deferred.push(e);
}
function Dg(e, t) {
  let n = e.getParent();
  for (; n !== null; ) {
    if (n.is(t)) return !0;
    n = n.getParent();
  }
  return !1;
}
function Ov(e) {
  const t = S9(e);
  return t ? t.defaultView : null;
}
function _r(e) {
  const t = e._window;
  return t === null && me(78), t;
}
function RO(e) {
  let t = e.getParentOrThrow();
  for (; t !== null; ) {
    if (Jt(t)) return t;
    t = t.getParentOrThrow();
  }
  return t;
}
function Jt(e) {
  return on(e) || te(e) && e.isShadowRoot();
}
function $O(e) {
  const t = e.constructor.clone(e);
  return v9(t, null), t.afterCloneFrom(e), t;
}
function Pn(e) {
  const t = Lt(), n = e.getType(), r = up(t, n);
  r === void 0 && me(200, e.constructor.name, n);
  const { replace: i, replaceWithKlass: s } = r;
  if (i !== null) {
    const o = i(e), a = o.constructor;
    return s !== null ? o instanceof s || me(201, s.name, s.getType(), a.name, a.getType(), e.constructor.name, n) : o instanceof e.constructor && a !== e.constructor || me(202, a.name, a.getType(), e.constructor.name, n), o.__key === e.__key && me(203, e.constructor.name, n, a.name, a.getType()), o;
  }
  return e;
}
function T1(e, t) {
  !on(e.getParent()) || te(t) || it(t) || me(99);
}
function VO(e) {
  const t = wt(e);
  return t === null && me(63, e), t;
}
function A1(e) {
  return (it(e) || te(e) && !e.canBeEmpty()) && !e.isInline();
}
function Fg(e, t, n) {
  n.style.removeProperty("caret-color"), t._blockCursorElement = null;
  const r = e.parentElement;
  r !== null && r.removeChild(e);
}
function Hr(e) {
  return qr ? (e || window).getSelection() : null;
}
function BO(e) {
  const t = Ov(e);
  return t ? t.getSelection() : null;
}
function T9(e) {
  return At(e) && e.tagName === "A";
}
function At(e) {
  return hl(e) && e.nodeType === PM;
}
function hl(e) {
  return typeof e == "object" && e !== null && "nodeType" in e && typeof e.nodeType == "number";
}
function Rg(e) {
  return hl(e) && e.nodeType === RM;
}
function $g(e) {
  const t = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return e.nodeName.match(t) !== null;
}
function Pd(e) {
  const t = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return e.nodeName.match(t) !== null;
}
function pr(e) {
  if (it(e) && !e.isInline()) return !0;
  if (!te(e) || Jt(e)) return !1;
  const t = e.getFirstChild(), n = t === null || Rr(t) || ye(t) || t.isInline();
  return !e.isInline() && e.canBeEmpty() !== !1 && n;
}
function N1(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
function Pv() {
  return Lt();
}
const zw = /* @__PURE__ */ new WeakMap(), zO = /* @__PURE__ */ new Map();
function Hw(e) {
  if (!e._readOnly && e.isEmpty()) return zO;
  e._readOnly || me(192);
  let t = zw.get(e);
  return t || (t = function(n) {
    const r = /* @__PURE__ */ new Map();
    for (const [i, s] of n._nodeMap) {
      const o = s.__type;
      let a = r.get(o);
      a || (a = /* @__PURE__ */ new Map(), r.set(o, a)), a.set(i, s);
    }
    return r;
  }(e), zw.set(e, t)), t;
}
function Dv(e) {
  const t = e.constructor.clone(e);
  return t.afterCloneFrom(e), t;
}
function Fv(e, t) {
  const n = parseInt(e.style.paddingInlineStart, 10) || 0, r = Math.round(n / 40);
  t.setIndent(r);
}
function HO(e) {
  return e.__lexicalUnmanaged === !0;
}
function Fl(e, t) {
  return function(n, r) {
    return Object.prototype.hasOwnProperty.call(n, r);
  }(e, t) && e[t] !== cl[t];
}
function Rv(e) {
  const t = tw in e.prototype ? e.prototype[tw]() : void 0, n = /* @__PURE__ */ function(o) {
    return o === bi || o === Wn || o === cl;
  }(e), r = !n && Fl(e, "getType") ? e.getType() : void 0;
  let i, s = r;
  if (t) if (r) i = t[r];
  else for (const [o, a] of Object.entries(t)) s = o, i = a;
  if (!n && s && (Fl(e, "getType") || (e.getType = () => s), Fl(e, "clone") || (e.clone = (o) => (Sv(o), new e())), Fl(e, "importJSON") || (e.importJSON = i && i.$importJSON || ((o) => new e().updateFromJSON(o))), !Fl(e, "importDOM") && i)) {
    const { importDOM: o } = i;
    o && (e.importDOM = () => o);
  }
  return { ownNodeConfig: i, ownNodeType: s };
}
const UO = { next: "previous", previous: "next" };
let $v = class {
  constructor(t) {
    this.origin = t;
  }
  [Symbol.iterator]() {
    return L9({ hasNext: ja, initial: this.getAdjacentCaret(), map: (t) => t, step: (t) => t.getAdjacentCaret() });
  }
  getAdjacentCaret() {
    return Kt(this.getNodeAtCaret(), this.direction);
  }
  getSiblingCaret() {
    return Kt(this.origin, this.direction);
  }
  remove() {
    const t = this.getNodeAtCaret();
    return t && t.remove(), this;
  }
  replaceOrInsert(t, n) {
    const r = this.getNodeAtCaret();
    return t.is(this.origin) || t.is(r) || (r === null ? this.insert(t) : r.replace(t, n)), this;
  }
  splice(t, n, r = "next") {
    const i = r === this.direction ? n : Array.from(n).reverse();
    let s = this;
    const o = this.getParentAtCaret(), a = /* @__PURE__ */ new Map();
    for (let l = s.getAdjacentCaret(); l !== null && a.size < t; l = l.getAdjacentCaret()) {
      const c = l.origin.getWritable();
      a.set(c.getKey(), c);
    }
    for (const l of i) {
      if (a.size > 0) {
        const c = s.getNodeAtCaret();
        if (c) {
          if (a.delete(c.getKey()), a.delete(l.getKey()), !(c.is(l) || s.origin.is(l))) {
            const u = l.getParent();
            u && u.is(o) && l.remove(), c.replace(l);
          }
        } else c === null && me(263, Array.from(a).join(" "));
      } else s.insert(l);
      s = Kt(l, this.direction);
    }
    for (const l of a.values()) l.remove();
    return this;
  }
}, Vg = class A9 extends $v {
  constructor() {
    super(...arguments);
    or(this, "type", "child");
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : br(n, this.direction);
  }
  getParentCaret(n = "root") {
    return Kt(Vv(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    const n = Go(this.direction);
    return Kt(this.getNodeAtCaret(), n) || br(this.origin, n);
  }
  getParentAtCaret() {
    return this.origin;
  }
  getChildCaret() {
    return this;
  }
  isSameNodeCaret(n) {
    return n instanceof A9 && this.direction === n.direction && this.origin.is(n.origin);
  }
  isSamePointCaret(n) {
    return this.isSameNodeCaret(n);
  }
};
const jO = { root: on, shadowRoot: Jt };
function Go(e) {
  return UO[e];
}
function Vv(e, t = "root") {
  return jO[t](e) ? null : e;
}
let Dd = class Bg extends $v {
  constructor() {
    super(...arguments);
    or(this, "type", "sibling");
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : Kt(n, this.direction);
  }
  getSiblingCaret() {
    return this;
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return te(this.origin) ? br(this.origin, this.direction) : null;
  }
  getParentCaret(n = "root") {
    return Kt(Vv(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    const n = Go(this.direction);
    return Kt(this.getNodeAtCaret(), n) || br(this.origin.getParentOrThrow(), n);
  }
  isSamePointCaret(n) {
    return n instanceof Bg && this.direction === n.direction && this.origin.is(n.origin);
  }
  isSameNodeCaret(n) {
    return (n instanceof Bg || n instanceof Fd) && this.direction === n.direction && this.origin.is(n.origin);
  }
}, Fd = class zg extends $v {
  constructor(n, r) {
    super(n);
    or(this, "type", "text");
    this.offset = r;
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : Ro(n, this.direction, this.offset);
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return null;
  }
  getParentCaret(n = "root") {
    return Kt(Vv(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    return Ro(this.origin, Go(this.direction), this.offset);
  }
  isSamePointCaret(n) {
    return n instanceof zg && this.direction === n.direction && this.origin.is(n.origin) && this.offset === n.offset;
  }
  isSameNodeCaret(n) {
    return (n instanceof Dd || n instanceof zg) && this.direction === n.direction && this.origin.is(n.origin);
  }
  getSiblingCaret() {
    return Kt(this.origin, this.direction);
  }
};
function di(e) {
  return e instanceof Fd;
}
function ja(e) {
  return e instanceof Dd;
}
function wr(e) {
  return e instanceof Vg;
}
const WO = { next: class extends Fd {
  constructor() {
    super(...arguments);
    or(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getNextSibling();
  }
  insert(t) {
    return this.origin.insertAfter(t), this;
  }
}, previous: class extends Fd {
  constructor() {
    super(...arguments);
    or(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getPreviousSibling();
  }
  insert(t) {
    return this.origin.insertBefore(t), this;
  }
} }, JO = { next: class extends Dd {
  constructor() {
    super(...arguments);
    or(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getNextSibling();
  }
  insert(t) {
    return this.origin.insertAfter(t), this;
  }
}, previous: class extends Dd {
  constructor() {
    super(...arguments);
    or(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getPreviousSibling();
  }
  insert(t) {
    return this.origin.insertBefore(t), this;
  }
} }, KO = { next: class extends Vg {
  constructor() {
    super(...arguments);
    or(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getFirstChild();
  }
  insert(t) {
    return this.origin.splice(0, 0, [t]), this;
  }
}, previous: class extends Vg {
  constructor() {
    super(...arguments);
    or(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getLastChild();
  }
  insert(t) {
    return this.origin.splice(this.origin.getChildrenSize(), 0, [t]), this;
  }
} };
function Kt(e, t) {
  return e ? new JO[t](e) : null;
}
function Ro(e, t, n) {
  return e ? new WO[t](e, Wa(e, n)) : null;
}
function Wa(e, t) {
  const n = e.getTextContentSize();
  let r = t === "next" ? n : t === "previous" ? 0 : t;
  return (r < 0 || r > n) && (function(i, ...s) {
    const o = new URL("https://lexical.dev/docs/error"), a = new URLSearchParams();
    a.append("code", i);
    for (const l of s) a.append("v", l);
    o.search = a.toString(), console.warn(`Minified Lexical warning #${i}; visit ${o.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(284, String(t), String(n), e.getKey()), r = r < 0 ? 0 : n), r;
}
function Uw(e, t) {
  return new YO(e, t);
}
function br(e, t) {
  return te(e) ? new KO[t](e) : null;
}
function qO(e) {
  return e && e.getChildCaret() || e;
}
function pp(e) {
  return e && qO(e.getAdjacentCaret());
}
let GO = class N9 {
  constructor(t, n, r) {
    or(this, "type", "node-caret-range");
    this.anchor = t, this.focus = n, this.direction = r;
  }
  getLatest() {
    const t = this.anchor.getLatest(), n = this.focus.getLatest();
    return t === this.anchor && n === this.focus ? this : new N9(t, n, this.direction);
  }
  isCollapsed() {
    return this.anchor.isSamePointCaret(this.focus);
  }
  getTextSlices() {
    const t = (i) => {
      const s = this[i].getLatest();
      return di(s) ? function(o, a) {
        const { direction: l, origin: c } = o, u = Wa(c, a === "focus" ? Go(l) : l);
        return Uw(o, u - o.offset);
      }(s, i) : null;
    }, n = t("anchor"), r = t("focus");
    if (n && r) {
      const { caret: i } = n, { caret: s } = r;
      if (i.isSameNodeCaret(s)) return [Uw(i, s.offset - i.offset), null];
    }
    return [n, r];
  }
  iterNodeCarets(t = "root") {
    const n = di(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest(), r = this.focus.getLatest(), i = di(r), s = (o) => o.isSameNodeCaret(r) ? null : pp(o) || o.getParentCaret(t);
    return L9({ hasNext: (o) => o !== null && !(i && r.isSameNodeCaret(o)), initial: n.isSameNodeCaret(r) ? null : s(n), map: (o) => o, step: s });
  }
  [Symbol.iterator]() {
    return this.iterNodeCarets("root");
  }
};
class YO {
  constructor(t, n) {
    or(this, "type", "slice");
    this.caret = t, this.distance = n;
  }
  getSliceIndices() {
    const { distance: t, caret: { offset: n } } = this, r = n + t;
    return r < n ? [r, n] : [n, r];
  }
  getTextContent() {
    const [t, n] = this.getSliceIndices();
    return this.caret.origin.getTextContent().slice(t, n);
  }
  getTextContentSize() {
    return Math.abs(this.distance);
  }
  removeTextSlice() {
    const { caret: { origin: t, direction: n } } = this, [r, i] = this.getSliceIndices(), s = t.getTextContent();
    return Ro(t.setTextContent(s.slice(0, r) + s.slice(i)), n, r);
  }
}
function Bv(e) {
  return Hs(e, Kt(Xe(), e.direction));
}
function I9(e) {
  return Hs(e, e);
}
function Hs(e, t) {
  return e.direction !== t.direction && me(265), new GO(e, t, e.direction);
}
function L9(e) {
  const { initial: t, hasNext: n, step: r, map: i } = e;
  let s = t;
  return { [Symbol.iterator]() {
    return this;
  }, next() {
    if (!n(s)) return { done: !0, value: void 0 };
    const o = { done: !1, value: i(s) };
    return s = r(s), o;
  } };
}
function M9(e, t) {
  const n = Pf(e.origin, t.origin);
  switch (n === null && me(275, e.origin.getKey(), t.origin.getKey()), n.type) {
    case "same": {
      const r = e.type === "text", i = t.type === "text";
      return r && i ? function(s, o) {
        return Math.sign(s - o);
      }(e.offset, t.offset) : e.type === t.type ? 0 : r ? -1 : i ? 1 : e.type === "child" ? -1 : 1;
    }
    case "ancestor":
      return e.type === "child" ? -1 : 1;
    case "descendant":
      return t.type === "child" ? 1 : -1;
    case "branch":
      return O9(n);
  }
}
function O9(e) {
  const { a: t, b: n } = e, r = t.__key, i = n.__key;
  let s = t, o = n;
  for (; s && o; s = s.getNextSibling(), o = o.getNextSibling()) {
    if (s.__key === i) return -1;
    if (o.__key === r) return 1;
  }
  return s === null ? 1 : -1;
}
function Gu(e, t) {
  return t.is(e);
}
function jw(e) {
  return te(e) ? [e.getLatest(), null] : [e.getParent(), e.getLatest()];
}
function Pf(e, t) {
  if (e.is(t)) return { commonAncestor: e, type: "same" };
  const n = /* @__PURE__ */ new Map();
  for (let [r, i] = jw(e); r; i = r, r = r.getParent()) n.set(r, i);
  for (let [r, i] = jw(t); r; i = r, r = r.getParent()) {
    const s = n.get(r);
    if (s !== void 0) return s === null ? (Gu(e, r) || me(276), { commonAncestor: r, type: "ancestor" }) : i === null ? (Gu(t, r) || me(277), { commonAncestor: r, type: "descendant" }) : ((te(s) || Gu(e, s)) && (te(i) || Gu(t, i)) && r.is(s.getParent()) && r.is(i.getParent()) || me(278), { a: s, b: i, commonAncestor: r, type: "branch" });
  }
  return null;
}
function yi(e, t) {
  const { type: n, key: r, offset: i } = e, s = VO(e.key);
  return n === "text" ? (ye(s) || me(266, s.getType(), r), Ro(s, t, i)) : (te(s) || me(267, s.getType(), r), ZO(s, e.offset, t));
}
function $o(e, t) {
  const { origin: n, direction: r } = t, i = r === "next";
  di(t) ? e.set(n.getKey(), t.offset, "text") : ja(t) ? ye(n) ? e.set(n.getKey(), Wa(n, r), "text") : e.set(n.getParentOrThrow().getKey(), n.getIndexWithinParent() + (i ? 1 : 0), "element") : (wr(t) && te(n) || me(268), e.set(n.getKey(), i ? 0 : n.getChildrenSize(), "element"));
}
function P9(e) {
  const t = ge(), n = fe(t) ? t : fl();
  return Df(n, e), Ot(n), n;
}
function Df(e, t) {
  $o(e.anchor, t.anchor), $o(e.focus, t.focus);
}
function Ww(e) {
  const { anchor: t, focus: n } = e, r = yi(t, "next"), i = yi(n, "next"), s = M9(r, i) <= 0 ? "next" : "previous";
  return Hs(Zi(r, s), Zi(i, s));
}
function ou(e) {
  const { direction: t, origin: n } = e, r = Kt(n, Go(t)).getNodeAtCaret();
  return r ? Kt(r, t) : br(n.getParentOrThrow(), t);
}
function Jw(e, t = "root") {
  const n = [e];
  for (let r = wr(e) ? e.getParentCaret(t) : e.getSiblingCaret(); r !== null; r = r.getParentCaret(t)) n.push(ou(r));
  return n;
}
function I1(e) {
  return !!e && e.origin.isAttached();
}
function XO(e, t = "removeEmptySlices") {
  if (e.isCollapsed()) return e;
  const n = "root", r = "next";
  let i = t;
  const s = F9(e, r), o = Jw(s.anchor, n), a = Jw(s.focus.getFlipped(), n), l = /* @__PURE__ */ new Set(), c = [];
  for (const m of s.iterNodeCarets(n)) if (wr(m)) l.add(m.origin.getKey());
  else if (ja(m)) {
    const { origin: p } = m;
    te(p) && !l.has(p.getKey()) || c.push(p);
  }
  for (const m of c) m.remove();
  for (const m of s.getTextSlices()) {
    if (!m) continue;
    const { origin: p } = m.caret, y = p.getTextContentSize(), v = ou(Kt(p, r)), g = p.getMode();
    if (Math.abs(m.distance) === y && i === "removeEmptySlices" || g === "token" && m.distance !== 0) v.remove();
    else if (m.distance !== 0) {
      i = "removeEmptySlices";
      let x = m.removeTextSlice();
      const _ = m.caret.origin;
      if (g === "segmented") {
        const b = x.origin, C = yt(b.getTextContent()).setStyle(b.getStyle()).setFormat(b.getFormat());
        v.replaceOrInsert(C), x = Ro(C, r, x.offset);
      }
      _.is(o[0].origin) && (o[0] = x), _.is(a[0].origin) && (a[0] = x.getFlipped());
    }
  }
  let u, f;
  for (const m of o) if (I1(m)) {
    u = tr(m);
    break;
  }
  for (const m of a) if (I1(m)) {
    f = tr(m);
    break;
  }
  const d = function(m, p, y) {
    if (!m || !p) return null;
    const v = m.getParentAtCaret(), g = p.getParentAtCaret();
    if (!v || !g) return null;
    const x = v.getParents().reverse();
    x.push(v);
    const _ = g.getParents().reverse();
    _.push(g);
    const b = Math.min(x.length, _.length);
    let C;
    for (C = 0; C < b && x[C] === _[C]; C++) ;
    const E = (M, O) => {
      let R;
      for (let I = C; I < M.length; I++) {
        const H = M[I];
        if (Jt(H)) return;
        !R && O(H) && (R = H);
      }
      return R;
    }, S = E(x, pr), k = S && E(_, (M) => y.has(M.getKey()) && pr(M));
    return S && k ? [S, k] : null;
  }(u, f, l);
  if (d) {
    const [m, p] = d;
    br(m, "previous").splice(0, p.getChildren()), p.remove();
  }
  const h = [u, f, ...o, ...a].find(I1);
  if (h)
    return I9(Zi(tr(h), e.direction));
  me(269, JSON.stringify(o.map((m) => m.origin.__key)));
}
function tr(e) {
  const t = function(i) {
    let s = i;
    for (; wr(s); ) {
      const o = pp(s);
      if (!wr(o)) break;
      s = o;
    }
    return s;
  }(e.getLatest()), { direction: n } = t;
  if (ye(t.origin)) return di(t) ? t : Ro(t.origin, n, n);
  const r = t.getAdjacentCaret();
  return ja(r) && ye(r.origin) ? Ro(r.origin, n, Go(n)) : t;
}
function D9(e) {
  return di(e) && e.offset !== Wa(e.origin, e.direction);
}
function Zi(e, t) {
  return e.direction === t ? e : e.getFlipped();
}
function F9(e, t) {
  return e.direction === t ? e : Hs(Zi(e.focus, t), Zi(e.anchor, t));
}
function ZO(e, t, n) {
  let r = br(e, "next");
  for (let i = 0; i < t; i++) {
    const s = r.getAdjacentCaret();
    if (s === null) break;
    r = s;
  }
  return Zi(r, n);
}
function QO(e) {
  const { origin: t, offset: n, direction: r } = e;
  if (n === Wa(t, r)) return e.getSiblingCaret();
  if (n === Wa(t, Go(r))) return ou(e.getSiblingCaret());
  const [i] = t.splitText(n);
  return ye(i) || me(281), Zi(Kt(i, "next"), r);
}
function eP(e, t) {
  return !0;
}
function tP(e, { $copyElementNode: t = $O, $splitTextPointCaretNext: n = QO, rootMode: r = "shadowRoot", $shouldSplit: i = eP } = {}) {
  if (di(e)) return n(e);
  const s = e.getParentCaret(r);
  if (s) {
    const { origin: o } = s;
    if (wr(e) && (!o.canBeEmpty() || !i(o, "first"))) return ou(s);
    const a = function(l) {
      const c = [];
      for (let u = l.getAdjacentCaret(); u; u = u.getAdjacentCaret()) c.push(u.origin);
      return c;
    }(e);
    (a.length > 0 || o.canBeEmpty() && i(o, "last")) && s.insert(t(o).splice(0, 0, a));
  }
  return s;
}
function nP(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const Hg = /* @__PURE__ */ new Map();
function R9(e) {
  const t = {};
  if (!e) return t;
  const n = e.split(";");
  for (const r of n) if (r !== "") {
    const [i, s] = r.split(/:([^]+)/);
    i && s && (t[i.trim()] = s.trim());
  }
  return t;
}
function Kw(e) {
  let t = Hg.get(e);
  return t === void 0 && (t = R9(e), Hg.set(e, t)), t;
}
function $9(e, t) {
  const n = e.getStartEndPoints();
  if (t.isSelected(e) && !Ri(t) && n !== null) {
    const [r, i] = n, s = e.isBackward(), o = r.getNode(), a = i.getNode(), l = t.is(o), c = t.is(a);
    if (l || c) {
      const [u, f] = Mg(e), d = o.is(a), h = t.is(s ? a : o), m = t.is(s ? o : a);
      let p, y = 0;
      d ? (y = u > f ? f : u, p = u > f ? u : f) : h ? (y = s ? f : u, p = void 0) : m && (y = 0, p = s ? u : f), t.__text = t.__text.slice(y, p);
    }
  }
  return t;
}
function qw(e) {
  if (e.type === "text") return e.offset === e.getNode().getTextContentSize();
  const t = e.getNode();
  return te(t) || nP(177), e.offset === t.getChildrenSize();
}
function rP(e) {
  const t = e.getStyle(), n = R9(t);
  Hg.set(t, n);
}
function iP(e, t) {
  const n = e.getFormatType(), r = e.getIndent();
  n !== t.getFormatType() && t.setFormat(n), r !== t.getIndent() && t.setIndent(r);
}
function sP(e, t, n = iP) {
  if (e === null) return;
  const r = e.getStartEndPoints(), i = /* @__PURE__ */ new Map();
  let s = null;
  if (r) {
    const [o, a] = r;
    s = fl(), s.anchor.set(o.key, o.offset, o.type), s.focus.set(a.key, a.offset, a.type);
    const l = L1(o.getNode(), pr), c = L1(a.getNode(), pr);
    te(l) && i.set(l.getKey(), l), te(c) && i.set(c.getKey(), c);
  }
  for (const o of e.getNodes()) if (te(o) && pr(o)) i.set(o.getKey(), o);
  else if (r === null) {
    const a = L1(o, pr);
    te(a) && i.set(a.getKey(), a);
  }
  for (const [o, a] of i) {
    const l = t();
    n(a, l), a.replace(l, !0), s && (o === s.anchor.key && s.anchor.set(l.getKey(), s.anchor.offset, s.anchor.type), o === s.focus.key && s.focus.set(l.getKey(), s.focus.offset, s.focus.type));
  }
  s && e.is(ge()) && Ot(s);
}
function V9(e) {
  const t = e.anchor.getNode(), n = on(t) ? t : t.getParentOrThrow(), r = Pv().getElementByKey(n.getKey());
  if (r === null) return !1;
  const i = r.ownerDocument.defaultView;
  return i === null ? !1 : i.getComputedStyle(r).writingMode === "vertical-rl";
}
function Gw(e, t) {
  const n = V9(e) ? !t : t, r = yi(e.focus, n ? "previous" : "next");
  if (D9(r)) return !1;
  for (const i of Bv(r)) {
    if (wr(i)) return !i.origin.isInline();
    if (!te(i.origin)) {
      if (it(i.origin)) return !0;
      break;
    }
  }
  return !1;
}
function oP(e, t, n, r) {
  e.modify(t ? "extend" : "move", n, r);
}
function aP(e) {
  const t = e.anchor.getNode();
  return (on(t) ? t : t.getParentOrThrow()).getDirection() === "rtl";
}
function Yw(e, t, n) {
  const r = aP(e);
  let i;
  i = V9(e) || r ? !n : n, oP(e, t, i, "character");
}
function L1(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
function B9(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const mp = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, lP = mp && "documentMode" in document ? document.documentMode : null, cP = mp && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!mp || !("InputEvent" in window) || lP) && "getTargetRanges" in new window.InputEvent("input");
function z9(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
function Dn(...e) {
  return () => {
    for (let t = e.length - 1; t >= 0; t--) e[t]();
    e.length = 0;
  };
}
const uP = mp, fP = cP;
function Ur(e, ...t) {
  const n = z9(...t);
  n.length > 0 && e.classList.add(...n);
}
function gp(e, ...t) {
  const n = z9(...t);
  n.length > 0 && e.classList.remove(...n);
}
function dP(e) {
  return e ? e.getAdjacentCaret() : null;
}
function H9(e, t) {
  let n = e;
  for (; n != null; ) {
    if (n instanceof t) return n;
    n = n.getParent();
  }
  return null;
}
function Ug(e) {
  const t = $r(e, (n) => te(n) && !n.isInline());
  return te(t) || B9(4, e.__key), t;
}
const $r = (e, t) => {
  let n = e;
  for (; n !== Xe() && n != null; ) {
    if (t(n)) return n;
    n = n.getParent();
  }
  return null;
};
function U9(e) {
  const t = ge() || qo();
  let n;
  if (fe(t)) n = yi(t.focus, "next");
  else {
    if (t != null) {
      const o = t.getNodes(), a = o[o.length - 1];
      a && (n = Kt(a, "next"));
    }
    n = n || br(Xe(), "previous").getFlipped().insert(st());
  }
  const r = hP(e, n), i = pp(r), s = wr(i) ? tr(i) : r;
  return P9(I9(s)), e.getLatest();
}
function hP(e, t, n) {
  let r = Zi(t, "next");
  for (let i = r; i; i = tP(i, n)) r = i;
  return di(r) && B9(283), r.insert(e.isInline() ? st().append(e) : e), Zi(Kt(e.getLatest(), "next"), t.direction);
}
function zv(e, t) {
  const n = t();
  return e.replace(n), n.append(e), n;
}
function Ns(e, t) {
  return e !== null && Object.getPrototypeOf(e).constructor.name === t.name;
}
function pP(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = t(e[r]);
    i !== null && n.push(i);
  }
  return n;
}
let M1 = !(fP || !uP) && void 0;
function mP(e) {
  let t = 1;
  if (function() {
    if (M1 === void 0) {
      const n = document.createElement("div");
      n.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;", document.body.appendChild(n);
      const r = n.getBoundingClientRect();
      n.style.setProperty("zoom", "2"), M1 = n.getBoundingClientRect().width === r.width, document.body.removeChild(n);
    }
    return M1;
  }()) for (; e; ) t *= Number(window.getComputedStyle(e).getPropertyValue("zoom")), e = e.parentElement;
  return t;
}
const Yu = 0, jg = 1, Wg = 2, Mr = 0, gP = 1, Xw = 2, vP = 3, yP = 4;
function xP(e, t, n, r, i) {
  if (e === null || n.size === 0 && r.size === 0 && !i) return Mr;
  const s = t._selection, o = e._selection;
  if (i) return gP;
  if (!(fe(s) && fe(o) && o.isCollapsed() && s.isCollapsed())) return Mr;
  const a = function(v, g, x) {
    const _ = v._nodeMap, b = [];
    for (const C of g) {
      const E = _.get(C);
      E !== void 0 && b.push(E);
    }
    for (const [C, E] of x) {
      if (!E) continue;
      const S = _.get(C);
      S === void 0 || on(S) || b.push(S);
    }
    return b;
  }(t, n, r);
  if (a.length === 0) return Mr;
  if (a.length > 1) {
    const v = t._nodeMap, g = v.get(s.anchor.key), x = v.get(o.anchor.key);
    return g && x && !e._nodeMap.has(g.__key) && ye(g) && g.__text.length === 1 && s.anchor.offset === 1 ? Xw : Mr;
  }
  const l = a[0], c = e._nodeMap.get(l.__key);
  if (!ye(c) || !ye(l) || c.__mode !== l.__mode) return Mr;
  const u = c.__text, f = l.__text;
  if (u === f) return Mr;
  const d = s.anchor, h = o.anchor;
  if (d.key !== h.key || d.type !== "text") return Mr;
  const m = d.offset, p = h.offset, y = f.length - u.length;
  return y === 1 && p === m - 1 ? Xw : y === -1 && p === m + 1 ? vP : y === -1 && p === m ? yP : Mr;
}
function wP(e, t) {
  let n = Date.now(), r = Mr;
  return (i, s, o, a, l, c) => {
    const u = Date.now();
    if (c.has(Id)) return r = Mr, n = u, Wg;
    const f = xP(i, s, a, l, e.isComposing()), d = (() => {
      const h = o === null || o.editor === e, m = c.has(kO);
      if (!m && h && c.has(Of)) return Yu;
      if (i === null) return jg;
      const p = s._selection;
      return a.size > 0 || l.size > 0 ? m === !1 && f !== Mr && f === r && u < n + t && h || a.size === 1 && function(y, v, g) {
        const x = v._nodeMap.get(y), _ = g._nodeMap.get(y), b = v._selection, C = g._selection;
        return !(fe(b) && fe(C) && b.anchor.type === "element" && b.focus.type === "element" && C.anchor.type === "text" && C.focus.type === "text" || !ye(x) || !ye(_) || x.__parent !== _.__parent) && JSON.stringify(v.read(() => x.exportJSON())) === JSON.stringify(g.read(() => _.exportJSON()));
      }(Array.from(a)[0], i, s) ? Yu : jg : p !== null ? Yu : Wg;
    })();
    return n = u, r = f, d;
  };
}
function Zw(e) {
  e.undoStack = [], e.redoStack = [], e.current = null;
}
function _P(e, t, n) {
  const r = wP(e, n);
  return Dn(e.registerCommand(tp, () => (function(s, o) {
    const a = o.redoStack, l = o.undoStack;
    if (l.length !== 0) {
      const c = o.current, u = l.pop();
      c !== null && (a.push(c), s.dispatchCommand(ql, !0)), l.length === 0 && s.dispatchCommand(Gl, !1), o.current = u || null, u && u.editor.setEditorState(u.editorState, { tag: Id });
    }
  }(e, t), !0), qe), e.registerCommand(np, () => (function(s, o) {
    const a = o.redoStack, l = o.undoStack;
    if (a.length !== 0) {
      const c = o.current;
      c !== null && (l.push(c), s.dispatchCommand(Gl, !0));
      const u = a.pop();
      a.length === 0 && s.dispatchCommand(ql, !1), o.current = u || null, u && u.editor.setEditorState(u.editorState, { tag: Id });
    }
  }(e, t), !0), qe), e.registerCommand(uO, () => (Zw(t), !1), qe), e.registerCommand(fO, () => (Zw(t), e.dispatchCommand(ql, !1), e.dispatchCommand(Gl, !1), !0), qe), e.registerUpdateListener(({ editorState: s, prevEditorState: o, dirtyLeaves: a, dirtyElements: l, tags: c }) => {
    const u = t.current, f = t.redoStack, d = t.undoStack, h = u === null ? null : u.editorState;
    if (u !== null && s === h) return;
    const m = r(o, s, u, a, l, c);
    if (m === jg) f.length !== 0 && (t.redoStack = [], e.dispatchCommand(ql, !1)), u !== null && (d.push({ ...u }), e.dispatchCommand(Gl, !0));
    else if (m === Wg) return;
    t.current = { editor: e, editorState: s };
  }));
}
function j9() {
  return { current: null, redoStack: [], undoStack: [] };
}
function bP({ delay: e, externalHistoryState: t }) {
  const [n] = vn();
  return function(r, i, s = 1e3) {
    const o = Jo(() => i || j9(), [i]);
    Le(() => _P(r, o, s), [s, r, o]);
  }(n, t, e), null;
}
function CP(e, t) {
  const n = t.body ? t.body.childNodes : [];
  let r = [];
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    if (!J9.has(o.nodeName)) {
      const a = K9(o, e, i, !1);
      a !== null && (r = r.concat(a));
    }
  }
  return function(s) {
    for (const o of s) o.getNextSibling() instanceof Cv && o.insertAfter(Br());
    for (const o of s) {
      const a = o.getChildren();
      for (const l of a) o.insertBefore(l);
      o.remove();
    }
  }(i), r;
}
function EP(e, t) {
  if (typeof document > "u" || typeof window > "u" && global.window === void 0) throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const n = document.createElement("div"), r = Xe().getChildren();
  for (let i = 0; i < r.length; i++)
    W9(e, r[i], n, t);
  return n.innerHTML;
}
function W9(e, t, n, r = null) {
  let i = r === null || t.isSelected(r);
  const s = te(t) && t.excludeFromCopy("html");
  let o = t;
  if (r !== null) {
    let h = Dv(t);
    h = ye(h) && r !== null ? $9(r, h) : h, o = h;
  }
  const a = te(o) ? o.getChildren() : [], l = up(e, o.getType());
  let c;
  c = l && l.exportDOM !== void 0 ? l.exportDOM(e, o) : o.exportDOM(e);
  const { element: u, after: f } = c;
  if (!u) return !1;
  const d = document.createDocumentFragment();
  for (let h = 0; h < a.length; h++) {
    const m = a[h], p = W9(e, m, d, r);
    !i && te(t) && p && t.extractWithChild(m, r, "html") && (i = !0);
  }
  if (i && !s) {
    if ((At(u) || Rg(u)) && u.append(d), n.append(u), f) {
      const h = f.call(o, u);
      h && (Rg(u) ? u.replaceChildren(h) : u.replaceWith(h));
    }
  } else n.append(d);
  return i;
}
const J9 = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function K9(e, t, n, r, i = /* @__PURE__ */ new Map(), s) {
  let o = [];
  if (J9.has(e.nodeName)) return o;
  let a = null;
  const l = function(m, p) {
    const { nodeName: y } = m, v = p._htmlConversions.get(y.toLowerCase());
    let g = null;
    if (v !== void 0) for (const x of v) {
      const _ = x(m);
      _ !== null && (g === null || (g.priority || 0) <= (_.priority || 0)) && (g = _);
    }
    return g !== null ? g.conversion : null;
  }(e, t), c = l ? l(e) : null;
  let u = null;
  if (c !== null) {
    u = c.after;
    const m = c.node;
    if (a = Array.isArray(m) ? m[m.length - 1] : m, a !== null) {
      for (const [, p] of i) if (a = p(a, s), !a) break;
      a && o.push(...Array.isArray(m) ? m : [a]);
    }
    c.forChild != null && i.set(e.nodeName, c.forChild);
  }
  const f = e.childNodes;
  let d = [];
  const h = (a == null || !Jt(a)) && (a != null && Td(a) || r);
  for (let m = 0; m < f.length; m++) d.push(...K9(f[m], t, n, h, new Map(i), a));
  return u != null && (d = u(d)), Pd(e) && (d = SP(e, d, h ? () => {
    const m = new Cv();
    return n.push(m), m;
  } : st)), a == null ? d.length > 0 ? o = o.concat(d) : Pd(e) && function(m) {
    return m.nextSibling == null || m.previousSibling == null ? !1 : $g(m.nextSibling) && $g(m.previousSibling);
  }(e) && (o = o.concat(Br())) : te(a) && a.append(...d), o;
}
function SP(e, t, n) {
  const r = e.style.textAlign, i = [];
  let s = [];
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (Td(a)) r && !a.getFormat() && a.setFormat(r), i.push(a);
    else if (s.push(a), o === t.length - 1 || o < t.length - 1 && Td(t[o + 1])) {
      const l = n();
      l.setFormat(r), l.append(...s), i.push(l), s = [];
    }
  }
  return i;
}
function Rd(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function kP(e, t = ge()) {
  return t == null && Rd(166), fe(t) && t.isCollapsed() || t.getNodes().length === 0 ? "" : EP(e, t);
}
function TP(e, t = ge()) {
  return t == null && Rd(166), fe(t) && t.isCollapsed() || t.getNodes().length === 0 ? null : JSON.stringify(AP(e, t));
}
function Qw(e, t, n) {
  const r = e.getData("application/x-lexical-editor");
  if (r) try {
    const a = JSON.parse(r);
    if (a.namespace === n._config.namespace && Array.isArray(a.nodes))
      return e_(n, NP(a.nodes), t);
  } catch {
  }
  const i = e.getData("text/html"), s = e.getData("text/plain");
  if (i && s !== i) try {
    const a = new DOMParser().parseFromString(function(l) {
      return window.trustedTypes && window.trustedTypes.createPolicy ? window.trustedTypes.createPolicy("lexical", { createHTML: (c) => c }).createHTML(l) : l;
    }(i), "text/html");
    return e_(n, CP(n, a), t);
  } catch {
  }
  const o = s || e.getData("text/uri-list");
  if (o != null) if (fe(t)) {
    const a = o.split(/(\r?\n|\t)/);
    a[a.length - 1] === "" && a.pop();
    for (let l = 0; l < a.length; l++) {
      const c = ge();
      if (fe(c)) {
        const u = a[l];
        u === `
` || u === `\r
` ? c.insertParagraph() : u === "	" ? c.insertNodes([ul()]) : c.insertText(u);
      }
    }
  } else t.insertRawText(o);
}
function e_(e, t, n) {
  e.dispatchCommand(sO, { nodes: t, selection: n }) || (n.insertNodes(t), function(r) {
    if (fe(r) && r.isCollapsed()) {
      const i = r.anchor;
      let s = null;
      const o = yi(i, "previous");
      if (o) if (di(o)) s = o.origin;
      else {
        const a = Hs(o, br(Xe(), "next").getFlipped());
        for (const l of a) {
          if (ye(l.origin)) {
            s = l.origin;
            break;
          }
          if (te(l.origin) && !l.origin.isInline()) break;
        }
      }
      if (s && ye(s)) {
        const a = s.getFormat(), l = s.getStyle();
        r.format === a && r.style === l || (r.format = a, r.style = l, r.dirty = !0);
      }
    }
  }(n));
}
function q9(e, t, n, r = []) {
  let i = t === null || n.isSelected(t);
  const s = te(n) && n.excludeFromCopy("html");
  let o = n;
  if (t !== null) {
    let c = Dv(n);
    c = ye(c) && t !== null ? $9(t, c) : c, o = c;
  }
  const a = te(o) ? o.getChildren() : [], l = function(c) {
    const u = c.exportJSON(), f = c.constructor;
    if (u.type !== f.getType() && Rd(58, f.name), te(c)) {
      const d = u.children;
      Array.isArray(d) || Rd(59, f.name);
    }
    return u;
  }(o);
  if (ye(o)) {
    const c = o.__text;
    c.length > 0 ? l.text = c : i = !1;
  }
  for (let c = 0; c < a.length; c++) {
    const u = a[c], f = q9(e, t, u, l.children);
    !i && te(n) && f && n.extractWithChild(u, t, "clone") && (i = !0);
  }
  if (i && !s) r.push(l);
  else if (Array.isArray(l.children)) for (let c = 0; c < l.children.length; c++) {
    const u = l.children[c];
    r.push(u);
  }
  return i;
}
function AP(e, t) {
  const n = [], r = Xe().getChildren();
  for (let i = 0; i < r.length; i++)
    q9(e, t, r[i], n);
  return { namespace: e._config.namespace, nodes: n };
}
function NP(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n], i = EO(r);
    ye(i) && rP(i), t.push(i);
  }
  return t;
}
let ra = null;
async function t_(e, t, n) {
  if (ra !== null) return !1;
  if (t !== null) return new Promise((c, u) => {
    e.update(() => {
      c(n_(e, t, n));
    });
  });
  const r = e.getRootElement(), i = e._window || window, s = window.document, o = Hr(i);
  if (r === null || o === null) return !1;
  const a = s.createElement("span");
  a.style.cssText = "position: fixed; top: -1000px;", a.append(s.createTextNode("#")), r.append(a);
  const l = new Range();
  return l.setStart(a, 0), l.setEnd(a, 1), o.removeAllRanges(), o.addRange(l), new Promise((c, u) => {
    const f = e.registerCommand(sp, (d) => (Ns(d, ClipboardEvent) && (f(), ra !== null && (window.clearTimeout(ra), ra = null), c(n_(e, d, n))), !0), zr);
    ra = window.setTimeout(() => {
      f(), ra = null, c(!1);
    }, 50), s.execCommand("copy"), a.remove();
  });
}
function n_(e, t, n) {
  if (n === void 0) {
    const i = Hr(e._window);
    if (!i) return !1;
    const s = i.anchorNode, o = i.focusNode;
    if (s !== null && o !== null && !iu(e, s, o)) return !1;
    const a = ge();
    if (a === null) return !1;
    n = LP(a);
  }
  t.preventDefault();
  const r = t.clipboardData;
  return r !== null && (MP(r, n), !0);
}
const IP = [["text/html", kP], ["application/x-lexical-editor", TP]];
function LP(e = ge()) {
  const t = { "text/plain": e ? e.getTextContent() : "" };
  if (e) {
    const n = Pv();
    for (const [r, i] of IP) {
      const s = i(n, e);
      s !== null && (t[r] = s);
    }
  }
  return t;
}
function MP(e, t) {
  for (const n in t) {
    const r = t[n];
    r !== void 0 && e.setData(n, r);
  }
}
function r_(e, t) {
  if (document.caretRangeFromPoint !== void 0) {
    const n = document.caretRangeFromPoint(e, t);
    return n === null ? null : { node: n.startContainer, offset: n.startOffset };
  }
  if (document.caretPositionFromPoint !== "undefined") {
    const n = document.caretPositionFromPoint(e, t);
    return n === null ? null : { node: n.offsetNode, offset: n.offset };
  }
  return null;
}
const pl = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, OP = pl && "documentMode" in document ? document.documentMode : null, PP = !(!pl || !("InputEvent" in window) || OP) && "getTargetRanges" in new window.InputEvent("input"), DP = pl && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), i_ = pl && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, FP = pl && /^(?=.*Chrome).*/i.test(navigator.userAgent), RP = pl && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !FP, s_ = Pe("DRAG_DROP_PASTE_FILE");
class ml extends Wn {
  static getType() {
    return "quote";
  }
  static clone(t) {
    return new ml(t.__key);
  }
  createDOM(t) {
    const n = document.createElement("blockquote");
    return Ur(n, t.theme.quote), n;
  }
  updateDOM(t, n) {
    return !1;
  }
  static importDOM() {
    return { blockquote: (t) => ({ conversion: $P, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (At(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    return au().updateFromJSON(t);
  }
  insertNewAfter(t, n) {
    const r = st(), i = this.getDirection();
    return r.setDirection(i), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = st();
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  canMergeWhenEmpty() {
    return !0;
  }
}
function au() {
  return Pn(new ml());
}
function Jg(e) {
  return e instanceof ml;
}
let lu = class G9 extends Wn {
  static getType() {
    return "heading";
  }
  static clone(t) {
    return new G9(t.__tag, t.__key);
  }
  constructor(t, n) {
    super(n), this.__tag = t;
  }
  getTag() {
    return this.__tag;
  }
  setTag(t) {
    const n = this.getWritable();
    return this.__tag = t, n;
  }
  createDOM(t) {
    const n = this.__tag, r = document.createElement(n), i = t.theme.heading;
    if (i !== void 0) {
      const s = i[n];
      Ur(r, s);
    }
    return r;
  }
  updateDOM(t, n, r) {
    return t.__tag !== this.__tag;
  }
  static importDOM() {
    return { h1: (t) => ({ conversion: ia, priority: 0 }), h2: (t) => ({ conversion: ia, priority: 0 }), h3: (t) => ({ conversion: ia, priority: 0 }), h4: (t) => ({ conversion: ia, priority: 0 }), h5: (t) => ({ conversion: ia, priority: 0 }), h6: (t) => ({ conversion: ia, priority: 0 }), p: (t) => {
      const n = t.firstChild;
      return n !== null && o_(n) ? { conversion: () => ({ node: null }), priority: 3 } : null;
    }, span: (t) => o_(t) ? { conversion: (n) => ({ node: li("h1") }), priority: 3 } : null };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (At(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    return li(t.tag).updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setTag(t.tag);
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag() };
  }
  insertNewAfter(t, n = !0) {
    const r = t ? t.anchor.offset : 0, i = this.getLastDescendant(), s = !i || t && t.anchor.key === i.getKey() && r === i.getTextContentSize() || !t ? st() : li(this.getTag()), o = this.getDirection();
    if (s.setDirection(o), this.insertAfter(s, n), r === 0 && !this.isEmpty() && t) {
      const a = st();
      a.select(), this.replace(a, !0);
    }
    return s;
  }
  collapseAtStart() {
    const t = this.isEmpty() ? st() : li(this.getTag());
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  extractWithChild() {
    return !0;
  }
};
function o_(e) {
  return e.nodeName.toLowerCase() === "span" && e.style.fontSize === "26pt";
}
function ia(e) {
  const t = e.nodeName.toLowerCase();
  let n = null;
  return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6" || (n = li(t), e.style !== null && (Fv(e, n), n.setFormat(e.style.textAlign))), { node: n };
}
function $P(e) {
  const t = au();
  return e.style !== null && (t.setFormat(e.style.textAlign), Fv(e, t)), { node: t };
}
function li(e = "h1") {
  return Pn(new lu(e));
}
function vp(e) {
  return e instanceof lu;
}
function Xu(e) {
  let t = null;
  if (Ns(e, DragEvent) ? t = e.dataTransfer : Ns(e, ClipboardEvent) && (t = e.clipboardData), t === null) return [!1, [], !1];
  const n = t.types, r = n.includes("Files"), i = n.includes("text/html") || n.includes("text/plain");
  return [r, Array.from(t.files), i];
}
function a_(e) {
  const t = ge();
  if (!fe(t)) return !1;
  const n = /* @__PURE__ */ new Set(), r = t.getNodes();
  for (let i = 0; i < r.length; i++) {
    const s = r[i], o = s.getKey();
    if (n.has(o)) continue;
    const a = $r(s, (c) => te(c) && !c.isInline());
    if (a === null) continue;
    const l = a.getKey();
    a.canIndent() && !n.has(l) && (n.add(l), e(a));
  }
  return n.size > 0;
}
function l_(e) {
  const t = vi(e);
  return it(t);
}
function O1(e) {
  for (const t of ["lowercase", "uppercase", "capitalize"]) e.hasFormat(t) && e.toggleFormat(t);
}
function VP(e) {
  return Dn(e.registerCommand(ep, (t) => {
    const n = ge();
    return !!Nt(n) && (n.clear(), !0);
  }, qe), e.registerCommand(Co, (t) => {
    const n = ge();
    return fe(n) ? (n.deleteCharacter(t), !0) : !!Nt(n) && (n.deleteNodes(), !0);
  }, qe), e.registerCommand(Tc, (t) => {
    const n = ge();
    return !!fe(n) && (n.deleteWord(t), !0);
  }, qe), e.registerCommand(Ac, (t) => {
    const n = ge();
    return !!fe(n) && (n.deleteLine(t), !0);
  }, qe), e.registerCommand(Na, (t) => {
    const n = ge();
    if (typeof t == "string") n !== null && n.insertText(t);
    else {
      if (n === null) return !1;
      const r = t.dataTransfer;
      if (r != null) Qw(r, n, e);
      else if (fe(n)) {
        const i = t.data;
        return i && n.insertText(i), !0;
      }
    }
    return !0;
  }, qe), e.registerCommand(Eg, () => {
    const t = ge();
    return !!fe(t) && (t.removeText(), !0);
  }, qe), e.registerCommand(Ui, (t) => {
    const n = ge();
    return !!fe(n) && (n.formatText(t), !0);
  }, qe), e.registerCommand(lO, (t) => {
    const n = ge();
    if (!fe(n) && !Nt(n)) return !1;
    const r = n.getNodes();
    for (const i of r) {
      const s = $r(i, (o) => te(o) && !o.isInline());
      s !== null && s.setFormat(t);
    }
    return !0;
  }, qe), e.registerCommand(Aa, (t) => {
    const n = ge();
    return !!fe(n) && (n.insertLineBreak(t), !0);
  }, qe), e.registerCommand(kc, () => {
    const t = ge();
    return !!fe(t) && (t.insertParagraph(), !0);
  }, qe), e.registerCommand($E, () => (dl([ul()]), !0), qe), e.registerCommand(Sd, () => a_((t) => {
    const n = t.getIndent();
    t.setIndent(n + 1);
  }), qe), e.registerCommand(Sg, () => a_((t) => {
    const n = t.getIndent();
    n > 0 && t.setIndent(Math.max(0, n - 1));
  }), qe), e.registerCommand(sv, (t) => {
    const n = ge();
    if (Nt(n)) {
      const r = n.getNodes();
      if (r.length > 0) return r[0].selectPrevious(), !0;
    } else if (fe(n)) {
      const r = Pg(n.focus, !0);
      if (!t.shiftKey && it(r) && !r.isIsolated() && !r.isInline()) return r.selectPrevious(), t.preventDefault(), !0;
    }
    return !1;
  }, qe), e.registerCommand(ov, (t) => {
    const n = ge();
    if (Nt(n)) {
      const r = n.getNodes();
      if (r.length > 0) return r[0].selectNext(0, 0), !0;
    } else if (fe(n)) {
      if (function(i) {
        const s = i.focus;
        return s.key === "root" && s.offset === Xe().getChildrenSize();
      }(n)) return t.preventDefault(), !0;
      const r = Pg(n.focus, !1);
      if (!t.shiftKey && it(r) && !r.isIsolated() && !r.isInline()) return r.selectNext(), t.preventDefault(), !0;
    }
    return !1;
  }, qe), e.registerCommand(iv, (t) => {
    const n = ge();
    if (Nt(n)) {
      const r = n.getNodes();
      if (r.length > 0) return t.preventDefault(), r[0].selectPrevious(), !0;
    }
    if (!fe(n)) return !1;
    if (Gw(n, !0)) {
      const r = t.shiftKey;
      return t.preventDefault(), Yw(n, r, !0), !0;
    }
    return !1;
  }, qe), e.registerCommand(RE, (t) => {
    const n = ge();
    if (Nt(n)) {
      const i = n.getNodes();
      if (i.length > 0) return t.preventDefault(), i[0].selectNext(0, 0), !0;
    }
    if (!fe(n)) return !1;
    const r = t.shiftKey;
    return !!Gw(n, !1) && (t.preventDefault(), Yw(n, r, !1), !0);
  }, qe), e.registerCommand(rp, (t) => {
    if (l_(t.target)) return !1;
    const n = ge();
    if (fe(n)) {
      if (function(r) {
        if (!r.isCollapsed()) return !1;
        const { anchor: i } = r;
        if (i.offset !== 0) return !1;
        const s = i.getNode();
        if (on(s)) return !1;
        const o = Ug(s);
        return o.getIndent() > 0 && (o.is(s) || s.is(o.getFirstDescendant()));
      }(n)) return t.preventDefault(), e.dispatchCommand(Sg, void 0);
      if (i_ && navigator.language === "ko-KR") return !1;
    } else if (!Nt(n)) return !1;
    return t.preventDefault(), e.dispatchCommand(Co, !0);
  }, qe), e.registerCommand(lv, (t) => {
    if (l_(t.target)) return !1;
    const n = ge();
    return !(!fe(n) && !Nt(n)) && (t.preventDefault(), e.dispatchCommand(Co, !1));
  }, qe), e.registerCommand(Nc, (t) => {
    const n = ge();
    if (!fe(n)) return !1;
    if (O1(n), t !== null) {
      if ((i_ || DP || RP) && PP) return !1;
      if (t.preventDefault(), t.shiftKey) return e.dispatchCommand(Aa, !1);
    }
    return e.dispatchCommand(kc, void 0);
  }, qe), e.registerCommand(eu, () => {
    const t = ge();
    return !!fe(t) && (e.blur(), !0);
  }, qe), e.registerCommand(uv, (t) => {
    const [, n] = Xu(t);
    if (n.length > 0) {
      const i = r_(t.clientX, t.clientY);
      if (i !== null) {
        const { offset: s, node: o } = i, a = vi(o);
        if (a !== null) {
          const l = fl();
          if (ye(a)) l.anchor.set(a.getKey(), s, "text"), l.focus.set(a.getKey(), s, "text");
          else {
            const u = a.getParentOrThrow().getKey(), f = a.getIndexWithinParent() + 1;
            l.anchor.set(u, f, "element"), l.focus.set(u, f, "element");
          }
          const c = Do(l);
          Ot(c);
        }
        e.dispatchCommand(s_, n);
      }
      return t.preventDefault(), !0;
    }
    const r = ge();
    return !!fe(r);
  }, qe), e.registerCommand(ip, (t) => {
    const [n] = Xu(t), r = ge();
    return !(n && !fe(r));
  }, qe), e.registerCommand(fv, (t) => {
    const [n] = Xu(t), r = ge();
    if (n && !fe(r)) return !1;
    const i = r_(t.clientX, t.clientY);
    if (i !== null) {
      const s = vi(i.node);
      it(s) && t.preventDefault();
    }
    return !0;
  }, qe), e.registerCommand(kg, () => (DO(), !0), qe), e.registerCommand(sp, (t) => (t_(e, Ns(t, ClipboardEvent) ? t : null), !0), qe), e.registerCommand(dv, (t) => (async function(n, r) {
    await t_(r, Ns(n, ClipboardEvent) ? n : null), r.update(() => {
      const i = ge();
      fe(i) ? i.removeText() : Nt(i) && i.getNodes().forEach((s) => s.remove());
    });
  }(t, e), !0), qe), e.registerCommand(Qc, (t) => {
    const [, n, r] = Xu(t);
    return n.length > 0 && !r ? (e.dispatchCommand(s_, n), !0) : hl(t.target) && kv(t.target) ? !1 : ge() !== null && (function(i, s) {
      i.preventDefault(), s.update(() => {
        const o = ge(), a = Ns(i, InputEvent) || Ns(i, KeyboardEvent) ? null : i.clipboardData;
        a != null && o !== null && Qw(a, o, s);
      }, { tag: TO });
    }(t, e), !0);
  }, qe), e.registerCommand(av, (t) => {
    const n = ge();
    return fe(n) && O1(n), !1;
  }, qe), e.registerCommand(cv, (t) => {
    const n = ge();
    return fe(n) && O1(n), !1;
  }, qe));
}
function nr(e, t, n, r) {
  const i = e.length;
  let s = 0, o;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(t, n), e.splice(...o);
  else
    for (n && e.splice(t, n); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(t, 0), e.splice(...o), s += 1e4, t += 1e4;
}
function dr(e, t) {
  return e.length > 0 ? (nr(e, e.length, 0, t), e) : t;
}
const er = Zs(/[A-Za-z]/), Tn = Zs(/[\dA-Za-z]/), BP = Zs(/[#-'*+\--9=?A-Z^-~]/);
function Kg(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const qg = Zs(/\d/), zP = Zs(/[\dA-Fa-f]/), HP = Zs(/[!-/:-@[-`{-~]/);
function be(e) {
  return e !== null && e < -2;
}
function ut(e) {
  return e !== null && (e < 0 || e === 32);
}
function He(e) {
  return e === -2 || e === -1 || e === 32;
}
const UP = Zs(new RegExp("\\p{P}|\\p{S}", "u")), Pi = Zs(/\s/);
function Zs(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Ja(e) {
  if (e === null || ut(e) || Pi(e))
    return 1;
  if (UP(e))
    return 2;
}
function yp(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const s = e[i].resolveAll;
    s && !r.includes(s) && (t = s(t, n), r.push(s));
  }
  return t;
}
function jP(e) {
  let n = {}.singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, a) {
    let l = -1;
    for (; ++l < o.length; )
      if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
        let c = l;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[l][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[l][1].start)
            }, d = [["enter", u, a], ["enter", o[c][1], a], ["exit", o[c][1], a], ["enter", f, a]], h = a.parser.constructs.insideSpan.null;
            h && nr(d, d.length, 0, yp(h, o.slice(c + 1, l), a)), nr(d, d.length, 0, [["exit", f, a], ["enter", o[l][1], a], ["exit", o[l][1], a], ["exit", u, a]]), nr(o, c - 1, l - c + 3, d), l = c + d.length - 2;
            break;
          }
      }
    for (l = -1; ++l < o.length; )
      o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
    return o;
  }
  function s(o, a, l) {
    const c = this.previous, u = this.events;
    let f = 0;
    return d;
    function d(m) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(m) : (o.enter("strikethroughSequenceTemporary"), h(m));
    }
    function h(m) {
      const p = Ja(c);
      if (m === 126)
        return f > 1 ? l(m) : (o.consume(m), f++, h);
      if (f < 2 && !n) return l(m);
      const y = o.exit("strikethroughSequenceTemporary"), v = Ja(m);
      return y._open = !v || v === 2 && !!p, y._close = !p || p === 2 && !!v, a(m);
    }
  }
}
const WP = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
X9.peek = GP;
function JP() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: KP },
    exit: { strikethrough: qP }
  };
}
function Y9() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: WP
      }
    ],
    handlers: { delete: X9 }
  };
}
function KP(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function qP(e) {
  this.exit(e);
}
function X9(e, t, n, r) {
  const i = n.createTracker(r), s = n.enter("strikethrough");
  let o = i.move("~~");
  return o += n.containerPhrasing(e, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function GP() {
  return "~";
}
function $d(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const YP = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], c_ = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function Z9(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function XP(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57;
}
function ZP(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function u_(e) {
  return ZP(e) || Z9(e);
}
const f_ = document.createElement("i");
function Ic(e) {
  const t = "&" + e + ";";
  f_.innerHTML = t;
  const n = f_.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
const QP = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function xp(e, t) {
  const n = t || {}, r = typeof n.additional == "string" ? n.additional.charCodeAt(0) : n.additional, i = [];
  let s = 0, o = -1, a = "", l, c;
  n.position && ("start" in n.position || "indent" in n.position ? (c = n.position.indent, l = n.position.start) : l = n.position);
  let u = (l ? l.line : 0) || 1, f = (l ? l.column : 0) || 1, d = m(), h;
  for (s--; ++s <= e.length; )
    if (h === 10 && (f = (c ? c[o] : 0) || 1), h = e.charCodeAt(s), h === 38) {
      const v = e.charCodeAt(s + 1);
      if (v === 9 || v === 10 || v === 12 || v === 32 || v === 38 || v === 60 || Number.isNaN(v) || r && v === r) {
        a += String.fromCharCode(h), f++;
        continue;
      }
      const g = s + 1;
      let x = g, _ = g, b;
      if (v === 35) {
        _ = ++x;
        const I = e.charCodeAt(_);
        I === 88 || I === 120 ? (b = "hexadecimal", _ = ++x) : b = "decimal";
      } else
        b = "named";
      let C = "", E = "", S = "";
      const k = b === "named" ? u_ : b === "decimal" ? Z9 : XP;
      for (_--; ++_ <= e.length; ) {
        const I = e.charCodeAt(_);
        if (!k(I))
          break;
        S += String.fromCharCode(I), b === "named" && YP.includes(S) && (C = S, E = Ic(S));
      }
      let M = e.charCodeAt(_) === 59;
      if (M) {
        _++;
        const I = b === "named" ? Ic(S) : !1;
        I && (C = S, E = I);
      }
      let O = 1 + _ - g, R = "";
      if (!(!M && n.nonTerminated === !1)) if (!S)
        b !== "named" && p(4, O);
      else if (b === "named") {
        if (M && !E)
          p(5, 1);
        else if (C !== S && (_ = x + C.length, O = 1 + _ - x, M = !1), !M) {
          const I = C ? 1 : 3;
          if (n.attribute) {
            const H = e.charCodeAt(_);
            H === 61 ? (p(I, O), E = "") : u_(H) ? E = "" : p(I, O);
          } else
            p(I, O);
        }
        R = E;
      } else {
        M || p(2, O);
        let I = Number.parseInt(
          S,
          b === "hexadecimal" ? 16 : 10
        );
        if (eD(I))
          p(7, O), R = "�";
        else if (I in c_)
          p(6, O), R = c_[I];
        else {
          let H = "";
          tD(I) && p(6, O), I > 65535 && (I -= 65536, H += String.fromCharCode(
            I >>> 10 | 55296
          ), I = 56320 | I & 1023), R = H + String.fromCharCode(I);
        }
      }
      if (R) {
        y(), d = m(), s = _ - 1, f += _ - g + 1, i.push(R);
        const I = m();
        I.offset++, n.reference && n.reference.call(
          n.referenceContext || void 0,
          R,
          { start: d, end: I },
          e.slice(g - 1, _)
        ), d = I;
      } else
        S = e.slice(g - 1, _), a += S, f += S.length, s = _ - 1;
    } else
      h === 10 && (u++, o++, f = 0), Number.isNaN(h) ? y() : (a += String.fromCharCode(h), f++);
  return i.join("");
  function m() {
    return {
      line: u,
      column: f,
      offset: s + ((l ? l.offset : 0) || 0)
    };
  }
  function p(v, g) {
    let x;
    n.warning && (x = m(), x.column += g, x.offset += g, n.warning.call(
      n.warningContext || void 0,
      QP[v],
      x,
      v
    ));
  }
  function y() {
    a && (i.push(a), n.text && n.text.call(n.textContext || void 0, a, {
      start: d,
      end: m()
    }), a = "");
  }
}
function eD(e) {
  return e >= 55296 && e <= 57343 || e > 1114111;
}
function tD(e) {
  return e >= 1 && e <= 8 || e === 11 || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534;
}
const nD = /["&'<>`]/g, rD = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, iD = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), sD = /[|\\{}()[\]^$+*?.]/g, d_ = /* @__PURE__ */ new WeakMap();
function oD(e, t) {
  if (e = e.replace(
    t.subset ? aD(t.subset) : nD,
    r
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(rD, n).replace(iD, r);
  function n(i, s, o) {
    return t.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      o.charCodeAt(s + 2),
      t
    );
  }
  function r(i, s, o) {
    return t.format(
      i.charCodeAt(0),
      o.charCodeAt(s + 1),
      t
    );
  }
}
function aD(e) {
  let t = d_.get(e);
  return t || (t = lD(e), d_.set(e, t)), t;
}
function lD(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(sD, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
function cD(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Q9(e, t) {
  return oD(e, Object.assign({ format: cD }, t));
}
function xr(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? h_(e.position) : "start" in e || "end" in e ? h_(e) : "line" in e || "column" in e ? Gg(e) : "";
}
function Gg(e) {
  return p_(e && e.line) + ":" + p_(e && e.column);
}
function h_(e) {
  return Gg(e && e.start) + "-" + Gg(e && e.end);
}
function p_(e) {
  return e && typeof e == "number" ? e : 1;
}
class ot extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", s = {}, o = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof t == "string" ? i = t : !s.cause && t && (o = !0, i = t.message, s.cause = t), !s.ruleId && !s.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? s.ruleId = r : (s.source = r.slice(0, l), s.ruleId = r.slice(l + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const l = s.ancestors[s.ancestors.length - 1];
      l && (s.place = l.position);
    }
    const a = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = a ? a.line : void 0, this.name = xr(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
ot.prototype.file = "";
ot.prototype.name = "";
ot.prototype.reason = "";
ot.prototype.message = "";
ot.prototype.stack = "";
ot.prototype.column = void 0;
ot.prototype.line = void 0;
ot.prototype.ancestors = void 0;
ot.prototype.cause = void 0;
ot.prototype.fatal = void 0;
ot.prototype.place = void 0;
ot.prototype.ruleId = void 0;
ot.prototype.source = void 0;
const e6 = "  ";
function Vd() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: r,
      mdxJsxFlowTagClosingMarker: i,
      mdxJsxFlowTagAttribute: f,
      mdxJsxFlowTagExpressionAttribute: d,
      mdxJsxFlowTagAttributeValueLiteral: e,
      mdxJsxFlowTagAttributeValueExpression: e,
      mdxJsxFlowTagSelfClosingMarker: o,
      mdxJsxTextTag: r,
      mdxJsxTextTagClosingMarker: i,
      mdxJsxTextTagAttribute: f,
      mdxJsxTextTagExpressionAttribute: d,
      mdxJsxTextTagAttributeValueLiteral: e,
      mdxJsxTextTagAttributeValueExpression: e,
      mdxJsxTextTagSelfClosingMarker: o
    },
    exit: {
      mdxJsxFlowTagClosingMarker: a,
      mdxJsxFlowTagNamePrimary: l,
      mdxJsxFlowTagNameMember: c,
      mdxJsxFlowTagNameLocal: u,
      mdxJsxFlowTagExpressionAttribute: h,
      mdxJsxFlowTagExpressionAttributeValue: n,
      mdxJsxFlowTagAttributeNamePrimary: m,
      mdxJsxFlowTagAttributeNameLocal: p,
      mdxJsxFlowTagAttributeValueLiteral: y,
      mdxJsxFlowTagAttributeValueLiteralValue: n,
      mdxJsxFlowTagAttributeValueExpression: v,
      mdxJsxFlowTagAttributeValueExpressionValue: n,
      mdxJsxFlowTagSelfClosingMarker: g,
      mdxJsxFlowTag: x,
      mdxJsxTextTagClosingMarker: a,
      mdxJsxTextTagNamePrimary: l,
      mdxJsxTextTagNameMember: c,
      mdxJsxTextTagNameLocal: u,
      mdxJsxTextTagExpressionAttribute: h,
      mdxJsxTextTagExpressionAttributeValue: n,
      mdxJsxTextTagAttributeNamePrimary: m,
      mdxJsxTextTagAttributeNameLocal: p,
      mdxJsxTextTagAttributeValueLiteral: y,
      mdxJsxTextTagAttributeValueLiteralValue: n,
      mdxJsxTextTagAttributeValueExpression: v,
      mdxJsxTextTagAttributeValueExpressionValue: n,
      mdxJsxTextTagSelfClosingMarker: g,
      mdxJsxTextTag: x
    }
  };
  function e() {
    this.buffer();
  }
  function t(E) {
    return { line: E.line, column: E.column, offset: E.offset };
  }
  function n(E) {
    this.config.enter.data.call(this, E), this.config.exit.data.call(this, E);
  }
  function r(E) {
    const S = {
      name: void 0,
      attributes: [],
      close: !1,
      selfClosing: !1,
      start: E.start,
      end: E.end
    };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), this.data.mdxJsxTag = S, this.buffer();
  }
  function i(E) {
    if (this.data.mdxJsxTagStack.length === 0)
      throw new ot(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: E.start, end: E.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
  }
  function s(E) {
    if (this.data.mdxJsxTag.close)
      throw new ot(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: E.start, end: E.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
  }
  function o(E) {
    if (this.data.mdxJsxTag.close)
      throw new ot(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: E.start, end: E.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
  }
  function a() {
    const E = this.data.mdxJsxTag;
    E.close = !0;
  }
  function l(E) {
    const S = this.data.mdxJsxTag;
    S.name = this.sliceSerialize(E);
  }
  function c(E) {
    const S = this.data.mdxJsxTag;
    S.name += "." + this.sliceSerialize(E);
  }
  function u(E) {
    const S = this.data.mdxJsxTag;
    S.name += ":" + this.sliceSerialize(E);
  }
  function f(E) {
    const S = this.data.mdxJsxTag;
    s.call(this, E), S.attributes.push({
      type: "mdxJsxAttribute",
      name: "",
      value: null,
      position: {
        start: t(E.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    });
  }
  function d(E) {
    const S = this.data.mdxJsxTag;
    s.call(this, E), S.attributes.push({
      type: "mdxJsxExpressionAttribute",
      value: "",
      position: {
        start: t(E.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    }), this.buffer();
  }
  function h(E) {
    const S = this.data.mdxJsxTag, k = S.attributes[S.attributes.length - 1];
    k.type;
    const M = E.estree;
    k.value = this.resume(), k.position, k.position.end = t(E.end), M && (k.data = { estree: M });
  }
  function m(E) {
    const S = this.data.mdxJsxTag, k = S.attributes[S.attributes.length - 1];
    k.type, k.name = this.sliceSerialize(E), k.position, k.position.end = t(E.end);
  }
  function p(E) {
    const S = this.data.mdxJsxTag, k = S.attributes[S.attributes.length - 1];
    k.type, k.name += ":" + this.sliceSerialize(E), k.position, k.position.end = t(E.end);
  }
  function y(E) {
    const S = this.data.mdxJsxTag, k = S.attributes[S.attributes.length - 1];
    k.value = xp(this.resume(), { nonTerminated: !1 }), k.position, k.position.end = t(E.end);
  }
  function v(E) {
    const S = this.data.mdxJsxTag, k = S.attributes[S.attributes.length - 1];
    k.type;
    const M = { type: "mdxJsxAttributeValueExpression", value: this.resume() }, O = E.estree;
    O && (M.data = { estree: O }), k.value = M, k.position, k.position.end = t(E.end);
  }
  function g() {
    const E = this.data.mdxJsxTag;
    E.selfClosing = !0;
  }
  function x(E) {
    const S = this.data.mdxJsxTag, k = this.data.mdxJsxTagStack, M = k[k.length - 1];
    if (S.close && M.name !== S.name)
      throw new ot(
        "Unexpected closing tag `" + C(S) + "`, expected corresponding closing tag for `" + C(M) + "` (" + xr(M) + ")",
        { start: E.start, end: E.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    this.resume(), S.close ? k.pop() : this.enter(
      {
        type: E.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
        name: S.name || null,
        attributes: S.attributes,
        children: []
      },
      E,
      _
    ), S.selfClosing || S.close ? this.exit(E, b) : k.push(S);
  }
  function _(E, S) {
    const k = this.data.mdxJsxTagStack, M = k[k.length - 1], O = E ? " before the end of `" + E.type + "`" : "", R = E ? { start: E.start, end: E.end } : void 0;
    throw new ot(
      "Expected a closing tag for `" + C(M) + "` (" + xr({ start: S.start, end: S.end }) + ")" + O,
      R,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function b(E, S) {
    const k = this.data.mdxJsxTag;
    throw new ot(
      "Expected the closing tag `" + C(k) + "` either after the end of `" + S.type + "` (" + xr(S.end) + ") or another opening tag after the start of `" + S.type + "` (" + xr(S.start) + ")",
      { start: E.start, end: E.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function C(E) {
    return "<" + (E.close ? "/" : "") + (E.name || "") + ">";
  }
}
function Hv(e) {
  const t = e || {}, n = t.quote || '"', r = t.quoteSmart || !1, i = t.tightSelfClosing || !1, s = t.printWidth || Number.POSITIVE_INFINITY, o = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error(
      "Cannot serialize attribute values with `" + n + "` for `options.quote`, expected `\"`, or `'`"
    );
  return a.peek = fD, {
    handlers: {
      mdxJsxFlowElement: a,
      mdxJsxTextElement: a
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: !0,
    // Always generate links with resources (never autolinks).
    resourceLink: !0
  };
  function a(l, c, u, f) {
    const d = l.type === "mdxJsxFlowElement", h = l.name ? !l.children || l.children.length === 0 : !1, m = t6(u), p = n6(m), y = u.createTracker(f), v = u.createTracker(f), g = [], x = (d ? p : "") + "<" + (l.name || ""), _ = u.enter(l.type);
    if (y.move(x), v.move(x), l.attributes && l.attributes.length > 0) {
      if (!l.name)
        throw new Error("Cannot serialize fragment w/ attributes");
      let k = -1;
      for (; ++k < l.attributes.length; ) {
        const M = l.attributes[k];
        let O;
        if (M.type === "mdxJsxExpressionAttribute")
          O = "{" + (M.value || "") + "}";
        else {
          if (!M.name)
            throw new Error("Cannot serialize attribute w/o name");
          const R = M.value, I = M.name;
          let H = "";
          if (R != null) if (typeof R == "object")
            H = "{" + (R.value || "") + "}";
          else {
            const P = r && $d(R, n) > $d(R, o) ? o : n;
            H = P + Q9(R, { subset: [P] }) + P;
          }
          O = I + (H ? "=" : "") + H;
        }
        g.push(O);
      }
    }
    let b = !1;
    const C = g.join(" ");
    // Block:
    d && // Including a line ending (expressions).
    (/\r?\n|\r/.test(C) || // Current position (including `<tag`).
    y.current().now.column + // -1 because columns, +1 for ` ` before attributes.
    // Attributes joined by spaces.
    C.length + // ` />`.
    (h ? i ? 2 : 3 : 1) > s) && (b = !0);
    let E = y, S = x;
    if (b) {
      E = v;
      let k = -1;
      for (; ++k < g.length; )
        g[k] = p + e6 + g[k];
      S += E.move(
        `
` + g.join(`
`) + `
` + p
      );
    } else C && (S += E.move(" " + C));
    return h && (S += E.move(
      (i || b ? "" : " ") + "/"
    )), S += E.move(">"), l.children && l.children.length > 0 && (l.type === "mdxJsxTextElement" ? S += E.move(
      u.containerPhrasing(l, {
        ...E.current(),
        before: ">",
        after: "<"
      })
    ) : (E.shift(2), S += E.move(`
`), S += E.move(uD(l, u, E.current())), S += E.move(`
`))), h || (S += E.move(
      (d ? p : "") + "</" + (l.name || "") + ">"
    )), _(), S;
  }
}
function uD(e, t, n) {
  const r = t.indexStack, i = e.children, s = t.createTracker(n), o = n6(t6(t)), a = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const c = i[l];
    r[r.length - 1] = l;
    const u = { before: `
`, after: `
`, ...s.current() }, f = t.handle(c, e, t, u), d = c.type === "mdxJsxFlowElement" ? f : t.indentLines(f, function(h, m, p) {
      return (p ? "" : o) + h;
    });
    a.push(s.move(d)), c.type !== "list" && (t.bulletLastUsed = void 0), l < i.length - 1 && a.push(s.move(`

`));
  }
  return r.pop(), a.join("");
}
function t6(e) {
  let t = 0, n = e.stack.length;
  for (; --n > -1; ) {
    const r = e.stack[n];
    if (r === "blockquote" || r === "listItem") break;
    r === "mdxJsxFlowElement" && t++;
  }
  return t;
}
function n6(e) {
  return e6.repeat(e);
}
function fD() {
  return "<";
}
const dD = /[$_\p{ID_Start}]/u, hD = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u, pD = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u, mD = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, gD = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, r6 = {};
function Tr(e) {
  return e ? dD.test(String.fromCodePoint(e)) : !1;
}
function Rl(e, t) {
  const r = (t || r6).jsx ? pD : hD;
  return e ? r.test(String.fromCodePoint(e)) : !1;
}
function hi(e, t) {
  return ((t || r6).jsx ? gD : mD).test(e);
}
function Ge(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(l) {
    return He(l) ? (e.enter(n), a(l)) : t(l);
  }
  function a(l) {
    return He(l) && s++ < i ? (e.consume(l), a) : (e.exit(n), t(l));
  }
}
const vD = {}.hasOwnProperty, yD = Symbol("continue"), P1 = Symbol("exit"), xD = Symbol("skip");
function wD(e, t) {
  let n, r;
  typeof t == "function" ? n = t : t && typeof t == "object" && (t.enter && (n = t.enter), t.leave && (r = t.leave)), i(e, void 0, void 0, [])();
  function i(s, o, a, l) {
    return D1(s) && (c.displayName = "node (" + s.type + ")"), c;
    function c() {
      const u = n ? m_(n(s, o, a, l)) : [];
      if (u[0] === P1)
        return u;
      if (u[0] !== xD) {
        let f;
        for (f in s)
          if (vD.call(s, f) && s[f] && typeof s[f] == "object" && // @ts-expect-error: custom esast extension.
          f !== "data" && // @ts-expect-error: custom esast extension.
          f !== "position") {
            const d = l.concat(s), h = s[f];
            if (Array.isArray(h)) {
              const m = (
                /** @type {Array<unknown>} */
                h
              );
              let p = 0;
              for (; p > -1 && p < m.length; ) {
                const y = m[p];
                if (D1(y)) {
                  const v = i(
                    y,
                    f,
                    p,
                    d
                  )();
                  if (v[0] === P1) return v;
                  p = typeof v[1] == "number" ? v[1] : p + 1;
                } else
                  p++;
              }
            } else if (D1(h)) {
              const m = i(h, f, void 0, d)();
              if (m[0] === P1) return m;
            }
          }
      }
      return r ? m_(r(s, o, a, l)) : u;
    }
  }
}
function m_(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [yD, e] : [e];
}
function D1(e) {
  return !!(e && typeof e == "object" && "type" in e && typeof e.type == "string" && e.type.length > 0);
}
function i6(e, t) {
  const n = t.prefix || "", r = t.suffix || "", i = Object.assign({}, t.acornOptions), s = [], o = [], a = i.onComment, l = i.onToken;
  let c = !1, u, f;
  const d = Object.assign({}, i, {
    onComment: s,
    preserveParens: !0
  });
  l && (d.onToken = o);
  const h = _D(e, t.tokenTypes), m = h.value, p = n + m + r, y = t.expression && g_(m);
  if (y && !t.allowEmpty)
    throw new ot("Unexpected empty expression", {
      place: g(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression"
    });
  try {
    u = t.expression && !y ? t.acorn.parseExpressionAt(p, 0, d) : t.acorn.parse(p, d);
  } catch (x) {
    const _ = (
      /** @type {AcornError} */
      x
    ), b = g(_.pos);
    _.message = String(_.message).replace(/ \(\d+:\d+\)$/, ""), _.pos = b.offset, _.loc = {
      line: b.line,
      column: b.column - 1
    }, f = _, c = _.raisedAt >= n.length + m.length || // Broken comments are raised at their start, not their end.
    _.message === "Unterminated comment";
  }
  if (u && t.expression && !y)
    if (g_(p.slice(u.end, p.length - r.length)))
      u = {
        type: "Program",
        start: 0,
        end: n.length + m.length,
        // @ts-expect-error: It’s good.
        body: [{
          type: "ExpressionStatement",
          expression: u,
          start: 0,
          end: n.length + m.length
        }],
        sourceType: "module",
        comments: []
      };
    else {
      const x = g(u.end), _ = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      _.pos = x.offset, _.loc = {
        line: x.line,
        column: x.column - 1
      }, f = _, u = void 0;
    }
  if (u) {
    if (u.comments = s, wD(u, function(x, _, b, C) {
      let E = (
        /** @type {AcornNode | Array<AcornNode>} */
        C[C.length - 1]
      ), S = _;
      x.type === "ParenthesizedExpression" && E && S && (typeof b == "number" && (E = E[S], S = b), E[S] = x.expression), v(x);
    }), Array.isArray(a))
      a.push(...s);
    else if (typeof a == "function")
      for (const x of s)
        a(x.type === "Block", x.value, x.start, x.end, x.loc.start, x.loc.end);
    for (const x of o)
      x.end <= n.length || x.start - n.length >= m.length || (v(x), Array.isArray(l) ? l.push(x) : l(x));
  }
  return {
    estree: u,
    error: f,
    swallow: c
  };
  function v(x) {
    const _ = g(x.start), b = g(x.end);
    x.start = _.offset, x.end = b.offset, x.loc = {
      start: {
        line: _.line,
        column: _.column - 1,
        // @ts-expect-error: not allowed by acorn types.
        offset: _.offset
      },
      end: {
        line: b.line,
        column: b.column - 1,
        // @ts-expect-error: not allowed by acorn types.
        offset: b.offset
      }
    }, x.range = [x.start, x.end];
  }
  function g(x) {
    let _ = x - n.length;
    _ < 0 ? _ = 0 : _ > m.length && (_ = m.length);
    let b = bD(h.stops, _);
    return b || (b = {
      line: t.start.line,
      column: t.start.column,
      offset: t.start.offset
    }), b;
  }
}
function g_(e) {
  return /^\s*$/.test(e.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function _D(e, t) {
  const n = {
    value: "",
    stops: []
  };
  let r = -1;
  for (; ++r < e.length; ) {
    const i = e[r];
    if (i[0] === "enter") {
      const s = i[1].type;
      if (s === "lineEnding" || t.includes(s)) {
        const o = i[2].sliceStream(i[1]);
        for (; o.length > 0 && o[0] === -1; )
          o.shift();
        const a = CD(o);
        n.stops.push([n.value.length, i[1].start]), n.value += a, n.stops.push([n.value.length, i[1].end]);
      }
    }
  }
  return n;
}
function bD(e, t) {
  let n = 0;
  for (; n < e.length && e[n][0] <= t; )
    n += 1;
  if (n === 0)
    return;
  const [r, i] = e[n - 1], s = t - r;
  return {
    line: i.line,
    column: i.column + s,
    offset: i.offset + s
  };
}
function CD(e) {
  let t = -1;
  const n = [];
  let r;
  for (; ++t < e.length; ) {
    const i = e[t];
    let s;
    if (typeof i == "string")
      s = i;
    else switch (i) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = "	";
        break;
      }
      case -1: {
        if (r) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(i);
    }
    r = i === -2, n.push(s);
  }
  return n.join("");
}
function ji(e) {
  const t = e || {}, n = t.loc || {}, r = t.range || [void 0, void 0], i = v_(n.start, r[0] || t.start), s = v_(n.end, r[1] || t.end);
  if (i && s)
    return { start: i, end: s };
}
function v_(e, t) {
  if (e && typeof e == "object") {
    const n = "line" in e ? F1(e.line) : void 0, r = "column" in e ? F1(e.column) : void 0;
    if (n && r !== void 0)
      return {
        line: n,
        column: r + 1,
        offset: F1(t)
      };
  }
}
function F1(e) {
  return typeof e == "number" && e > -1 ? e : void 0;
}
const ED = 2, wa = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression", SD = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-", kD = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed", y_ = "#unexpected-type-in-code-expected-an-object-spread-spread", TD = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported", AD = "#could-not-parse-expression-with-acorn";
function Bd(e, t, n, r, i, s, o, a, l, c, u) {
  const f = this, d = this.events.length + 3;
  let h = 0, m, p;
  return y;
  function y(_) {
    return e.enter(n), e.enter(r), e.consume(_), e.exit(r), m = f.now(), v;
  }
  function v(_) {
    if (_ === null) {
      if (p) throw p;
      const b = new ot("Unexpected end of file in expression, expected a corresponding closing brace for `{`", {
        place: f.now(),
        ruleId: "unexpected-eof",
        source: "micromark-extension-mdx-expression"
      });
      throw b.url = wa + SD, b;
    }
    if (be(_))
      return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), x;
    if (_ === 125 && h === 0) {
      const b = s ? ND.call(f, s, o, i, d, m, c || !1, l || !1) : {
        type: "ok",
        estree: void 0
      };
      if (b.type === "ok") {
        e.enter(r), e.consume(_), e.exit(r);
        const C = e.exit(n);
        return a && b.estree && Object.assign(C, {
          estree: b.estree
        }), t;
      }
      return p = b.message, e.enter(i), e.consume(_), g;
    }
    return e.enter(i), g(_);
  }
  function g(_) {
    return _ === 125 && h === 0 || _ === null || be(_) ? (e.exit(i), v(_)) : (_ === 123 && !s ? h += 1 : _ === 125 && (h -= 1), e.consume(_), g);
  }
  function x(_) {
    const b = f.now();
    if (b.line !== m.line && !u && f.parser.lazy[b.line]) {
      const C = new ot("Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", {
        place: f.now(),
        ruleId: "unexpected-lazy",
        source: "micromark-extension-mdx-expression"
      });
      throw C.url = wa + kD, C;
    }
    return He(_) ? Ge(e, v, "linePrefix", ED + 1)(_) : v(_);
  }
}
function ND(e, t, n, r, i, s, o) {
  const a = i6(this.events.slice(r), {
    acorn: e,
    tokenTypes: [n],
    acornOptions: t,
    start: i,
    expression: !0,
    allowEmpty: s,
    prefix: o ? "({" : "",
    suffix: o ? "})" : ""
  }), l = a.estree;
  if (o && l) {
    const c = l.body[0];
    if (c.type !== "ExpressionStatement" || c.expression.type !== "ObjectExpression") {
      const u = ji(c), f = new ot("Unexpected `" + c.type + "` in code: expected an object spread (`{...spread}`)", {
        place: u.start,
        ruleId: "non-spread",
        source: "micromark-extension-mdx-expression"
      });
      throw f.url = wa + y_, f;
    }
    if (c.expression.properties[1]) {
      const u = ji(c.expression.properties[1]), f = new ot("Unexpected extra content in spread: only a single spread is supported", {
        place: u.start,
        ruleId: "spread-extra",
        source: "micromark-extension-mdx-expression"
      });
      throw f.url = wa + TD, f;
    }
    if (c.expression.properties[0] && c.expression.properties[0].type !== "SpreadElement") {
      const u = ji(c.expression.properties[0]), f = new ot("Unexpected `" + c.expression.properties[0].type + "` in code: only spread elements are supported", {
        place: u.start,
        ruleId: "non-spread",
        source: "micromark-extension-mdx-expression"
      });
      throw f.url = wa + y_, f;
    }
  }
  if (a.error) {
    const c = new ot("Could not parse expression with acorn", {
      cause: a.error,
      place: {
        line: a.error.loc.line,
        column: a.error.loc.column + 1,
        offset: a.error.pos
      },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression"
    });
    return c.url = wa + AD, {
      type: "nok",
      message: c
    };
  }
  return {
    type: "ok",
    estree: l
  };
}
const x_ = "https://github.com/micromark/micromark-extension-mdx-jsx";
function s6(e, t, n, r, i, s, o, a, l, c, u, f, d, h, m, p, y, v, g, x, _, b, C, E, S, k, M, O, R, I, H, P) {
  const W = this;
  let G, J;
  return X;
  function X(D) {
    return e.enter(a), e.enter(l), e.consume(D), e.exit(l), N;
  }
  function N(D) {
    return ut(D) ? n(D) : (G = U, ne(D));
  }
  function U(D) {
    if (D === 47)
      return e.enter(c), e.consume(D), e.exit(c), G = ee, ne;
    if (D === 62)
      return se(D);
    if (D !== null && D >= 0 && Tr(D))
      return e.enter(f), e.enter(d), e.consume(D), F;
    re(D, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (D === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""));
  }
  function ee(D) {
    if (D === 62)
      return se(D);
    if (D !== null && D >= 0 && Tr(D))
      return e.enter(f), e.enter(d), e.consume(D), F;
    re(D, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (D === 42 || D === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
  }
  function F(D) {
    if (D !== null && D >= 0 && Rl(D, {
      jsx: !0
    }))
      return e.consume(D), F;
    if (D === 46 || D === 47 || D === 58 || D === 62 || D === 123 || ut(D) || Pi(D))
      return e.exit(d), G = ue, ne(D);
    re(D, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (D === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function ue(D) {
    if (D === 46)
      return e.enter(h), e.consume(D), e.exit(h), G = pe, ne;
    if (D === 58)
      return e.enter(p), e.consume(D), e.exit(p), G = Z, ne;
    if (D === 47 || D === 62 || D === 123 || D !== null && D >= 0 && Tr(D))
      return e.exit(f), ie(D);
    re(D, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function pe(D) {
    if (D !== null && D >= 0 && Tr(D))
      return e.enter(m), e.consume(D), ce;
    re(D, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ce(D) {
    if (D !== null && D >= 0 && Rl(D, {
      jsx: !0
    }))
      return e.consume(D), ce;
    if (D === 46 || D === 47 || D === 62 || D === 123 || ut(D) || Pi(D))
      return e.exit(m), G = q, ne(D);
    re(D, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (D === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function q(D) {
    if (D === 46)
      return e.enter(h), e.consume(D), e.exit(h), G = pe, ne;
    if (D === 47 || D === 62 || D === 123 || D !== null && D >= 0 && Tr(D))
      return e.exit(f), ie(D);
    re(D, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function Z(D) {
    if (D !== null && D >= 0 && Tr(D))
      return e.enter(y), e.consume(D), oe;
    re(D, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (D === 43 || D !== null && D > 46 && D < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function oe(D) {
    if (D !== null && D >= 0 && Rl(D, {
      jsx: !0
    }))
      return e.consume(D), oe;
    if (D === 47 || D === 62 || D === 123 || ut(D) || Pi(D))
      return e.exit(y), G = le, ne(D);
    re(D, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function le(D) {
    if (D === 47 || D === 62 || D === 123 || D !== null && D >= 0 && Tr(D))
      return e.exit(f), ie(D);
    re(D, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ie(D) {
    if (D === 47)
      return e.enter(u), e.consume(D), e.exit(u), G = Q, ne;
    if (D === 62)
      return se(D);
    if (D === 123)
      return Bd.call(W, e, Y, v, g, x, r, i, s, !0, !1, o)(D);
    if (D !== null && D >= 0 && Tr(D))
      return e.enter(_), e.enter(b), e.enter(C), e.consume(D), Ce;
    re(D, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function Y(D) {
    return G = ie, ne(D);
  }
  function Ce(D) {
    if (D !== null && D >= 0 && Rl(D, {
      jsx: !0
    }))
      return e.consume(D), Ce;
    if (D === 47 || D === 58 || D === 61 || D === 62 || D === 123 || ut(D) || Pi(D))
      return e.exit(C), G = Fe, ne(D);
    re(D, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
  }
  function Fe(D) {
    if (D === 58)
      return e.enter(E), e.consume(D), e.exit(E), G = je, ne;
    if (D === 61)
      return e.exit(b), e.enter(k), e.consume(D), e.exit(k), G = xn, ne;
    if (D === 47 || D === 62 || D === 123 || ut(D) || Pi(D) || D !== null && D >= 0 && Tr(D))
      return e.exit(b), e.exit(_), G = ie, ne(D);
    re(D, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function je(D) {
    if (D !== null && D >= 0 && Tr(D))
      return e.enter(S), e.consume(D), Ze;
    re(D, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function Ze(D) {
    if (D !== null && D >= 0 && Rl(D, {
      jsx: !0
    }))
      return e.consume(D), Ze;
    if (D === 47 || D === 61 || D === 62 || D === 123 || ut(D) || Pi(D))
      return e.exit(S), e.exit(b), G = mt, ne(D);
    re(D, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
  }
  function mt(D) {
    if (D === 61)
      return e.enter(k), e.consume(D), e.exit(k), G = xn, ne;
    if (D === 47 || D === 62 || D === 123 || D !== null && D >= 0 && Tr(D))
      return e.exit(_), ie(D);
    re(D, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function xn(D) {
    if (D === 34 || D === 39)
      return e.enter(M), e.enter(O), e.consume(D), e.exit(O), J = D, z;
    if (D === 123)
      return Bd.call(W, e, bt, I, H, P, r, i, s, !1, !1, o)(D);
    re(D, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (D === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
  }
  function bt(D) {
    return e.exit(_), G = ie, ne(D);
  }
  function z(D) {
    return D === null && re(D, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(J) + "`"), D === J ? (e.enter(O), e.consume(D), e.exit(O), e.exit(M), e.exit(_), J = void 0, G = ie, ne) : be(D) ? (G = z, ne(D)) : (e.enter(R), K(D));
  }
  function K(D) {
    return D === null || D === J || be(D) ? (e.exit(R), z(D)) : (e.consume(D), K);
  }
  function Q(D) {
    if (D === 62)
      return se(D);
    re(D, "after self-closing slash", "`>` to end the tag" + (D === 42 || D === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
  }
  function se(D) {
    return e.enter(l), e.consume(D), e.exit(l), e.exit(a), t;
  }
  function ne(D) {
    return be(D) ? (e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), j) : He(D) || Pi(D) ? (e.enter("esWhitespace"), he(D)) : G(D);
  }
  function he(D) {
    return be(D) ? (e.exit("esWhitespace"), ne(D)) : He(D) || Pi(D) ? (e.consume(D), he) : (e.exit("esWhitespace"), G(D));
  }
  function j(D) {
    if (!o && W.parser.lazy[W.now().line]) {
      const Ie = new ot("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", W.now(), "micromark-extension-mdx-jsx:unexpected-lazy");
      throw Ie.url = x_ + "#unexpected-lazy-line-in-container-expected-line-to-be", Ie;
    }
    return ne(D);
  }
  function re(D, Ie, Ue) {
    const et = new ot("Unexpected " + (D === null ? "end of file" : "character `" + (D === 96 ? "` ` `" : String.fromCodePoint(D)) + "` (" + ID(D) + ")") + " " + Ie + ", expected " + Ue, W.now(), "micromark-extension-mdx-jsx:unexpected-" + (D === null ? "eof" : "character"));
    throw et.url = x_ + (D === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect"), et;
  }
}
function ID(e) {
  return "U+" + e.toString(16).toUpperCase().padStart(4, "0");
}
function LD(e, t) {
  return {
    name: "mdxJsxTextTag",
    tokenize: n
  };
  function n(r, i, s) {
    return s6.call(this, r, i, s, e, t.acornOptions, t.addResult, !0, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
  }
}
function MD(e, t) {
  return {
    concrete: !0,
    name: "mdxJsxFlowTag",
    tokenize: n
  };
  function n(r, i, s) {
    const o = this;
    return a;
    function a(f) {
      return l(f);
    }
    function l(f) {
      return s6.call(o, r, c, s, e, t.acornOptions, t.addResult, !1, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(f);
    }
    function c(f) {
      return He(f) ? Ge(r, u, "whitespace")(f) : u(f);
    }
    function u(f) {
      const d = o.parser.constructs.flow[123], h = Array.isArray(d) ? d : d ? [d] : [];
      let m;
      for (const p of h)
        if (p.name === "mdxFlowExpression") {
          m = p;
          break;
        }
      return f === 60 ? (
        // We can’t just say: fine. Lines of blocks have to be parsed until an eol/eof.
        a(f)
      ) : f === 123 && m ? r.attempt(m, u, s)(f) : f === null || be(f) ? i(f) : s(f);
    }
  }
}
function zd(e) {
  const t = e || {}, n = t.acorn;
  let r;
  if (n) {
    if (!n.parse || !n.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    r = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, t.acornOptions, {
      locations: !0
    });
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      60: MD(n || void 0, {
        acornOptions: r,
        addResult: t.addResult || void 0
      })
    },
    text: {
      60: LD(n || void 0, {
        acornOptions: r,
        addResult: t.addResult || void 0
      })
    }
  };
}
function o6() {
  return {
    disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
  };
}
const w_ = {}.hasOwnProperty;
function a6(e, t) {
  const n = t || {};
  function r(i, ...s) {
    let o = r.invalid;
    const a = r.handlers;
    if (i && w_.call(i, e)) {
      const l = String(i[e]);
      o = w_.call(a, l) ? a[l] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const OD = {}.hasOwnProperty;
function l6(e, t) {
  let n = -1, r;
  if (t.extensions)
    for (; ++n < t.extensions.length; )
      l6(e, t.extensions[n]);
  for (r in t)
    if (OD.call(t, r))
      switch (r) {
        case "extensions":
          break;
        case "unsafe": {
          __(e[r], t[r]);
          break;
        }
        case "join": {
          __(e[r], t[r]);
          break;
        }
        case "handlers": {
          PD(e[r], t[r]);
          break;
        }
        default:
          e.options[r] = t[r];
      }
  return e;
}
function __(e, t) {
  t && e.push(...t);
}
function PD(e, t) {
  t && Object.assign(e, t);
}
function DD(e, t, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const o = n.indentLines(
    n.containerFlow(e, s.current()),
    FD
  );
  return i(), o;
}
function FD(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function c6(e, t) {
  return b_(e, t.inConstruct, !0) && !b_(e, t.notInConstruct, !1);
}
function b_(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function C_(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && c6(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function RD(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, s = 0, o = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + t.length, r = n.indexOf(t, i);
  return o;
}
function Yg(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function $D(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function VD(e, t, n, r) {
  const i = $D(n), s = e.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (Yg(e, n)) {
    const f = n.enter("codeIndented"), d = n.indentLines(s, BD);
    return f(), d;
  }
  const a = n.createTracker(r), l = i.repeat(Math.max(RD(s, i) + 1, 3)), c = n.enter("codeFenced");
  let u = a.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${o}`);
    u += a.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${o}`);
    u += a.move(" "), u += a.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), f();
  }
  return u += a.move(`
`), s && (u += a.move(s + `
`)), u += a.move(l), c(), u;
}
function BD(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Uv(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function zD(e, t, n, r) {
  const i = Uv(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), a(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), a(), e.title && (a = n.enter(`title${s}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), a()), o(), c;
}
function HD(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Us(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Hd(e, t, n) {
  const r = Ja(e), i = Ja(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
u6.peek = UD;
function u6(e, t, n, r) {
  const i = HD(n), s = n.enter("emphasis"), o = n.createTracker(r), a = o.move(i);
  let l = o.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = Hd(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (l = Us(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), d = Hd(r.after.charCodeAt(0), f, i);
  d.inside && (l = l.slice(0, -1) + Us(f));
  const h = o.move(i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: u.outside
  }, a + l + h;
}
function UD(e, t, n) {
  return n.options.emphasis || "*";
}
const jv = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return KD;
    if (typeof e == "function")
      return wp(e);
    if (typeof e == "object")
      return Array.isArray(e) ? jD(e) : WD(e);
    if (typeof e == "string")
      return JD(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function jD(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = jv(e[n]);
  return wp(r);
  function r(...i) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, i)) return !0;
    return !1;
  }
}
function WD(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return wp(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in e)
      if (i[s] !== t[s]) return !1;
    return !0;
  }
}
function JD(e) {
  return wp(t);
  function t(n) {
    return n && n.type === e;
  }
}
function wp(e) {
  return t;
  function t(n, r, i) {
    return !!(qD(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function KD() {
  return !0;
}
function qD(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const f6 = [], GD = !0, Xg = !1, YD = "skip";
function d6(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const s = jv(i), o = r ? -1 : 1;
  a(e, void 0, [])();
  function a(l, c, u) {
    const f = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof f.type == "string") {
      const h = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(d, "name", {
        value: "node (" + (l.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return d;
    function d() {
      let h = f6, m, p, y;
      if ((!t || s(l, c, u[u.length - 1] || void 0)) && (h = XD(n(l, u)), h[0] === Xg))
        return h;
      if ("children" in l && l.children) {
        const v = (
          /** @type {UnistParent} */
          l
        );
        if (v.children && h[0] !== YD)
          for (p = (r ? v.children.length : -1) + o, y = u.concat(v); p > -1 && p < v.children.length; ) {
            const g = v.children[p];
            if (m = a(g, p, y)(), m[0] === Xg)
              return m;
            p = typeof m[1] == "number" ? m[1] : p + o;
          }
      }
      return h;
    }
  }
}
function XD(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [GD, e] : e == null ? f6 : [e];
}
function cu(e, t, n, r) {
  let i, s, o;
  typeof t == "function" && typeof n != "function" ? (s = void 0, o = t, i = n) : (s = t, o = n, i = r), d6(e, s, a, i);
  function a(l, c) {
    const u = c[c.length - 1], f = u ? u.children.indexOf(l) : void 0;
    return o(l, f, u);
  }
}
const ZD = {};
function Wv(e, t) {
  const n = ZD, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return h6(e, r, i);
}
function h6(e, t, n) {
  if (QD(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return E_(e.children, t, n);
  }
  return Array.isArray(e) ? E_(e, t, n) : "";
}
function E_(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = h6(e[i], t, n);
  return r.join("");
}
function QD(e) {
  return !!(e && typeof e == "object");
}
function p6(e, t) {
  let n = !1;
  return cu(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Xg;
  }), !!((!e.depth || e.depth < 3) && Wv(e) && (t.options.setext || n));
}
function eF(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), s = n.createTracker(r);
  if (p6(e, n)) {
    const u = n.enter("headingSetext"), f = n.enter("phrasing"), d = n.containerPhrasing(e, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return f(), u(), d + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), a = n.enter("headingAtx"), l = n.enter("phrasing");
  s.move(o + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(c) && (c = Us(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), a(), c;
}
m6.peek = tF;
function m6(e) {
  return e.value || "";
}
function tF() {
  return "<";
}
g6.peek = nF;
function g6(e, t, n, r) {
  const i = Uv(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), a(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), a(), e.title && (a = n.enter(`title${s}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), a()), c += l.move(")"), o(), c;
}
function nF() {
  return "!";
}
v6.peek = rF;
function v6(e, t, n, r) {
  const i = e.referenceType, s = n.enter("imageReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = u, s(), i === "full" || !c || c !== f ? l += a.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function rF() {
  return "!";
}
y6.peek = iF;
function y6(e, t, n) {
  let r = e.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const o = n.unsafe[s], a = n.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; l = a.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function iF() {
  return "`";
}
function x6(e, t) {
  const n = Wv(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
w6.peek = sF;
function w6(e, t, n, r) {
  const i = Uv(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let a, l;
  if (x6(e, n)) {
    const u = n.stack;
    n.stack = [], a = n.enter("autolink");
    let f = o.move("<");
    return f += o.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...o.current()
      })
    ), f += o.move(">"), a(), n.stack = u, f;
  }
  a = n.enter("link"), l = n.enter("label");
  let c = o.move("[");
  return c += o.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), l(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    n.safe(e.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...o.current()
    })
  )), l(), e.title && (l = n.enter(`title${s}`), c += o.move(" " + i), c += o.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), l()), c += o.move(")"), a(), c;
}
function sF(e, t, n) {
  return x6(e, n) ? "<" : "[";
}
_6.peek = oF;
function _6(e, t, n, r) {
  const i = e.referenceType, s = n.enter("linkReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = u, s(), i === "full" || !c || c !== f ? l += a.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function oF() {
  return "[";
}
function Jv(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function aF(e) {
  const t = Jv(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function lF(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function b6(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function cF(e, t, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let o = e.ordered ? lF(n) : Jv(n);
  const a = e.ordered ? o === "." ? ")" : "." : aF(n);
  let l = t && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), b6(n) === o && u
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const d = e.children[f];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = a), n.bulletCurrent = o;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = o, n.bulletCurrent = s, i(), c;
}
function uF(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function fF(e, t, n, r) {
  const i = uF(n);
  let s = n.bulletCurrent || Jv(n);
  t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (o = Math.ceil(o / 4) * 4);
  const a = n.createTracker(r);
  a.move(s + " ".repeat(o - s.length)), a.shift(o);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, a.current()),
    u
  );
  return l(), c;
  function u(f, d, h) {
    return d ? (h ? "" : " ".repeat(o)) + f : (h ? s : s + " ".repeat(o - s.length)) + f;
  }
}
function dF(e, t, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), o = n.containerPhrasing(e, r);
  return s(), i(), o;
}
const hF = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  jv([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function pF(e, t, n, r) {
  return (e.children.some(function(o) {
    return hF(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function mF(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
C6.peek = gF;
function C6(e, t, n, r) {
  const i = mF(n), s = n.enter("strong"), o = n.createTracker(r), a = o.move(i + i);
  let l = o.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = Hd(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (l = Us(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), d = Hd(r.after.charCodeAt(0), f, i);
  d.inside && (l = l.slice(0, -1) + Us(f));
  const h = o.move(i + i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: u.outside
  }, a + l + h;
}
function gF(e, t, n) {
  return n.options.strong || "*";
}
function vF(e, t, n, r) {
  return n.safe(e.value, r);
}
function yF(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function xF(e, t, n) {
  const r = (b6(n) + (n.options.ruleSpaces ? " " : "")).repeat(yF(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Kv = {
  blockquote: DD,
  break: C_,
  code: VD,
  definition: zD,
  emphasis: u6,
  hardBreak: C_,
  heading: eF,
  html: m6,
  image: g6,
  imageReference: v6,
  inlineCode: y6,
  link: w6,
  linkReference: _6,
  list: cF,
  listItem: fF,
  paragraph: dF,
  root: pF,
  strong: C6,
  text: vF,
  thematicBreak: xF
}, wF = [_F];
function _F(e, t, n, r) {
  if (t.type === "code" && Yg(t, r) && (e.type === "list" || e.type === t.type && Yg(e, r)))
    return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return e.type === "paragraph" && // Two paragraphs.
    (e.type === t.type || t.type === "definition" || // Paragraph followed by a setext heading.
    t.type === "heading" && p6(t, r)) ? void 0 : n.spread ? 1 : 0;
}
const lo = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], bF = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: lo
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: lo
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: lo },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: lo
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: lo },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: lo },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: lo },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
];
function E6(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
const CF = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function S6(e) {
  return e.replace(CF, EF);
}
function EF(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), s = i === 120 || i === 88;
    return E6(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return Ic(n) || e;
}
function SF(e) {
  return e.label || !e.identifier ? e.label || "" : S6(e.identifier);
}
function kF(e) {
  if (!e._compiled) {
    const t = (e.atBreak ? "[\\r\\n][\\t ]*" : "") + (e.before ? "(?:" + e.before + ")" : "");
    e._compiled = new RegExp(
      (t ? "(" + t + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(e.character) ? "\\" : "") + e.character + (e.after ? "(?:" + e.after + ")" : ""),
      "g"
    );
  }
  return e._compiled;
}
function TF(e, t, n) {
  const r = t.indexStack, i = e.children || [], s = [];
  let o = -1, a = n.before, l;
  r.push(-1);
  let c = t.createTracker(n);
  for (; ++o < i.length; ) {
    const u = i[o];
    let f;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let m = t.handle.handlers[i[o + 1].type];
      m && m.peek && (m = m.peek), f = m ? m(i[o + 1], e, t, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      f = n.after;
    s.length > 0 && (a === "\r" || a === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), a = " ", c = t.createTracker(n), c.move(s.join("")));
    let d = t.handle(u, e, t, {
      ...c.current(),
      after: f,
      before: a
    });
    l && l === d.slice(0, 1) && (d = Us(l.charCodeAt(0)) + d.slice(1));
    const h = t.attentionEncodeSurroundingInfo;
    t.attentionEncodeSurroundingInfo = void 0, l = void 0, h && (s.length > 0 && h.before && a === s[s.length - 1].slice(-1) && (s[s.length - 1] = s[s.length - 1].slice(0, -1) + Us(a.charCodeAt(0))), h.after && (l = f)), c.move(d), s.push(d), a = d.slice(-1);
  }
  return r.pop(), s.join("");
}
function AF(e, t, n) {
  const r = t.indexStack, i = e.children || [], s = t.createTracker(n), o = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const l = i[a];
    r[r.length - 1] = a, o.push(
      s.move(
        t.handle(l, e, t, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), l.type !== "list" && (t.bulletLastUsed = void 0), a < i.length - 1 && o.push(
      s.move(NF(l, i[a + 1], e, t))
    );
  }
  return r.pop(), o.join("");
}
function NF(e, t, n, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](e, t, n, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const IF = /\r?\n|\r/g;
function LF(e, t) {
  const n = [];
  let r = 0, i = 0, s;
  for (; s = IF.exec(e); )
    o(e.slice(r, s.index)), n.push(s[0]), r = s.index + s[0].length, i++;
  return o(e.slice(r)), n.join("");
  function o(a) {
    n.push(t(a, i, !a));
  }
}
function MF(e, t, n) {
  const r = (n.before || "") + (t || "") + (n.after || ""), i = [], s = [], o = {};
  let a = -1;
  for (; ++a < e.unsafe.length; ) {
    const u = e.unsafe[a];
    if (!c6(e.stack, u))
      continue;
    const f = e.compilePattern(u);
    let d;
    for (; d = f.exec(r); ) {
      const h = "before" in u || !!u.atBreak, m = "after" in u, p = d.index + (h ? d[1].length : 0);
      i.includes(p) ? (o[p].before && !h && (o[p].before = !1), o[p].after && !m && (o[p].after = !1)) : (i.push(p), o[p] = { before: h, after: m });
    }
  }
  i.sort(OF);
  let l = n.before ? n.before.length : 0;
  const c = r.length - (n.after ? n.after.length : 0);
  for (a = -1; ++a < i.length; ) {
    const u = i[a];
    u < l || u >= c || u + 1 < c && i[a + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after || i[a - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after || (l !== u && s.push(S_(r.slice(l, u), "\\")), l = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!n.encode || !n.encode.includes(r.charAt(u))) ? s.push("\\") : (s.push(Us(r.charCodeAt(u))), l++));
  }
  return s.push(S_(r.slice(l, c), n.after)), s.join("");
}
function OF(e, t) {
  return e - t;
}
function S_(e, t) {
  const n = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = e + t;
  let o = -1, a = 0, l;
  for (; l = n.exec(s); )
    r.push(l.index);
  for (; ++o < r.length; )
    a !== r[o] && i.push(e.slice(a, r[o])), i.push("\\"), a = r[o];
  return i.push(e.slice(a)), i.join("");
}
function PF(e) {
  const t = e || {}, n = t.now || {};
  let r = t.lineShift || 0, i = n.line || 1, s = n.column || 1;
  return { move: l, current: o, shift: a };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function a(c) {
    r += c;
  }
  function l(c) {
    const u = c || "", f = u.split(/\r?\n|\r/g), d = f[f.length - 1];
    return i += f.length - 1, s = f.length === 1 ? s + d.length : 1 + d.length + r, u;
  }
}
function qv(e, t) {
  const n = t || {}, r = {
    associationId: SF,
    containerPhrasing: $F,
    containerFlow: VF,
    createTracker: PF,
    compilePattern: kF,
    enter: s,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...Kv },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: LF,
    indexStack: [],
    join: [...wF],
    options: {},
    safe: BF,
    stack: [],
    unsafe: [...bF]
  };
  l6(r, n), r.options.tightDefinitions && r.join.push(RF), r.handle = a6("type", {
    invalid: DF,
    unknown: FF,
    handlers: r.handlers
  });
  let i = r.handle(e, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return i && i.charCodeAt(i.length - 1) !== 10 && i.charCodeAt(i.length - 1) !== 13 && (i += `
`), i;
  function s(o) {
    return r.stack.push(o), a;
    function a() {
      r.stack.pop();
    }
  }
}
function DF(e) {
  throw new Error("Cannot handle value `" + e + "`, expected node");
}
function FF(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot handle unknown node `" + t.type + "`");
}
function RF(e, t) {
  if (e.type === "definition" && e.type === t.type)
    return 0;
}
function $F(e, t) {
  return TF(e, this, t);
}
function VF(e, t) {
  return AF(e, this, t);
}
function BF(e, t) {
  return MF(this, e, t);
}
const zF = ["mdxJsxTextElement", "mdxJsxFlowElement"];
function k6(e) {
  return zF.includes(e.type) && T6.includes(e.name.toLowerCase());
}
const T6 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  // 'img',
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function HF(e, t) {
  const n = k_(e), r = k_(t), i = { ...n, ...r };
  return UF(i);
}
function k_(e) {
  const t = {};
  return e.split(";").filter((r) => r.trim() !== "").forEach((r) => {
    const [i, s] = r.split(":").map((o) => o.trim());
    t[i] = s;
  }), t;
}
function UF(e) {
  return Object.entries(e).map(([t, n]) => `${t}: ${n}`).join("; ");
}
function jF(e) {
  return e.children instanceof Array;
}
function A6({
  root: e,
  visitors: t,
  jsxComponentDescriptors: n,
  jsxIsAvailable: r,
  addImportStatements: i = !0
}) {
  let s = null;
  const o = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Map();
  t = t.sort((v, g) => (g.priority ?? 0) - (v.priority ?? 0)), f(e, null);
  function l(v, g) {
    o.add(v), g && a.set(v, { ...g });
  }
  function c(v, g) {
    if (s === null)
      return s = g, s;
    if (!jF(v))
      throw new Error("Attempting to append children to a non-parent");
    const x = v.children, _ = x.at(-1);
    if (_) {
      const b = t.find((C) => {
        var E;
        return (E = C.shouldJoin) == null ? void 0 : E.call(C, _, g);
      });
      if (b) {
        const C = b.join(_, g);
        return x.splice(x.length - 1, 1, C), C;
      }
    }
    return x.push(g), g;
  }
  function u(v, g) {
    v.getChildren().forEach((x) => {
      f(x, g);
    });
  }
  function f(v, g, x = null) {
    var _;
    const b = t.find((C, E) => {
      var S;
      return x != null && x.has(E) ? !1 : (S = C.testLexicalNode) == null ? void 0 : S.call(C, v);
    });
    if (!b)
      throw new Error(`no lexical visitor found for ${v.getType()}`, {
        cause: v
      });
    (_ = b.visitLexicalNode) == null || _.call(b, {
      lexicalNode: v,
      mdastParent: g,
      actions: {
        addAndStepInto(C, E = {}, S = !0) {
          const k = {
            type: C,
            ...E,
            ...S ? { children: [] } : {}
          };
          c(g, k), te(v) && S && u(v, k);
        },
        appendToParent: c,
        visitChildren: u,
        visit: f,
        registerReferredComponent: l,
        nextVisitor() {
          f(v, g, (x ?? /* @__PURE__ */ new Set()).add(t.indexOf(b)));
        }
      }
    });
  }
  if (s === null)
    throw new Error("traversal ended with no root element");
  const d = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
  for (const v of o) {
    const g = n.find((x) => x.name === v) ?? a.get(v) ?? n.find((x) => x.name === "*");
    if (!g)
      throw new Error(`Component ${v} is used but not imported`);
    if (g.source)
      if (g.defaultExport)
        h.set(v, g.source);
      else {
        const { source: x } = g, _ = d.get(x);
        _ ? _.push(v) : d.set(x, [v]);
      }
  }
  if (!i) {
    for (const [v, g] of d.entries()) {
      const x = g.filter((_) => a.has(_));
      x.length > 0 ? d.set(v, x) : d.delete(v);
    }
    for (const v of h.keys())
      a.has(v) || h.delete(v);
  }
  const m = Array.from(d).map(([v, g]) => ({
    type: "mdxjsEsm",
    value: `import { ${g.join(", ")} } from '${v}'`
  }));
  m.push(
    ...Array.from(h).map(([v, g]) => ({
      type: "mdxjsEsm",
      value: `import ${v} from '${g}'`
    }))
  );
  const p = s, y = p.children.find((v) => v.type === "yaml");
  return y ? p.children.splice(p.children.indexOf(y) + 1, 0, ...m) : p.children.unshift(...m), Ff(p, []), N6(p), r || I6(p), p;
}
function N6(e) {
  if ("children" in e && e.children.length > 0) {
    if (k6(e) && e.children.length === 1) {
      const t = e.children[0];
      t.type === "mdxJsxTextElement" && t.name === "span" && (t.attributes.forEach((n) => {
        if (n.type === "mdxJsxAttribute") {
          const r = e.attributes.find((i) => i.type === "mdxJsxAttribute" && i.name === n.name);
          if (r)
            if (n.name === "className") {
              const i = /* @__PURE__ */ new Set([
                ...r.value.split(" "),
                ...n.value.split(" ")
              ]);
              r.value = Array.from(i).join(" ");
            } else n.name === "style" && (r.value = HF(r.value, n.value));
          else
            e.attributes.push(n);
        }
      }), e.children = t.children);
    }
    e.children.forEach((t) => {
      N6(t);
    });
  }
}
function I6(e) {
  if (Object.hasOwn(e, "children")) {
    const t = e, n = [];
    t.children.forEach((r) => {
      r.type === "mdxJsxTextElement" && r.name === "u" ? n.push({ type: "html", value: "<u>" }, ...r.children, { type: "html", value: "</u>" }) : (n.push(r), I6(r));
    }), t.children = n;
  }
}
const T_ = /\s+$/, A_ = /^\s+/;
function Ff(e, t) {
  if (e.type === "strong" || e.type === "emphasis") {
    const n = e.children.at(-1);
    if ((n == null ? void 0 : n.type) === "text") {
      const i = n.value.match(T_);
      if (i) {
        n.value = n.value.replace(T_, "");
        const s = t.at(-1);
        s && (s.children.splice(s.children.indexOf(e) + 1, 0, {
          type: "text",
          value: i[0]
        }), Ff(s, t.slice(0, -1)));
      }
    }
    const r = e.children.at(0);
    if ((r == null ? void 0 : r.type) === "text") {
      const i = r.value.match(A_);
      if (i) {
        r.value = r.value.replace(A_, "");
        const s = t.at(-1);
        s && (s.children.splice(s.children.indexOf(e), 0, {
          type: "text",
          value: i[0]
        }), Ff(s, t.slice(0, -1)));
      }
    }
  }
  if ("children" in e && e.children.length > 0) {
    const n = e;
    n.children.forEach((r) => {
      Ff(r, [...t, n]);
    });
  }
}
function WF({
  root: e,
  toMarkdownOptions: t,
  toMarkdownExtensions: n,
  visitors: r,
  jsxComponentDescriptors: i,
  jsxIsAvailable: s
}) {
  return qv(A6({ root: e, visitors: r, jsxComponentDescriptors: i, jsxIsAvailable: s }), {
    extensions: n,
    ...t
  }) + `
`;
}
const N_ = {}.hasOwnProperty;
function L6(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    JF(t, e[n]);
  return t;
}
function JF(e, t) {
  let n;
  for (n in t) {
    const i = (N_.call(e, n) ? e[n] : void 0) || (e[n] = {}), s = t[n];
    let o;
    if (s)
      for (o in s) {
        N_.call(i, o) || (i[o] = []);
        const a = s[o];
        KF(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function KF(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  nr(e, 0, 0, r);
}
function Ma(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
function gl(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const s = e.charCodeAt(n);
    let o = "";
    if (s === 37 && Tn(e.charCodeAt(n + 1)) && Tn(e.charCodeAt(n + 2)))
      i = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (o = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const a = e.charCodeAt(n + 1);
      s < 56320 && a > 56319 && a < 57344 ? (o = String.fromCharCode(s, a), i = 1) : o = "�";
    } else
      o = String.fromCharCode(s);
    o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + i + 1, o = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
const qF = {
  tokenize: GF
};
function GF(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Ge(e, t, "linePrefix");
  }
  function i(a) {
    return e.enter("paragraph"), s(a);
  }
  function s(a) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, o(a);
  }
  function o(a) {
    if (a === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(a);
      return;
    }
    return be(a) ? (e.consume(a), e.exit("chunkText"), s) : (e.consume(a), o);
  }
}
const YF = {
  tokenize: XF
}, I_ = {
  tokenize: ZF
};
function XF(e) {
  const t = this, n = [];
  let r = 0, i, s, o;
  return a;
  function a(x) {
    if (r < n.length) {
      const _ = n[r];
      return t.containerState = _[1], e.attempt(_[0].continuation, l, c)(x);
    }
    return c(x);
  }
  function l(x) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && g();
      const _ = t.events.length;
      let b = _, C;
      for (; b--; )
        if (t.events[b][0] === "exit" && t.events[b][1].type === "chunkFlow") {
          C = t.events[b][1].end;
          break;
        }
      v(r);
      let E = _;
      for (; E < t.events.length; )
        t.events[E][1].end = {
          ...C
        }, E++;
      return nr(t.events, b + 1, 0, t.events.slice(_)), t.events.length = E, c(x);
    }
    return a(x);
  }
  function c(x) {
    if (r === n.length) {
      if (!i)
        return d(x);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(x);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(I_, u, f)(x);
  }
  function u(x) {
    return i && g(), v(r), d(x);
  }
  function f(x) {
    return t.parser.lazy[t.now().line] = r !== n.length, o = t.now().offset, m(x);
  }
  function d(x) {
    return t.containerState = {}, e.attempt(I_, h, m)(x);
  }
  function h(x) {
    return r++, n.push([t.currentConstruct, t.containerState]), d(x);
  }
  function m(x) {
    if (x === null) {
      i && g(), v(0), e.consume(x);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), p(x);
  }
  function p(x) {
    if (x === null) {
      y(e.exit("chunkFlow"), !0), v(0), e.consume(x);
      return;
    }
    return be(x) ? (e.consume(x), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(x), p);
  }
  function y(x, _) {
    const b = t.sliceStream(x);
    if (_ && b.push(null), x.previous = s, s && (s.next = x), s = x, i.defineSkip(x.start), i.write(b), t.parser.lazy[x.start.line]) {
      let C = i.events.length;
      for (; C--; )
        if (
          // The token starts before the line ending…
          i.events[C][1].start.offset < o && // …and either is not ended yet…
          (!i.events[C][1].end || // …or ends after it.
          i.events[C][1].end.offset > o)
        )
          return;
      const E = t.events.length;
      let S = E, k, M;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          if (k) {
            M = t.events[S][1].end;
            break;
          }
          k = !0;
        }
      for (v(r), C = E; C < t.events.length; )
        t.events[C][1].end = {
          ...M
        }, C++;
      nr(t.events, S + 1, 0, t.events.slice(E)), t.events.length = C;
    }
  }
  function v(x) {
    let _ = n.length;
    for (; _-- > x; ) {
      const b = n[_];
      t.containerState = b[1], b[0].exit.call(t, e);
    }
    n.length = x;
  }
  function g() {
    i.write([null]), s = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function ZF(e, t, n) {
  return Ge(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
const Zg = {
  name: "attention",
  resolveAll: QF,
  tokenize: eR
};
function QF(e, t) {
  let n = -1, r, i, s, o, a, l, c, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = {
            ...e[r][1].end
          }, d = {
            ...e[n][1].start
          };
          L_(f, -l), L_(d, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: {
              ...e[r][1].end
            }
          }, a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: d
          }, s = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...a.end
            }
          }, e[r][1].end = {
            ...o.start
          }, e[n][1].start = {
            ...a.end
          }, c = [], e[r][1].end.offset - e[r][1].start.offset && (c = dr(c, [["enter", e[r][1], t], ["exit", e[r][1], t]])), c = dr(c, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["enter", s, t]]), c = dr(c, yp(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), c = dr(c, [["exit", s, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, c = dr(c, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : u = 0, nr(e, r - 1, n - r + 3, c), n = r + c.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function eR(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Ja(r);
  let s;
  return o;
  function o(l) {
    return s = l, e.enter("attentionSequence"), a(l);
  }
  function a(l) {
    if (l === s)
      return e.consume(l), a;
    const c = e.exit("attentionSequence"), u = Ja(l), f = !u || u === 2 && i || n.includes(l), d = !i || i === 2 && u || n.includes(r);
    return c._open = !!(s === 42 ? f : f && (i || !d)), c._close = !!(s === 42 ? d : d && (u || !f)), t(l);
  }
}
function L_(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const tR = {
  name: "autolink",
  tokenize: nR
};
function nR(e, t, n) {
  let r = 0;
  return i;
  function i(h) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s;
  }
  function s(h) {
    return er(h) ? (e.consume(h), o) : h === 64 ? n(h) : c(h);
  }
  function o(h) {
    return h === 43 || h === 45 || h === 46 || Tn(h) ? (r = 1, a(h)) : c(h);
  }
  function a(h) {
    return h === 58 ? (e.consume(h), r = 0, l) : (h === 43 || h === 45 || h === 46 || Tn(h)) && r++ < 32 ? (e.consume(h), a) : (r = 0, c(h));
  }
  function l(h) {
    return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || Kg(h) ? n(h) : (e.consume(h), l);
  }
  function c(h) {
    return h === 64 ? (e.consume(h), u) : BP(h) ? (e.consume(h), c) : n(h);
  }
  function u(h) {
    return Tn(h) ? f(h) : n(h);
  }
  function f(h) {
    return h === 46 ? (e.consume(h), r = 0, u) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : d(h);
  }
  function d(h) {
    if ((h === 45 || Tn(h)) && r++ < 63) {
      const m = h === 45 ? d : f;
      return e.consume(h), m;
    }
    return n(h);
  }
}
const uu = {
  partial: !0,
  tokenize: rR
};
function rR(e, t, n) {
  return r;
  function r(s) {
    return He(s) ? Ge(e, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || be(s) ? t(s) : n(s);
  }
}
const M6 = {
  continuation: {
    tokenize: sR
  },
  exit: oR,
  name: "blockQuote",
  tokenize: iR
};
function iR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (e.enter("blockQuote", {
        _container: !0
      }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(o), e.exit("blockQuoteMarker"), s;
    }
    return n(o);
  }
  function s(o) {
    return He(o) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(o), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(o));
  }
}
function sR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return He(o) ? Ge(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return e.attempt(M6, t, n)(o);
  }
}
function oR(e) {
  e.exit("blockQuote");
}
const O6 = {
  name: "characterEscape",
  tokenize: aR
};
function aR(e, t, n) {
  return r;
  function r(s) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), i;
  }
  function i(s) {
    return HP(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(s);
  }
}
const P6 = {
  name: "characterReference",
  tokenize: lR
};
function lR(e, t, n) {
  const r = this;
  let i = 0, s, o;
  return a;
  function a(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), s = 31, o = Tn, u(f));
  }
  function c(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, o = zP, u) : (e.enter("characterReferenceValue"), s = 7, o = qg, u(f));
  }
  function u(f) {
    if (f === 59 && i) {
      const d = e.exit("characterReferenceValue");
      return o === Tn && !Ic(r.sliceSerialize(d)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return o(f) && i++ < s ? (e.consume(f), u) : n(f);
  }
}
const M_ = {
  partial: !0,
  tokenize: uR
}, O_ = {
  concrete: !0,
  name: "codeFenced",
  tokenize: cR
};
function cR(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: b
  };
  let s = 0, o = 0, a;
  return l;
  function l(C) {
    return c(C);
  }
  function c(C) {
    const E = r.events[r.events.length - 1];
    return s = E && E[1].type === "linePrefix" ? E[2].sliceSerialize(E[1], !0).length : 0, a = C, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(C);
  }
  function u(C) {
    return C === a ? (o++, e.consume(C), u) : o < 3 ? n(C) : (e.exit("codeFencedFenceSequence"), He(C) ? Ge(e, f, "whitespace")(C) : f(C));
  }
  function f(C) {
    return C === null || be(C) ? (e.exit("codeFencedFence"), r.interrupt ? t(C) : e.check(M_, p, _)(C)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), d(C));
  }
  function d(C) {
    return C === null || be(C) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(C)) : He(C) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Ge(e, h, "whitespace")(C)) : C === 96 && C === a ? n(C) : (e.consume(C), d);
  }
  function h(C) {
    return C === null || be(C) ? f(C) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), m(C));
  }
  function m(C) {
    return C === null || be(C) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(C)) : C === 96 && C === a ? n(C) : (e.consume(C), m);
  }
  function p(C) {
    return e.attempt(i, _, y)(C);
  }
  function y(C) {
    return e.enter("lineEnding"), e.consume(C), e.exit("lineEnding"), v;
  }
  function v(C) {
    return s > 0 && He(C) ? Ge(e, g, "linePrefix", s + 1)(C) : g(C);
  }
  function g(C) {
    return C === null || be(C) ? e.check(M_, p, _)(C) : (e.enter("codeFlowValue"), x(C));
  }
  function x(C) {
    return C === null || be(C) ? (e.exit("codeFlowValue"), g(C)) : (e.consume(C), x);
  }
  function _(C) {
    return e.exit("codeFenced"), t(C);
  }
  function b(C, E, S) {
    let k = 0;
    return M;
    function M(P) {
      return C.enter("lineEnding"), C.consume(P), C.exit("lineEnding"), O;
    }
    function O(P) {
      return C.enter("codeFencedFence"), He(P) ? Ge(C, R, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(P) : R(P);
    }
    function R(P) {
      return P === a ? (C.enter("codeFencedFenceSequence"), I(P)) : S(P);
    }
    function I(P) {
      return P === a ? (k++, C.consume(P), I) : k >= o ? (C.exit("codeFencedFenceSequence"), He(P) ? Ge(C, H, "whitespace")(P) : H(P)) : S(P);
    }
    function H(P) {
      return P === null || be(P) ? (C.exit("codeFencedFence"), E(P)) : S(P);
    }
  }
}
function uR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? n(o) : (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
const R1 = {
  name: "codeIndented",
  tokenize: dR
}, fR = {
  partial: !0,
  tokenize: hR
};
function dR(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), Ge(e, s, "linePrefix", 5)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : n(c);
  }
  function o(c) {
    return c === null ? l(c) : be(c) ? e.attempt(fR, o, l)(c) : (e.enter("codeFlowValue"), a(c));
  }
  function a(c) {
    return c === null || be(c) ? (e.exit("codeFlowValue"), o(c)) : (e.consume(c), a);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function hR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : be(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), i) : Ge(e, s, "linePrefix", 5)(o);
  }
  function s(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(o) : be(o) ? i(o) : n(o);
  }
}
const pR = {
  name: "codeText",
  previous: gR,
  resolve: mR,
  tokenize: vR
};
function mR(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function gR(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function vR(e, t, n) {
  let r = 0, i, s;
  return o;
  function o(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), a(f);
  }
  function a(f) {
    return f === 96 ? (e.consume(f), r++, a) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (s = e.enter("codeTextSequence"), i = 0, u(f)) : be(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(f));
  }
  function c(f) {
    return f === null || f === 32 || f === 96 || be(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), c);
  }
  function u(f) {
    return f === 96 ? (e.consume(f), i++, u) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (s.type = "codeTextData", c(f));
  }
}
class yR {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && $l(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), $l(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), $l(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        $l(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        $l(this.left, n.reverse());
      }
  }
}
function $l(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function D6(e) {
  const t = {};
  let n = -1, r, i, s, o, a, l, c;
  const u = new yR(e);
  for (; ++n < u.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = u.get(n), n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, s = 0, s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2), s < l.length && l[s][1].type === "content"))
      for (; ++s < l.length && l[s][1].type !== "content"; )
        l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, xR(u, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (s = n, i = void 0; s--; )
        if (o = u.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
        else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, a = u.slice(i, n), a.unshift(r), u.splice(i, n - i + 1, a));
    }
  }
  return nr(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function xR(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const s = [];
  let o = n._tokenizer;
  o || (o = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0));
  const a = o.events, l = [], c = {};
  let u, f, d = -1, h = n, m = 0, p = 0;
  const y = [p];
  for (; h; ) {
    for (; e.get(++i)[1] !== h; )
      ;
    s.push(i), h._tokenizer || (u = r.sliceStream(h), h.next || u.push(null), f && o.defineSkip(h.start), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), f = h, h = h.next;
  }
  for (h = n; ++d < a.length; )
    // Find a void token that includes a break.
    a[d][0] === "exit" && a[d - 1][0] === "enter" && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (p = d + 1, y.push(p), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (o.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : y.pop(), d = y.length; d--; ) {
    const v = a.slice(y[d], y[d + 1]), g = s.pop();
    l.push([g, g + v.length - 1]), e.splice(g, 2, v);
  }
  for (l.reverse(), d = -1; ++d < l.length; )
    c[m + l[d][0]] = m + l[d][1], m += l[d][1] - l[d][0] - 1;
  return c;
}
const wR = {
  resolve: bR,
  tokenize: CR
}, _R = {
  partial: !0,
  tokenize: ER
};
function bR(e) {
  return D6(e), e;
}
function CR(e, t) {
  let n;
  return r;
  function r(a) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? s(a) : be(a) ? e.check(_R, o, s)(a) : (e.consume(a), i);
  }
  function s(a) {
    return e.exit("chunkContent"), e.exit("content"), t(a);
  }
  function o(a) {
    return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function ER(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), Ge(e, s, "linePrefix");
  }
  function s(o) {
    if (o === null || be(o))
      return n(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(o) : e.interrupt(r.parser.constructs.flow, n, t)(o);
  }
}
function F6(e, t, n, r, i, s, o, a, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return f;
  function f(v) {
    return v === 60 ? (e.enter(r), e.enter(i), e.enter(s), e.consume(v), e.exit(s), d) : v === null || v === 32 || v === 41 || Kg(v) ? n(v) : (e.enter(r), e.enter(o), e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), p(v));
  }
  function d(v) {
    return v === 62 ? (e.enter(s), e.consume(v), e.exit(s), e.exit(i), e.exit(r), t) : (e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), h(v));
  }
  function h(v) {
    return v === 62 ? (e.exit("chunkString"), e.exit(a), d(v)) : v === null || v === 60 || be(v) ? n(v) : (e.consume(v), v === 92 ? m : h);
  }
  function m(v) {
    return v === 60 || v === 62 || v === 92 ? (e.consume(v), h) : h(v);
  }
  function p(v) {
    return !u && (v === null || v === 41 || ut(v)) ? (e.exit("chunkString"), e.exit(a), e.exit(o), e.exit(r), t(v)) : u < c && v === 40 ? (e.consume(v), u++, p) : v === 41 ? (e.consume(v), u--, p) : v === null || v === 32 || v === 40 || Kg(v) ? n(v) : (e.consume(v), v === 92 ? y : p);
  }
  function y(v) {
    return v === 40 || v === 41 || v === 92 ? (e.consume(v), p) : p(v);
  }
}
function R6(e, t, n, r, i, s) {
  const o = this;
  let a = 0, l;
  return c;
  function c(h) {
    return e.enter(r), e.enter(i), e.consume(h), e.exit(i), e.enter(s), u;
  }
  function u(h) {
    return a > 999 || h === null || h === 91 || h === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs ? n(h) : h === 93 ? (e.exit(s), e.enter(i), e.consume(h), e.exit(i), e.exit(r), t) : be(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), f(h));
  }
  function f(h) {
    return h === null || h === 91 || h === 93 || be(h) || a++ > 999 ? (e.exit("chunkString"), u(h)) : (e.consume(h), l || (l = !He(h)), h === 92 ? d : f);
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), a++, f) : f(h);
  }
}
function $6(e, t, n, r, i, s) {
  let o;
  return a;
  function a(d) {
    return d === 34 || d === 39 || d === 40 ? (e.enter(r), e.enter(i), e.consume(d), e.exit(i), o = d === 40 ? 41 : d, l) : n(d);
  }
  function l(d) {
    return d === o ? (e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : (e.enter(s), c(d));
  }
  function c(d) {
    return d === o ? (e.exit(s), l(o)) : d === null ? n(d) : be(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), Ge(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(d));
  }
  function u(d) {
    return d === o || d === null || be(d) ? (e.exit("chunkString"), c(d)) : (e.consume(d), d === 92 ? f : u);
  }
  function f(d) {
    return d === o || d === 92 ? (e.consume(d), u) : u(d);
  }
}
function Wi(e, t) {
  let n;
  return r;
  function r(i) {
    return be(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : He(i) ? Ge(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const SR = {
  name: "definition",
  tokenize: TR
}, kR = {
  partial: !0,
  tokenize: AR
};
function TR(e, t, n) {
  const r = this;
  let i;
  return s;
  function s(h) {
    return e.enter("definition"), o(h);
  }
  function o(h) {
    return R6.call(
      r,
      e,
      a,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function a(h) {
    return i = Ma(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), l) : n(h);
  }
  function l(h) {
    return ut(h) ? Wi(e, c)(h) : c(h);
  }
  function c(h) {
    return F6(
      e,
      u,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function u(h) {
    return e.attempt(kR, f, f)(h);
  }
  function f(h) {
    return He(h) ? Ge(e, d, "whitespace")(h) : d(h);
  }
  function d(h) {
    return h === null || be(h) ? (e.exit("definition"), r.parser.defined.push(i), t(h)) : n(h);
  }
}
function AR(e, t, n) {
  return r;
  function r(a) {
    return ut(a) ? Wi(e, i)(a) : n(a);
  }
  function i(a) {
    return $6(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function s(a) {
    return He(a) ? Ge(e, o, "whitespace")(a) : o(a);
  }
  function o(a) {
    return a === null || be(a) ? t(a) : n(a);
  }
}
const NR = {
  name: "hardBreakEscape",
  tokenize: IR
};
function IR(e, t, n) {
  return r;
  function r(s) {
    return e.enter("hardBreakEscape"), e.consume(s), i;
  }
  function i(s) {
    return be(s) ? (e.exit("hardBreakEscape"), t(s)) : n(s);
  }
}
const LR = {
  name: "headingAtx",
  resolve: MR,
  tokenize: OR
};
function MR(e, t) {
  let n = e.length - 2, r = 3, i, s;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, s = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, nr(e, r, n - r + 1, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]])), e;
}
function OR(e, t, n) {
  let r = 0;
  return i;
  function i(u) {
    return e.enter("atxHeading"), s(u);
  }
  function s(u) {
    return e.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), o) : u === null || ut(u) ? (e.exit("atxHeadingSequence"), a(u)) : n(u);
  }
  function a(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), l(u)) : u === null || be(u) ? (e.exit("atxHeading"), t(u)) : He(u) ? Ge(e, a, "whitespace")(u) : (e.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (e.consume(u), l) : (e.exit("atxHeadingSequence"), a(u));
  }
  function c(u) {
    return u === null || u === 35 || ut(u) ? (e.exit("atxHeadingText"), a(u)) : (e.consume(u), c);
  }
}
const PR = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], P_ = ["pre", "script", "style", "textarea"], DR = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: $R,
  tokenize: VR
}, FR = {
  partial: !0,
  tokenize: zR
}, RR = {
  partial: !0,
  tokenize: BR
};
function $R(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function VR(e, t, n) {
  const r = this;
  let i, s, o, a, l;
  return c;
  function c(F) {
    return u(F);
  }
  function u(F) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(F), f;
  }
  function f(F) {
    return F === 33 ? (e.consume(F), d) : F === 47 ? (e.consume(F), s = !0, p) : F === 63 ? (e.consume(F), i = 3, r.interrupt ? t : N) : er(F) ? (e.consume(F), o = String.fromCharCode(F), y) : n(F);
  }
  function d(F) {
    return F === 45 ? (e.consume(F), i = 2, h) : F === 91 ? (e.consume(F), i = 5, a = 0, m) : er(F) ? (e.consume(F), i = 4, r.interrupt ? t : N) : n(F);
  }
  function h(F) {
    return F === 45 ? (e.consume(F), r.interrupt ? t : N) : n(F);
  }
  function m(F) {
    const ue = "CDATA[";
    return F === ue.charCodeAt(a++) ? (e.consume(F), a === ue.length ? r.interrupt ? t : R : m) : n(F);
  }
  function p(F) {
    return er(F) ? (e.consume(F), o = String.fromCharCode(F), y) : n(F);
  }
  function y(F) {
    if (F === null || F === 47 || F === 62 || ut(F)) {
      const ue = F === 47, pe = o.toLowerCase();
      return !ue && !s && P_.includes(pe) ? (i = 1, r.interrupt ? t(F) : R(F)) : PR.includes(o.toLowerCase()) ? (i = 6, ue ? (e.consume(F), v) : r.interrupt ? t(F) : R(F)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(F) : s ? g(F) : x(F));
    }
    return F === 45 || Tn(F) ? (e.consume(F), o += String.fromCharCode(F), y) : n(F);
  }
  function v(F) {
    return F === 62 ? (e.consume(F), r.interrupt ? t : R) : n(F);
  }
  function g(F) {
    return He(F) ? (e.consume(F), g) : M(F);
  }
  function x(F) {
    return F === 47 ? (e.consume(F), M) : F === 58 || F === 95 || er(F) ? (e.consume(F), _) : He(F) ? (e.consume(F), x) : M(F);
  }
  function _(F) {
    return F === 45 || F === 46 || F === 58 || F === 95 || Tn(F) ? (e.consume(F), _) : b(F);
  }
  function b(F) {
    return F === 61 ? (e.consume(F), C) : He(F) ? (e.consume(F), b) : x(F);
  }
  function C(F) {
    return F === null || F === 60 || F === 61 || F === 62 || F === 96 ? n(F) : F === 34 || F === 39 ? (e.consume(F), l = F, E) : He(F) ? (e.consume(F), C) : S(F);
  }
  function E(F) {
    return F === l ? (e.consume(F), l = null, k) : F === null || be(F) ? n(F) : (e.consume(F), E);
  }
  function S(F) {
    return F === null || F === 34 || F === 39 || F === 47 || F === 60 || F === 61 || F === 62 || F === 96 || ut(F) ? b(F) : (e.consume(F), S);
  }
  function k(F) {
    return F === 47 || F === 62 || He(F) ? x(F) : n(F);
  }
  function M(F) {
    return F === 62 ? (e.consume(F), O) : n(F);
  }
  function O(F) {
    return F === null || be(F) ? R(F) : He(F) ? (e.consume(F), O) : n(F);
  }
  function R(F) {
    return F === 45 && i === 2 ? (e.consume(F), W) : F === 60 && i === 1 ? (e.consume(F), G) : F === 62 && i === 4 ? (e.consume(F), U) : F === 63 && i === 3 ? (e.consume(F), N) : F === 93 && i === 5 ? (e.consume(F), X) : be(F) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(FR, ee, I)(F)) : F === null || be(F) ? (e.exit("htmlFlowData"), I(F)) : (e.consume(F), R);
  }
  function I(F) {
    return e.check(RR, H, ee)(F);
  }
  function H(F) {
    return e.enter("lineEnding"), e.consume(F), e.exit("lineEnding"), P;
  }
  function P(F) {
    return F === null || be(F) ? I(F) : (e.enter("htmlFlowData"), R(F));
  }
  function W(F) {
    return F === 45 ? (e.consume(F), N) : R(F);
  }
  function G(F) {
    return F === 47 ? (e.consume(F), o = "", J) : R(F);
  }
  function J(F) {
    if (F === 62) {
      const ue = o.toLowerCase();
      return P_.includes(ue) ? (e.consume(F), U) : R(F);
    }
    return er(F) && o.length < 8 ? (e.consume(F), o += String.fromCharCode(F), J) : R(F);
  }
  function X(F) {
    return F === 93 ? (e.consume(F), N) : R(F);
  }
  function N(F) {
    return F === 62 ? (e.consume(F), U) : F === 45 && i === 2 ? (e.consume(F), N) : R(F);
  }
  function U(F) {
    return F === null || be(F) ? (e.exit("htmlFlowData"), ee(F)) : (e.consume(F), U);
  }
  function ee(F) {
    return e.exit("htmlFlow"), t(F);
  }
}
function BR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return be(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), s) : n(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
function zR(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(uu, t, n);
  }
}
const HR = {
  name: "htmlText",
  tokenize: UR
};
function UR(e, t, n) {
  const r = this;
  let i, s, o;
  return a;
  function a(N) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(N), l;
  }
  function l(N) {
    return N === 33 ? (e.consume(N), c) : N === 47 ? (e.consume(N), b) : N === 63 ? (e.consume(N), x) : er(N) ? (e.consume(N), S) : n(N);
  }
  function c(N) {
    return N === 45 ? (e.consume(N), u) : N === 91 ? (e.consume(N), s = 0, m) : er(N) ? (e.consume(N), g) : n(N);
  }
  function u(N) {
    return N === 45 ? (e.consume(N), h) : n(N);
  }
  function f(N) {
    return N === null ? n(N) : N === 45 ? (e.consume(N), d) : be(N) ? (o = f, G(N)) : (e.consume(N), f);
  }
  function d(N) {
    return N === 45 ? (e.consume(N), h) : f(N);
  }
  function h(N) {
    return N === 62 ? W(N) : N === 45 ? d(N) : f(N);
  }
  function m(N) {
    const U = "CDATA[";
    return N === U.charCodeAt(s++) ? (e.consume(N), s === U.length ? p : m) : n(N);
  }
  function p(N) {
    return N === null ? n(N) : N === 93 ? (e.consume(N), y) : be(N) ? (o = p, G(N)) : (e.consume(N), p);
  }
  function y(N) {
    return N === 93 ? (e.consume(N), v) : p(N);
  }
  function v(N) {
    return N === 62 ? W(N) : N === 93 ? (e.consume(N), v) : p(N);
  }
  function g(N) {
    return N === null || N === 62 ? W(N) : be(N) ? (o = g, G(N)) : (e.consume(N), g);
  }
  function x(N) {
    return N === null ? n(N) : N === 63 ? (e.consume(N), _) : be(N) ? (o = x, G(N)) : (e.consume(N), x);
  }
  function _(N) {
    return N === 62 ? W(N) : x(N);
  }
  function b(N) {
    return er(N) ? (e.consume(N), C) : n(N);
  }
  function C(N) {
    return N === 45 || Tn(N) ? (e.consume(N), C) : E(N);
  }
  function E(N) {
    return be(N) ? (o = E, G(N)) : He(N) ? (e.consume(N), E) : W(N);
  }
  function S(N) {
    return N === 45 || Tn(N) ? (e.consume(N), S) : N === 47 || N === 62 || ut(N) ? k(N) : n(N);
  }
  function k(N) {
    return N === 47 ? (e.consume(N), W) : N === 58 || N === 95 || er(N) ? (e.consume(N), M) : be(N) ? (o = k, G(N)) : He(N) ? (e.consume(N), k) : W(N);
  }
  function M(N) {
    return N === 45 || N === 46 || N === 58 || N === 95 || Tn(N) ? (e.consume(N), M) : O(N);
  }
  function O(N) {
    return N === 61 ? (e.consume(N), R) : be(N) ? (o = O, G(N)) : He(N) ? (e.consume(N), O) : k(N);
  }
  function R(N) {
    return N === null || N === 60 || N === 61 || N === 62 || N === 96 ? n(N) : N === 34 || N === 39 ? (e.consume(N), i = N, I) : be(N) ? (o = R, G(N)) : He(N) ? (e.consume(N), R) : (e.consume(N), H);
  }
  function I(N) {
    return N === i ? (e.consume(N), i = void 0, P) : N === null ? n(N) : be(N) ? (o = I, G(N)) : (e.consume(N), I);
  }
  function H(N) {
    return N === null || N === 34 || N === 39 || N === 60 || N === 61 || N === 96 ? n(N) : N === 47 || N === 62 || ut(N) ? k(N) : (e.consume(N), H);
  }
  function P(N) {
    return N === 47 || N === 62 || ut(N) ? k(N) : n(N);
  }
  function W(N) {
    return N === 62 ? (e.consume(N), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(N);
  }
  function G(N) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), J;
  }
  function J(N) {
    return He(N) ? Ge(e, X, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(N) : X(N);
  }
  function X(N) {
    return e.enter("htmlTextData"), o(N);
  }
}
const Gv = {
  name: "labelEnd",
  resolveAll: KR,
  resolveTo: qR,
  tokenize: GR
}, jR = {
  tokenize: YR
}, WR = {
  tokenize: XR
}, JR = {
  tokenize: ZR
};
function KR(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && nr(e, 0, e.length, n), e;
}
function qR(e, t) {
  let n = e.length, r = 0, i, s, o, a;
  for (; n--; )
    if (i = e[n][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = n);
  const l = {
    type: e[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...e[s + r + 2][1].end
    },
    end: {
      ...e[o - 2][1].start
    }
  };
  return a = [["enter", l, t], ["enter", c, t]], a = dr(a, e.slice(s + 1, s + r + 3)), a = dr(a, [["enter", u, t]]), a = dr(a, yp(t.parser.constructs.insideSpan.null, e.slice(s + r + 4, o - 3), t)), a = dr(a, [["exit", u, t], e[o - 2], e[o - 1], ["exit", c, t]]), a = dr(a, e.slice(o + 1)), a = dr(a, [["exit", l, t]]), nr(e, s, e.length, a), e;
}
function GR(e, t, n) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return a;
  function a(d) {
    return s ? s._inactive ? f(d) : (o = r.parser.defined.includes(Ma(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(d), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(d);
  }
  function l(d) {
    return d === 40 ? e.attempt(jR, u, o ? u : f)(d) : d === 91 ? e.attempt(WR, u, o ? c : f)(d) : o ? u(d) : f(d);
  }
  function c(d) {
    return e.attempt(JR, u, f)(d);
  }
  function u(d) {
    return t(d);
  }
  function f(d) {
    return s._balanced = !0, n(d);
  }
}
function YR(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), i;
  }
  function i(f) {
    return ut(f) ? Wi(e, s)(f) : s(f);
  }
  function s(f) {
    return f === 41 ? u(f) : F6(e, o, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(f);
  }
  function o(f) {
    return ut(f) ? Wi(e, l)(f) : u(f);
  }
  function a(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? $6(e, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(f) : u(f);
  }
  function c(f) {
    return ut(f) ? Wi(e, u)(f) : u(f);
  }
  function u(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function XR(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return R6.call(r, e, s, o, "reference", "referenceMarker", "referenceString")(a);
  }
  function s(a) {
    return r.parser.defined.includes(Ma(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(a) : n(a);
  }
  function o(a) {
    return n(a);
  }
}
function ZR(e, t, n) {
  return r;
  function r(s) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : n(s);
  }
}
const QR = {
  name: "labelStartImage",
  resolveAll: Gv.resolveAll,
  tokenize: e$
};
function e$(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), s;
  }
  function s(a) {
    return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), o) : n(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const t$ = {
  name: "labelStartLink",
  resolveAll: Gv.resolveAll,
  tokenize: n$
};
function n$(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const $1 = {
  name: "lineEnding",
  tokenize: r$
};
function r$(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Ge(e, t, "linePrefix");
  }
}
const Rf = {
  name: "thematicBreak",
  tokenize: i$
};
function i$(e, t, n) {
  let r = 0, i;
  return s;
  function s(c) {
    return e.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, a(c);
  }
  function a(c) {
    return c === i ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || be(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === i ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), He(c) ? Ge(e, a, "whitespace")(c) : a(c));
  }
}
const Vn = {
  continuation: {
    tokenize: l$
  },
  exit: u$,
  name: "list",
  tokenize: a$
}, s$ = {
  partial: !0,
  tokenize: f$
}, o$ = {
  partial: !0,
  tokenize: c$
};
function a$(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return a;
  function a(h) {
    const m = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : qg(h)) {
      if (r.containerState.type || (r.containerState.type = m, e.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(Rf, n, c)(h) : c(h);
      if (!r.interrupt || h === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(h);
    }
    return n(h);
  }
  function l(h) {
    return qg(h) && ++o < 10 ? (e.consume(h), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), c(h)) : n(h);
  }
  function c(h) {
    return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(
      uu,
      // Can’t be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(s$, d, f)
    );
  }
  function u(h) {
    return r.containerState.initialBlankLine = !0, s++, d(h);
  }
  function f(h) {
    return He(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), d) : n(h);
  }
  function d(h) {
    return r.containerState.size = s + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h);
  }
}
function l$(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(uu, i, s);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Ge(e, t, "listItemIndent", r.containerState.size + 1)(a);
  }
  function s(a) {
    return r.containerState.furtherBlankLines || !He(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(o$, t, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Ge(e, e.attempt(Vn, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function c$(e, t, n) {
  const r = this;
  return Ge(e, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(s) : n(s);
  }
}
function u$(e) {
  e.exit(this.containerState.type);
}
function f$(e, t, n) {
  const r = this;
  return Ge(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !He(s) && o && o[1].type === "listItemPrefixWhitespace" ? t(s) : n(s);
  }
}
const D_ = {
  name: "setextUnderline",
  resolveTo: d$,
  tokenize: h$
};
function d$(e, t) {
  let n = e.length, r, i, s;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !s && e[n][1].type === "definition" && (s = n);
  const o = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", s ? (e.splice(i, 0, ["enter", o, t]), e.splice(s + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[s][1].end
  }) : e[r][1] = o, e.push(["exit", o, t]), e;
}
function h$(e, t, n) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length, f;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        f = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), i = c, o(c)) : n(c);
  }
  function o(c) {
    return e.enter("setextHeadingLineSequence"), a(c);
  }
  function a(c) {
    return c === i ? (e.consume(c), a) : (e.exit("setextHeadingLineSequence"), He(c) ? Ge(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || be(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const p$ = {
  tokenize: m$
};
function m$(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    uu,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, Ge(e, e.attempt(this.parser.constructs.flow, i, e.attempt(wR, i)), "linePrefix"))
  );
  return n;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const g$ = {
  resolveAll: B6()
}, v$ = V6("string"), y$ = V6("text");
function V6(e) {
  return {
    resolveAll: B6(e === "text" ? x$ : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], s = n.attempt(i, o, a);
    return o;
    function o(u) {
      return c(u) ? s(u) : a(u);
    }
    function a(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), s(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const f = i[u];
      let d = -1;
      if (f)
        for (; ++d < f.length; ) {
          const h = f[d];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function B6(e) {
  return t;
  function t(n, r) {
    let i = -1, s;
    for (; ++i <= n.length; )
      s === void 0 ? n[i] && n[i][1].type === "data" && (s = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== s + 2 && (n[s][1].end = n[i - 1][1].end, n.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return e ? e(n, r) : n;
  }
}
function x$(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let s = i.length, o = -1, a = 0, l;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          l = !0, a++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (a = 0), a) {
        const c = {
          type: n === e.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? o : r.start._bufferIndex + o,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(n, 0, ["enter", c, t], ["exit", c, t]), n += 2);
      }
      n++;
    }
  return e;
}
const w$ = {
  42: Vn,
  43: Vn,
  45: Vn,
  48: Vn,
  49: Vn,
  50: Vn,
  51: Vn,
  52: Vn,
  53: Vn,
  54: Vn,
  55: Vn,
  56: Vn,
  57: Vn,
  62: M6
}, _$ = {
  91: SR
}, b$ = {
  [-2]: R1,
  [-1]: R1,
  32: R1
}, C$ = {
  35: LR,
  42: Rf,
  45: [D_, Rf],
  60: DR,
  61: D_,
  95: Rf,
  96: O_,
  126: O_
}, E$ = {
  38: P6,
  92: O6
}, S$ = {
  [-5]: $1,
  [-4]: $1,
  [-3]: $1,
  33: QR,
  38: P6,
  42: Zg,
  60: [tR, HR],
  91: t$,
  92: [NR, O6],
  93: Gv,
  95: Zg,
  96: pR
}, k$ = {
  null: [Zg, g$]
}, T$ = {
  null: [42, 95]
}, A$ = {
  null: []
}, N$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: T$,
  contentInitial: _$,
  disable: A$,
  document: w$,
  flow: C$,
  flowInitial: b$,
  insideSpan: k$,
  string: E$,
  text: S$
}, Symbol.toStringTag, { value: "Module" }));
function I$(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, s = [];
  let o = [], a = [];
  const l = {
    attempt: E(b),
    check: E(C),
    consume: g,
    enter: x,
    exit: _,
    interrupt: E(C, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: p,
    events: [],
    now: m,
    parser: e,
    previous: null,
    sliceSerialize: d,
    sliceStream: h,
    write: f
  };
  let u = t.tokenize.call(c, l);
  return t.resolveAll && s.push(t), c;
  function f(O) {
    return o = dr(o, O), y(), o[o.length - 1] !== null ? [] : (S(t, 0), c.events = yp(s, c.events, c), c.events);
  }
  function d(O, R) {
    return M$(h(O), R);
  }
  function h(O) {
    return L$(o, O);
  }
  function m() {
    const {
      _bufferIndex: O,
      _index: R,
      line: I,
      column: H,
      offset: P
    } = r;
    return {
      _bufferIndex: O,
      _index: R,
      line: I,
      column: H,
      offset: P
    };
  }
  function p(O) {
    i[O.line] = O.column, M();
  }
  function y() {
    let O;
    for (; r._index < o.length; ) {
      const R = o[r._index];
      if (typeof R == "string")
        for (O = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === O && r._bufferIndex < R.length; )
          v(R.charCodeAt(r._bufferIndex));
      else
        v(R);
    }
  }
  function v(O) {
    u = u(O);
  }
  function g(O) {
    be(O) ? (r.line++, r.column = 1, r.offset += O === -3 ? 2 : 1, M()) : O !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = O;
  }
  function x(O, R) {
    const I = R || {};
    return I.type = O, I.start = m(), c.events.push(["enter", I, c]), a.push(I), I;
  }
  function _(O) {
    const R = a.pop();
    return R.end = m(), c.events.push(["exit", R, c]), R;
  }
  function b(O, R) {
    S(O, R.from);
  }
  function C(O, R) {
    R.restore();
  }
  function E(O, R) {
    return I;
    function I(H, P, W) {
      let G, J, X, N;
      return Array.isArray(H) ? (
        /* c8 ignore next 1 */
        ee(H)
      ) : "tokenize" in H ? (
        // Looks like a construct.
        ee([
          /** @type {Construct} */
          H
        ])
      ) : U(H);
      function U(ce) {
        return q;
        function q(Z) {
          const oe = Z !== null && ce[Z], le = Z !== null && ce.null, ie = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(oe) ? oe : oe ? [oe] : [],
            ...Array.isArray(le) ? le : le ? [le] : []
          ];
          return ee(ie)(Z);
        }
      }
      function ee(ce) {
        return G = ce, J = 0, ce.length === 0 ? W : F(ce[J]);
      }
      function F(ce) {
        return q;
        function q(Z) {
          return N = k(), X = ce, ce.partial || (c.currentConstruct = ce), ce.name && c.parser.constructs.disable.null.includes(ce.name) ? pe() : ce.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            R ? Object.assign(Object.create(c), R) : c,
            l,
            ue,
            pe
          )(Z);
        }
      }
      function ue(ce) {
        return O(X, N), P;
      }
      function pe(ce) {
        return N.restore(), ++J < G.length ? F(G[J]) : W;
      }
    }
  }
  function S(O, R) {
    O.resolveAll && !s.includes(O) && s.push(O), O.resolve && nr(c.events, R, c.events.length - R, O.resolve(c.events.slice(R), c)), O.resolveTo && (c.events = O.resolveTo(c.events, c));
  }
  function k() {
    const O = m(), R = c.previous, I = c.currentConstruct, H = c.events.length, P = Array.from(a);
    return {
      from: H,
      restore: W
    };
    function W() {
      r = O, c.previous = R, c.currentConstruct = I, c.events.length = H, a = P, M();
    }
  }
  function M() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function L$(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, s = t.end._bufferIndex;
  let o;
  if (n === i)
    o = [e[n].slice(r, s)];
  else {
    if (o = e.slice(n, i), r > -1) {
      const a = o[0];
      typeof a == "string" ? o[0] = a.slice(r) : o.shift();
    }
    s > 0 && o.push(e[i].slice(0, s));
  }
  return o;
}
function M$(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const s = e[n];
    let o;
    if (typeof s == "string")
      o = s;
    else switch (s) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(s);
    }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
function O$(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      L6([N$, ...(e || {}).extensions || []])
    ),
    content: i(qF),
    defined: [],
    document: i(YF),
    flow: i(p$),
    lazy: {},
    string: i(v$),
    text: i(y$)
  };
  return r;
  function i(s) {
    return o;
    function o(a) {
      return I$(r, s, a);
    }
  }
}
function P$(e) {
  for (; !D6(e); )
    ;
  return e;
}
const F_ = /[\0\t\n\r]/g;
function D$() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(s, o, a) {
    const l = [];
    let c, u, f, d, h;
    for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), f = 0, t = "", n && (s.charCodeAt(0) === 65279 && f++, n = void 0); f < s.length; ) {
      if (F_.lastIndex = f, c = F_.exec(s), d = c && c.index !== void 0 ? c.index : s.length, h = s.charCodeAt(d), !c) {
        t = s.slice(f);
        break;
      }
      if (h === 10 && f === d && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < d && (l.push(s.slice(f, d)), e += d - f), h) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, l.push(-2); e++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = d + 1;
    }
    return a && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const z6 = {}.hasOwnProperty;
function Ud(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), F$(n)(P$(O$(n).document().write(D$()(e, t, !0))));
}
function F$(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(bt),
      autolinkProtocol: k,
      autolinkEmail: k,
      atxHeading: s(je),
      blockQuote: s(le),
      characterEscape: k,
      characterReference: k,
      codeFenced: s(ie),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(ie, o),
      codeText: s(Y, o),
      codeTextData: k,
      data: k,
      codeFlowValue: k,
      definition: s(Ce),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(Fe),
      hardBreakEscape: s(Ze),
      hardBreakTrailing: s(Ze),
      htmlFlow: s(mt, o),
      htmlFlowData: k,
      htmlText: s(mt, o),
      htmlTextData: k,
      image: s(xn),
      label: o,
      link: s(bt),
      listItem: s(K),
      listItemValue: d,
      listOrdered: s(z, f),
      listUnordered: s(z),
      paragraph: s(Q),
      reference: F,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(je),
      strong: s(se),
      thematicBreak: s(he)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: b,
      autolink: l(),
      autolinkEmail: oe,
      autolinkProtocol: Z,
      blockQuote: l(),
      characterEscapeValue: M,
      characterReferenceMarkerHexadecimal: pe,
      characterReferenceMarkerNumeric: pe,
      characterReferenceValue: ce,
      characterReference: q,
      codeFenced: l(y),
      codeFencedFence: p,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: m,
      codeFlowValue: M,
      codeIndented: l(v),
      codeText: l(P),
      codeTextData: M,
      data: M,
      definition: l(),
      definitionDestinationString: _,
      definitionLabelString: g,
      definitionTitleString: x,
      emphasis: l(),
      hardBreakEscape: l(R),
      hardBreakTrailing: l(R),
      htmlFlow: l(I),
      htmlFlowData: M,
      htmlText: l(H),
      htmlTextData: M,
      image: l(G),
      label: X,
      labelText: J,
      lineEnding: O,
      link: l(W),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: ue,
      resourceDestinationString: N,
      resourceTitleString: U,
      resource: ee,
      setextHeading: l(S),
      setextHeadingLineSequence: E,
      setextHeadingText: C,
      strong: l(),
      thematicBreak: l()
    }
  };
  H6(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(j) {
    let re = {
      type: "root",
      children: []
    };
    const D = {
      stack: [re],
      tokenStack: [],
      config: t,
      enter: a,
      exit: c,
      buffer: o,
      resume: u,
      data: n
    }, Ie = [];
    let Ue = -1;
    for (; ++Ue < j.length; )
      if (j[Ue][1].type === "listOrdered" || j[Ue][1].type === "listUnordered")
        if (j[Ue][0] === "enter")
          Ie.push(Ue);
        else {
          const et = Ie.pop();
          Ue = i(j, et, Ue);
        }
    for (Ue = -1; ++Ue < j.length; ) {
      const et = t[j[Ue][0]];
      z6.call(et, j[Ue][1].type) && et[j[Ue][1].type].call(Object.assign({
        sliceSerialize: j[Ue][2].sliceSerialize
      }, D), j[Ue][1]);
    }
    if (D.tokenStack.length > 0) {
      const et = D.tokenStack[D.tokenStack.length - 1];
      (et[1] || R_).call(D, void 0, et[0]);
    }
    for (re.position = {
      start: ms(j.length > 0 ? j[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ms(j.length > 0 ? j[j.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ue = -1; ++Ue < t.transforms.length; )
      re = t.transforms[Ue](re) || re;
    return re;
  }
  function i(j, re, D) {
    let Ie = re - 1, Ue = -1, et = !1, Qt, qt, ki, so;
    for (; ++Ie <= D; ) {
      const dn = j[Ie];
      switch (dn[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          dn[0] === "enter" ? Ue++ : Ue--, so = void 0;
          break;
        }
        case "lineEndingBlank": {
          dn[0] === "enter" && (Qt && !so && !Ue && !ki && (ki = Ie), so = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          so = void 0;
      }
      if (!Ue && dn[0] === "enter" && dn[1].type === "listItemPrefix" || Ue === -1 && dn[0] === "exit" && (dn[1].type === "listUnordered" || dn[1].type === "listOrdered")) {
        if (Qt) {
          let hs = Ie;
          for (qt = void 0; hs--; ) {
            const sr = j[hs];
            if (sr[1].type === "lineEnding" || sr[1].type === "lineEndingBlank") {
              if (sr[0] === "exit") continue;
              qt && (j[qt][1].type = "lineEndingBlank", et = !0), sr[1].type = "lineEnding", qt = hs;
            } else if (!(sr[1].type === "linePrefix" || sr[1].type === "blockQuotePrefix" || sr[1].type === "blockQuotePrefixWhitespace" || sr[1].type === "blockQuoteMarker" || sr[1].type === "listItemIndent")) break;
          }
          ki && (!qt || ki < qt) && (Qt._spread = !0), Qt.end = Object.assign({}, qt ? j[qt][1].start : dn[1].end), j.splice(qt || Ie, 0, ["exit", Qt, dn[2]]), Ie++, D++;
        }
        if (dn[1].type === "listItemPrefix") {
          const hs = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, dn[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Qt = hs, j.splice(Ie, 0, ["enter", hs, dn[2]]), Ie++, D++, ki = void 0, so = !0;
        }
      }
    }
    return j[re][1]._spread = et, D;
  }
  function s(j, re) {
    return D;
    function D(Ie) {
      a.call(this, j(Ie), Ie), re && re.call(this, Ie);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a(j, re, D) {
    this.stack[this.stack.length - 1].children.push(j), this.stack.push(j), this.tokenStack.push([re, D || void 0]), j.position = {
      start: ms(re.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(j) {
    return re;
    function re(D) {
      j && j.call(this, D), c.call(this, D);
    }
  }
  function c(j, re) {
    const D = this.stack.pop(), Ie = this.tokenStack.pop();
    if (Ie)
      Ie[0].type !== j.type && (re ? re.call(this, j, Ie[0]) : (Ie[1] || R_).call(this, j, Ie[0]));
    else throw new Error("Cannot close `" + j.type + "` (" + xr({
      start: j.start,
      end: j.end
    }) + "): it’s not open");
    D.position.end = ms(j.end);
  }
  function u() {
    return Wv(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function d(j) {
    if (this.data.expectingFirstListItemValue) {
      const re = this.stack[this.stack.length - 2];
      re.start = Number.parseInt(this.sliceSerialize(j), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function h() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.lang = j;
  }
  function m() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.meta = j;
  }
  function p() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = j.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function v() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = j.replace(/(\r?\n|\r)$/g, "");
  }
  function g(j) {
    const re = this.resume(), D = this.stack[this.stack.length - 1];
    D.label = re, D.identifier = Ma(this.sliceSerialize(j)).toLowerCase();
  }
  function x() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.title = j;
  }
  function _() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.url = j;
  }
  function b(j) {
    const re = this.stack[this.stack.length - 1];
    if (!re.depth) {
      const D = this.sliceSerialize(j).length;
      re.depth = D;
    }
  }
  function C() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function E(j) {
    const re = this.stack[this.stack.length - 1];
    re.depth = this.sliceSerialize(j).codePointAt(0) === 61 ? 1 : 2;
  }
  function S() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function k(j) {
    const D = this.stack[this.stack.length - 1].children;
    let Ie = D[D.length - 1];
    (!Ie || Ie.type !== "text") && (Ie = ne(), Ie.position = {
      start: ms(j.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, D.push(Ie)), this.stack.push(Ie);
  }
  function M(j) {
    const re = this.stack.pop();
    re.value += this.sliceSerialize(j), re.position.end = ms(j.end);
  }
  function O(j) {
    const re = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const D = re.children[re.children.length - 1];
      D.position.end = ms(j.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(re.type) && (k.call(this, j), M.call(this, j));
  }
  function R() {
    this.data.atHardBreak = !0;
  }
  function I() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = j;
  }
  function H() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = j;
  }
  function P() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = j;
  }
  function W() {
    const j = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const re = this.data.referenceType || "shortcut";
      j.type += "Reference", j.referenceType = re, delete j.url, delete j.title;
    } else
      delete j.identifier, delete j.label;
    this.data.referenceType = void 0;
  }
  function G() {
    const j = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const re = this.data.referenceType || "shortcut";
      j.type += "Reference", j.referenceType = re, delete j.url, delete j.title;
    } else
      delete j.identifier, delete j.label;
    this.data.referenceType = void 0;
  }
  function J(j) {
    const re = this.sliceSerialize(j), D = this.stack[this.stack.length - 2];
    D.label = S6(re), D.identifier = Ma(re).toLowerCase();
  }
  function X() {
    const j = this.stack[this.stack.length - 1], re = this.resume(), D = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, D.type === "link") {
      const Ie = j.children;
      D.children = Ie;
    } else
      D.alt = re;
  }
  function N() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.url = j;
  }
  function U() {
    const j = this.resume(), re = this.stack[this.stack.length - 1];
    re.title = j;
  }
  function ee() {
    this.data.inReference = void 0;
  }
  function F() {
    this.data.referenceType = "collapsed";
  }
  function ue(j) {
    const re = this.resume(), D = this.stack[this.stack.length - 1];
    D.label = re, D.identifier = Ma(this.sliceSerialize(j)).toLowerCase(), this.data.referenceType = "full";
  }
  function pe(j) {
    this.data.characterReferenceType = j.type;
  }
  function ce(j) {
    const re = this.sliceSerialize(j), D = this.data.characterReferenceType;
    let Ie;
    D ? (Ie = E6(re, D === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ie = Ic(re);
    const Ue = this.stack[this.stack.length - 1];
    Ue.value += Ie;
  }
  function q(j) {
    const re = this.stack.pop();
    re.position.end = ms(j.end);
  }
  function Z(j) {
    M.call(this, j);
    const re = this.stack[this.stack.length - 1];
    re.url = this.sliceSerialize(j);
  }
  function oe(j) {
    M.call(this, j);
    const re = this.stack[this.stack.length - 1];
    re.url = "mailto:" + this.sliceSerialize(j);
  }
  function le() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function ie() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Y() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ce() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Fe() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function je() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ze() {
    return {
      type: "break"
    };
  }
  function mt() {
    return {
      type: "html",
      value: ""
    };
  }
  function xn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function bt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function z(j) {
    return {
      type: "list",
      ordered: j.type === "listOrdered",
      start: null,
      spread: j._spread,
      children: []
    };
  }
  function K(j) {
    return {
      type: "listItem",
      spread: j._spread,
      checked: null,
      children: []
    };
  }
  function Q() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function se() {
    return {
      type: "strong",
      children: []
    };
  }
  function ne() {
    return {
      type: "text",
      value: ""
    };
  }
  function he() {
    return {
      type: "thematicBreak"
    };
  }
}
function ms(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function H6(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? H6(e, r) : R$(e, r);
  }
}
function R$(e, t) {
  let n;
  for (n in t)
    if (z6.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function R_(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + xr({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + xr({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + xr({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function Vl(e) {
  return e.children instanceof Array;
}
class Qg extends Error {
  constructor(t, n) {
    super(t), this.name = "MarkdownParseError", this.cause = n;
  }
}
class e0 extends Error {
  constructor(t) {
    super(t), this.name = "UnrecognizedMarkdownConstructError";
  }
}
function $$(e) {
  const t = /* @__PURE__ */ new Map();
  return e.type !== "root" ? {
    importDeclarations: {}
  } : (e.children.filter((r) => r.type === "mdxjsEsm").filter((r) => r.value.startsWith("import ")).forEach((r) => {
    var i, s;
    (((s = (i = r.data) == null ? void 0 : i.estree) == null ? void 0 : s.body) ?? []).forEach((o) => {
      o.type === "ImportDeclaration" && o.specifiers.forEach((a) => {
        t.set(a.local.name, {
          source: `${o.source.value}`,
          defaultExport: a.type === "ImportDefaultSpecifier"
        });
      });
    });
  }), {
    importDeclarations: Object.fromEntries(t.entries())
  });
}
function V$({
  root: e,
  markdown: t,
  visitors: n,
  syntaxExtensions: r,
  mdastExtensions: i,
  ...s
}) {
  var o;
  let a;
  try {
    a = Ud(t, {
      extensions: r,
      mdastExtensions: i
    });
  } catch (l) {
    throw l instanceof Error ? new Qg(`Error parsing markdown: ${l.message}`, l) : new Qg(`Error parsing markdown: ${l}`, l);
  }
  a.children.length === 0 && a.children.push({ type: "paragraph", children: [] }), ((o = a.children.at(-1)) == null ? void 0 : o.type) !== "paragraph" && a.children.push({ type: "paragraph", children: [] }), U6({ root: e, mdastRoot: a, visitors: n, ...s });
}
function U6({ root: e, mdastRoot: t, visitors: n, ...r }) {
  const i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), o = $$(t);
  n = n.sort((c, u) => (u.priority ?? 0) - (c.priority ?? 0));
  function a(c, u) {
    if (!Vl(c))
      throw new Error("Attempting to visit children of a non-parent");
    c.children.forEach((f) => {
      l(f, u, c);
    });
  }
  function l(c, u, f, d = null) {
    const h = n.find((m, p) => d != null && d.has(p) ? !1 : typeof m.testNode == "string" ? m.testNode === c.type : m.testNode(c, r));
    if (!h)
      try {
        throw new e0(`Unsupported markdown syntax: ${qv(c)}`);
      } catch {
        throw new e0(
          `Parsing of the following markdown structure failed: ${JSON.stringify({
            type: c.type,
            name: "name" in c ? c.name : "N/A"
          })}`
        );
      }
    h.visitNode({
      //@ts-expect-error root type is glitching
      mdastNode: c,
      lexicalParent: u,
      mdastParent: f,
      descriptors: r,
      metaData: o,
      actions: {
        visitChildren: a,
        nextVisitor() {
          l(c, u, f, (d ?? /* @__PURE__ */ new Set()).add(n.indexOf(h)));
        },
        addAndStepInto(m) {
          u.append(m), Vl(c) && a(c, m);
        },
        addFormatting(m, p) {
          p || Vl(c) && (p = c), p && i.set(p, m | (i.get(f) ?? 0));
        },
        removeFormatting(m, p) {
          p || Vl(c) && (p = c), p && i.set(p, m ^ (i.get(f) ?? 0));
        },
        getParentFormatting() {
          return i.get(f) ?? 0;
        },
        addStyle(m, p) {
          p || Vl(c) && (p = c), p && s.set(p, m);
        },
        getParentStyle() {
          return s.get(f) ?? "";
        }
      }
    });
  }
  l(t, e, null);
}
var B$ = Object.defineProperty, z$ = (e, t, n) => t in e ? B$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, V1 = (e, t, n) => (z$(e, typeof t != "symbol" ? t + "" : t, n), n);
const $_ = "generic-html";
class fu extends Wn {
  /**
   * Constructs a new {@link GenericHTMLNode} with the specified MDAST HTML node as the object to edit.
   */
  constructor(t, n, r, i) {
    super(i), V1(this, "__tag"), V1(this, "__nodeType"), V1(this, "__attributes"), this.__tag = t, this.__nodeType = n, this.__attributes = r;
  }
  /** @internal */
  static getType() {
    return $_;
  }
  /** @internal */
  static clone(t) {
    return new fu(t.__tag, t.__nodeType, t.__attributes, t.__key);
  }
  getTag() {
    return this.__tag;
  }
  getNodeType() {
    return this.__nodeType;
  }
  getAttributes() {
    return this.__attributes;
  }
  updateAttributes(t) {
    const n = this.getWritable();
    n.__attributes = t;
  }
  getStyle() {
    var t;
    return (t = this.__attributes.find((n) => n.name === "style")) == null ? void 0 : t.value;
  }
  // View
  createDOM() {
    const t = this.__tag, n = document.createElement(t);
    return this.__attributes.forEach((r) => {
      n.setAttribute(r.name, r.value);
    }), n;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    return {
      element: n
    };
  }
  static importJSON(t) {
    const n = j6(t.tag, t.mdxType, t.attributes);
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      tag: this.getTag(),
      attributes: this.__attributes,
      mdxType: this.__nodeType,
      type: $_,
      version: 1
    };
  }
  /*
    // Mutation
    insertNewAfter(selection?: RangeSelection, restoreSelection = true): ParagraphNode | GenericHTMLNode {
      const anchorOffet = selection ? selection.anchor.offset : 0
      const newElement =
        anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const direction = this.getDirection()
      newElement.setDirection(direction)
      this.insertAfter(newElement, restoreSelection)
      return newElement
    }
  
    collapseAtStart(): true {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const children = this.getChildren()
      children.forEach((child) => newElement.append(child))
      this.replace(newElement)
      return true
    }*/
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__nodeType === "mdxJsxTextElement";
  }
}
function j6(e, t, n) {
  return Pn(new fu(e, t, n));
}
function H$(e) {
  return e instanceof fu;
}
const U$ = {
  testLexicalNode: H$,
  visitLexicalNode({ actions: e, lexicalNode: t }) {
    e.addAndStepInto("mdxJsxTextElement", {
      name: t.getTag(),
      type: t.getNodeType(),
      attributes: t.getAttributes()
    });
  },
  priority: -100
}, j$ = {
  testLexicalNode: Rr,
  visitLexicalNode: ({ mdastParent: e, actions: t }) => {
    t.appendToParent(e, { type: "text", value: `
` });
  }
}, W$ = {
  testLexicalNode: Ev,
  visitLexicalNode: ({ actions: e }) => {
    e.addAndStepInto("paragraph");
  }
}, J$ = {
  testLexicalNode: on,
  visitLexicalNode: ({ actions: e }) => {
    e.addAndStepInto("root");
  }
}, lc = 1, cc = 2, $f = 4, uc = 8, _p = 16, Vf = 32, Bf = 64;
function V_(e) {
  return e.type === "text";
}
const K$ = ["u", "span", "sub", "sup"], q$ = {
  shouldJoin: (e, t) => {
    if (["text", "emphasis", "strong"].includes(e.type))
      return e.type === t.type;
    if (e.type === "mdxJsxTextElement" && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    t.type === "mdxJsxTextElement" && K$.includes(t.name)) {
      const n = t;
      return e.name === n.name && JSON.stringify(e.attributes) === JSON.stringify(n.attributes);
    }
    return !1;
  },
  join(e, t) {
    return V_(e) && V_(t) ? {
      type: "text",
      value: e.value + t.value
    } : {
      ...e,
      children: [...e.children, ...t.children]
    };
  },
  testLexicalNode: ye,
  visitLexicalNode: ({ lexicalNode: e, mdastParent: t, actions: n }) => {
    const r = e.getPreviousSibling(), i = ye(r) ? r.getFormat() : 0, s = e.getTextContent(), o = e.getFormat(), a = e.getStyle();
    let l = t;
    if (a && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "span",
      children: [],
      attributes: [{ type: "mdxJsxAttribute", name: "style", value: a }]
    })), i & o & uc && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "u",
      children: [],
      attributes: []
    })), i & o & Bf && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "sup",
      children: [],
      attributes: []
    })), i & o & Vf && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "sub",
      children: [],
      attributes: []
    })), i & o & cc && (l = n.appendToParent(l, {
      type: "emphasis",
      children: []
    })), i & o & lc && (l = n.appendToParent(l, {
      type: "strong",
      children: []
    })), i & o & $f && (l = n.appendToParent(l, {
      type: "delete",
      children: []
    })), o & uc && !(i & uc) && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "u",
      children: [],
      attributes: []
    })), o & Bf && !(i & Bf) && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "sup",
      children: [],
      attributes: []
    })), o & Vf && !(i & Vf) && (l = n.appendToParent(l, {
      type: "mdxJsxTextElement",
      name: "sub",
      children: [],
      attributes: []
    })), o & cc && !(i & cc) && (l = n.appendToParent(l, {
      type: "emphasis",
      children: []
    })), o & lc && !(i & lc) && (l = n.appendToParent(l, {
      type: "strong",
      children: []
    })), o & $f && !(i & $f) && (l = n.appendToParent(l, {
      type: "delete",
      children: []
    })), o & _p) {
      n.appendToParent(l, {
        type: "inlineCode",
        value: s
      });
      return;
    }
    n.appendToParent(l, {
      type: "text",
      value: s
    });
  }
}, G$ = {
  testNode: "break",
  visitNode: function({ lexicalParent: e }) {
    e.append(Br());
  }
};
function Zu(e, t) {
  return [
    {
      testNode: (n) => n.type === "mdxJsxTextElement" && n.name === e,
      visitNode({ actions: n, mdastNode: r, lexicalParent: i }) {
        n.addFormatting(t), n.visitChildren(r, i);
      }
    },
    {
      testNode: (n) => n.type === "html" && n.value === `<${e}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.addFormatting(t, r);
      }
    },
    {
      testNode: (n) => n.type === "html" && n.value === `</${e}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.removeFormatting(t, r);
      }
    }
  ];
}
const Y$ = {
  testNode: "delete",
  visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
    t.addFormatting($f), t.visitChildren(e, n);
  }
}, X$ = {
  testNode: "inlineCode",
  visitNode({ mdastNode: e, actions: t }) {
    t.addAndStepInto(yt(e.value).setFormat(t.getParentFormatting() | _p));
  }
}, Z$ = {
  testNode: "emphasis",
  visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
    t.addFormatting(cc), t.visitChildren(e, n);
  }
}, Q$ = {
  testNode: "strong",
  visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
    t.addFormatting(lc), t.visitChildren(e, n);
  }
}, eV = [
  // emphasis
  Z$,
  // strong
  Q$,
  // underline
  ...Zu("u", uc),
  // code
  ...Zu("code", _p),
  X$,
  // strikethrough
  Y$,
  // superscript
  ...Zu("sup", Bf),
  // subscript
  ...Zu("sub", Vf)
], tV = {
  testNode: k6,
  visitNode: function({ mdastNode: e, actions: t, lexicalParent: n }) {
    e.name === "span" && e.attributes.length === 1 && e.attributes[0].type === "mdxJsxAttribute" && e.attributes[0].name === "style" ? (t.addStyle(e.attributes[0].value, e), t.visitChildren(e, n)) : t.addAndStepInto(j6(e.name, e.type, e.attributes));
  },
  priority: -100
}, nV = ["listitem", "quote", "admonition"], rV = {
  testNode: "paragraph",
  visitNode: function({ mdastNode: e, lexicalParent: t, actions: n }) {
    nV.includes(t.getType()) ? n.visitChildren(e, t) : n.addAndStepInto(st());
  }
}, iV = {
  testNode: "root",
  visitNode({ actions: e, mdastNode: t, lexicalParent: n }) {
    e.visitChildren(t, n);
  }
}, sV = {
  testNode: "text",
  visitNode({ mdastNode: e, actions: t }) {
    const n = yt(e.value);
    n.setFormat(t.getParentFormatting());
    const r = t.getParentStyle();
    r !== "" && n.setStyle(r), t.addAndStepInto(n);
  }
}, W6 = () => /* @__PURE__ */ T.createElement(bP, { externalHistoryState: mn(NV) }), Ar = (
  /** @type {const} */
  {
    eof: null,
    exclamationMark: 33,
    // `!`
    dash: 45,
    // `-`
    greaterThan: 62
  }
), co = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix"
  }
);
function oV(e) {
  return {
    canContainEols: ["comment"],
    enter: {
      comment(t) {
        this.buffer();
      }
    },
    exit: {
      comment(t) {
        this.resume();
      }
    }
  };
}
const B_ = (e, t, n) => {
  return r;
  function r(m) {
    return e.enter("comment"), e.consume(m), i;
  }
  function i(m) {
    return m === Ar.exclamationMark ? (e.consume(m), s) : n(m);
  }
  function s(m) {
    return m === Ar.dash ? (e.consume(m), o) : n(m);
  }
  function o(m) {
    return m === Ar.dash ? (e.consume(m), a) : n(m);
  }
  function a(m) {
    return m === Ar.greaterThan ? n(m) : be(m) ? u(m) : (e.enter(co.data), m === Ar.dash ? (e.consume(m), l) : c(m));
  }
  function l(m) {
    return m === Ar.greaterThan ? n(m) : c(m);
  }
  function c(m) {
    return m === Ar.eof ? n(m) : m === Ar.dash ? (e.consume(m), d) : be(m) ? (e.exit(co.data), u(m)) : (e.consume(m), c);
  }
  function u(m) {
    return e.enter(co.lineEnding), e.consume(m), e.exit(co.lineEnding), Ge(e, f, co.linePrefix);
  }
  function f(m) {
    return be(m) ? u(m) : (e.enter(co.data), c(m));
  }
  function d(m) {
    return m === Ar.dash ? (e.consume(m), h) : c(m);
  }
  function h(m) {
    return m === Ar.greaterThan ? (e.exit(co.data), e.enter("commentEnd"), e.consume(m), e.exit("commentEnd"), e.exit("comment"), t(m)) : m === Ar.dash ? (e.consume(m), h) : c(m);
  }
}, aV = {
  flow: { 60: { tokenize: B_, concrete: !0 } },
  text: { 60: { tokenize: B_ } }
}, lV = "_bold_1tncs_10", cV = "_italic_1tncs_14", uV = "_underline_1tncs_18", fV = "_strikethrough_1tncs_34", dV = "_underlineStrikethrough_1tncs_38", hV = "_subscript_1tncs_42", pV = "_superscript_1tncs_47", mV = "_code_1tncs_52", gV = "_nestedListItem_1tncs_59", vV = "_listitem_1tncs_69", yV = "_listItemChecked_1tncs_73", xV = "_listItemUnchecked_1tncs_74", wV = "_admonitionDanger_1tncs_151", _V = "_admonitionInfo_1tncs_152", bV = "_admonitionNote_1tncs_153", CV = "_admonitionTip_1tncs_154", EV = "_admonitionCaution_1tncs_155", SV = "_mdxExpression_1tncs_188", en = {
  bold: lV,
  italic: cV,
  underline: uV,
  strikethrough: fV,
  underlineStrikethrough: dV,
  subscript: hV,
  superscript: pV,
  code: mV,
  nestedListItem: gV,
  listitem: vV,
  listItemChecked: yV,
  listItemUnchecked: xV,
  admonitionDanger: wV,
  admonitionInfo: _V,
  admonitionNote: bV,
  admonitionTip: CV,
  admonitionCaution: EV,
  mdxExpression: SV
}, Yv = {
  text: {
    bold: en.bold,
    italic: en.italic,
    underline: en.underline,
    code: en.code,
    strikethrough: en.strikethrough,
    subscript: en.subscript,
    superscript: en.superscript,
    underlineStrikethrough: en.underlineStrikethrough
  },
  list: {
    listitem: en.listitem,
    listitemChecked: en.listItemChecked,
    listitemUnchecked: en.listItemUnchecked,
    nested: {
      listitem: en.nestedListItem
    }
  },
  admonition: {
    danger: en.admonitionDanger,
    info: en.admonitionInfo,
    note: en.admonitionNote,
    tip: en.admonitionTip,
    caution: en.admonitionCaution
  }
}, du = Pe("NESTED_EDITOR_UPDATED_COMMAND"), Gr = Te(null), Ft = Te(null), t0 = Te(""), n0 = Te(!0), Cr = Te(!1, (e) => {
  e.sub(e.pipe(Cr, Tt(Gr)), ([t, n]) => {
    n == null || n.setEditable(!t);
  });
}), r0 = Te(""), z_ = Te(!1), Lc = Te(!1), Xv = Te(0), jd = Te(null), i0 = Bt((e) => {
  e.link(
    e.pipe(
      jd,
      Xc((t) => t !== null)
    ),
    i0
  );
}), Zv = Bt((e) => {
  e.sub(e.pipe(Zv, Tt(Ft)), ([t, n]) => {
    n == null || n.dispatchCommand(Ui, t);
  });
}), Ka = Te(null, (e) => {
  e.sub(e.pipe(Ka, Tt(Ft)), ([t, n]) => {
    if (!t || !n)
      return;
    const r = t.anchor.getNode();
    let i = r.getKey() === "root" ? r : $r(r, (a) => {
      const l = a.getParent();
      return l !== null && Jt(l);
    });
    i === null && (i = r.getTopLevelElementOrThrow());
    const s = i.getKey();
    if (n.getElementByKey(s) !== null) {
      const a = vp(i) ? i.getTag() : i.getType();
      e.pub(lS, a);
    }
  });
}), J6 = Te(""), Vo = Te(""), Wd = Te(!1), bp = Bt((e) => {
  e.link(Vo, bp), e.sub(J6, (t) => {
    e.pubIn({
      [Wd]: !0,
      [Vo]: t
    });
  });
}), s0 = Bt((e) => {
  e.link(
    e.pipe(
      bp,
      Tt(a0),
      Xc(([, t]) => !t),
      Ds(([t]) => t)
    ),
    s0
  );
}, !0), Qv = Te([]), ey = Te([]), K6 = Te([]), q6 = Te([]), ty = Te([]), G6 = Te([]), o0 = Te({}), ny = Te(!1), qa = Te([]), Mc = Te([]), hu = Te([]), Yo = Te(null), kV = Te(null), Yr = Fn(ey), Er = Fn(Qv), Ga = Fn(K6), Ya = Fn(q6), Xr = Fn(ty), pu = Fn(G6), a0 = Te(!1), ry = Bt((e) => {
  e.sub(
    e.pipe(
      ry,
      Tt(Vo, Gr, Lc),
      Xc(([t, n]) => t.trim() !== n.trim())
    ),
    ([t, , n, r]) => {
      e.pub(a0, !0), n == null || n.update(
        () => {
          Xe().clear(), iy(e, Xe(), t), r ? n.focus() : Ot(null);
        },
        {
          onUpdate: () => {
            e.pub(a0, !1);
          }
        }
      );
    }
  );
}), Y6 = Bt((e) => {
  e.sub(e.pipe(Y6, Tt(Ft, Lc)), ([t, n, r]) => {
    n == null || n.update(() => {
      const i = ge();
      if (i !== null) {
        const s = {
          children: [],
          append(o) {
            this.children.push(o);
          },
          getType() {
            return i.getNodes()[0].getType();
          }
        };
        iy(e, s, t), dl(s.children);
      }
      r ? n.focus() : Ot(null);
    });
  });
});
function X6() {
  return xE((e, [t, n]) => (e.forEach((r) => {
    if (!r)
      throw new Error("You have a subscription that does not return a teardown");
    r();
  }), n ? t.map((r) => r(n)) : []), []);
}
const Z6 = Te([], (e) => {
  e.pipe(e.combine(Z6, Ft), X6());
}), Q6 = Te([], (e) => {
  e.pipe(e.combine(Q6, Gr), X6());
}), eS = Te(null), l0 = Bt(), ir = Te((e) => {
  throw new Error(`No icon component for ${e}`);
});
function Fn(e, t) {
  return Bt((n, r) => {
    n.changeWith(e, r, (i, s) => {
      Array.isArray(s) || (s = [s]);
      let o = i;
      for (const a of s)
        i.includes(a) || (o = [...o, a]);
      return o;
    }), t == null || t(n, r);
  });
}
function tS(e) {
  const t = ge();
  fe(t) && e.pubIn({
    [Ka]: t,
    [Xv]: t.format
  });
}
const Cp = Fn(Q6, (e, t) => {
  e.pub(t, [
    (n) => n.registerCommand(
      Zc,
      (r, i) => (e.pubIn({
        [Ft]: i,
        [Lc]: !0
      }), i._parentEditor === null && i.getEditorState().read(() => {
        e.pub(eS, {
          rootNode: Xe(),
          editorType: "lexical"
        });
      }), tS(e), !1),
      zr
    ),
    // Export handler
    (n) => n.registerUpdateListener(({ dirtyElements: r, dirtyLeaves: i, editorState: s }) => {
      if (e.getValue(jd) !== null || r.size === 0 && i.size === 0)
        return;
      let a;
      s.read(() => {
        Xe().getLastChild() instanceof bi && n.update(
          () => {
            Xe().append(st());
          },
          { discrete: !0 }
        ), a = WF({
          root: Xe(),
          visitors: e.getValue(ty),
          jsxComponentDescriptors: e.getValue(qa),
          toMarkdownExtensions: e.getValue(G6),
          toMarkdownOptions: e.getValue(o0),
          jsxIsAvailable: e.getValue(ny)
        });
      }), e.pub(Vo, a.trim()), e.pub(Wd, !1);
    }),
    (n) => n.registerCommand(
      hv,
      () => (e.pub(Lc, !0), !1),
      zr
    )
    /*
        // Fixes select all when frontmatter is present
        (rootEditor) => {
          return rootEditor.registerCommand<KeyboardEvent>(
            KEY_DOWN_COMMAND,
            (event) => {
              const { keyCode, ctrlKey, metaKey } = event
              if (keyCode === 65 && controlOrMeta(metaKey, ctrlKey)) {
                let shouldOverride = false
    
                rootEditor.getEditorState().read(() => {
                  shouldOverride = $isDecoratorNode($getRoot().getFirstChild()) || $isDecoratorNode($getRoot().getLastChild())
                })
    
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (shouldOverride) {
                  event.preventDefault()
                  event.stopImmediatePropagation()
                  rootEditor.update(() => {
                    const rootElement = rootEditor.getRootElement() as HTMLDivElement
                    window.getSelection()?.selectAllChildren(rootElement)
                    rootElement.focus({
                      preventScroll: true
                    })
                  })
                  return true
                }
              }
    
              return false
            },
            COMMAND_PRIORITY_CRITICAL
          )
        }*/
  ]);
}), Oc = Fn(Z6, (e, t) => {
  e.pub(t, [
    (n) => n.registerUpdateListener(({ editorState: r }) => {
      r.read(() => {
        tS(e);
      });
    }),
    (n) => n.registerCommand(
      pv,
      (r) => {
        var i;
        const s = e.getValue(Gr);
        return s && !((i = s.getRootElement()) != null && i.contains(r.relatedTarget)) && e.pubIn({
          [Lc]: !1,
          [l0]: r
        }), !1;
      },
      zr
    )
  ]);
});
function iy(e, t, n) {
  try {
    V$({
      root: t,
      visitors: e.getValue(Qv),
      mdastExtensions: e.getValue(q6),
      markdown: n,
      syntaxExtensions: e.getValue(K6),
      jsxComponentDescriptors: e.getValue(qa),
      directiveDescriptors: e.getValue(Mc),
      codeBlockEditorDescriptors: e.getValue(hu)
    }), e.pub(jd, null);
  } catch (r) {
    if (r instanceof Qg || r instanceof e0)
      e.pubIn({
        [Vo]: n,
        [jd]: {
          error: r.message,
          source: n
        }
      });
    else
      throw r;
  }
}
const nS = Te([]), Xo = Fn(nS), rS = Te([]), TV = Fn(rS), iS = Te([]), AV = Fn(iS), sS = Te([]);
Fn(sS);
const oS = Te([]), aS = Fn(oS), NV = Te(j9()), lS = Te("");
Bt();
const Jd = Bt((e) => {
  e.sub(e.pipe(Jd, Tt(Ft)), ([t, n]) => {
    n == null || n.update(() => {
      const r = ge();
      fe(r) && (sP(r, t), setTimeout(() => {
        n.focus();
      }));
    });
  });
}), Ep = Bt((e) => {
  e.sub(e.pipe(Ep, Tt(Ft)), ([t, n]) => {
    n == null || n.focus(
      () => {
        n.getEditorState().read(() => {
          const r = ge();
          fe(r) && (n.update(() => {
            const i = t();
            i.isInline() ? (dl([i]), Jt(i.getParentOrThrow()) && zv(i, st).selectEnd()) : U9(i), setTimeout(() => {
              "select" in i && typeof i.select == "function" && i.select();
            });
          }), setTimeout(() => {
            n.dispatchCommand(du, void 0);
          }));
        });
      },
      { defaultSelection: "rootEnd" }
    );
  });
}), Kd = Te("rich-text", (e) => {
  function t() {
    return xE(
      (n, r) => ({
        current: n.next,
        next: r
      }),
      { current: "rich-text", next: "rich-text" }
    );
  }
  e.sub(e.pipe(Kd, t(), Tt(Pc)), ([{ current: n }, r]) => {
    (n === "source" || n === "diff") && e.pub(ry, r);
  }), e.sub(
    e.pipe(
      Kd,
      t(),
      Xc((n) => n.current === "rich-text"),
      Tt(Ft)
    ),
    ([, n]) => {
      n == null || n.dispatchCommand(du, void 0);
    }
  );
}), Pc = Te(
  "",
  (e) => {
    e.link(Vo, Pc), e.link(Pc, bp);
  },
  !0
), sy = Te([]), vl = Fn(sy), cS = Te(() => {
  throw new Error("No translation function provided");
}), qd = Te(Yv), IV = Jn({
  init(e, t) {
    const n = (t == null ? void 0 : t.initialMarkdown) ?? "";
    e.register(Cp), e.register(Oc), e.register(bp), e.register(Pc), e.pubIn({
      [J6]: t != null && t.trim ? n.trim() : n,
      [ir]: t == null ? void 0 : t.iconComponentFor,
      [Er]: [iV, rV, sV, G$, ...eV],
      [Yr]: [lp, Ys, fu],
      [Xr]: [
        J$,
        W$,
        q$,
        j$,
        U$
      ],
      [Xo]: W6,
      [t0]: t == null ? void 0 : t.contentEditableClassName,
      [n0]: t == null ? void 0 : t.spellCheck,
      [o0]: t == null ? void 0 : t.toMarkdownOptions,
      [z_]: t == null ? void 0 : t.autoFocus,
      [r0]: t == null ? void 0 : t.placeholder,
      [Cr]: t == null ? void 0 : t.readOnly,
      [cS]: t == null ? void 0 : t.translation,
      [Ya]: JP(),
      [Ga]: jP(),
      [pu]: [Hv(), Y9()],
      [qd]: (t == null ? void 0 : t.lexicalTheme) ?? Yv
    }), e.singletonSub(i0, t == null ? void 0 : t.onError), e.singletonSub(s0, (r) => {
      t == null || t.onChange(r, e.getValue(Wd));
    }), e.singletonSub(l0, t == null ? void 0 : t.onBlur), t != null && t.suppressHtmlProcessing || e.pubIn({
      [Ya]: [Vd(), oV()],
      [Ga]: [zd(), o6(), aV],
      [Er]: tV
    });
  },
  postInit(e, t) {
    const n = p9({
      editable: (t == null ? void 0 : t.readOnly) !== !0,
      namespace: "MDXEditor",
      nodes: e.getValue(ey),
      onError: (r) => {
        throw r;
      },
      theme: e.getValue(qd)
    });
    n.update(() => {
      const r = (t == null ? void 0 : t.initialMarkdown.trim()) ?? "";
      iy(e, Xe(), r);
      const i = t == null ? void 0 : t.autoFocus;
      if (i) {
        if (i === !0) {
          setTimeout(() => {
            n.focus(Ta, { defaultSelection: "rootStart" });
          });
          return;
        }
        setTimeout(() => {
          n.focus(Ta, {
            defaultSelection: i.defaultSelection ?? "rootStart"
          });
        });
      }
    }), e.pub(Gr, n), e.pub(Ft, n);
  },
  update(e, t) {
    e.pubIn({
      [t0]: t == null ? void 0 : t.contentEditableClassName,
      [n0]: t == null ? void 0 : t.spellCheck,
      [o0]: t == null ? void 0 : t.toMarkdownOptions,
      [z_]: t == null ? void 0 : t.autoFocus,
      [r0]: t == null ? void 0 : t.placeholder,
      [Cr]: t == null ? void 0 : t.readOnly
    }), e.singletonSub(s0, (n) => {
      t == null || t.onChange(n, e.getValue(Wd));
    }), e.singletonSub(l0, t == null ? void 0 : t.onBlur), e.singletonSub(i0, t == null ? void 0 : t.onError);
  }
});
function Kn() {
  return mn(cS);
}
function LV() {
  return Xe().getTextContent();
}
function MV(e, t = !0) {
  if (e) return !1;
  let n = LV();
  return t && (n = n.trim()), n === "";
}
function OV(e) {
  if (!MV(e, !1)) return !1;
  const t = Xe().getChildren(), n = t.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const i = t[r];
    if (it(i)) return !1;
    if (te(i)) {
      if (!Ev(i) || i.__indent !== 0) return !1;
      const s = i.getChildren(), o = s.length;
      for (let a = 0; a < o; a++) {
        const l = s[r];
        if (!ye(l)) return !1;
      }
    }
  }
  return !0;
}
function uS(e) {
  return () => OV(e);
}
const fS = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? Ko : Le;
function PV({ editor: e, ariaActiveDescendant: t, ariaAutoComplete: n, ariaControls: r, ariaDescribedBy: i, ariaErrorMessage: s, ariaExpanded: o, ariaInvalid: a, ariaLabel: l, ariaLabelledBy: c, ariaMultiline: u, ariaOwns: f, ariaRequired: d, autoCapitalize: h, className: m, id: p, role: y = "textbox", spellCheck: v = !0, style: g, tabIndex: x, "data-testid": _, ...b }, C) {
  const [E, S] = Re(e.isEditable()), k = Ht((O) => {
    O && O.ownerDocument && O.ownerDocument.defaultView ? e.setRootElement(O) : e.setRootElement(null);
  }, [e]), M = Jo(() => /* @__PURE__ */ function(...O) {
    return (R) => {
      O.forEach((I) => {
        typeof I == "function" ? I(R) : I != null && (I.current = R);
      });
    };
  }(C, k), [k, C]);
  return fS(() => (S(e.isEditable()), e.registerEditableListener((O) => {
    S(O);
  })), [e]), A("div", { "aria-activedescendant": E ? t : void 0, "aria-autocomplete": E ? n : "none", "aria-controls": E ? r : void 0, "aria-describedby": i, ...s != null ? { "aria-errormessage": s } : {}, "aria-expanded": E && y === "combobox" ? !!o : void 0, ...a != null ? { "aria-invalid": a } : {}, "aria-label": l, "aria-labelledby": c, "aria-multiline": u, "aria-owns": E ? f : void 0, "aria-readonly": !E || void 0, "aria-required": d, autoCapitalize: h, className: m, contentEditable: E, "data-testid": _, id: p, ref: M, role: y, spellCheck: v, style: g, tabIndex: x, ...b });
}
const DV = wi(PV);
function H_(e) {
  return e.getEditorState().read(uS(e.isComposing()));
}
const dS = wi(FV);
function FV(e, t) {
  const { placeholder: n, ...r } = e, [i] = vn();
  return Oe(Ut, { children: [A(DV, { editor: i, ...r, ref: t }), n != null && A(RV, { editor: i, content: n })] });
}
function RV({ content: e, editor: t }) {
  const n = function(o) {
    const [a, l] = Re(() => H_(o));
    return fS(() => {
      function c() {
        const u = H_(o);
        l(u);
      }
      return c(), Dn(o.registerUpdateListener(() => {
        c();
      }), o.registerEditableListener(() => {
        c();
      }));
    }, [o]), a;
  }(t), [r, i] = Re(t.isEditable());
  if (Ko(() => (i(t.isEditable()), t.registerEditableListener((o) => {
    i(o);
  })), [t]), !n) return null;
  let s = null;
  return typeof e == "function" ? s = e(r) : e !== null && (s = e), s === null ? null : A("div", { "aria-hidden": !0, children: s });
}
const $V = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? Ko : Le;
function VV(e) {
  return { initialValueFn: () => e.isEditable(), subscribe: (t) => e.registerEditableListener(t) };
}
function BV() {
  return function(e) {
    const [t] = vn(), n = Jo(() => e(t), [t, e]), [r, i] = Re(() => n.initialValueFn()), s = $e(r);
    return $V(() => {
      const { initialValueFn: o, subscribe: a } = n, l = o();
      return s.current !== l && (s.current = l, i(l)), a((c) => {
        s.current = c, i(c);
      });
    }, [n, e]), r;
  }(VV);
}
function zV(e) {
  const t = window.location.origin, n = (r) => {
    if (r.origin !== t) return;
    const i = e.getRootElement();
    if (document.activeElement !== i) return;
    const s = r.data;
    if (typeof s == "string") {
      let o;
      try {
        o = JSON.parse(s);
      } catch {
        return;
      }
      if (o && o.protocol === "nuanria_messaging" && o.type === "request") {
        const a = o.payload;
        if (a && a.functionId === "makeChanges") {
          const l = a.args;
          if (l) {
            const [c, u, f, d, h, m] = l;
            e.update(() => {
              const p = ge();
              if (fe(p)) {
                const y = p.anchor;
                let v = y.getNode(), g = 0, x = 0;
                if (ye(v) && c >= 0 && u >= 0 && (g = c, x = c + u, p.setTextNodeRange(v, g, v, x)), g === x && f === "" || (p.insertRawText(f), v = y.getNode()), ye(v)) {
                  g = d, x = d + h;
                  const _ = v.getTextContentSize();
                  g = g > _ ? _ : g, x = x > _ ? _ : x, p.setTextNodeRange(v, g, v, x);
                }
                r.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  return window.addEventListener("message", n, !0), () => {
    window.removeEventListener("message", n, !0);
  };
}
const c0 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? Ko : Le;
function U_(e) {
  return e.getEditorState().read(uS(e.isComposing()));
}
function hS({ contentEditable: e, placeholder: t = null, ErrorBoundary: n }) {
  const [r] = vn(), i = function(s, o) {
    const [a, l] = Re(() => s.getDecorators());
    return c0(() => s.registerDecoratorListener((c) => {
      DI(() => {
        l(c);
      });
    }), [s]), Le(() => {
      l(s.getDecorators());
    }, [s]), Jo(() => {
      const c = [], u = Object.keys(a);
      for (let f = 0; f < u.length; f++) {
        const d = u[f], h = A(o, { onError: (p) => s._onError(p), children: A(ng, { fallback: null, children: a[d] }) }), m = s.getElementByKey(d);
        m !== null && c.push(FI(h, m, d));
      }
      return c;
    }, [o, a, s]);
  }(r, n);
  return function(s) {
    c0(() => Dn(VP(s), zV(s)), [s]);
  }(r), Oe(Ut, { children: [e, A(HV, { content: t }), i] });
}
function HV({ content: e }) {
  const [t] = vn(), n = function(i) {
    const [s, o] = Re(() => U_(i));
    return c0(() => {
      function a() {
        const l = U_(i);
        o(l);
      }
      return a(), Dn(i.registerUpdateListener(() => {
        a();
      }), i.registerEditableListener(() => {
        a();
      }));
    }, [i]), s;
  }(t), r = BV();
  return n ? typeof e == "function" ? e(r) : e : null;
}
var Xa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function UV(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var pS = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var a = arguments[o];
        a && (s = i(s, r(a)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return n.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var o = "";
      for (var a in s)
        t.call(s, a) && s[a] && (o = i(o, a));
      return o;
    }
    function i(s, o) {
      return o ? s ? s + " " + o : s + o : s;
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(pS);
var jV = pS.exports;
const rt = /* @__PURE__ */ yl(jV), WV = "_editorRoot_sects_53", JV = "_editorWrapper_sects_155", KV = "_toolbarRoot_sects_162", qV = "_readOnlyToolbarRoot_sects_189", GV = "_toolbarToggleItem_sects_208", YV = "_toolbarGroupOfGroups_sects_219", XV = "_toolbarToggleSingleGroup_sects_224", ZV = "_toolbarButton_sects_239", QV = "_selectContainer_sects_288", eB = "_selectItem_sects_301", tB = "_selectTrigger_sects_308", nB = "_selectDropdownArrow_sects_374", rB = "_contentEditable_sects_380", iB = "_propertyPanelTitle_sects_431", sB = "_propertyEditorTable_sects_439", oB = "_iconButton_sects_457", aB = "_readOnlyColumnCell_sects_462", lB = "_buttonsFooter_sects_475", cB = "_propertyEditorInput_sects_481", uB = "_primaryButton_sects_507", fB = "_secondaryButton_sects_508", dB = "_smallButton_sects_523", hB = "_linkDialogEditForm_sects_541", pB = "_linkDialogAnchor_sects_587", mB = "_linkDialogPopoverContent_sects_601", gB = "_dialogContent_sects_603", vB = "_largeDialogContent_sects_615", yB = "_dialogTitle_sects_625", xB = "_dialogCloseButton_sects_631", wB = "_popoverContent_sects_638", _B = "_popoverArrow_sects_650", bB = "_linkDialogPreviewAnchor_sects_654", CB = "_tooltipTrigger_sects_677", EB = "_tooltipContent_sects_681", SB = "_actionButton_sects_695", kB = "_dialogOverlay_sects_870", TB = "_focusedImage_sects_916", AB = "_imageWrapper_sects_920", NB = "_editImageToolbar_sects_933", IB = "_editImageButton_sects_937", LB = "_inlineEditor_sects_943", MB = "_blockEditor_sects_952", OB = "_nestedEditor_sects_961", PB = "_genericComponentName_sects_980", DB = "_imageControlWrapperResizing_sects_1032", FB = "_imageResizer_sects_1036", RB = "_imageResizerN_sects_1045", $B = "_imageResizerNe_sects_1051", VB = "_imageResizerE_sects_1057", BB = "_imageResizerSe_sects_1063", zB = "_imageResizerS_sects_1063", HB = "_imageResizerSw_sects_1075", UB = "_imageResizerW_sects_1081", jB = "_imageResizerNw_sects_1087", WB = "_imagePlaceholder_sects_1093", JB = "_placeholder_sects_1101", KB = "_rootContentEditableWrapper_sects_1114", qB = "_downshiftInputWrapper_sects_1124", GB = "_downshiftInput_sects_1124", YB = "_downshiftAutocompleteContainer_sects_1155", XB = "_textInput_sects_1201", ZB = "_multiFieldForm_sects_1209", QB = "_formField_sects_1215", ez = "_popupContainer_sects_1235", tz = "_inputSizer_sects_1240", de = {
  editorRoot: WV,
  editorWrapper: JV,
  toolbarRoot: KV,
  readOnlyToolbarRoot: qV,
  toolbarToggleItem: GV,
  toolbarGroupOfGroups: YV,
  toolbarToggleSingleGroup: XV,
  toolbarButton: ZV,
  selectContainer: QV,
  selectItem: eB,
  selectTrigger: tB,
  selectDropdownArrow: nB,
  contentEditable: rB,
  propertyPanelTitle: iB,
  propertyEditorTable: sB,
  iconButton: oB,
  readOnlyColumnCell: aB,
  buttonsFooter: lB,
  propertyEditorInput: cB,
  primaryButton: uB,
  secondaryButton: fB,
  smallButton: dB,
  linkDialogEditForm: hB,
  linkDialogAnchor: pB,
  linkDialogPopoverContent: mB,
  dialogContent: gB,
  largeDialogContent: vB,
  dialogTitle: yB,
  dialogCloseButton: xB,
  popoverContent: wB,
  popoverArrow: _B,
  linkDialogPreviewAnchor: bB,
  tooltipTrigger: CB,
  tooltipContent: EB,
  actionButton: SB,
  dialogOverlay: kB,
  focusedImage: TB,
  imageWrapper: AB,
  editImageToolbar: NB,
  editImageButton: IB,
  inlineEditor: LB,
  blockEditor: MB,
  nestedEditor: OB,
  genericComponentName: PB,
  imageControlWrapperResizing: DB,
  imageResizer: FB,
  imageResizerN: RB,
  imageResizerNe: $B,
  imageResizerE: VB,
  imageResizerSe: BB,
  imageResizerS: zB,
  imageResizerSw: HB,
  imageResizerW: UB,
  imageResizerNw: jB,
  imagePlaceholder: WB,
  placeholder: JB,
  rootContentEditableWrapper: KB,
  downshiftInputWrapper: qB,
  downshiftInput: GB,
  downshiftAutocompleteContainer: YB,
  textInput: XB,
  multiFieldForm: ZB,
  formField: QB,
  popupContainer: ez,
  inputSizer: tz
}, nz = {
  undo: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M7.202 18.5V17H14.3788C15.4224 17 16.3205 16.6554 17.073 15.9663C17.8257 15.2773 18.202 14.4263 18.202 13.4135C18.202 12.4007 17.8257 11.5512 17.073 10.8652C16.3205 10.1794 15.4224 9.8365 14.3788 9.8365H7.35775L10.1402 12.6193L9.0865 13.673L4.5 9.0865L9.0865 4.5L10.1402 5.55375L7.35775 8.3365H14.3788C15.8416 8.3365 17.0945 8.82467 18.1375 9.801C19.1805 10.7773 19.702 11.9815 19.702 13.4135C19.702 14.8455 19.1805 16.0513 18.1375 17.0308C17.0945 18.0103 15.8416 18.5 14.3788 18.5H7.202Z",
      fill: "currentColor"
    }
  )),
  redo: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M9.6211 18.5C8.15827 18.5 6.90535 18.0103 5.86235 17.0308C4.81935 16.0513 4.29785 14.8455 4.29785 13.4135C4.29785 11.9815 4.81935 10.7773 5.86235 9.801C6.90535 8.82467 8.15827 8.3365 9.6211 8.3365H16.6421L13.8596 5.55375L14.9134 4.5L19.4999 9.0865L14.9134 13.673L13.8596 12.6193L16.6421 9.8365H9.6211C8.57744 9.8365 7.67935 10.1794 6.92685 10.8652C6.17418 11.5512 5.79785 12.4007 5.79785 13.4135C5.79785 14.4263 6.17418 15.2773 6.92685 15.9663C7.67935 16.6554 8.57744 17 9.6211 17H16.7979V18.5H9.6211Z",
      fill: "currentColor"
    }
  )),
  format_bold: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M7.33838 18.625V5.375H12.1999C13.219 5.375 14.1405 5.69233 14.9644 6.327C15.788 6.9615 16.1999 7.816 16.1999 8.8905C16.1999 9.63783 16.0194 10.2471 15.6584 10.7182C15.2975 11.1894 14.9088 11.5314 14.4921 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3158 16.6614 14.0193 16.6614 14.9038C16.6614 16.1819 16.1902 17.1217 15.2479 17.723C14.3055 18.3243 13.3562 18.625 12.3999 18.625H7.33838ZM9.48838 16.6328H12.3191C13.1063 16.6328 13.6627 16.4142 13.9884 15.977C14.314 15.5398 14.4769 15.1206 14.4769 14.7192C14.4769 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8058 12.2729 12.8058H9.48838V16.6328ZM9.48838 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5279 10.3538C13.8835 10.0064 14.0614 9.59042 14.0614 9.10575C14.0614 8.59042 13.8733 8.16925 13.4971 7.84225C13.1208 7.51542 12.6595 7.352 12.1134 7.352H9.48838V10.875Z",
      fill: "currentColor"
    }
  )),
  format_italic: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5.39404 18.625V16.8173H9.21129L12.4518 7.18275H8.63454V5.375H17.7883V7.18275H14.2785L11.0383 16.8173H14.5478V18.625H5.39404Z",
      fill: "currentColor"
    }
  )),
  format_underlined: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5.34619 22.125V20.625H18.6537V22.125H5.34619ZM11.9999 18.5287C10.4448 18.5287 9.23102 18.0566 8.35869 17.1125C7.48619 16.1683 7.04994 14.9032 7.04994 13.3172V5.41345H8.90369V13.4095C8.90369 14.4198 9.17228 15.2295 9.70944 15.8385C10.2466 16.4475 11.0101 16.752 11.9999 16.752C12.9898 16.752 13.7533 16.4475 14.2904 15.8385C14.8276 15.2295 15.0962 14.4198 15.0962 13.4095V5.41345H16.9499V13.3172C16.9499 14.9032 16.5137 16.1683 15.6412 17.1125C14.7689 18.0566 13.5551 18.5287 11.9999 18.5287Z",
      fill: "currentColor"
    }
  )),
  code: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M7.99994 17.6537L2.34619 11.9999L7.99994 6.34619L9.06919 7.41544L4.46919 12.0154L9.05369 16.5999L7.99994 17.6537ZM15.9999 17.6537L14.9307 16.5844L19.5307 11.9844L14.9462 7.39994L15.9999 6.34619L21.6537 11.9999L15.9999 17.6537Z",
      fill: "currentColor"
    }
  )),
  strikeThrough: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M12.15 19.6923C10.9732 19.6923 9.9315 19.359 9.025 18.6923C8.11867 18.0256 7.45525 17.1128 7.03475 15.9538L8.6385 15.2635C8.91667 16.0444 9.3545 16.6867 9.952 17.1905C10.5493 17.6944 11.2923 17.9463 12.1808 17.9463C12.9578 17.9463 13.6744 17.7508 14.3307 17.3598C14.9872 16.9686 15.3155 16.3487 15.3155 15.5C15.3155 15.123 15.2555 14.7968 15.1355 14.5213C15.0157 14.2456 14.8462 13.9885 14.627 13.75H16.677C16.7987 13.9705 16.8932 14.2256 16.9605 14.5153C17.0278 14.8051 17.0615 15.1334 17.0615 15.5C17.0615 16.8372 16.5747 17.8702 15.601 18.599C14.6272 19.3279 13.4768 19.6923 12.15 19.6923ZM2.25 11.75V10.25H21.75V11.75H2.25ZM12.05 4.19629C13.0475 4.19629 13.9123 4.42704 14.6443 4.88854C15.3763 5.35004 15.9673 6.05896 16.4173 7.01529L14.823 7.73079C14.6218 7.26029 14.2978 6.84462 13.851 6.48379C13.4042 6.12279 12.8141 5.94229 12.0808 5.94229C11.2244 5.94229 10.5392 6.16221 10.025 6.60204C9.51083 7.04171 9.264 7.59104 9.2845 8.25004H7.5385C7.50133 7.16421 7.89783 6.21712 8.728 5.40879C9.558 4.60046 10.6653 4.19629 12.05 4.19629Z",
      fill: "currentColor"
    }
  )),
  superscript: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M16.6924 8V6.2115C16.6924 5.95383 16.7786 5.73875 16.9511 5.56625C17.1235 5.39392 17.3385 5.30775 17.5961 5.30775H19.5001V4.38475H16.6924V3.5H19.4809C19.7385 3.5 19.9536 3.58625 20.1261 3.75875C20.2985 3.93108 20.3846 4.14617 20.3846 4.404V5.2885C20.3846 5.54617 20.2985 5.76125 20.1261 5.93375C19.9536 6.10608 19.7385 6.19225 19.4809 6.19225H17.5771V7.1155H20.3846V8H16.6924ZM4.44238 18.5L8.84638 11.6287L4.77713 5.30775H6.74438L9.95963 10.404H10.0214L13.2501 5.30775H15.2329L11.1194 11.6287L15.5579 18.5H13.5751L10.0214 12.9308H9.95963L6.42513 18.5H4.44238Z",
      fill: "currentColor"
    }
  )),
  subscript: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M16.6924 20.5V18.7115C16.6924 18.4538 16.7786 18.2387 16.9511 18.0662C17.1235 17.8939 17.3385 17.8077 17.5961 17.8077H19.5001V16.8845H16.6924V16H19.4809C19.7385 16 19.9536 16.0863 20.1261 16.2587C20.2985 16.4311 20.3846 16.6461 20.3846 16.9038V17.7885C20.3846 18.0462 20.2985 18.2612 20.1261 18.4337C19.9536 18.6061 19.7385 18.6923 19.4809 18.6923H17.5771V19.6152H20.3846V20.5H16.6924ZM4.44238 18.6923L8.84638 11.8212L4.77713 5.5H6.74438L9.95963 10.5962H10.0214L13.2501 5.5H15.2329L11.1194 11.8212L15.5579 18.6923H13.5751L10.0214 13.123H9.95963L6.42513 18.6923H4.44238Z",
      fill: "currentColor"
    }
  )),
  format_list_bulleted: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75005V5.25005H20.5V6.75005H9.30775ZM5.1635 19.6635C4.706 19.6635 4.31442 19.5006 3.98875 19.1748C3.66292 18.8491 3.5 18.4575 3.5 18C3.5 17.5425 3.66292 17.151 3.98875 16.8253C4.31442 16.4995 4.706 16.3365 5.1635 16.3365C5.621 16.3365 6.01258 16.4995 6.33825 16.8253C6.66408 17.151 6.827 17.5425 6.827 18C6.827 18.4575 6.66408 18.8491 6.33825 19.1748C6.01258 19.5006 5.621 19.6635 5.1635 19.6635ZM5.1635 13.6635C4.706 13.6635 4.31442 13.5006 3.98875 13.1748C3.66292 12.8491 3.5 12.4575 3.5 12C3.5 11.5425 3.66292 11.151 3.98875 10.8253C4.31442 10.4995 4.706 10.3365 5.1635 10.3365C5.621 10.3365 6.01258 10.4995 6.33825 10.8253C6.66408 11.151 6.827 11.5425 6.827 12C6.827 12.4575 6.66408 12.8491 6.33825 13.1748C6.01258 13.5006 5.621 13.6635 5.1635 13.6635ZM5.1635 7.66355C4.706 7.66355 4.31442 7.50063 3.98875 7.1748C3.66292 6.84913 3.5 6.45755 3.5 6.00005C3.5 5.54255 3.66292 5.15096 3.98875 4.8253C4.31442 4.49946 4.706 4.33655 5.1635 4.33655C5.621 4.33655 6.01258 4.49946 6.33825 4.8253C6.66408 5.15096 6.827 5.54255 6.827 6.00005C6.827 6.45755 6.66408 6.84913 6.33825 7.1748C6.01258 7.50063 5.621 7.66355 5.1635 7.66355Z",
      fill: "currentColor"
    }
  )),
  format_list_numbered: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M3.5 21.5V20.3078H6V19.25H4.5V18.0577H6V17H3.5V15.8077H6.34625C6.58592 15.8077 6.78683 15.8888 6.949 16.051C7.11117 16.2132 7.19225 16.4141 7.19225 16.6538V17.8462C7.19225 18.0859 7.11117 18.2868 6.949 18.449C6.78683 18.6112 6.58592 18.6923 6.34625 18.6923C6.58592 18.6923 6.78683 18.7733 6.949 18.9355C7.11117 19.0977 7.19225 19.2987 7.19225 19.5385V20.6538C7.19225 20.8936 7.11117 21.0946 6.949 21.2568C6.78683 21.4189 6.58592 21.5 6.34625 21.5H3.5ZM3.5 14.8463V12.25C3.5 12.0103 3.58108 11.8093 3.74325 11.647C3.90542 11.4848 4.10642 11.4038 4.34625 11.4038H6V10.3462H3.5V9.15375H6.34625C6.58592 9.15375 6.78683 9.23483 6.949 9.397C7.11117 9.55933 7.19225 9.76033 7.19225 10V11.75C7.19225 11.9897 7.11117 12.1907 6.949 12.353C6.78683 12.5152 6.58592 12.5963 6.34625 12.5963H4.69225V13.6538H7.19225V14.8463H3.5ZM5 8.19225V3.69225H3.5V2.5H6.19225V8.19225H5ZM9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75V5.25H20.5V6.75H9.30775Z",
      fill: "currentColor"
    }
  )),
  format_list_checked: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5.69425 18.452L2.5 15.2578L3.54425 14.2135L5.66925 16.3385L9.91925 12.0885L10.9635 13.1578L5.69425 18.452ZM5.69425 10.8365L2.5 7.64227L3.54425 6.59802L5.66925 8.72302L9.91925 4.47302L10.9635 5.54227L5.69425 10.8365ZM13.0095 16.5578V15.0578H21.5095V16.5578H13.0095ZM13.0095 8.94227V7.44227H21.5095V8.94227H13.0095Z",
      fill: "currentColor"
    }
  )),
  link: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M10.8077 16.5385H7.0385C5.78283 16.5385 4.7125 16.096 3.8275 15.211C2.9425 14.3262 2.5 13.256 2.5 12.0005C2.5 10.745 2.9425 9.67471 3.8275 8.78955C4.7125 7.90421 5.78283 7.46155 7.0385 7.46155H10.8077V8.96155H7.0385C6.19867 8.96155 5.48233 9.25805 4.8895 9.85105C4.2965 10.444 4 11.1604 4 12C4 12.8397 4.2965 13.556 4.8895 14.149C5.48233 14.742 6.19867 15.0385 7.0385 15.0385H10.8077V16.5385ZM8.25 12.75V11.25H15.75V12.75H8.25ZM13.1923 16.5385V15.0385H16.9615C17.8013 15.0385 18.5177 14.742 19.1105 14.149C19.7035 13.556 20 12.8397 20 12C20 11.1604 19.7035 10.444 19.1105 9.85105C18.5177 9.25805 17.8013 8.96155 16.9615 8.96155H13.1923V7.46155H16.9615C18.2172 7.46155 19.2875 7.90405 20.1725 8.78905C21.0575 9.67388 21.5 10.744 21.5 11.9995C21.5 13.255 21.0575 14.3254 20.1725 15.2105C19.2875 16.0959 18.2172 16.5385 16.9615 16.5385H13.1923Z",
      fill: "currentColor"
    }
  )),
  add_photo: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5.11537 20.5C4.6182 20.5 4.19262 20.323 3.83862 19.969C3.48462 19.615 3.30762 19.1894 3.30762 18.6922V5.30773C3.30762 4.81056 3.48462 4.38498 3.83862 4.03098C4.19262 3.67698 4.6182 3.49998 5.11537 3.49998H13.8076V4.99998H5.11537C5.02553 4.99998 4.95178 5.02881 4.89412 5.08648C4.83645 5.14415 4.80762 5.2179 4.80762 5.30773V18.6922C4.80762 18.7821 4.83645 18.8558 4.89412 18.9135C4.95178 18.9711 5.02553 19 5.11537 19H18.4999C18.5895 19 18.6633 18.9711 18.7211 18.9135C18.7788 18.8558 18.8076 18.7821 18.8076 18.6922V9.99998H20.3076V18.6922C20.3076 19.1894 20.1306 19.615 19.7766 19.969C19.4226 20.323 18.997 20.5 18.4999 20.5H5.11537ZM17.1921 8.61523V6.61523H15.1921V5.11548H17.1921V3.11548H18.6921V5.11548H20.6921V6.61523H18.6921V8.61523H17.1921ZM6.55762 16.75H17.1344L13.8459 12.3655L11.0384 16.0192L9.03837 13.4615L6.55762 16.75Z",
      fill: "currentColor"
    }
  )),
  table: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M3.5 18.6923V5.30775C3.5 4.81058 3.677 4.385 4.031 4.031C4.385 3.677 4.81058 3.5 5.30775 3.5H18.6923C19.1894 3.5 19.615 3.677 19.969 4.031C20.323 4.385 20.5 4.81058 20.5 5.30775V18.6923C20.5 19.1894 20.323 19.615 19.969 19.969C19.615 20.323 19.1894 20.5 18.6923 20.5H5.30775C4.81058 20.5 4.385 20.323 4.031 19.969C3.677 19.615 3.5 19.1894 3.5 18.6923ZM5 9.077H19V5.30775C19 5.21792 18.9712 5.14417 18.9135 5.0865C18.8558 5.02883 18.7821 5 18.6923 5H5.30775C5.21792 5 5.14417 5.02883 5.0865 5.0865C5.02883 5.14417 5 5.21792 5 5.30775V9.077ZM10.1615 14.0385H13.8385V10.577H10.1615V14.0385ZM10.1615 19H13.8385V15.5385H10.1615V19ZM5 14.0385H8.6615V10.577H5V14.0385ZM15.3385 14.0385H19V10.577H15.3385V14.0385ZM5.30775 19H8.6615V15.5385H5V18.6923C5 18.7821 5.02883 18.8558 5.0865 18.9135C5.14417 18.9712 5.21792 19 5.30775 19ZM15.3385 19H18.6923C18.7821 19 18.8558 18.9712 18.9135 18.9135C18.9712 18.8558 19 18.7821 19 18.6923V15.5385H15.3385V19Z",
      fill: "currentColor"
    }
  )),
  horizontal_rule: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement("path", { d: "M4.5 12.75V11.25H19.5V12.75H4.5Z", fill: "currentColor" })),
  frontmatter: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement("path", { d: "M4.5 8.75V7.25H8.5V8.75H4.5Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement("path", { d: "M4.5 14.75V13.25H8.5V14.75H4.5Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement("path", { d: "M9.5 8.75V7.25H13.5V8.75H9.5Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement("path", { d: "M9.5 14.75V13.25H13.5V14.75H9.5Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement("path", { d: "M14.5 8.75V7.25H18.5V8.75H14.5Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement("path", { d: "M14.5 14.75V13.25H18.5V14.75H14.5Z", fill: "currentColor" })),
  frame_source: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M8.6 15.2443L5.35575 12L8.6 8.75575L9.64425 9.825L7.46925 12L9.64425 14.175L8.6 15.2443ZM15.4 15.2443L14.3558 14.175L16.5307 12L14.3558 9.825L15.4 8.75575L18.6443 12L15.4 15.2443ZM5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V15H5V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H9V20.5H5.30775ZM15 20.5V19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V15H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H15ZM3.5 9V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H9V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V9H3.5ZM19 9V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H15V3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V9H19Z",
      fill: "currentColor"
    }
  )),
  arrow_drop_down: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement("path", { d: "M11.9999 14.6537L7.59619 10.25H16.4037L11.9999 14.6537Z", fill: "currentColor" })),
  admonition: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M12.0001 21.4C11.7654 21.4 11.5385 21.3548 11.3193 21.2645C11.1002 21.174 10.9002 21.0435 10.7193 20.873L3.1271 13.2807C2.9566 13.0999 2.8261 12.8999 2.7356 12.6807C2.64526 12.4616 2.6001 12.2346 2.6001 12C2.6001 11.7653 2.64526 11.5358 2.7356 11.3115C2.8261 11.0871 2.9566 10.8897 3.1271 10.7192L10.7193 3.12698C10.9002 2.94614 11.1002 2.81314 11.3193 2.72798C11.5385 2.64264 11.7654 2.59998 12.0001 2.59998C12.2348 2.59998 12.4643 2.64264 12.6886 2.72798C12.9129 2.81314 13.1103 2.94614 13.2808 3.12698L20.8731 10.7192C21.0539 10.8897 21.1869 11.0871 21.2721 11.3115C21.3574 11.5358 21.4001 11.7653 21.4001 12C21.4001 12.2346 21.3574 12.4616 21.2721 12.6807C21.1869 12.8999 21.0539 13.0999 20.8731 13.2807L13.2808 20.873C13.1103 21.0435 12.9129 21.174 12.6886 21.2645C12.4643 21.3548 12.2348 21.4 12.0001 21.4ZM12.2213 19.8037L19.8039 12.2212C19.8552 12.1699 19.8808 12.0961 19.8808 12C19.8808 11.9038 19.8552 11.8301 19.8039 11.7787L12.2213 4.19623C12.17 4.14489 12.0963 4.11923 12.0001 4.11923C11.9039 4.11923 11.8302 4.14489 11.7788 4.19623L4.19635 11.7787C4.14501 11.8301 4.11935 11.9038 4.11935 12C4.11935 12.0961 4.14501 12.1699 4.19635 12.2212L11.7788 19.8037C11.8302 19.8551 11.9039 19.8807 12.0001 19.8807C12.0963 19.8807 12.17 19.8551 12.2213 19.8037ZM11.2501 13.0865H12.7501V7.47123H11.2501V13.0865ZM12.0001 15.702C12.2258 15.702 12.4168 15.6237 12.5731 15.4672C12.7296 15.3109 12.8078 15.1199 12.8078 14.8942C12.8078 14.6686 12.7296 14.4776 12.5731 14.3212C12.4168 14.1647 12.2258 14.0865 12.0001 14.0865C11.7744 14.0865 11.5834 14.1647 11.4271 14.3212C11.2706 14.4776 11.1923 14.6686 11.1923 14.8942C11.1923 15.1199 11.2706 15.3109 11.4271 15.4672C11.5834 15.6237 11.7744 15.702 12.0001 15.702Z",
      fill: "currentColor"
    }
  )),
  sandpack: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M12.9999 22.5C12.4947 22.5 12.0671 22.325 11.7171 21.975C11.3671 21.625 11.1921 21.1974 11.1921 20.6922V7.30775C11.1921 6.80258 11.3671 6.375 11.7171 6.025C12.0671 5.675 12.4947 5.5 12.9999 5.5H16.3844C16.8895 5.5 17.3171 5.675 17.6671 6.025C18.0171 6.375 18.1921 6.80258 18.1921 7.30775V20.6922C18.1921 21.1974 18.0171 21.625 17.6671 21.975C17.3171 22.325 16.8895 22.5 16.3844 22.5H12.9999ZM12.6921 7.30775V20.6922C12.6921 20.7692 12.7242 20.8398 12.7884 20.9038C12.8524 20.9679 12.9229 21 12.9999 21H16.3844C16.4614 21 16.5319 20.9679 16.5959 20.9038C16.66 20.8398 16.6921 20.7692 16.6921 20.6922V7.30775C16.6921 7.23075 16.66 7.16025 16.5959 7.09625C16.5319 7.03208 16.4614 7 16.3844 7H12.9999C12.9229 7 12.8524 7.03208 12.7884 7.09625C12.7242 7.16025 12.6921 7.23075 12.6921 7.30775ZM6.61537 18.5C6.1102 18.5 5.68262 18.325 5.33262 17.975C4.98262 17.625 4.80762 17.1974 4.80762 16.6923V3.30775C4.80762 2.80258 4.98262 2.375 5.33262 2.025C5.68262 1.675 6.1102 1.5 6.61537 1.5H9.99987C10.505 1.5 10.9326 1.675 11.2826 2.025C11.6326 2.375 11.8076 2.80258 11.8076 3.30775V16.6923C11.8076 17.1974 11.6326 17.625 11.2826 17.975C10.9326 18.325 10.505 18.5 9.99987 18.5H6.61537ZM6.30762 3.30775V16.6923C6.30762 16.7692 6.3397 16.8398 6.40387 16.9038C6.46787 16.9679 6.53837 17 6.61537 17H9.99987C10.0769 17 10.1474 16.9679 10.2114 16.9038C10.2755 16.8398 10.3076 16.7692 10.3076 16.6923V3.30775C10.3076 3.23075 10.2755 3.16025 10.2114 3.09625C10.1474 3.03208 10.0769 3 9.99987 3H6.61537C6.53837 3 6.46787 3.03208 6.40387 3.09625C6.3397 3.16025 6.30762 3.23075 6.30762 3.30775Z",
      fill: "currentColor"
    }
  )),
  rich_text: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19ZM6.75 17H17.3268L14 12.3655L11.2308 16.0192L9 13.4615L6.75 17Z",
      fill: "currentColor"
    }
  ), /* @__PURE__ */ T.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6 12V6.5H9.1925C9.5925 6.5 9.9425 6.65 10.2425 6.95C10.5425 7.25 10.6925 7.6 10.6925 8V8.6925C10.6925 9.03733 10.605 9.32675 10.43 9.56075C10.255 9.79458 10.0168 9.97817 9.7155 10.1115L10.6155 12H9.404L8.504 10.1925H7.1925V12H6ZM9.1925 9H7.1925V7.6925H9.1925C9.26933 7.6925 9.33983 7.7245 9.404 7.7885C9.468 7.85267 9.5 7.92317 9.5 8V8.6925C9.5 8.76933 9.468 8.83983 9.404 8.904C9.33983 8.968 9.26933 9 9.1925 9Z",
      fill: "currentColor"
    }
  ), /* @__PURE__ */ T.createElement("path", { d: "M12.5 7H17.5V8.25H12.5V7Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement("path", { d: "M12.5 9.25H17.5V10.5H12.5V9.25Z", fill: "currentColor" })),
  difference: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
      fill: "currentColor"
    }
  ), /* @__PURE__ */ T.createElement("rect", { x: "9", y: "10", width: "5.5", height: "1.5", fill: "currentColor" }), /* @__PURE__ */ T.createElement("rect", { x: "9", y: "15", width: "5.5", height: "1.5", fill: "currentColor" }), /* @__PURE__ */ T.createElement("rect", { x: "11", y: "8", width: "1.5", height: "5.5", fill: "currentColor" })),
  markdown: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
      fill: "currentColor"
    }
  ), /* @__PURE__ */ T.createElement("path", { d: "M13 15H11.5V11L9.5 14L7.5 11V15H6V8H7.5L9.5 11L11.5 8H13V15Z", fill: "currentColor" }), /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M15.9921 15.5833L13.2886 12.8797L14.0546 12.1137L15.4504 13.5016V7.99597L16.5336 7.99993V13.5016L17.9296 12.1137L18.6954 12.8797L15.9921 15.5833Z",
      fill: "currentColor"
    }
  )),
  open_in_new: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H11.6152V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V12.3848H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM9.71925 15.3345L8.6655 14.2808L17.9462 5H14V3.5H20.5V10H19V6.05375L9.71925 15.3345Z",
      fill: "currentColor"
    }
  )),
  link_off: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M18.8843 16.1038L17.7498 14.9385C18.4228 14.7552 18.9661 14.3946 19.3796 13.8568C19.7931 13.319 19.9998 12.7 19.9998 12C19.9998 11.1604 19.705 10.444 19.1153 9.85105C18.5255 9.25805 17.8139 8.96155 16.9806 8.96155H13.1728V7.46155H16.9806C18.2293 7.46155 19.2947 7.90422 20.1768 8.78955C21.0588 9.67472 21.4998 10.7449 21.4998 12C21.4998 12.8859 21.262 13.6951 20.7863 14.4278C20.3107 15.1606 19.6767 15.7193 18.8843 16.1038ZM15.5806 12.75L14.0806 11.25H15.7306V12.75H15.5806ZM20.1461 22.2538L1.74609 3.8538L2.79984 2.80005L21.1998 21.2L20.1461 22.2538ZM10.8268 16.5386H7.03834C5.78318 16.5386 4.71301 16.0959 3.82784 15.2105C2.94251 14.3254 2.49984 13.2552 2.49984 12C2.49984 10.8885 2.85784 9.91322 3.57384 9.07405C4.28984 8.23505 5.18826 7.72838 6.26909 7.55405H6.49984L7.90759 8.96155H7.03834C6.19851 8.96155 5.48218 9.25805 4.88934 9.85105C4.29634 10.444 3.99984 11.1604 3.99984 12C3.99984 12.8397 4.29634 13.556 4.88934 14.149C5.48218 14.742 6.19851 15.0385 7.03834 15.0385H10.8268V16.5386ZM8.26909 12.75V11.25H10.2113L11.6863 12.75H8.26909Z",
      fill: "currentColor"
    }
  )),
  edit: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M5 19H6.2615L16.498 8.7635L15.2365 7.502L5 17.7385V19ZM3.5 20.5V17.1155L16.6905 3.93075C16.8417 3.79342 17.0086 3.68733 17.1913 3.6125C17.3741 3.5375 17.5658 3.5 17.7663 3.5C17.9668 3.5 18.1609 3.53558 18.3488 3.60675C18.5367 3.67792 18.7032 3.79108 18.848 3.94625L20.0693 5.18275C20.2244 5.32758 20.335 5.49425 20.401 5.68275C20.467 5.87125 20.5 6.05975 20.5 6.24825C20.5 6.44942 20.4657 6.64133 20.397 6.824C20.3283 7.00683 20.2191 7.17383 20.0693 7.325L6.8845 20.5H3.5ZM15.8562 8.14375L15.2365 7.502L16.498 8.7635L15.8562 8.14375Z",
      fill: "currentColor"
    }
  )),
  content_copy: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M9.05775 17.5C8.55258 17.5 8.125 17.325 7.775 16.975C7.425 16.625 7.25 16.1974 7.25 15.6923V4.30775C7.25 3.80258 7.425 3.375 7.775 3.025C8.125 2.675 8.55258 2.5 9.05775 2.5H17.4423C17.9474 2.5 18.375 2.675 18.725 3.025C19.075 3.375 19.25 3.80258 19.25 4.30775V15.6923C19.25 16.1974 19.075 16.625 18.725 16.975C18.375 17.325 17.9474 17.5 17.4423 17.5H9.05775ZM9.05775 16H17.4423C17.5192 16 17.5898 15.9679 17.6538 15.9038C17.7179 15.8398 17.75 15.7692 17.75 15.6923V4.30775C17.75 4.23075 17.7179 4.16025 17.6538 4.09625C17.5898 4.03208 17.5192 4 17.4423 4H9.05775C8.98075 4 8.91025 4.03208 8.84625 4.09625C8.78208 4.16025 8.75 4.23075 8.75 4.30775V15.6923C8.75 15.7692 8.78208 15.8398 8.84625 15.9038C8.91025 15.9679 8.98075 16 9.05775 16ZM5.55775 21C5.05258 21 4.625 20.825 4.275 20.475C3.925 20.125 3.75 19.6974 3.75 19.1923V6.30775H5.25V19.1923C5.25 19.2693 5.28208 19.3398 5.34625 19.4038C5.41025 19.4679 5.48075 19.5 5.55775 19.5H15.4423V21H5.55775Z",
      fill: "currentColor"
    }
  )),
  more_horiz: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M6.23096 13.5C5.81846 13.5 5.46537 13.3531 5.17171 13.0592C4.87787 12.7656 4.73096 12.4125 4.73096 12C4.73096 11.5875 4.87787 11.2344 5.17171 10.9408C5.46537 10.6469 5.81846 10.5 6.23096 10.5C6.64346 10.5 6.99662 10.6469 7.29046 10.9408C7.58412 11.2344 7.73096 11.5875 7.73096 12C7.73096 12.4125 7.58412 12.7656 7.29046 13.0592C6.99662 13.3531 6.64346 13.5 6.23096 13.5ZM12.0002 13.5C11.5877 13.5 11.2346 13.3531 10.941 13.0592C10.6471 12.7656 10.5002 12.4125 10.5002 12C10.5002 11.5875 10.6471 11.2344 10.941 10.9408C11.2346 10.6469 11.5877 10.5 12.0002 10.5C12.4127 10.5 12.7658 10.6469 13.0595 10.9408C13.3533 11.2344 13.5002 11.5875 13.5002 12C13.5002 12.4125 13.3533 12.7656 13.0595 13.0592C12.7658 13.3531 12.4127 13.5 12.0002 13.5ZM17.7695 13.5C17.357 13.5 17.0038 13.3531 16.71 13.0592C16.4163 12.7656 16.2695 12.4125 16.2695 12C16.2695 11.5875 16.4163 11.2344 16.71 10.9408C17.0038 10.6469 17.357 10.5 17.7695 10.5C18.182 10.5 18.535 10.6469 18.8287 10.9408C19.1225 11.2344 19.2695 11.5875 19.2695 12C19.2695 12.4125 19.1225 12.7656 18.8287 13.0592C18.535 13.3531 18.182 13.5 17.7695 13.5Z",
      fill: "currentColor"
    }
  )),
  more_vert: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M12 19.2692C11.5875 19.2692 11.2344 19.1223 10.9408 18.8285C10.6469 18.5348 10.5 18.1817 10.5 17.7692C10.5 17.3567 10.6469 17.0035 10.9408 16.7097C11.2344 16.416 11.5875 16.2692 12 16.2692C12.4125 16.2692 12.7656 16.416 13.0592 16.7097C13.3531 17.0035 13.5 17.3567 13.5 17.7692C13.5 18.1817 13.3531 18.5348 13.0592 18.8285C12.7656 19.1223 12.4125 19.2692 12 19.2692ZM12 13.5C11.5875 13.5 11.2344 13.353 10.9408 13.0592C10.6469 12.7655 10.5 12.4125 10.5 12C10.5 11.5875 10.6469 11.2344 10.9408 10.9407C11.2344 10.6469 11.5875 10.5 12 10.5C12.4125 10.5 12.7656 10.6469 13.0592 10.9407C13.3531 11.2344 13.5 11.5875 13.5 12C13.5 12.4125 13.3531 12.7655 13.0592 13.0592C12.7656 13.353 12.4125 13.5 12 13.5ZM12 7.73071C11.5875 7.73071 11.2344 7.58388 10.9408 7.29021C10.6469 6.99638 10.5 6.64321 10.5 6.23071C10.5 5.81821 10.6469 5.46513 10.9408 5.17146C11.2344 4.87763 11.5875 4.73071 12 4.73071C12.4125 4.73071 12.7656 4.87763 13.0592 5.17146C13.3531 5.46513 13.5 5.81821 13.5 6.23071C13.5 6.64321 13.3531 6.99638 13.0592 7.29021C12.7656 7.58388 12.4125 7.73071 12 7.73071Z",
      fill: "currentColor"
    }
  )),
  close: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M6.39994 18.6538L5.34619 17.6L10.9462 12L5.34619 6.4L6.39994 5.34625L11.9999 10.9463L17.5999 5.34625L18.6537 6.4L13.0537 12L18.6537 17.6L17.5999 18.6538L11.9999 13.0538L6.39994 18.6538Z",
      fill: "currentColor"
    }
  )),
  settings: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M9.69225 21.5L9.3115 18.4538C9.04367 18.3641 8.769 18.2385 8.4875 18.077C8.20617 17.9153 7.95459 17.7422 7.73275 17.5577L4.9115 18.75L2.604 14.75L5.04425 12.9058C5.02125 12.7571 5.00492 12.6077 4.99525 12.4578C4.98559 12.3078 4.98075 12.1583 4.98075 12.0095C4.98075 11.8673 4.98559 11.7228 4.99525 11.576C5.00492 11.4292 5.02125 11.2686 5.04425 11.0943L2.604 9.25L4.9115 5.26925L7.723 6.452C7.96417 6.261 8.22159 6.08633 8.49525 5.928C8.76892 5.76967 9.03784 5.64242 9.302 5.54625L9.69225 2.5H14.3078L14.6885 5.55575C14.9885 5.66475 15.2599 5.792 15.5028 5.9375C15.7458 6.083 15.991 6.2545 16.2385 6.452L19.0885 5.26925L21.396 9.25L18.9173 11.123C18.9531 11.2845 18.9727 11.4355 18.976 11.576C18.9792 11.7163 18.9808 11.8577 18.9808 12C18.9808 12.1358 18.9775 12.274 18.971 12.4145C18.9647 12.5548 18.9417 12.7154 18.902 12.8963L21.3615 14.75L19.0538 18.75L16.2385 17.548C15.991 17.7455 15.7384 17.9202 15.4808 18.072C15.2231 18.224 14.959 18.3481 14.6885 18.4443L14.3078 21.5H9.69225ZM11 20H12.9655L13.325 17.3212C13.8353 17.1879 14.3017 16.9985 14.724 16.753C15.1465 16.5073 15.5539 16.1916 15.9463 15.8057L18.4308 16.85L19.4155 15.15L17.2463 13.5155C17.3296 13.2565 17.3863 13.0026 17.4163 12.7537C17.4464 12.5051 17.4615 12.2538 17.4615 12C17.4615 11.7397 17.4464 11.4884 17.4163 11.2463C17.3863 11.0039 17.3296 10.7564 17.2463 10.5038L19.4345 8.85L18.45 7.15L15.9365 8.2095C15.6018 7.85183 15.2009 7.53583 14.7338 7.2615C14.2664 6.98717 13.7937 6.79292 13.3155 6.67875L13 4H11.0155L10.6845 6.66925C10.1743 6.78975 9.70325 6.97433 9.27125 7.223C8.83909 7.47183 8.42684 7.79233 8.0345 8.1845L5.55 7.15L4.5655 8.85L6.725 10.4595C6.64167 10.6968 6.58334 10.9437 6.55 11.2C6.51667 11.4563 6.5 11.7262 6.5 12.0095C6.5 12.2698 6.51667 12.525 6.55 12.775C6.58334 13.025 6.6385 13.2718 6.7155 13.5155L4.5655 15.15L5.55 16.85L8.025 15.8C8.4045 16.1897 8.81025 16.5089 9.24225 16.7578C9.67442 17.0064 10.152 17.1974 10.675 17.3307L11 20ZM12.0115 15C12.8435 15 13.5515 14.708 14.1355 14.124C14.7195 13.54 15.0115 12.832 15.0115 12C15.0115 11.168 14.7195 10.46 14.1355 9.876C13.5515 9.292 12.8435 9 12.0115 9C11.1692 9 10.4586 9.292 9.87975 9.876C9.30092 10.46 9.0115 11.168 9.0115 12C9.0115 12.832 9.30092 13.54 9.87975 14.124C10.4586 14.708 11.1692 15 12.0115 15Z",
      fill: "currentColor"
    }
  )),
  delete_big: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
      fill: "currentColor"
    }
  )),
  delete_small: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
      fill: "currentColor"
    }
  )),
  format_align_center: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M3.5 20.5V19H20.5V20.5H3.5ZM7.5 16.625V15.125H16.5V16.625H7.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM7.5 8.875V7.375H16.5V8.875H7.5ZM3.5 5V3.5H20.5V5H3.5Z",
      fill: "currentColor"
    }
  )),
  format_align_left: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M3.5 20.5V19H20.5V20.5H3.5ZM3.5 16.625V15.125H14.5V16.625H3.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM3.5 8.875V7.375H14.5V8.875H3.5ZM3.5 5V3.5H20.5V5H3.5Z",
      fill: "currentColor"
    }
  )),
  format_align_right: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M3.5 5V3.5H20.5V5H3.5ZM9.5 8.875V7.375H20.5V8.875H9.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM9.5 16.625V15.125H20.5V16.625H9.5ZM3.5 20.5V19H20.5V20.5H3.5Z",
      fill: "currentColor"
    }
  )),
  add_row: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4.025 10.2077C4.375 9.85775 4.80258 9.68275 5.30775 9.68275H6.5V11.1827H5.30775C5.21792 11.1827 5.14417 11.2116 5.0865 11.2693C5.02883 11.3269 5 11.4007 5 11.4905V16.1923C5 16.2821 5.02883 16.3558 5.0865 16.4135C5.14417 16.4712 5.21792 16.5 5.30775 16.5H18.6923C18.7821 16.5 18.8558 16.4712 18.9135 16.4135C18.9712 16.3558 19 16.2821 19 16.1923V11.4905C19 11.4007 18.9712 11.3269 18.9135 11.2693C18.8558 11.2116 18.7821 11.1827 18.6923 11.1827H17.6923V9.68275H18.6923C19.1974 9.68275 19.625 9.85775 19.975 10.2077C20.325 10.5577 20.5 10.9853 20.5 11.4905V16.1923C20.5 16.6974 20.325 17.125 19.975 17.475C19.625 17.825 19.1974 18 18.6923 18H5.30775C4.80258 18 4.375 17.825 4.025 17.475C3.675 17.125 3.5 16.6974 3.5 16.1923V11.4905C3.5 10.9853 3.675 10.5577 4.025 10.2077Z",
      fill: "currentColor"
    }
  ), /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M11.3848 9.68275V7.5H12.8848V9.68275H15V11.1827H12.8848V13.2307H11.3848V11.1827H9.26925V9.68275H11.3848Z",
      fill: "currentColor"
    }
  )),
  add_column: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.70775 4.025C9.35775 4.375 9.18275 4.80258 9.18275 5.30775V6.5H10.6827V5.30775C10.6827 5.21792 10.7116 5.14417 10.7693 5.0865C10.8269 5.02883 10.9007 5 10.9905 5H15.6923C15.7821 5 15.8558 5.02883 15.9135 5.0865C15.9712 5.14417 16 5.21792 16 5.30775V18.6923C16 18.7821 15.9712 18.8558 15.9135 18.9135C15.8558 18.9712 15.7821 19 15.6923 19H10.9905C10.9007 19 10.8269 18.9712 10.7693 18.9135C10.7116 18.8558 10.6827 18.7821 10.6827 18.6923V17.6923H9.18275V18.6923C9.18275 19.1974 9.35775 19.625 9.70775 19.975C10.0577 20.325 10.4853 20.5 10.9905 20.5H15.6923C16.1974 20.5 16.625 20.325 16.975 19.975C17.325 19.625 17.5 19.1974 17.5 18.6923V5.30775C17.5 4.80258 17.325 4.375 16.975 4.025C16.625 3.675 16.1974 3.5 15.6923 3.5H10.9905C10.4853 3.5 10.0577 3.675 9.70775 4.025Z",
      fill: "currentColor"
    }
  ), /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M9.18275 11.3848H7V12.8848H9.18275V15H10.6827V12.8848H12.7307V11.3848H10.6827V9.26925H9.18275V11.3848Z",
      fill: "currentColor"
    }
  )),
  insert_col_left: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M13.0001 20.1152H8.67713H8.75388H8.69238H13.0001ZM7.19238 19.8075C7.19238 20.3127 7.36738 20.7402 7.71738 21.0902C8.06738 21.4402 8.49497 21.6152 9.00013 21.6152H12.6924C13.1975 21.6152 13.6251 21.4402 13.9751 21.0902C14.3251 20.7402 14.5001 20.3127 14.5001 19.8075V10.423H13.0001V19.8075C13.0001 19.8973 12.9713 19.9711 12.9136 20.0287C12.856 20.0864 12.7822 20.1152 12.6924 20.1152H9.00013C8.9103 20.1152 8.83655 20.0864 8.77888 20.0287C8.72122 19.9711 8.69238 19.8973 8.69238 19.8075V4.69223C8.26422 4.74357 7.90722 4.93299 7.62138 5.26048C7.33538 5.58798 7.19238 5.97548 7.19238 6.42298V19.8075ZM13.0001 2.49998V4.61523H10.8846V6.11523H13.0001V8.23073H14.5001V6.11523H16.6154V4.61523H14.5001V2.49998H13.0001Z",
      fill: "currentColor"
    }
  )),
  insert_row_above: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M20.1152 9.99987V14.3229V14.2461V14.3076V9.99987ZM19.8075 15.8076C20.3127 15.8076 20.7402 15.6326 21.0902 15.2826C21.4402 14.9326 21.6152 14.505 21.6152 13.9999V10.3076C21.6152 9.80245 21.4402 9.37487 21.0902 9.02487C20.7402 8.67487 20.3127 8.49987 19.8075 8.49987H10.423V9.99987H19.8075C19.8973 9.99987 19.9711 10.0287 20.0287 10.0864C20.0864 10.144 20.1152 10.2178 20.1152 10.3076V13.9999C20.1152 14.0897 20.0864 14.1635 20.0287 14.2211C19.9711 14.2788 19.8973 14.3076 19.8075 14.3076H4.69223C4.74357 14.7358 4.93299 15.0928 5.26048 15.3786C5.58798 15.6646 5.97548 15.8076 6.42298 15.8076H19.8075ZM2.49998 9.99987H4.61523V12.1154H6.11523V9.99987H8.23073V8.49987H6.11523V6.38462H4.61523V8.49987H2.49998V9.99987Z",
      fill: "currentColor"
    }
  )),
  insert_row_below: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M20.1152 14.1924V9.86939V9.94614V9.88464V14.1924ZM19.8075 8.38464C20.3127 8.38464 20.7402 8.55964 21.0902 8.90964C21.4402 9.25964 21.6152 9.68723 21.6152 10.1924V13.8846C21.6152 14.3898 21.4402 14.8174 21.0902 15.1674C20.7402 15.5174 20.3127 15.6924 19.8075 15.6924H10.423V14.1924H19.8075C19.8973 14.1924 19.9711 14.1636 20.0287 14.1059C20.0864 14.0482 20.1152 13.9745 20.1152 13.8846V10.1924C20.1152 10.1026 20.0864 10.0288 20.0287 9.97114C19.9711 9.91348 19.8973 9.88464 19.8075 9.88464H4.69223C4.74357 9.45648 4.93299 9.09948 5.26048 8.81364C5.58798 8.52764 5.97548 8.38464 6.42298 8.38464H19.8075ZM2.49998 14.1924H4.61523V12.0769H6.11523V14.1924H8.23073V15.6924H6.11523V17.8076H4.61523V15.6924H2.49998V14.1924Z",
      fill: "currentColor"
    }
  )),
  insert_col_right: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M10.8075 20.1152H15.1305H15.0537H15.1152H10.8075ZM16.6152 19.8075C16.6152 20.3127 16.4402 20.7402 16.0902 21.0902C15.7402 21.4402 15.3127 21.6152 14.8075 21.6152H11.1152C10.6101 21.6152 10.1825 21.4402 9.83248 21.0902C9.48248 20.7402 9.30748 20.3127 9.30748 19.8075V10.423H10.8075V19.8075C10.8075 19.8973 10.8363 19.9711 10.894 20.0287C10.9517 20.0864 11.0254 20.1152 11.1152 20.1152H14.8075C14.8973 20.1152 14.9711 20.0864 15.0287 20.0287C15.0864 19.9711 15.1152 19.8973 15.1152 19.8075V4.69223C15.5434 4.74357 15.9004 4.93299 16.1862 5.26048C16.4722 5.58798 16.6152 5.97548 16.6152 6.42298V19.8075ZM10.8075 2.49998V4.61523H12.923V6.11523H10.8075V8.23073H9.30748V6.11523H7.19223V4.61523H9.30748V2.49998H10.8075Z",
      fill: "currentColor"
    }
  )),
  check: /* @__PURE__ */ T.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ T.createElement(
    "path",
    {
      d: "M9.54983 17.6537L4.21533 12.3192L5.28433 11.25L9.54983 15.5155L18.7153 6.34998L19.7843 7.41923L9.54983 17.6537Z",
      fill: "currentColor"
    }
  ))
};
function u0(e, t) {
  return u0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, u0(e, t);
}
var j_ = { error: null }, rz = function(e) {
  var t, n;
  function r() {
    for (var s, o = arguments.length, a = new Array(o), l = 0; l < o; l++) a[l] = arguments[l];
    return (s = e.call.apply(e, [this].concat(a)) || this).state = j_, s.resetErrorBoundary = function() {
      for (var c, u = arguments.length, f = new Array(u), d = 0; d < u; d++) f[d] = arguments[d];
      s.props.onReset == null || (c = s.props).onReset.apply(c, f), s.reset();
    }, s;
  }
  n = e, (t = r).prototype = Object.create(n.prototype), t.prototype.constructor = t, u0(t, n), r.getDerivedStateFromError = function(s) {
    return { error: s };
  };
  var i = r.prototype;
  return i.reset = function() {
    this.setState(j_);
  }, i.componentDidCatch = function(s, o) {
    var a, l;
    (a = (l = this.props).onError) == null || a.call(l, s, o);
  }, i.componentDidUpdate = function(s, o) {
    var a, l, c, u, f = this.state.error, d = this.props.resetKeys;
    f !== null && o.error !== null && ((c = s.resetKeys) === void 0 && (c = []), (u = d) === void 0 && (u = []), c.length !== u.length || c.some(function(h, m) {
      return !Object.is(h, u[m]);
    })) && ((a = (l = this.props).onResetKeysChange) == null || a.call(l, s.resetKeys, d), this.reset());
  }, i.render = function() {
    var s = this.state.error, o = this.props, a = o.fallbackRender, l = o.FallbackComponent, c = o.fallback;
    if (s !== null) {
      var u = { error: s, resetErrorBoundary: this.resetErrorBoundary };
      if (w.isValidElement(c)) return c;
      if (typeof a == "function") return a(u);
      if (l) return w.createElement(l, u);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, r;
}(w.Component);
function mS({ children: e, onError: t }) {
  return A(rz, { fallback: A("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }), onError: t, children: e });
}
const iz = ({ children: e }) => {
  const t = mn(Gr), n = T.useMemo(() => [t, wE(null, Yv)], [t]);
  return /* @__PURE__ */ T.createElement(gd.Provider, { value: n }, e);
}, sz = () => {
  const e = Kn(), t = It(kV), n = (u) => {
    t({ current: u });
  }, [r, i, s, o, a, l, c] = On(
    t0,
    n0,
    nS,
    rS,
    sS,
    r0,
    iS
  );
  return /* @__PURE__ */ T.createElement(T.Fragment, null, o.map((u, f) => /* @__PURE__ */ T.createElement(u, { key: f })), /* @__PURE__ */ T.createElement(gS, { wrappers: a }, /* @__PURE__ */ T.createElement("div", { className: rt(de.rootContentEditableWrapper, "mdxeditor-root-contenteditable") }, /* @__PURE__ */ T.createElement(
    hS,
    {
      contentEditable: /* @__PURE__ */ T.createElement("div", { ref: n }, /* @__PURE__ */ T.createElement(
        dS,
        {
          className: rt(de.contentEditable, r),
          ariaLabel: e("contentArea.editableMarkdown", "editable markdown"),
          spellCheck: i
        }
      )),
      placeholder: /* @__PURE__ */ T.createElement("div", { className: rt(de.contentEditable, de.placeholder, r) }, /* @__PURE__ */ T.createElement("p", null, l)),
      ErrorBoundary: mS
    }
  ))), s.map((u, f) => /* @__PURE__ */ T.createElement(u, { key: f })), c.map((u, f) => /* @__PURE__ */ T.createElement(u, { key: f })));
}, oz = {
  listItemIndent: "one"
}, az = (e) => nz[e];
function lz(e, t, n = {}) {
  let r = t;
  for (const [i, s] of Object.entries(n))
    r = r.replaceAll(`{{${i}}}`, String(s));
  return r;
}
const gS = ({ wrappers: e, children: t }) => {
  if (e.length === 0)
    return /* @__PURE__ */ T.createElement(T.Fragment, null, t);
  const n = e[0];
  return /* @__PURE__ */ T.createElement(n, null, /* @__PURE__ */ T.createElement(gS, { wrappers: e.slice(1) }, t));
}, cz = ({ children: e, className: t, overlayContainer: n }) => {
  const r = T.useRef(null), i = It(Yo);
  return T.useEffect(() => {
    const s = document.createElement("div");
    return s.classList.add(
      "mdxeditor-popup-container",
      de.editorRoot,
      de.popupContainer,
      ...(t ?? "").trim().split(" ").filter(Boolean)
    ), (n ?? document.body).appendChild(s), r.current = s, i(r), () => {
      s.remove();
    };
  }, [t, r, n, i]), /* @__PURE__ */ T.createElement("div", { className: rt("mdxeditor", de.editorRoot, de.editorWrapper, t) }, e);
}, uz = ({ mdxRef: e }) => {
  const t = Yc();
  return T.useImperativeHandle(
    e,
    () => ({
      getMarkdown: () => {
        const n = t.getValue(Kd);
        return n === "source" || n === "diff" ? t.getValue(Pc) : t.getValue(Vo);
      },
      setMarkdown: (n) => {
        t.pub(ry, n);
      },
      insertMarkdown: (n) => {
        t.pub(Y6, n);
      },
      focus: (n, r) => {
        var i;
        (i = t.getValue(Gr)) == null || i.focus(n, r);
      }
    }),
    [t]
  ), null;
}, fz = T.forwardRef((e, t) => /* @__PURE__ */ T.createElement(
  LM,
  {
    plugins: [
      IV({
        contentEditableClassName: e.contentEditableClassName ?? "",
        spellCheck: e.spellCheck ?? !0,
        initialMarkdown: e.markdown,
        onChange: e.onChange ?? Ta,
        onBlur: e.onBlur ?? Ta,
        toMarkdownOptions: e.toMarkdownOptions ?? oz,
        autoFocus: e.autoFocus ?? !1,
        placeholder: e.placeholder ?? "",
        readOnly: !!e.readOnly,
        iconComponentFor: e.iconComponentFor ?? az,
        suppressHtmlProcessing: e.suppressHtmlProcessing ?? !1,
        onError: e.onError ?? Ta,
        translation: e.translation ?? lz,
        trim: e.trim ?? !0,
        lexicalTheme: e.lexicalTheme
      }),
      ...e.plugins ?? []
    ]
  },
  /* @__PURE__ */ T.createElement(cz, { className: e.className, overlayContainer: e.overlayContainer }, /* @__PURE__ */ T.createElement(iz, null, /* @__PURE__ */ T.createElement(sz, null))),
  /* @__PURE__ */ T.createElement(uz, { mdxRef: t })
)), vS = typeof window < "u" && typeof window.document.createElement < "u", Gd = vS && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function dz(e, t) {
  return Gd ? e : t;
}
const hz = {
  testLexicalNode: vp,
  visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
    const n = parseInt(e.getTag()[1], 10);
    t.addAndStepInto("heading", { depth: n });
  }
}, pz = {
  testNode: "heading",
  visitNode: function({ mdastNode: e, actions: t }) {
    t.addAndStepInto(li(`h${e.depth}`));
  }
}, mz = [48, 49, 50, 51, 52, 53, 54], yS = [1, 2, 3, 4, 5, 6], gz = {
  49: 1,
  50: 2,
  51: 3,
  52: 4,
  53: 5,
  54: 6
}, Sp = Te(yS, (e) => {
  e.pub(Cp, (t) => t.registerCommand(
    rv,
    (n) => {
      const { keyCode: r, ctrlKey: i, metaKey: s, altKey: o } = n;
      return mz.includes(r) && dz(s, i) && o ? (n.preventDefault(), t.update(() => {
        if (r === 48)
          e.pub(Jd, () => st());
        else {
          const a = e.getValue(Sp), l = gz[r];
          a.includes(l) || e.pub(Jd, () => li(`h${l}`));
        }
      }), !0) : !1;
    },
    xt
  ));
}), vz = Jn({
  init(e) {
    e.pubIn({
      [vl]: "headings",
      [Er]: pz,
      [Yr]: lu,
      [Xr]: hz
    });
  },
  update(e, t) {
    e.pub(Sp, (t == null ? void 0 : t.allowedHeadingLevels) ?? yS);
  }
});
function W_(e, t) {
  return e.getEditorState().read(() => {
    const n = wt(t);
    return n !== null && n.isSelected();
  });
}
function xS(e) {
  const [t] = vn(), [n, r] = Re(() => W_(t, e));
  return Le(() => {
    let i = !0;
    const s = t.registerUpdateListener(() => {
      i && r(W_(t, e));
    });
    return () => {
      i = !1, s();
    };
  }, [t, e]), [n, Ht((i) => {
    t.update(() => {
      let s = ge();
      Nt(s) || (s = vv(), Ot(s)), Nt(s) && (i ? s.add(e) : s.delete(e));
    });
  }, [t, e]), Ht(() => {
    t.update(() => {
      const i = ge();
      Nt(i) && i.clear();
    });
  }, [t])];
}
const wS = Pe("INSERT_HORIZONTAL_RULE_COMMAND");
function yz({ nodeKey: e }) {
  const [t] = vn(), [n, r, i] = xS(e);
  return Le(() => Dn(t.registerCommand(ep, (s) => {
    const o = t.getElementByKey(e);
    return s.target === o && (s.shiftKey || i(), r(!n), !0);
  }, xt)), [i, t, n, e, r]), Le(() => {
    const s = t.getElementByKey(e), o = t._config.theme.hrSelected ?? "selected";
    s !== null && (n ? Ur(s, o) : gp(s, o));
  }, [t, n, e]), null;
}
let mu = class _S extends bi {
  static getType() {
    return "horizontalrule";
  }
  static clone(t) {
    return new _S(t.__key);
  }
  static importJSON(t) {
    return xl().updateFromJSON(t);
  }
  static importDOM() {
    return { hr: () => ({ conversion: xz, priority: 0 }) };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(t) {
    const n = document.createElement("hr");
    return Ur(n, t.theme.hr), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return A(yz, { nodeKey: this.__key });
  }
};
function xz() {
  return { node: xl() };
}
function xl() {
  return Pn(new mu());
}
function oy(e) {
  return e instanceof mu;
}
function wz() {
  const [e] = vn();
  return Le(() => e.registerCommand(wS, (t) => {
    const n = ge();
    if (!fe(n)) return !1;
    if (n.focus.getNode() !== null) {
      const r = xl();
      U9(r);
    }
    return !0;
  }, qe), [e]), null;
}
const _z = {
  testLexicalNode: oy,
  visitLexicalNode({ actions: e }) {
    e.addAndStepInto("thematicBreak");
  }
}, bz = {
  testNode: "thematicBreak",
  visitNode({ actions: e }) {
    e.addAndStepInto(xl());
  }
}, Cz = _i((e) => {
  e.sub(e.pipe(Cz, Tt(Ft)), ([, t]) => {
    t == null || t.dispatchCommand(wS, void 0);
  });
}), Ez = Jn({
  init(e) {
    e.pubIn({
      [vl]: "thematicBreak",
      [Er]: bz,
      [Yr]: mu,
      [Xr]: _z,
      [Xo]: wz
    });
  }
});
function Is(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function Dc(e) {
  let t = 1, n = e.getParent();
  for (; n != null; ) {
    if (Je(n)) {
      const r = n.getParent();
      if (De(r)) {
        t++, n = r.getParent();
        continue;
      }
      Is(40);
    }
    return t;
  }
  return t;
}
function f0(e) {
  let t = e.getParent();
  De(t) || Is(40);
  let n = t;
  for (; n !== null; ) n = n.getParent(), De(n) && (t = n);
  return t;
}
function bS(e) {
  let t = [];
  const n = e.getChildren().filter(Je);
  for (let r = 0; r < n.length; r++) {
    const i = n[r], s = i.getFirstChild();
    De(s) ? t = t.concat(bS(s)) : t.push(i);
  }
  return t;
}
function si(e) {
  return Je(e) && De(e.getFirstChild());
}
function J_(e) {
  return Ln().append(e);
}
function CS(e, t) {
  return Je(e) && (t.length === 0 || t.length === 1 && e.is(t[0]) && e.getChildrenSize() === 0);
}
function d0(e) {
  const t = ge();
  if (t !== null) {
    let n = t.getNodes();
    if (fe(t)) {
      const i = t.getStartEndPoints();
      i === null && Is(143);
      const [s] = i, o = s.getNode(), a = o.getParent();
      if (Jt(o)) {
        const l = o.getFirstChild();
        if (l) n = l.selectStart().getNodes();
        else {
          const c = st();
          o.append(c), n = c.select().getNodes();
        }
      } else if (CS(o, n)) {
        const l = In(e);
        if (Jt(a)) {
          o.replace(l);
          const c = Ln();
          te(o) && (c.setFormat(o.getFormatType()), c.setIndent(o.getIndent())), l.append(c);
        } else if (Je(o)) {
          const c = o.getParentOrThrow();
          Bo(l, c.getChildren()), c.replace(l);
        }
        return;
      }
    }
    const r = /* @__PURE__ */ new Set();
    for (let i = 0; i < n.length; i++) {
      const s = n[i];
      if (te(s) && s.isEmpty() && !Je(s) && !r.has(s.getKey())) {
        K_(s, e);
        continue;
      }
      let o = g9(s) ? s.getParent() : Je(s) && s.isEmpty() ? s : null;
      for (; o != null; ) {
        const a = o.getKey();
        if (De(o)) {
          if (!r.has(a)) {
            const l = In(e);
            Bo(l, o.getChildren()), o.replace(l), r.add(a);
          }
          break;
        }
        {
          const l = o.getParent();
          if (Jt(l) && !r.has(a)) {
            r.add(a), K_(o, e);
            break;
          }
          o = l;
        }
      }
    }
  }
}
function Bo(e, t) {
  e.splice(e.getChildrenSize(), 0, t);
}
function K_(e, t) {
  if (De(e)) return e;
  const n = e.getPreviousSibling(), r = e.getNextSibling(), i = Ln();
  let s;
  if (Bo(i, e.getChildren()), De(n) && t === n.getListType()) n.append(i), De(r) && t === r.getListType() && (Bo(n, r.getChildren()), r.remove()), s = n;
  else if (De(r) && t === r.getListType()) r.getFirstChildOrThrow().insertBefore(i), s = r;
  else {
    const o = In(t);
    o.append(i), e.replace(o), s = o;
  }
  return i.setFormat(e.getFormatType()), i.setIndent(e.getIndent()), e.remove(), s;
}
function ay(e, t) {
  const n = e.getLastChild(), r = t.getFirstChild();
  n && r && si(n) && si(r) && (ay(n.getFirstChild(), r.getFirstChild()), r.remove());
  const i = t.getChildren();
  i.length > 0 && e.append(...i), t.remove();
}
function Sz() {
  const e = ge();
  if (fe(e)) {
    const t = /* @__PURE__ */ new Set(), n = e.getNodes(), r = e.anchor.getNode();
    if (CS(r, n)) t.add(f0(r));
    else for (let i = 0; i < n.length; i++) {
      const s = n[i];
      if (g9(s)) {
        const o = H9(s, ls);
        o != null && t.add(f0(o));
      }
    }
    for (const i of t) {
      let s = i;
      const o = bS(i);
      for (const a of o) {
        const l = st().setTextStyle(e.style).setTextFormat(e.format);
        Bo(l, a.getChildren()), s.insertAfter(l), s = l, a.__key === e.anchor.key && $o(e.anchor, tr(br(l, "next"))), a.__key === e.focus.key && $o(e.focus, tr(br(l, "next"))), a.remove();
      }
      i.remove();
    }
  }
}
function ES(e) {
  const t = e.getListType() !== "check";
  let n = e.getStart();
  for (const r of e.getChildren()) Je(r) && (r.getValue() !== n && r.setValue(n), t && r.getLatest().__checked != null && r.setChecked(void 0), De(r.getFirstChild()) || n++);
}
function kz(e) {
  const t = /* @__PURE__ */ new Set();
  if (si(e) || t.has(e.getKey())) return;
  const n = e.getParent(), r = e.getNextSibling(), i = e.getPreviousSibling();
  if (si(r) && si(i)) {
    const s = i.getFirstChild();
    if (De(s)) {
      s.append(e);
      const o = r.getFirstChild();
      De(o) && (Bo(s, o.getChildren()), r.remove(), t.add(r.getKey()));
    }
  } else if (si(r)) {
    const s = r.getFirstChild();
    if (De(s)) {
      const o = s.getFirstChild();
      o !== null && o.insertBefore(e);
    }
  } else if (si(i)) {
    const s = i.getFirstChild();
    De(s) && s.append(e);
  } else if (De(n)) {
    const s = Ln().setTextFormat(e.getTextFormat()).setTextStyle(e.getTextStyle()), o = In(n.getListType()).setTextFormat(n.getTextFormat()).setTextStyle(n.getTextStyle());
    s.append(o), o.append(e), i ? i.insertAfter(s) : r ? r.insertBefore(s) : n.append(s);
  }
}
function Tz(e) {
  if (si(e)) return;
  const t = e.getParent(), n = t ? t.getParent() : void 0;
  if (De(n ? n.getParent() : void 0) && Je(n) && De(t)) {
    const r = t ? t.getFirstChild() : void 0, i = t ? t.getLastChild() : void 0;
    if (e.is(r)) n.insertBefore(e), t.isEmpty() && n.remove();
    else if (e.is(i)) n.insertAfter(e), t.isEmpty() && n.remove();
    else {
      const s = t.getListType(), o = Ln(), a = In(s);
      o.append(a), e.getPreviousSiblings().forEach((u) => a.append(u));
      const l = Ln(), c = In(s);
      l.append(c), Bo(c, e.getNextSiblings()), n.insertBefore(o), n.insertAfter(l), n.replace(e);
    }
  }
}
function Az() {
  const e = ge();
  if (!fe(e) || !e.isCollapsed()) return !1;
  const t = e.anchor.getNode();
  if (!Je(t) || t.getChildrenSize() !== 0) return !1;
  const n = f0(t), r = t.getParent();
  De(r) || Is(40);
  const i = r.getParent();
  let s;
  if (Jt(i)) s = st(), n.insertAfter(s);
  else {
    if (!Je(i)) return !1;
    s = Ln(), i.insertAfter(s);
  }
  s.setTextStyle(e.style).setTextFormat(e.format).select();
  const o = t.getNextSiblings();
  if (o.length > 0) {
    const a = In(r.getListType());
    if (Je(s)) {
      const l = Ln();
      l.append(a), s.insertAfter(l);
    } else s.insertAfter(a);
    a.append(...o);
  }
  return function(a) {
    let l = a;
    for (; l.getNextSibling() == null && l.getPreviousSibling() == null; ) {
      const c = l.getParent();
      if (c == null || !Je(c) && !De(c)) break;
      l = c;
    }
    l.remove();
  }(t), !0;
}
function Yd(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
let ls = class extends Wn {
  $config() {
    return this.config("listitem", { $transform: (t) => {
      if (t.__checked == null) return;
      const n = t.getParent();
      De(n) && n.getListType() !== "check" && t.getChecked() != null && t.setChecked(void 0);
    }, extends: Wn, importDOM: { li: () => ({ conversion: Nz, priority: 0 }) } });
  }
  constructor(t = 1, n = void 0, r) {
    super(r), this.__value = t === void 0 ? 1 : t, this.__checked = n;
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__value = t.__value, this.__checked = t.__checked;
  }
  createDOM(t) {
    const n = document.createElement("li");
    return this.updateListItemDOM(null, n, t), n;
  }
  updateListItemDOM(t, n, r) {
    const i = this.getParent();
    De(i) && i.getListType() === "check" && function(a, l, c, u) {
      De(l.getFirstChild()) ? (a.removeAttribute("role"), a.removeAttribute("tabIndex"), a.removeAttribute("aria-checked")) : (a.setAttribute("role", "checkbox"), a.setAttribute("tabIndex", "-1"), c && l.__checked === c.__checked || a.setAttribute("aria-checked", l.getChecked() ? "true" : "false"));
    }(n, this, t), n.value = this.__value, function(a, l, c) {
      const u = [], f = [], d = l.list, h = d ? d.listitem : void 0;
      let m;
      if (d && d.nested && (m = d.nested.listitem), h !== void 0 && u.push(...Yd(h)), d) {
        const p = c.getParent(), y = De(p) && p.getListType() === "check", v = c.getChecked();
        y && !v || f.push(d.listitemUnchecked), y && v || f.push(d.listitemChecked), y && u.push(v ? d.listitemChecked : d.listitemUnchecked);
      }
      if (m !== void 0) {
        const p = Yd(m);
        c.getChildren().some((y) => De(y)) ? u.push(...p) : f.push(...p);
      }
      f.length > 0 && gp(a, ...f), u.length > 0 && Ur(a, ...u);
    }(n, r.theme, this);
    const s = t ? t.__style : "", o = this.__style;
    s !== o && (o === "" ? n.removeAttribute("style") : n.style.cssText = o), function(a, l, c) {
      const u = Kw(l.__textStyle);
      for (const f in u) a.style.setProperty(`--listitem-marker-${f}`, u[f]);
      if (c) for (const f in Kw(c.__textStyle)) f in u || a.style.removeProperty(`--listitem-marker-${f}`);
    }(n, this, t);
  }
  updateDOM(t, n, r) {
    const i = n;
    return this.updateListItemDOM(t, i, r), !1;
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setValue(t.value).setChecked(t.checked);
  }
  exportDOM(t) {
    const n = this.createDOM(t._config), r = this.getFormatType();
    r && (n.style.textAlign = r);
    const i = this.getDirection();
    return i && (n.dir = i), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), checked: this.getChecked(), value: this.getValue() };
  }
  append(...t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      if (te(r) && this.canMergeWith(r)) {
        const i = r.getChildren();
        this.append(...i), r.remove();
      } else super.append(r);
    }
    return this;
  }
  replace(t, n) {
    if (Je(t)) return super.replace(t);
    this.setIndent(0);
    const r = this.getParentOrThrow();
    if (!De(r)) return t;
    if (r.__first === this.getKey()) r.insertBefore(t);
    else if (r.__last === this.getKey()) r.insertAfter(t);
    else {
      const i = In(r.getListType());
      let s = this.getNextSibling();
      for (; s; ) {
        const o = s;
        s = s.getNextSibling(), i.append(o);
      }
      r.insertAfter(t), t.insertAfter(i);
    }
    return n && (te(t) || Is(139), this.getChildren().forEach((i) => {
      t.append(i);
    })), this.remove(), r.getChildrenSize() === 0 && r.remove(), t;
  }
  insertAfter(t, n = !0) {
    const r = this.getParentOrThrow();
    if (De(r) || Is(39), Je(t)) return super.insertAfter(t, n);
    const i = this.getNextSiblings();
    if (r.insertAfter(t, n), i.length !== 0) {
      const s = In(r.getListType());
      i.forEach((o) => s.append(o)), t.insertAfter(s, n);
    }
    return t;
  }
  remove(t) {
    const n = this.getPreviousSibling(), r = this.getNextSibling();
    super.remove(t), n && r && si(n) && si(r) && (ay(n.getFirstChild(), r.getFirstChild()), r.remove());
  }
  insertNewAfter(t, n = !0) {
    const r = Ln().updateFromJSON(this.exportJSON()).setChecked(!this.getChecked() && void 0);
    return this.insertAfter(r, n), r;
  }
  collapseAtStart(t) {
    const n = st();
    this.getChildren().forEach((o) => n.append(o));
    const r = this.getParentOrThrow(), i = r.getParentOrThrow(), s = Je(i);
    if (r.getChildrenSize() === 1) if (s) r.remove(), i.select();
    else {
      r.insertBefore(n), r.remove();
      const o = t.anchor, a = t.focus, l = n.getKey();
      o.type === "element" && o.getNode().is(this) && o.set(l, o.offset, "element"), a.type === "element" && a.getNode().is(this) && a.set(l, a.offset, "element");
    }
    else r.insertBefore(n), this.remove();
    return !0;
  }
  getValue() {
    return this.getLatest().__value;
  }
  setValue(t) {
    const n = this.getWritable();
    return n.__value = t, n;
  }
  getChecked() {
    const t = this.getLatest();
    let n;
    const r = this.getParent();
    return De(r) && (n = r.getListType()), n === "check" ? !!t.__checked : void 0;
  }
  setChecked(t) {
    const n = this.getWritable();
    return n.__checked = t, n;
  }
  toggleChecked() {
    const t = this.getWritable();
    return t.setChecked(!t.__checked);
  }
  getIndent() {
    const t = this.getParent();
    if (t === null || !this.isAttached()) return this.getLatest().__indent;
    let n = t.getParentOrThrow(), r = 0;
    for (; Je(n); ) n = n.getParentOrThrow().getParentOrThrow(), r++;
    return r;
  }
  setIndent(t) {
    typeof t != "number" && Is(117), (t = Math.floor(t)) >= 0 || Is(199);
    let n = this.getIndent();
    for (; n !== t; ) n < t ? (kz(this), n++) : (Tz(this), n--);
    return this;
  }
  canInsertAfter(t) {
    return Je(t);
  }
  canReplaceWith(t) {
    return Je(t);
  }
  canMergeWith(t) {
    return Je(t) || Ev(t);
  }
  extractWithChild(t, n) {
    if (!fe(n)) return !1;
    const r = n.anchor.getNode(), i = n.focus.getNode();
    return this.isParentOf(r) && this.isParentOf(i) && this.getTextContent().length === n.getTextContent().length;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return In("bullet");
  }
  canMergeWhenEmpty() {
    return !0;
  }
};
function Nz(e) {
  if (e.classList.contains("task-list-item")) {
    for (const n of e.children) if (n.tagName === "INPUT") return Iz(n);
  }
  const t = e.getAttribute("aria-checked");
  return { node: Ln(t === "true" || t !== "false" && void 0) };
}
function Iz(e) {
  return e.getAttribute("type") !== "checkbox" ? { node: null } : { node: Ln(e.hasAttribute("checked")) };
}
function Ln(e) {
  return Pn(new ls(void 0, e));
}
function Je(e) {
  return e instanceof ls;
}
let cs = class extends Wn {
  $config() {
    return this.config("list", { $transform: (t) => {
      (function(n) {
        const r = n.getNextSibling();
        De(r) && n.getListType() === r.getListType() && ay(n, r);
      })(t), ES(t);
    }, extends: Wn, importDOM: { ol: () => ({ conversion: G_, priority: 0 }), ul: () => ({ conversion: G_, priority: 0 }) } });
  }
  constructor(t = "number", n = 1, r) {
    super(r);
    const i = Mz[t] || t;
    this.__listType = i, this.__tag = i === "number" ? "ol" : "ul", this.__start = n;
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__listType = t.__listType, this.__tag = t.__tag, this.__start = t.__start;
  }
  getTag() {
    return this.getLatest().__tag;
  }
  setListType(t) {
    const n = this.getWritable();
    return n.__listType = t, n.__tag = t === "number" ? "ol" : "ul", n;
  }
  getListType() {
    return this.getLatest().__listType;
  }
  getStart() {
    return this.getLatest().__start;
  }
  setStart(t) {
    const n = this.getWritable();
    return n.__start = t, n;
  }
  createDOM(t, n) {
    const r = this.__tag, i = document.createElement(r);
    return this.__start !== 1 && i.setAttribute("start", String(this.__start)), i.__lexicalListType = this.__listType, q_(i, t.theme, this), i;
  }
  updateDOM(t, n, r) {
    return t.__tag !== this.__tag || (q_(n, r.theme, this), !1);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setListType(t.listType).setStart(t.start);
  }
  exportDOM(t) {
    const n = this.createDOM(t._config, t);
    return At(n) && (this.__start !== 1 && n.setAttribute("start", String(this.__start)), this.__listType === "check" && n.setAttribute("__lexicalListType", "check")), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag() };
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
  splice(t, n, r) {
    let i = r;
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      Je(o) || (i === r && (i = [...r]), i[s] = Ln().append(!te(o) || De(o) || o.isInline() ? o : yt(o.getTextContent())));
    }
    return super.splice(t, n, i);
  }
  extractWithChild(t) {
    return Je(t);
  }
};
function q_(e, t, n) {
  const r = [], i = [], s = t.list;
  if (s !== void 0) {
    const o = s[`${n.__tag}Depth`] || [], a = Dc(n) - 1, l = a % o.length, c = o[l], u = s[n.__tag];
    let f;
    const d = s.nested, h = s.checklist;
    if (d !== void 0 && d.list && (f = d.list), u !== void 0 && r.push(u), h !== void 0 && n.__listType === "check" && r.push(h), c !== void 0) {
      r.push(...Yd(c));
      for (let m = 0; m < o.length; m++) m !== l && i.push(n.__tag + m);
    }
    if (f !== void 0) {
      const m = Yd(f);
      a > 1 ? r.push(...m) : i.push(...m);
    }
  }
  i.length > 0 && gp(e, ...i), r.length > 0 && Ur(e, ...r);
}
function Lz(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (Je(r)) {
      t.push(r);
      const i = r.getChildren();
      i.length > 1 && i.forEach((s) => {
        De(s) && t.push(J_(s));
      });
    } else t.push(J_(r));
  }
  return t;
}
function G_(e) {
  const t = e.nodeName.toLowerCase();
  let n = null;
  return t === "ol" ? n = In("number", e.start) : t === "ul" && (n = function(r) {
    if (r.getAttribute("__lexicallisttype") === "check" || r.classList.contains("contains-task-list")) return !0;
    for (const i of r.childNodes) if (At(i) && i.hasAttribute("aria-checked")) return !0;
    return !1;
  }(e) ? In("check") : In("bullet")), { after: Lz, node: n };
}
const Mz = { ol: "number", ul: "bullet" };
function In(e = "number", t = 1) {
  return Pn(new cs(e, t));
}
function De(e) {
  return e instanceof cs;
}
const SS = Pe("INSERT_CHECK_LIST_COMMAND");
function Oz(e) {
  return Dn(e.registerCommand(SS, () => (d0("check"), !0), xt), e.registerCommand(ov, (t) => Z_(t, e, !1), xt), e.registerCommand(sv, (t) => Z_(t, e, !0), xt), e.registerCommand(eu, () => {
    if (h0() != null) {
      const t = e.getRootElement();
      return t != null && t.focus(), !0;
    }
    return !1;
  }, xt), e.registerCommand(av, (t) => {
    const n = h0();
    return !(n == null || !e.isEditable()) && (e.update(() => {
      const r = vi(n);
      Je(r) && (t.preventDefault(), r.toggleChecked());
    }), !0);
  }, xt), e.registerCommand(iv, (t) => e.getEditorState().read(() => {
    const n = ge();
    if (fe(n) && n.isCollapsed()) {
      const { anchor: r } = n, i = r.type === "element";
      if (i || r.offset === 0) {
        const s = r.getNode(), o = $r(s, (a) => te(a) && !a.isInline());
        if (Je(o)) {
          const a = o.getParent();
          if (De(a) && a.getListType() === "check" && (i || o.getFirstDescendant() === s)) {
            const l = e.getElementByKey(o.__key);
            if (l != null && document.activeElement !== l) return l.focus(), t.preventDefault(), !0;
          }
        }
      }
    }
    return !1;
  }), xt), e.registerRootListener((t, n) => {
    t !== null && (t.addEventListener("click", Y_), t.addEventListener("pointerdown", X_)), n !== null && (n.removeEventListener("click", Y_), n.removeEventListener("pointerdown", X_));
  }));
}
function kS(e, t) {
  const n = e.target;
  if (!At(n)) return;
  const r = n.firstChild;
  if (At(r) && (r.tagName === "UL" || r.tagName === "OL")) return;
  const i = n.parentNode;
  if (!i || i.__lexicalListType !== "check") return;
  const s = n.getBoundingClientRect(), o = mP(n), a = e.clientX / o, l = window.getComputedStyle ? window.getComputedStyle(n, "::before") : { width: "0px" }, c = parseFloat(l.width), u = e.pointerType === "touch" ? 32 : 0;
  (n.dir === "rtl" ? a < s.right + u && a > s.right - c - u : a > s.left - u && a < s.left + c + u) && t();
}
function Y_(e) {
  kS(e, () => {
    if (At(e.target)) {
      const t = e.target, n = Av(t);
      n != null && n.isEditable() && n.update(() => {
        const r = vi(t);
        Je(r) && (t.focus(), r.toggleChecked());
      });
    }
  });
}
function X_(e) {
  kS(e, () => {
    e.preventDefault();
  });
}
function h0() {
  const e = document.activeElement;
  return At(e) && e.tagName === "LI" && e.parentNode != null && e.parentNode.__lexicalListType === "check" ? e : null;
}
function Z_(e, t, n) {
  const r = h0();
  return r != null && t.update(() => {
    const i = vi(r);
    if (!Je(i)) return;
    const s = function(o, a) {
      let l = a ? o.getPreviousSibling() : o.getNextSibling(), c = o;
      for (; l == null && Je(c); ) c = c.getParentOrThrow().getParent(), c != null && (l = a ? c.getPreviousSibling() : c.getNextSibling());
      for (; Je(l); ) {
        const u = a ? l.getLastChild() : l.getFirstChild();
        if (!De(u)) return l;
        l = a ? u.getLastChild() : u.getFirstChild();
      }
      return null;
    }(i, n);
    if (s != null) {
      s.selectStart();
      const o = t.getElementByKey(s.__key);
      o != null && (e.preventDefault(), setTimeout(() => {
        o.focus();
      }, 0));
    }
  }), !1;
}
const Pz = Pe("UPDATE_LIST_START_COMMAND"), TS = Pe("INSERT_UNORDERED_LIST_COMMAND"), AS = Pe("INSERT_ORDERED_LIST_COMMAND"), NS = Pe("REMOVE_LIST_COMMAND");
function Dz(e) {
  return Dn(e.registerCommand(AS, () => (d0("number"), !0), xt), e.registerCommand(Pz, (t) => {
    const { listNodeKey: n, newStart: r } = t, i = wt(n);
    return !!De(i) && (i.getListType() === "number" && (i.setStart(r), ES(i)), !0);
  }, xt), e.registerCommand(TS, () => (d0("bullet"), !0), xt), e.registerCommand(NS, () => (Sz(), !0), xt), e.registerCommand(kc, () => Az(), xt), e.registerNodeTransform(ls, (t) => {
    const n = t.getFirstChild();
    if (n) {
      if (ye(n)) {
        const r = n.getStyle(), i = n.getFormat();
        t.getTextStyle() !== r && t.setTextStyle(r), t.getTextFormat() !== i && t.setTextFormat(i);
      }
    } else {
      const r = ge();
      fe(r) && (r.style !== t.getTextStyle() || r.format !== t.getTextFormat()) && r.isCollapsed() && t.is(r.anchor.getNode()) && t.setTextStyle(r.style).setTextFormat(r.format);
    }
  }), e.registerNodeTransform(Ys, (t) => {
    const n = t.getParent();
    if (Je(n) && t.is(n.getFirstChild())) {
      const r = t.getStyle(), i = t.getFormat();
      r === n.getTextStyle() && i === n.getTextFormat() || n.setTextStyle(r).setTextFormat(i);
    }
  }));
}
function Fz(e) {
  const t = (n) => {
    const r = n.getParent();
    if (De(n.getFirstChild()) || !De(r)) return;
    const i = $r(n, (s) => Je(s) && De(s.getParent()) && Je(s.getPreviousSibling()));
    if (i === null && n.getIndent() > 0) n.setIndent(0);
    else if (Je(i)) {
      const s = i.getPreviousSibling();
      if (Je(s)) {
        const o = function(l) {
          let c = l, u = c.getFirstChild();
          for (; De(u); ) {
            const f = u.getLastChild();
            if (!Je(f)) break;
            c = f, u = c.getFirstChild();
          }
          return c;
        }(s), a = o.getParent();
        if (De(a)) {
          const l = Dc(a);
          l + 1 < Dc(r) && n.setIndent(l);
        }
      }
    }
  };
  return e.registerNodeTransform(cs, (n) => {
    const r = [n];
    for (; r.length > 0; ) {
      const i = r.shift();
      if (De(i)) {
        for (const s of i.getChildren()) if (Je(s)) {
          t(s);
          const o = s.getFirstChild();
          De(o) && r.push(o);
        }
      }
    }
  });
}
const Rz = {
  testNode: "list",
  visitNode: function({ mdastNode: e, lexicalParent: t, actions: n }) {
    const r = e.children.some((s) => typeof s.checked == "boolean") ? "check" : e.ordered ? "number" : "bullet", i = In(r);
    if (Je(t)) {
      const s = Ln();
      s.append(i), t.insertAfter(s);
    } else
      t.append(i);
    n.visitChildren(e, i);
  }
}, $z = {
  testNode: "listItem",
  visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
    const r = n.getListType() === "check" ? e.checked ?? !1 : void 0;
    t.addAndStepInto(Ln(r));
  }
}, Vz = {
  testLexicalNode: De,
  visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
    t.addAndStepInto("list", {
      ordered: e.getListType() === "number",
      spread: !1
    });
  }
}, Bz = {
  testLexicalNode: Je,
  visitLexicalNode: ({ lexicalNode: e, mdastParent: t, actions: n }) => {
    const r = e.getChildren(), i = r[0];
    if (r.length === 1 && De(i)) {
      const s = t.children.at(-1);
      s ? n.visitChildren(e, s) : n.visitChildren(i, t);
    } else {
      const s = e.getParent(), o = n.appendToParent(t, {
        type: "listItem",
        checked: s.getListType() === "check" ? !!e.getChecked() : void 0,
        spread: !1,
        children: []
      });
      let a = null;
      for (const l of e.getChildren())
        ye(l) || Rr(l) || l.isInline() && (te(l) || it(l)) ? (a || (a = n.appendToParent(o, {
          type: "paragraph",
          children: []
        })), n.visit(l, a)) : (a = null, n.visit(l, o));
    }
  }
};
function zz(e, t) {
  return Dn(e.registerCommand(cv, (n) => {
    const r = ge();
    if (!fe(r)) return !1;
    n.preventDefault();
    const i = function(s) {
      const o = s.getNodes();
      if (pP(o, (d) => Td(d) && d.canIndent() ? d : null).length > 0) return !0;
      const a = s.anchor, l = s.focus, c = l.isBefore(a) ? l : a, u = c.getNode(), f = Ug(u);
      if (f.canIndent()) {
        const d = f.getKey();
        let h = fl();
        if (h.anchor.set(d, 0, "element"), h.focus.set(d, 0, "element"), h = Do(h), h.anchor.is(c)) return !0;
      }
      return !1;
    }(r) ? n.shiftKey ? Sg : Sd : $E;
    return e.dispatchCommand(i, void 0);
  }, qe), e.registerCommand(Sd, () => {
    if (t == null) return !1;
    const n = ge();
    if (!fe(n)) return !1;
    const r = n.getNodes().map((i) => Ug(i).getIndent());
    return Math.max(...r) + 1 >= t;
  }, zr));
}
function Q_({ maxIndent: e }) {
  const [t] = vn();
  return Le(() => zz(t, e), [t, e]), null;
}
function eb() {
  const [e] = vn();
  return Le(() => Oz(e), [e]), null;
}
function tb({ hasStrictIndent: e = !1 }) {
  const [t] = vn();
  return Le(() => {
    if (!t.hasNodes([cs, ls])) throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
  }, [t]), Le(() => {
    if (e) return Fz(t);
  }, [t, e]), function(n) {
    Le(() => Dz(n), [n]);
  }(t), null;
}
const Hz = {
  name: "tasklistCheck",
  tokenize: jz
};
function Uz() {
  return {
    text: {
      91: Hz
    }
  };
}
function jz(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), s)
    );
  }
  function s(l) {
    return ut(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), o) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), o) : n(l);
  }
  function o(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(l);
  }
  function a(l) {
    return be(l) ? t(l) : He(l) ? e.check({
      tokenize: Wz
    }, t, n)(l) : n(l);
  }
}
function Wz(e, t, n) {
  return Ge(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function Jz() {
  return {
    exit: {
      taskListCheckValueChecked: nb,
      taskListCheckValueUnchecked: nb,
      paragraph: Kz
    }
  };
}
function IS() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: qz }
  };
}
function nb(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Kz(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let s = -1, o;
      for (; ++s < i.length; ) {
        const a = i[s];
        if (a.type === "paragraph") {
          o = a;
          break;
        }
      }
      o === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function qz(e, t, n, r) {
  const i = e.children[0], s = typeof e.checked == "boolean" && i && i.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r);
  s && a.move(o);
  let l = Kv.listItem(e, t, n, {
    ...r,
    ...a.current()
  });
  return s && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + o;
  }
}
const Gz = /* @__PURE__ */ new Map([
  ["number", AS],
  ["bullet", TS],
  ["check", SS],
  ["", NS]
]), p0 = Te("", (e) => {
  e.sub(e.pipe(Ka, Tt(Ft)), ([t, n]) => {
    if (!t || !n)
      return;
    const r = t.anchor.getNode();
    let i = r.getKey() === "root" ? r : $r(r, (a) => {
      const l = a.getParent();
      return l !== null && Jt(l);
    });
    i === null && (i = r.getTopLevelElementOrThrow());
    const s = i.getKey();
    if (n.getElementByKey(s) !== null)
      if (De(i)) {
        const a = H9(r, cs), l = a ? a.getListType() : i.getListType();
        e.pub(p0, l);
      } else
        e.pub(p0, "");
  });
}), LS = Bt((e) => {
  e.sub(e.pipe(LS, Tt(Ft)), ([t, n]) => {
    n == null || n.dispatchCommand(Gz.get(t), void 0);
  });
}), Yz = Jn({
  init(e) {
    var t;
    (t = e.getValue(Gr)) == null || t.registerCommand(Sd, () => !Zz(7), zr), e.pubIn({
      [vl]: "lists",
      [Ya]: Jz(),
      [Ga]: Uz(),
      [Er]: [Rz, $z],
      [Yr]: [ls, cs],
      [Xr]: [Vz, Bz],
      [pu]: IS(),
      [Xo]: [Q_, tb, eb],
      [aS]: [Q_, tb, eb]
    });
  }
});
function Xz(e) {
  const t = e.getNodes();
  return t.length === 0 ? /* @__PURE__ */ new Set([e.anchor.getNode().getParentOrThrow(), e.focus.getNode().getParentOrThrow()]) : new Set(t.map((n) => te(n) ? n : n.getParentOrThrow()));
}
function Zz(e) {
  const t = ge();
  if (!fe(t))
    return !1;
  const n = Xz(t);
  let r = 0;
  for (const i of n)
    if (De(i))
      r = Math.max(Dc(i) + 1, r);
    else if (Je(i)) {
      const s = i.getParent();
      if ((s == null ? void 0 : s.getChildren().length) === 1) {
        const o = s.getParent();
        if (Je(o) && o.getChildren().length === 1)
          return !1;
      }
      if (!De(s))
        throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      r = Math.max(Dc(s) + 1, r);
    }
  return r <= e;
}
function Qz(e) {
  return e.length;
}
function eH(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || Qz, s = [], o = [], a = [], l = [];
  let c = 0, u = -1;
  for (; ++u < e.length; ) {
    const p = [], y = [];
    let v = -1;
    for (e[u].length > c && (c = e[u].length); ++v < e[u].length; ) {
      const g = tH(e[u][v]);
      if (n.alignDelimiters !== !1) {
        const x = i(g);
        y[v] = x, (l[v] === void 0 || x > l[v]) && (l[v] = x);
      }
      p.push(g);
    }
    o[u] = p, a[u] = y;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < c; )
      s[f] = rb(r[f]);
  else {
    const p = rb(r);
    for (; ++f < c; )
      s[f] = p;
  }
  f = -1;
  const d = [], h = [];
  for (; ++f < c; ) {
    const p = s[f];
    let y = "", v = "";
    p === 99 ? (y = ":", v = ":") : p === 108 ? y = ":" : p === 114 && (v = ":");
    let g = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - y.length - v.length
    );
    const x = y + "-".repeat(g) + v;
    n.alignDelimiters !== !1 && (g = y.length + g + v.length, g > l[f] && (l[f] = g), h[f] = g), d[f] = x;
  }
  o.splice(1, 0, d), a.splice(1, 0, h), u = -1;
  const m = [];
  for (; ++u < o.length; ) {
    const p = o[u], y = a[u];
    f = -1;
    const v = [];
    for (; ++f < c; ) {
      const g = p[f] || "";
      let x = "", _ = "";
      if (n.alignDelimiters !== !1) {
        const b = l[f] - (y[f] || 0), C = s[f];
        C === 114 ? x = " ".repeat(b) : C === 99 ? b % 2 ? (x = " ".repeat(b / 2 + 0.5), _ = " ".repeat(b / 2 - 0.5)) : (x = " ".repeat(b / 2), _ = x) : _ = " ".repeat(b);
      }
      n.delimiterStart !== !1 && !f && v.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && g === "") && (n.delimiterStart !== !1 || f) && v.push(" "), n.alignDelimiters !== !1 && v.push(x), v.push(g), n.alignDelimiters !== !1 && v.push(_), n.padding !== !1 && v.push(" "), (n.delimiterEnd !== !1 || f !== c - 1) && v.push("|");
    }
    m.push(
      n.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return m.join(`
`);
}
function tH(e) {
  return e == null ? "" : String(e);
}
function rb(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function nH(e) {
  const t = {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: d,
      table: o,
      tableCell: l,
      tableRow: a
    }
  };
  function o(h, m, p, y) {
    return c(u(h, p, y), h.align);
  }
  function a(h, m, p, y) {
    const v = f(h, p, y), g = c([v]);
    return g.slice(0, g.indexOf(`
`));
  }
  function l(h, m, p, y) {
    const v = p.enter("tableCell"), g = p.enter("phrasing"), x = p.containerPhrasing(h, {
      ...y,
      before: s,
      after: s
    });
    return g(), v(), x;
  }
  function c(h, m) {
    return eH(h, {
      align: m,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(h, m, p) {
    const y = h.children;
    let v = -1;
    const g = [], x = m.enter("table");
    for (; ++v < y.length; )
      g[v] = f(y[v], m, p);
    return x(), g;
  }
  function f(h, m, p) {
    const y = h.children;
    let v = -1;
    const g = [], x = m.enter("tableRow");
    for (; ++v < y.length; )
      g[v] = l(y[v], h, m, p);
    return x(), g;
  }
  function d(h, m, p) {
    let y = Kv.inlineCode(h, m, p);
    return p.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
const ib = [["Cat", "rgb(125, 50, 0)"], ["Dog", "rgb(100, 0, 0)"], ["Rabbit", "rgb(150, 0, 0)"], ["Frog", "rgb(200, 0, 0)"], ["Fox", "rgb(200, 75, 0)"], ["Hedgehog", "rgb(0, 75, 0)"], ["Pigeon", "rgb(0, 125, 0)"], ["Squirrel", "rgb(75, 100, 0)"], ["Bear", "rgb(125, 100, 0)"], ["Tiger", "rgb(0, 0, 150)"], ["Leopard", "rgb(0, 0, 200)"], ["Zebra", "rgb(0, 0, 250)"], ["Wolf", "rgb(0, 100, 150)"], ["Owl", "rgb(0, 100, 100)"], ["Gull", "rgb(100, 0, 100)"], ["Squid", "rgb(150, 0, 150)"]], sb = ib[Math.floor(Math.random() * ib.length)], rH = al({ clientID: 0, color: sb[1], isCollabActive: !1, name: sb[0], yjsDocMap: /* @__PURE__ */ new Map() });
function iH(e, t) {
  return ll(rH);
}
function ob(e) {
  const t = e.transform();
  return new Set(t ? [t] : []);
}
function sH({ initialEditor: e, children: t, initialNodes: n, initialTheme: r, skipCollabChecks: i, skipEditableListener: s }) {
  const o = $e(!1), a = ll(gd);
  a == null && function(m, ...p) {
    const y = new URL("https://lexical.dev/docs/error"), v = new URLSearchParams();
    v.append("code", m);
    for (const g of p) v.append("v", g);
    throw y.search = v.toString(), Error(`Minified Lexical error #${m}; visit ${y.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(9);
  const [l, { getTheme: c }] = a, u = Jo(() => {
    const m = r || c() || void 0, p = wE(a, m);
    m !== void 0 && (e._config.theme = m), e._parentEditor = e._parentEditor || l;
    const y = e._createEditorArgs, v = y && y.namespace;
    if (n) {
      v || (e._config.namespace = l._config.namespace);
      for (let g of n) {
        let x = null, _ = null;
        if (typeof g != "function") {
          const C = g;
          g = C.replace, x = C.with, _ = C.withKlass || null;
        }
        const b = up(e, g.getType());
        e._nodes.set(g.getType(), { exportDOM: b ? b.exportDOM : void 0, klass: g, replace: x, replaceWithKlass: _, sharedNodeState: vg(g), transforms: ob(g) });
      }
    } else if (y && y.nodes) v || (e._config.namespace = l._config.namespace);
    else {
      const g = e._nodes = new Map(l._nodes);
      v || (e._config.namespace = l._config.namespace);
      for (const [x, _] of g) e._nodes.set(x, { exportDOM: _.exportDOM, klass: _.klass, replace: _.replace, replaceWithKlass: _.replaceWithKlass, sharedNodeState: vg(_.klass), transforms: ob(_.klass) });
    }
    return [e, p];
  }, []), { isCollabActive: f, yjsDocMap: d } = iH(), h = i || o.current || d.has(e.getKey());
  return Le(() => {
    h && (o.current = !0);
  }, [h]), Le(() => {
    if (!s) {
      const m = (p) => e.setEditable(p);
      return m(l.isEditable()), l.registerEditableListener(m);
    }
  }, [e, l, s]), A(gd.Provider, { value: u, children: !f || h ? t : null });
}
function ze(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function ab(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function MS(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const s = ab(i, t);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i];
          typeof s == "function" ? s() : ab(e[i], null);
        }
      };
  };
}
function _t(...e) {
  return w.useCallback(MS(...e), e);
}
function oH(e, t) {
  const n = w.createContext(t), r = (s) => {
    const { children: o, ...a } = s, l = w.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ A(n.Provider, { value: l, children: o });
  };
  r.displayName = e + "Provider";
  function i(s) {
    const o = w.useContext(n);
    if (o) return o;
    if (t !== void 0) return t;
    throw new Error(`\`${s}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function us(e, t = []) {
  let n = [];
  function r(s, o) {
    const a = w.createContext(o), l = n.length;
    n = [...n, o];
    const c = (f) => {
      var v;
      const { scope: d, children: h, ...m } = f, p = ((v = d == null ? void 0 : d[e]) == null ? void 0 : v[l]) || a, y = w.useMemo(() => m, Object.values(m));
      return /* @__PURE__ */ A(p.Provider, { value: y, children: h });
    };
    c.displayName = s + "Provider";
    function u(f, d) {
      var p;
      const h = ((p = d == null ? void 0 : d[e]) == null ? void 0 : p[l]) || a, m = w.useContext(h);
      if (m) return m;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${s}\``);
    }
    return [c, u];
  }
  const i = () => {
    const s = n.map((o) => w.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || s;
      return w.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [r, aH(i, ...t)];
}
function aH(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const o = r.reduce((a, { useScope: l, scopeName: c }) => {
        const f = l(s)[`__scope${c}`];
        return { ...a, ...f };
      }, {});
      return w.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
// @__NO_SIDE_EFFECTS__
function Za(e) {
  const t = /* @__PURE__ */ lH(e), n = w.forwardRef((r, i) => {
    const { children: s, ...o } = r, a = w.Children.toArray(s), l = a.find(uH);
    if (l) {
      const c = l.props.children, u = a.map((f) => f === l ? w.Children.count(c) > 1 ? w.Children.only(null) : w.isValidElement(c) ? c.props.children : null : f);
      return /* @__PURE__ */ A(t, { ...o, ref: i, children: w.isValidElement(c) ? w.cloneElement(c, void 0, u) : null });
    }
    return /* @__PURE__ */ A(t, { ...o, ref: i, children: s });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function lH(e) {
  const t = w.forwardRef((n, r) => {
    const { children: i, ...s } = n;
    if (w.isValidElement(i)) {
      const o = dH(i), a = fH(s, i.props);
      return i.type !== w.Fragment && (a.ref = r ? MS(r, o) : o), w.cloneElement(i, a);
    }
    return w.Children.count(i) > 1 ? w.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var OS = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function cH(e) {
  const t = ({ children: n }) => /* @__PURE__ */ A(Ut, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = OS, t;
}
function uH(e) {
  return w.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === OS;
}
function fH(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...a) => {
      const l = s(...a);
      return i(...a), l;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function dH(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var hH = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Ye = hH.reduce((e, t) => {
  const n = /* @__PURE__ */ Za(`Primitive.${t}`), r = w.forwardRef((i, s) => {
    const { asChild: o, ...a } = i, l = o ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ A(l, { ...a, ref: s });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function pH(e, t) {
  e && Dh.flushSync(() => e.dispatchEvent(t));
}
function js(e) {
  const t = w.useRef(e);
  return w.useEffect(() => {
    t.current = e;
  }), w.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function mH(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = js(e);
  w.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var gH = "DismissableLayer", m0 = "dismissableLayer.update", vH = "dismissableLayer.pointerDownOutside", yH = "dismissableLayer.focusOutside", lb, PS = w.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), gu = w.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: o,
      onDismiss: a,
      ...l
    } = e, c = w.useContext(PS), [u, f] = w.useState(null), d = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = w.useState({}), m = _t(t, (E) => f(E)), p = Array.from(c.layers), [y] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), v = p.indexOf(y), g = u ? p.indexOf(u) : -1, x = c.layersWithOutsidePointerEventsDisabled.size > 0, _ = g >= v, b = _H((E) => {
      const S = E.target, k = [...c.branches].some((M) => M.contains(S));
      !_ || k || (i == null || i(E), o == null || o(E), E.defaultPrevented || a == null || a());
    }, d), C = bH((E) => {
      const S = E.target;
      [...c.branches].some((M) => M.contains(S)) || (s == null || s(E), o == null || o(E), E.defaultPrevented || a == null || a());
    }, d);
    return mH((E) => {
      g === c.layers.size - 1 && (r == null || r(E), !E.defaultPrevented && a && (E.preventDefault(), a()));
    }, d), w.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (lb = d.body.style.pointerEvents, d.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), cb(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = lb);
        };
    }, [u, d, n, c]), w.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), cb());
    }, [u, c]), w.useEffect(() => {
      const E = () => h({});
      return document.addEventListener(m0, E), () => document.removeEventListener(m0, E);
    }, []), /* @__PURE__ */ A(
      Ye.div,
      {
        ...l,
        ref: m,
        style: {
          pointerEvents: x ? _ ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: ze(e.onFocusCapture, C.onFocusCapture),
        onBlurCapture: ze(e.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: ze(
          e.onPointerDownCapture,
          b.onPointerDownCapture
        )
      }
    );
  }
);
gu.displayName = gH;
var xH = "DismissableLayerBranch", wH = w.forwardRef((e, t) => {
  const n = w.useContext(PS), r = w.useRef(null), i = _t(t, r);
  return w.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ A(Ye.div, { ...e, ref: i });
});
wH.displayName = xH;
function _H(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = js(e), r = w.useRef(!1), i = w.useRef(() => {
  });
  return w.useEffect(() => {
    const s = (a) => {
      if (a.target && !r.current) {
        let l = function() {
          DS(
            vH,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", s), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function bH(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = js(e), r = w.useRef(!1);
  return w.useEffect(() => {
    const i = (s) => {
      s.target && !r.current && DS(yH, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function cb() {
  const e = new CustomEvent(m0);
  document.dispatchEvent(e);
}
function DS(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? pH(i, s) : i.dispatchEvent(s);
}
var B1 = 0;
function ly() {
  w.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? ub()), document.body.insertAdjacentElement("beforeend", e[1] ?? ub()), B1++, () => {
      B1 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), B1--;
    };
  }, []);
}
function ub() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var z1 = "focusScope.autoFocusOnMount", H1 = "focusScope.autoFocusOnUnmount", fb = { bubbles: !1, cancelable: !0 }, CH = "FocusScope", kp = w.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...o
  } = e, [a, l] = w.useState(null), c = js(i), u = js(s), f = w.useRef(null), d = _t(t, (p) => l(p)), h = w.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  w.useEffect(() => {
    if (r) {
      let p = function(x) {
        if (h.paused || !a) return;
        const _ = x.target;
        a.contains(_) ? f.current = _ : bs(f.current, { select: !0 });
      }, y = function(x) {
        if (h.paused || !a) return;
        const _ = x.relatedTarget;
        _ !== null && (a.contains(_) || bs(f.current, { select: !0 }));
      }, v = function(x) {
        if (document.activeElement === document.body)
          for (const b of x)
            b.removedNodes.length > 0 && bs(a);
      };
      document.addEventListener("focusin", p), document.addEventListener("focusout", y);
      const g = new MutationObserver(v);
      return a && g.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", y), g.disconnect();
      };
    }
  }, [r, a, h.paused]), w.useEffect(() => {
    if (a) {
      hb.add(h);
      const p = document.activeElement;
      if (!a.contains(p)) {
        const v = new CustomEvent(z1, fb);
        a.addEventListener(z1, c), a.dispatchEvent(v), v.defaultPrevented || (EH(NH(FS(a)), { select: !0 }), document.activeElement === p && bs(a));
      }
      return () => {
        a.removeEventListener(z1, c), setTimeout(() => {
          const v = new CustomEvent(H1, fb);
          a.addEventListener(H1, u), a.dispatchEvent(v), v.defaultPrevented || bs(p ?? document.body, { select: !0 }), a.removeEventListener(H1, u), hb.remove(h);
        }, 0);
      };
    }
  }, [a, c, u, h]);
  const m = w.useCallback(
    (p) => {
      if (!n && !r || h.paused) return;
      const y = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey, v = document.activeElement;
      if (y && v) {
        const g = p.currentTarget, [x, _] = SH(g);
        x && _ ? !p.shiftKey && v === _ ? (p.preventDefault(), n && bs(x, { select: !0 })) : p.shiftKey && v === x && (p.preventDefault(), n && bs(_, { select: !0 })) : v === g && p.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ A(Ye.div, { tabIndex: -1, ...o, ref: d, onKeyDown: m });
});
kp.displayName = CH;
function EH(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (bs(r, { select: t }), document.activeElement !== n) return;
}
function SH(e) {
  const t = FS(e), n = db(t, e), r = db(t.reverse(), e);
  return [n, r];
}
function FS(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function db(e, t) {
  for (const n of e)
    if (!kH(n, { upTo: t })) return n;
}
function kH(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function TH(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function bs(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && TH(e) && t && e.select();
  }
}
var hb = AH();
function AH() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = pb(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = pb(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function pb(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function NH(e) {
  return e.filter((t) => t.tagName !== "A");
}
var gn = globalThis != null && globalThis.document ? w.useLayoutEffect : () => {
}, IH = w[" useId ".trim().toString()] || (() => {
}), LH = 0;
function qi(e) {
  const [t, n] = w.useState(IH());
  return gn(() => {
    n((r) => r ?? String(LH++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const MH = ["top", "right", "bottom", "left"], Ws = Math.min, Qn = Math.max, Xd = Math.round, Qu = Math.floor, pi = (e) => ({
  x: e,
  y: e
}), OH = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, PH = {
  start: "end",
  end: "start"
};
function g0(e, t, n) {
  return Qn(e, Ws(t, n));
}
function Qi(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function es(e) {
  return e.split("-")[0];
}
function wl(e) {
  return e.split("-")[1];
}
function cy(e) {
  return e === "x" ? "y" : "x";
}
function uy(e) {
  return e === "y" ? "height" : "width";
}
const DH = /* @__PURE__ */ new Set(["top", "bottom"]);
function ci(e) {
  return DH.has(es(e)) ? "y" : "x";
}
function fy(e) {
  return cy(ci(e));
}
function FH(e, t, n) {
  n === void 0 && (n = !1);
  const r = wl(e), i = fy(e), s = uy(i);
  let o = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = Zd(o)), [o, Zd(o)];
}
function RH(e) {
  const t = Zd(e);
  return [v0(e), t, v0(t)];
}
function v0(e) {
  return e.replace(/start|end/g, (t) => PH[t]);
}
const mb = ["left", "right"], gb = ["right", "left"], $H = ["top", "bottom"], VH = ["bottom", "top"];
function BH(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? gb : mb : t ? mb : gb;
    case "left":
    case "right":
      return t ? $H : VH;
    default:
      return [];
  }
}
function zH(e, t, n, r) {
  const i = wl(e);
  let s = BH(es(e), n === "start", r);
  return i && (s = s.map((o) => o + "-" + i), t && (s = s.concat(s.map(v0)))), s;
}
function Zd(e) {
  return e.replace(/left|right|bottom|top/g, (t) => OH[t]);
}
function HH(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function RS(e) {
  return typeof e != "number" ? HH(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Qd(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function vb(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const s = ci(t), o = fy(t), a = uy(o), l = es(t), c = s === "y", u = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, d = r[a] / 2 - i[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      h = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (wl(t)) {
    case "start":
      h[o] -= d * (n && c ? -1 : 1);
      break;
    case "end":
      h[o] += d * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const UH = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = n, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: f
  } = vb(c, r, l), d = r, h = {}, m = 0;
  for (let p = 0; p < a.length; p++) {
    const {
      name: y,
      fn: v
    } = a[p], {
      x: g,
      y: x,
      data: _,
      reset: b
    } = await v({
      x: u,
      y: f,
      initialPlacement: r,
      placement: d,
      strategy: i,
      middlewareData: h,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = g ?? u, f = x ?? f, h = {
      ...h,
      [y]: {
        ...h[y],
        ..._
      }
    }, b && m <= 50 && (m++, typeof b == "object" && (b.placement && (d = b.placement), b.rects && (c = b.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : b.rects), {
      x: u,
      y: f
    } = vb(c, d, l)), p = -1);
  }
  return {
    x: u,
    y: f,
    placement: d,
    strategy: i,
    middlewareData: h
  };
};
async function Fc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: a,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: d = !1,
    padding: h = 0
  } = Qi(t, e), m = RS(h), y = a[d ? f === "floating" ? "reference" : "floating" : f], v = Qd(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(y))) == null || n ? y : y.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), g = f === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, x = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(x)) ? await (s.getScale == null ? void 0 : s.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, b = Qd(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: g,
    offsetParent: x,
    strategy: l
  }) : g);
  return {
    top: (v.top - b.top + m.top) / _.y,
    bottom: (b.bottom - v.bottom + m.bottom) / _.y,
    left: (v.left - b.left + m.left) / _.x,
    right: (b.right - v.right + m.right) / _.x
  };
}
const jH = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: s,
      platform: o,
      elements: a,
      middlewareData: l
    } = t, {
      element: c,
      padding: u = 0
    } = Qi(e, t) || {};
    if (c == null)
      return {};
    const f = RS(u), d = {
      x: n,
      y: r
    }, h = fy(i), m = uy(h), p = await o.getDimensions(c), y = h === "y", v = y ? "top" : "left", g = y ? "bottom" : "right", x = y ? "clientHeight" : "clientWidth", _ = s.reference[m] + s.reference[h] - d[h] - s.floating[m], b = d[h] - s.reference[h], C = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
    let E = C ? C[x] : 0;
    (!E || !await (o.isElement == null ? void 0 : o.isElement(C))) && (E = a.floating[x] || s.floating[m]);
    const S = _ / 2 - b / 2, k = E / 2 - p[m] / 2 - 1, M = Ws(f[v], k), O = Ws(f[g], k), R = M, I = E - p[m] - O, H = E / 2 - p[m] / 2 + S, P = g0(R, H, I), W = !l.arrow && wl(i) != null && H !== P && s.reference[m] / 2 - (H < R ? M : O) - p[m] / 2 < 0, G = W ? H < R ? H - R : H - I : 0;
    return {
      [h]: d[h] + G,
      data: {
        [h]: P,
        centerOffset: H - P - G,
        ...W && {
          alignmentOffset: G
        }
      },
      reset: W
    };
  }
}), WH = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: f = !0,
        fallbackPlacements: d,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: p = !0,
        ...y
      } = Qi(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const v = es(i), g = ci(a), x = es(a) === a, _ = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), b = d || (x || !p ? [Zd(a)] : RH(a)), C = m !== "none";
      !d && C && b.push(...zH(a, p, m, _));
      const E = [a, ...b], S = await Fc(t, y), k = [];
      let M = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (u && k.push(S[v]), f) {
        const H = FH(i, o, _);
        k.push(S[H[0]], S[H[1]]);
      }
      if (M = [...M, {
        placement: i,
        overflows: k
      }], !k.every((H) => H <= 0)) {
        var O, R;
        const H = (((O = s.flip) == null ? void 0 : O.index) || 0) + 1, P = E[H];
        if (P && (!(f === "alignment" ? g !== ci(P) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((J) => ci(J.placement) === g ? J.overflows[0] > 0 : !0)))
          return {
            data: {
              index: H,
              overflows: M
            },
            reset: {
              placement: P
            }
          };
        let W = (R = M.filter((G) => G.overflows[0] <= 0).sort((G, J) => G.overflows[1] - J.overflows[1])[0]) == null ? void 0 : R.placement;
        if (!W)
          switch (h) {
            case "bestFit": {
              var I;
              const G = (I = M.filter((J) => {
                if (C) {
                  const X = ci(J.placement);
                  return X === g || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  X === "y";
                }
                return !0;
              }).map((J) => [J.placement, J.overflows.filter((X) => X > 0).reduce((X, N) => X + N, 0)]).sort((J, X) => J[1] - X[1])[0]) == null ? void 0 : I[0];
              G && (W = G);
              break;
            }
            case "initialPlacement":
              W = a;
              break;
          }
        if (i !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
function yb(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function xb(e) {
  return MH.some((t) => e[t] >= 0);
}
const JH = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = Qi(e, t);
      switch (r) {
        case "referenceHidden": {
          const s = await Fc(t, {
            ...i,
            elementContext: "reference"
          }), o = yb(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: xb(o)
            }
          };
        }
        case "escaped": {
          const s = await Fc(t, {
            ...i,
            altBoundary: !0
          }), o = yb(s, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: xb(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, $S = /* @__PURE__ */ new Set(["left", "top"]);
async function KH(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = es(n), a = wl(n), l = ci(n) === "y", c = $S.has(o) ? -1 : 1, u = s && l ? -1 : 1, f = Qi(t, e);
  let {
    mainAxis: d,
    crossAxis: h,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return a && typeof m == "number" && (h = a === "end" ? m * -1 : m), l ? {
    x: h * u,
    y: d * c
  } : {
    x: d * c,
    y: h * u
  };
}
const qH = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: a
      } = t, l = await KH(t, e);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, GH = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (y) => {
            let {
              x: v,
              y: g
            } = y;
            return {
              x: v,
              y: g
            };
          }
        },
        ...l
      } = Qi(e, t), c = {
        x: n,
        y: r
      }, u = await Fc(t, l), f = ci(es(i)), d = cy(f);
      let h = c[d], m = c[f];
      if (s) {
        const y = d === "y" ? "top" : "left", v = d === "y" ? "bottom" : "right", g = h + u[y], x = h - u[v];
        h = g0(g, h, x);
      }
      if (o) {
        const y = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", g = m + u[y], x = m - u[v];
        m = g0(g, m, x);
      }
      const p = a.fn({
        ...t,
        [d]: h,
        [f]: m
      });
      return {
        ...p,
        data: {
          x: p.x - n,
          y: p.y - r,
          enabled: {
            [d]: s,
            [f]: o
          }
        }
      };
    }
  };
}, YH = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: s,
        middlewareData: o
      } = t, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = Qi(e, t), u = {
        x: n,
        y: r
      }, f = ci(i), d = cy(f);
      let h = u[d], m = u[f];
      const p = Qi(a, t), y = typeof p == "number" ? {
        mainAxis: p,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...p
      };
      if (l) {
        const x = d === "y" ? "height" : "width", _ = s.reference[d] - s.floating[x] + y.mainAxis, b = s.reference[d] + s.reference[x] - y.mainAxis;
        h < _ ? h = _ : h > b && (h = b);
      }
      if (c) {
        var v, g;
        const x = d === "y" ? "width" : "height", _ = $S.has(es(i)), b = s.reference[f] - s.floating[x] + (_ && ((v = o.offset) == null ? void 0 : v[f]) || 0) + (_ ? 0 : y.crossAxis), C = s.reference[f] + s.reference[x] + (_ ? 0 : ((g = o.offset) == null ? void 0 : g[f]) || 0) - (_ ? y.crossAxis : 0);
        m < b ? m = b : m > C && (m = C);
      }
      return {
        [d]: h,
        [f]: m
      };
    }
  };
}, XH = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: s,
        platform: o,
        elements: a
      } = t, {
        apply: l = () => {
        },
        ...c
      } = Qi(e, t), u = await Fc(t, c), f = es(i), d = wl(i), h = ci(i) === "y", {
        width: m,
        height: p
      } = s.floating;
      let y, v;
      f === "top" || f === "bottom" ? (y = f, v = d === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (v = f, y = d === "end" ? "top" : "bottom");
      const g = p - u.top - u.bottom, x = m - u.left - u.right, _ = Ws(p - u[y], g), b = Ws(m - u[v], x), C = !t.middlewareData.shift;
      let E = _, S = b;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (S = x), (r = t.middlewareData.shift) != null && r.enabled.y && (E = g), C && !d) {
        const M = Qn(u.left, 0), O = Qn(u.right, 0), R = Qn(u.top, 0), I = Qn(u.bottom, 0);
        h ? S = m - 2 * (M !== 0 || O !== 0 ? M + O : Qn(u.left, u.right)) : E = p - 2 * (R !== 0 || I !== 0 ? R + I : Qn(u.top, u.bottom));
      }
      await l({
        ...t,
        availableWidth: S,
        availableHeight: E
      });
      const k = await o.getDimensions(a.floating);
      return m !== k.width || p !== k.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Tp() {
  return typeof window < "u";
}
function _l(e) {
  return VS(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function rr(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Ci(e) {
  var t;
  return (t = (VS(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function VS(e) {
  return Tp() ? e instanceof Node || e instanceof rr(e).Node : !1;
}
function jr(e) {
  return Tp() ? e instanceof Element || e instanceof rr(e).Element : !1;
}
function xi(e) {
  return Tp() ? e instanceof HTMLElement || e instanceof rr(e).HTMLElement : !1;
}
function wb(e) {
  return !Tp() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof rr(e).ShadowRoot;
}
const ZH = /* @__PURE__ */ new Set(["inline", "contents"]);
function vu(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = Wr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !ZH.has(i);
}
const QH = /* @__PURE__ */ new Set(["table", "td", "th"]);
function eU(e) {
  return QH.has(_l(e));
}
const tU = [":popover-open", ":modal"];
function Ap(e) {
  return tU.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const nU = ["transform", "translate", "scale", "rotate", "perspective"], rU = ["transform", "translate", "scale", "rotate", "perspective", "filter"], iU = ["paint", "layout", "strict", "content"];
function dy(e) {
  const t = hy(), n = jr(e) ? Wr(e) : e;
  return nU.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || rU.some((r) => (n.willChange || "").includes(r)) || iU.some((r) => (n.contain || "").includes(r));
}
function sU(e) {
  let t = Js(e);
  for (; xi(t) && !Qa(t); ) {
    if (dy(t))
      return t;
    if (Ap(t))
      return null;
    t = Js(t);
  }
  return null;
}
function hy() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const oU = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Qa(e) {
  return oU.has(_l(e));
}
function Wr(e) {
  return rr(e).getComputedStyle(e);
}
function Np(e) {
  return jr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Js(e) {
  if (_l(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    wb(e) && e.host || // Fallback.
    Ci(e)
  );
  return wb(t) ? t.host : t;
}
function BS(e) {
  const t = Js(e);
  return Qa(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : xi(t) && vu(t) ? t : BS(t);
}
function Rc(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = BS(e), s = i === ((r = e.ownerDocument) == null ? void 0 : r.body), o = rr(i);
  if (s) {
    const a = y0(o);
    return t.concat(o, o.visualViewport || [], vu(i) ? i : [], a && n ? Rc(a) : []);
  }
  return t.concat(i, Rc(i, [], n));
}
function y0(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function zS(e) {
  const t = Wr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = xi(e), s = i ? e.offsetWidth : n, o = i ? e.offsetHeight : r, a = Xd(n) !== s || Xd(r) !== o;
  return a && (n = s, r = o), {
    width: n,
    height: r,
    $: a
  };
}
function py(e) {
  return jr(e) ? e : e.contextElement;
}
function Oa(e) {
  const t = py(e);
  if (!xi(t))
    return pi(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = zS(t);
  let o = (s ? Xd(n.width) : n.width) / r, a = (s ? Xd(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const aU = /* @__PURE__ */ pi(0);
function HS(e) {
  const t = rr(e);
  return !hy() || !t.visualViewport ? aU : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function lU(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== rr(e) ? !1 : t;
}
function zo(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), s = py(e);
  let o = pi(1);
  t && (r ? jr(r) && (o = Oa(r)) : o = Oa(e));
  const a = lU(s, n, r) ? HS(s) : pi(0);
  let l = (i.left + a.x) / o.x, c = (i.top + a.y) / o.y, u = i.width / o.x, f = i.height / o.y;
  if (s) {
    const d = rr(s), h = r && jr(r) ? rr(r) : r;
    let m = d, p = y0(m);
    for (; p && r && h !== m; ) {
      const y = Oa(p), v = p.getBoundingClientRect(), g = Wr(p), x = v.left + (p.clientLeft + parseFloat(g.paddingLeft)) * y.x, _ = v.top + (p.clientTop + parseFloat(g.paddingTop)) * y.y;
      l *= y.x, c *= y.y, u *= y.x, f *= y.y, l += x, c += _, m = rr(p), p = y0(m);
    }
  }
  return Qd({
    width: u,
    height: f,
    x: l,
    y: c
  });
}
function my(e, t) {
  const n = Np(e).scrollLeft;
  return t ? t.left + n : zo(Ci(e)).left + n;
}
function US(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    my(e, r)
  )), s = r.top + t.scrollTop;
  return {
    x: i,
    y: s
  };
}
function cU(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const s = i === "fixed", o = Ci(r), a = t ? Ap(t.floating) : !1;
  if (r === o || a && s)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = pi(1);
  const u = pi(0), f = xi(r);
  if ((f || !f && !s) && ((_l(r) !== "body" || vu(o)) && (l = Np(r)), xi(r))) {
    const h = zo(r);
    c = Oa(r), u.x = h.x + r.clientLeft, u.y = h.y + r.clientTop;
  }
  const d = o && !f && !s ? US(o, l, !0) : pi(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + d.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + d.y
  };
}
function uU(e) {
  return Array.from(e.getClientRects());
}
function fU(e) {
  const t = Ci(e), n = Np(e), r = e.ownerDocument.body, i = Qn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = Qn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + my(e);
  const a = -n.scrollTop;
  return Wr(r).direction === "rtl" && (o += Qn(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: a
  };
}
function dU(e, t) {
  const n = rr(e), r = Ci(e), i = n.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
  if (i) {
    s = i.width, o = i.height;
    const c = hy();
    (!c || c && t === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
const hU = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function pU(e, t) {
  const n = zo(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, s = xi(e) ? Oa(e) : pi(1), o = e.clientWidth * s.x, a = e.clientHeight * s.y, l = i * s.x, c = r * s.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function _b(e, t, n) {
  let r;
  if (t === "viewport")
    r = dU(e, n);
  else if (t === "document")
    r = fU(Ci(e));
  else if (jr(t))
    r = pU(t, n);
  else {
    const i = HS(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return Qd(r);
}
function jS(e, t) {
  const n = Js(e);
  return n === t || !jr(n) || Qa(n) ? !1 : Wr(n).position === "fixed" || jS(n, t);
}
function mU(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Rc(e, [], !1).filter((a) => jr(a) && _l(a) !== "body"), i = null;
  const s = Wr(e).position === "fixed";
  let o = s ? Js(e) : e;
  for (; jr(o) && !Qa(o); ) {
    const a = Wr(o), l = dy(o);
    !l && a.position === "fixed" && (i = null), (s ? !l && !i : !l && a.position === "static" && !!i && hU.has(i.position) || vu(o) && !l && jS(e, o)) ? r = r.filter((u) => u !== o) : i = a, o = Js(o);
  }
  return t.set(e, r), r;
}
function gU(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const o = [...n === "clippingAncestors" ? Ap(t) ? [] : mU(t, this._c) : [].concat(n), r], a = o[0], l = o.reduce((c, u) => {
    const f = _b(t, u, i);
    return c.top = Qn(f.top, c.top), c.right = Ws(f.right, c.right), c.bottom = Ws(f.bottom, c.bottom), c.left = Qn(f.left, c.left), c;
  }, _b(t, a, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function vU(e) {
  const {
    width: t,
    height: n
  } = zS(e);
  return {
    width: t,
    height: n
  };
}
function yU(e, t, n) {
  const r = xi(t), i = Ci(t), s = n === "fixed", o = zo(e, !0, s, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = pi(0);
  function c() {
    l.x = my(i);
  }
  if (r || !r && !s)
    if ((_l(t) !== "body" || vu(i)) && (a = Np(t)), r) {
      const h = zo(t, !0, s, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? US(i, a) : pi(0), f = o.left + a.scrollLeft - l.x - u.x, d = o.top + a.scrollTop - l.y - u.y;
  return {
    x: f,
    y: d,
    width: o.width,
    height: o.height
  };
}
function U1(e) {
  return Wr(e).position === "static";
}
function bb(e, t) {
  if (!xi(e) || Wr(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Ci(e) === n && (n = n.ownerDocument.body), n;
}
function WS(e, t) {
  const n = rr(e);
  if (Ap(e))
    return n;
  if (!xi(e)) {
    let i = Js(e);
    for (; i && !Qa(i); ) {
      if (jr(i) && !U1(i))
        return i;
      i = Js(i);
    }
    return n;
  }
  let r = bb(e, t);
  for (; r && eU(r) && U1(r); )
    r = bb(r, t);
  return r && Qa(r) && U1(r) && !dy(r) ? n : r || sU(e) || n;
}
const xU = async function(e) {
  const t = this.getOffsetParent || WS, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: yU(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function wU(e) {
  return Wr(e).direction === "rtl";
}
const _U = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cU,
  getDocumentElement: Ci,
  getClippingRect: gU,
  getOffsetParent: WS,
  getElementRects: xU,
  getClientRects: uU,
  getDimensions: vU,
  getScale: Oa,
  isElement: jr,
  isRTL: wU
};
function JS(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function bU(e, t) {
  let n = null, r;
  const i = Ci(e);
  function s() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function o(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), s();
    const c = e.getBoundingClientRect(), {
      left: u,
      top: f,
      width: d,
      height: h
    } = c;
    if (a || t(), !d || !h)
      return;
    const m = Qu(f), p = Qu(i.clientWidth - (u + d)), y = Qu(i.clientHeight - (f + h)), v = Qu(u), x = {
      rootMargin: -m + "px " + -p + "px " + -y + "px " + -v + "px",
      threshold: Qn(0, Ws(1, l)) || 1
    };
    let _ = !0;
    function b(C) {
      const E = C[0].intersectionRatio;
      if (E !== l) {
        if (!_)
          return o();
        E ? o(!1, E) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      E === 1 && !JS(c, e.getBoundingClientRect()) && o(), _ = !1;
    }
    try {
      n = new IntersectionObserver(b, {
        ...x,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(b, x);
    }
    n.observe(e);
  }
  return o(!0), s;
}
function CU(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = py(e), u = i || s ? [...c ? Rc(c) : [], ...Rc(t)] : [];
  u.forEach((v) => {
    i && v.addEventListener("scroll", n, {
      passive: !0
    }), s && v.addEventListener("resize", n);
  });
  const f = c && a ? bU(c, n) : null;
  let d = -1, h = null;
  o && (h = new ResizeObserver((v) => {
    let [g] = v;
    g && g.target === c && h && (h.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var x;
      (x = h) == null || x.observe(t);
    })), n();
  }), c && !l && h.observe(c), h.observe(t));
  let m, p = l ? zo(e) : null;
  l && y();
  function y() {
    const v = zo(e);
    p && !JS(p, v) && n(), p = v, m = requestAnimationFrame(y);
  }
  return n(), () => {
    var v;
    u.forEach((g) => {
      i && g.removeEventListener("scroll", n), s && g.removeEventListener("resize", n);
    }), f == null || f(), (v = h) == null || v.disconnect(), h = null, l && cancelAnimationFrame(m);
  };
}
const EU = qH, SU = GH, kU = WH, TU = XH, AU = JH, Cb = jH, NU = YH, IU = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: _U,
    ...n
  }, s = {
    ...i.platform,
    _c: r
  };
  return UH(e, t, {
    ...i,
    platform: s
  });
};
var LU = typeof document < "u", MU = function() {
}, zf = LU ? Ko : MU;
function eh(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!eh(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && e.$$typeof) && !eh(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function KS(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Eb(e, t) {
  const n = KS(e);
  return Math.round(t * n) / n;
}
function j1(e) {
  const t = w.useRef(e);
  return zf(() => {
    t.current = e;
  }), t;
}
function OU(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: s,
      floating: o
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: c
  } = e, [u, f] = w.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [d, h] = w.useState(r);
  eh(d, r) || h(r);
  const [m, p] = w.useState(null), [y, v] = w.useState(null), g = w.useCallback((J) => {
    J !== C.current && (C.current = J, p(J));
  }, []), x = w.useCallback((J) => {
    J !== E.current && (E.current = J, v(J));
  }, []), _ = s || m, b = o || y, C = w.useRef(null), E = w.useRef(null), S = w.useRef(u), k = l != null, M = j1(l), O = j1(i), R = j1(c), I = w.useCallback(() => {
    if (!C.current || !E.current)
      return;
    const J = {
      placement: t,
      strategy: n,
      middleware: d
    };
    O.current && (J.platform = O.current), IU(C.current, E.current, J).then((X) => {
      const N = {
        ...X,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: R.current !== !1
      };
      H.current && !eh(S.current, N) && (S.current = N, Dh.flushSync(() => {
        f(N);
      }));
    });
  }, [d, t, n, O, R]);
  zf(() => {
    c === !1 && S.current.isPositioned && (S.current.isPositioned = !1, f((J) => ({
      ...J,
      isPositioned: !1
    })));
  }, [c]);
  const H = w.useRef(!1);
  zf(() => (H.current = !0, () => {
    H.current = !1;
  }), []), zf(() => {
    if (_ && (C.current = _), b && (E.current = b), _ && b) {
      if (M.current)
        return M.current(_, b, I);
      I();
    }
  }, [_, b, I, M, k]);
  const P = w.useMemo(() => ({
    reference: C,
    floating: E,
    setReference: g,
    setFloating: x
  }), [g, x]), W = w.useMemo(() => ({
    reference: _,
    floating: b
  }), [_, b]), G = w.useMemo(() => {
    const J = {
      position: n,
      left: 0,
      top: 0
    };
    if (!W.floating)
      return J;
    const X = Eb(W.floating, u.x), N = Eb(W.floating, u.y);
    return a ? {
      ...J,
      transform: "translate(" + X + "px, " + N + "px)",
      ...KS(W.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: X,
      top: N
    };
  }, [n, a, W.floating, u.x, u.y]);
  return w.useMemo(() => ({
    ...u,
    update: I,
    refs: P,
    elements: W,
    floatingStyles: G
  }), [u, I, P, W, G]);
}
const PU = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? Cb({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? Cb({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, DU = (e, t) => ({
  ...EU(e),
  options: [e, t]
}), FU = (e, t) => ({
  ...SU(e),
  options: [e, t]
}), RU = (e, t) => ({
  ...NU(e),
  options: [e, t]
}), $U = (e, t) => ({
  ...kU(e),
  options: [e, t]
}), VU = (e, t) => ({
  ...TU(e),
  options: [e, t]
}), BU = (e, t) => ({
  ...AU(e),
  options: [e, t]
}), zU = (e, t) => ({
  ...PU(e),
  options: [e, t]
});
var HU = "Arrow", qS = w.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...s } = e;
  return /* @__PURE__ */ A(
    Ye.svg,
    {
      ...s,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ A("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
qS.displayName = HU;
var UU = qS;
function jU(e) {
  const [t, n] = w.useState(void 0);
  return gn(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let o, a;
        if ("borderBoxSize" in s) {
          const l = s.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          o = c.inlineSize, a = c.blockSize;
        } else
          o = e.offsetWidth, a = e.offsetHeight;
        n({ width: o, height: a });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var gy = "Popper", [GS, bl] = us(gy), [WU, YS] = GS(gy), XS = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = w.useState(null);
  return /* @__PURE__ */ A(WU, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
XS.displayName = gy;
var ZS = "PopperAnchor", QS = w.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, s = YS(ZS, n), o = w.useRef(null), a = _t(t, o);
    return w.useEffect(() => {
      s.onAnchorChange((r == null ? void 0 : r.current) || o.current);
    }), r ? null : /* @__PURE__ */ A(Ye.div, { ...i, ref: a });
  }
);
QS.displayName = ZS;
var vy = "PopperContent", [JU, KU] = GS(vy), e7 = w.forwardRef(
  (e, t) => {
    var q, Z, oe, le, ie, Y;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: o = 0,
      arrowPadding: a = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: f = "partial",
      hideWhenDetached: d = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: m,
      ...p
    } = e, y = YS(vy, n), [v, g] = w.useState(null), x = _t(t, (Ce) => g(Ce)), [_, b] = w.useState(null), C = jU(_), E = (C == null ? void 0 : C.width) ?? 0, S = (C == null ? void 0 : C.height) ?? 0, k = r + (s !== "center" ? "-" + s : ""), M = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, O = Array.isArray(c) ? c : [c], R = O.length > 0, I = {
      padding: M,
      boundary: O.filter(GU),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: R
    }, { refs: H, floatingStyles: P, placement: W, isPositioned: G, middlewareData: J } = OU({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: k,
      whileElementsMounted: (...Ce) => CU(...Ce, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: y.anchor
      },
      middleware: [
        DU({ mainAxis: i + S, alignmentAxis: o }),
        l && FU({
          mainAxis: !0,
          crossAxis: !1,
          limiter: f === "partial" ? RU() : void 0,
          ...I
        }),
        l && $U({ ...I }),
        VU({
          ...I,
          apply: ({ elements: Ce, rects: Fe, availableWidth: je, availableHeight: Ze }) => {
            const { width: mt, height: xn } = Fe.reference, bt = Ce.floating.style;
            bt.setProperty("--radix-popper-available-width", `${je}px`), bt.setProperty("--radix-popper-available-height", `${Ze}px`), bt.setProperty("--radix-popper-anchor-width", `${mt}px`), bt.setProperty("--radix-popper-anchor-height", `${xn}px`);
          }
        }),
        _ && zU({ element: _, padding: a }),
        YU({ arrowWidth: E, arrowHeight: S }),
        d && BU({ strategy: "referenceHidden", ...I })
      ]
    }), [X, N] = r7(W), U = js(m);
    gn(() => {
      G && (U == null || U());
    }, [G, U]);
    const ee = (q = J.arrow) == null ? void 0 : q.x, F = (Z = J.arrow) == null ? void 0 : Z.y, ue = ((oe = J.arrow) == null ? void 0 : oe.centerOffset) !== 0, [pe, ce] = w.useState();
    return gn(() => {
      v && ce(window.getComputedStyle(v).zIndex);
    }, [v]), /* @__PURE__ */ A(
      "div",
      {
        ref: H.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...P,
          transform: G ? P.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: pe,
          "--radix-popper-transform-origin": [
            (le = J.transformOrigin) == null ? void 0 : le.x,
            (ie = J.transformOrigin) == null ? void 0 : ie.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((Y = J.hide) == null ? void 0 : Y.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ A(
          JU,
          {
            scope: n,
            placedSide: X,
            onArrowChange: b,
            arrowX: ee,
            arrowY: F,
            shouldHideArrow: ue,
            children: /* @__PURE__ */ A(
              Ye.div,
              {
                "data-side": X,
                "data-align": N,
                ...p,
                ref: x,
                style: {
                  ...p.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: G ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
e7.displayName = vy;
var t7 = "PopperArrow", qU = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, n7 = w.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, s = KU(t7, r), o = qU[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ A(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ A(
          UU,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
n7.displayName = t7;
function GU(e) {
  return e !== null;
}
var YU = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var y, v, g;
    const { placement: n, rects: r, middlewareData: i } = t, o = ((y = i.arrow) == null ? void 0 : y.centerOffset) !== 0, a = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [c, u] = r7(n), f = { start: "0%", center: "50%", end: "100%" }[u], d = (((v = i.arrow) == null ? void 0 : v.x) ?? 0) + a / 2, h = (((g = i.arrow) == null ? void 0 : g.y) ?? 0) + l / 2;
    let m = "", p = "";
    return c === "bottom" ? (m = o ? f : `${d}px`, p = `${-l}px`) : c === "top" ? (m = o ? f : `${d}px`, p = `${r.floating.height + l}px`) : c === "right" ? (m = `${-l}px`, p = o ? f : `${h}px`) : c === "left" && (m = `${r.floating.width + l}px`, p = o ? f : `${h}px`), { data: { x: m, y: p } };
  }
});
function r7(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var yy = XS, Ip = QS, xy = e7, wy = n7, XU = "Portal", yu = w.forwardRef((e, t) => {
  var a;
  const { container: n, ...r } = e, [i, s] = w.useState(!1);
  gn(() => s(!0), []);
  const o = n || i && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return o ? iC.createPortal(/* @__PURE__ */ A(Ye.div, { ...r, ref: t }), o) : null;
});
yu.displayName = XU;
function ZU(e, t) {
  return w.useReducer((n, r) => t[n][r] ?? n, e);
}
var Qs = (e) => {
  const { present: t, children: n } = e, r = QU(t), i = typeof n == "function" ? n({ present: r.isPresent }) : w.Children.only(n), s = _t(r.ref, ej(i));
  return typeof n == "function" || r.isPresent ? w.cloneElement(i, { ref: s }) : null;
};
Qs.displayName = "Presence";
function QU(e) {
  const [t, n] = w.useState(), r = w.useRef(null), i = w.useRef(e), s = w.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = ZU(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return w.useEffect(() => {
    const c = ef(r.current);
    s.current = a === "mounted" ? c : "none";
  }, [a]), gn(() => {
    const c = r.current, u = i.current;
    if (u !== e) {
      const d = s.current, h = ef(c);
      e ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && d !== h ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), gn(() => {
    if (t) {
      let c;
      const u = t.ownerDocument.defaultView ?? window, f = (h) => {
        const p = ef(r.current).includes(h.animationName);
        if (h.target === t && p && (l("ANIMATION_END"), !i.current)) {
          const y = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = y);
          });
        }
      }, d = (h) => {
        h.target === t && (s.current = ef(r.current));
      };
      return t.addEventListener("animationstart", d), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        u.clearTimeout(c), t.removeEventListener("animationstart", d), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: w.useCallback((c) => {
      r.current = c ? getComputedStyle(c) : null, n(c);
    }, [])
  };
}
function ef(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function ej(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var tj = w[" useInsertionEffect ".trim().toString()] || gn;
function ts({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, s, o] = nj({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, l = a ? e : i;
  {
    const u = w.useRef(e !== void 0);
    w.useEffect(() => {
      const f = u.current;
      f !== a && console.warn(
        `${r} is changing from ${f ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), u.current = a;
    }, [a, r]);
  }
  const c = w.useCallback(
    (u) => {
      var f;
      if (a) {
        const d = rj(u) ? u(e) : u;
        d !== e && ((f = o.current) == null || f.call(o, d));
      } else
        s(u);
    },
    [a, e, s, o]
  );
  return [l, c];
}
function nj({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = w.useState(e), i = w.useRef(n), s = w.useRef(t);
  return tj(() => {
    s.current = t;
  }, [t]), w.useEffect(() => {
    var o;
    i.current !== n && ((o = s.current) == null || o.call(s, n), i.current = n);
  }, [n, i]), [n, r, s];
}
function rj(e) {
  return typeof e == "function";
}
var ij = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, sa = /* @__PURE__ */ new WeakMap(), tf = /* @__PURE__ */ new WeakMap(), nf = {}, W1 = 0, i7 = function(e) {
  return e && (e.host || i7(e.parentNode));
}, sj = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = i7(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, oj = function(e, t, n, r) {
  var i = sj(t, Array.isArray(e) ? e : [e]);
  nf[n] || (nf[n] = /* @__PURE__ */ new WeakMap());
  var s = nf[n], o = [], a = /* @__PURE__ */ new Set(), l = new Set(i), c = function(f) {
    !f || a.has(f) || (a.add(f), c(f.parentNode));
  };
  i.forEach(c);
  var u = function(f) {
    !f || l.has(f) || Array.prototype.forEach.call(f.children, function(d) {
      if (a.has(d))
        u(d);
      else
        try {
          var h = d.getAttribute(r), m = h !== null && h !== "false", p = (sa.get(d) || 0) + 1, y = (s.get(d) || 0) + 1;
          sa.set(d, p), s.set(d, y), o.push(d), p === 1 && m && tf.set(d, !0), y === 1 && d.setAttribute(n, "true"), m || d.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", d, v);
        }
    });
  };
  return u(t), a.clear(), W1++, function() {
    o.forEach(function(f) {
      var d = sa.get(f) - 1, h = s.get(f) - 1;
      sa.set(f, d), s.set(f, h), d || (tf.has(f) || f.removeAttribute(r), tf.delete(f)), h || f.removeAttribute(n);
    }), W1--, W1 || (sa = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), tf = /* @__PURE__ */ new WeakMap(), nf = {});
  };
}, _y = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = ij(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), oj(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, mr = function() {
  return mr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, mr.apply(this, arguments);
};
function s7(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function aj(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, s; r < i; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var Hf = "right-scroll-bar-position", Uf = "width-before-scroll-bar", lj = "with-scroll-bars-hidden", cj = "--removed-body-scroll-bar-size";
function J1(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function uj(e, t) {
  var n = Re(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var fj = typeof window < "u" ? w.useLayoutEffect : w.useEffect, Sb = /* @__PURE__ */ new WeakMap();
function dj(e, t) {
  var n = uj(null, function(r) {
    return e.forEach(function(i) {
      return J1(i, r);
    });
  });
  return fj(function() {
    var r = Sb.get(n);
    if (r) {
      var i = new Set(r), s = new Set(e), o = n.current;
      i.forEach(function(a) {
        s.has(a) || J1(a, null);
      }), s.forEach(function(a) {
        i.has(a) || J1(a, o);
      });
    }
    Sb.set(n, e);
  }, [e]), n;
}
function hj(e) {
  return e;
}
function pj(e, t) {
  t === void 0 && (t = hj);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var o = t(s, r);
      return n.push(o), function() {
        n = n.filter(function(a) {
          return a !== o;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(s);
      }
      n = {
        push: function(a) {
          return s(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var o = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(s), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(s);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return i;
}
function mj(e) {
  e === void 0 && (e = {});
  var t = pj(null);
  return t.options = mr({ async: !0, ssr: !1 }, e), t;
}
var o7 = function(e) {
  var t = e.sideCar, n = s7(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return w.createElement(r, mr({}, n));
};
o7.isSideCarExport = !0;
function gj(e, t) {
  return e.useMedium(t), o7;
}
var a7 = mj(), K1 = function() {
}, Lp = w.forwardRef(function(e, t) {
  var n = w.useRef(null), r = w.useState({
    onScrollCapture: K1,
    onWheelCapture: K1,
    onTouchMoveCapture: K1
  }), i = r[0], s = r[1], o = e.forwardProps, a = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, f = e.shards, d = e.sideCar, h = e.noRelative, m = e.noIsolation, p = e.inert, y = e.allowPinchZoom, v = e.as, g = v === void 0 ? "div" : v, x = e.gapMode, _ = s7(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), b = d, C = dj([n, t]), E = mr(mr({}, _), i);
  return w.createElement(
    w.Fragment,
    null,
    u && w.createElement(b, { sideCar: a7, removeScrollBar: c, shards: f, noRelative: h, noIsolation: m, inert: p, setCallbacks: s, allowPinchZoom: !!y, lockRef: n, gapMode: x }),
    o ? w.cloneElement(w.Children.only(a), mr(mr({}, E), { ref: C })) : w.createElement(g, mr({}, E, { className: l, ref: C }), a)
  );
});
Lp.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Lp.classNames = {
  fullWidth: Uf,
  zeroRight: Hf
};
var vj = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function yj() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = vj();
  return t && e.setAttribute("nonce", t), e;
}
function xj(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function wj(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var _j = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = yj()) && (xj(t, n), wj(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, bj = function() {
  var e = _j();
  return function(t, n) {
    w.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, l7 = function() {
  var e = bj(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, Cj = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, q1 = function(e) {
  return parseInt(e || "", 10) || 0;
}, Ej = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [q1(n), q1(r), q1(i)];
}, Sj = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Cj;
  var t = Ej(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, kj = l7(), Pa = "data-scroll-locked", Tj = function(e, t, n, r) {
  var i = e.left, s = e.top, o = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(lj, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Pa, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Hf, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Uf, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Hf, " .").concat(Hf, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Uf, " .").concat(Uf, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Pa, `] {
    `).concat(cj, ": ").concat(a, `px;
  }
`);
}, kb = function() {
  var e = parseInt(document.body.getAttribute(Pa) || "0", 10);
  return isFinite(e) ? e : 0;
}, Aj = function() {
  w.useEffect(function() {
    return document.body.setAttribute(Pa, (kb() + 1).toString()), function() {
      var e = kb() - 1;
      e <= 0 ? document.body.removeAttribute(Pa) : document.body.setAttribute(Pa, e.toString());
    };
  }, []);
}, Nj = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  Aj();
  var s = w.useMemo(function() {
    return Sj(i);
  }, [i]);
  return w.createElement(kj, { styles: Tj(s, !t, i, n ? "" : "!important") });
}, x0 = !1;
if (typeof window < "u")
  try {
    var rf = Object.defineProperty({}, "passive", {
      get: function() {
        return x0 = !0, !0;
      }
    });
    window.addEventListener("test", rf, rf), window.removeEventListener("test", rf, rf);
  } catch {
    x0 = !1;
  }
var oa = x0 ? { passive: !1 } : !1, Ij = function(e) {
  return e.tagName === "TEXTAREA";
}, c7 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Ij(e) && n[t] === "visible")
  );
}, Lj = function(e) {
  return c7(e, "overflowY");
}, Mj = function(e) {
  return c7(e, "overflowX");
}, Tb = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = u7(e, r);
    if (i) {
      var s = f7(e, r), o = s[1], a = s[2];
      if (o > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Oj = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, Pj = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, u7 = function(e, t) {
  return e === "v" ? Lj(t) : Mj(t);
}, f7 = function(e, t) {
  return e === "v" ? Oj(t) : Pj(t);
}, Dj = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Fj = function(e, t, n, r, i) {
  var s = Dj(e, window.getComputedStyle(t).direction), o = s * r, a = n.target, l = t.contains(a), c = !1, u = o > 0, f = 0, d = 0;
  do {
    if (!a)
      break;
    var h = f7(e, a), m = h[0], p = h[1], y = h[2], v = p - y - s * m;
    (m || v) && u7(e, a) && (f += v, d += m);
    var g = a.parentNode;
    a = g && g.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? g.host : g;
  } while (
    // portaled content
    !l && a !== document.body || // self content
    l && (t.contains(a) || t === a)
  );
  return (u && Math.abs(f) < 1 || !u && Math.abs(d) < 1) && (c = !0), c;
}, sf = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Ab = function(e) {
  return [e.deltaX, e.deltaY];
}, Nb = function(e) {
  return e && "current" in e ? e.current : e;
}, Rj = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, $j = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, Vj = 0, aa = [];
function Bj(e) {
  var t = w.useRef([]), n = w.useRef([0, 0]), r = w.useRef(), i = w.useState(Vj++)[0], s = w.useState(l7)[0], o = w.useRef(e);
  w.useEffect(function() {
    o.current = e;
  }, [e]), w.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var p = aj([e.lockRef.current], (e.shards || []).map(Nb), !0).filter(Boolean);
      return p.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), p.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = w.useCallback(function(p, y) {
    if ("touches" in p && p.touches.length === 2 || p.type === "wheel" && p.ctrlKey)
      return !o.current.allowPinchZoom;
    var v = sf(p), g = n.current, x = "deltaX" in p ? p.deltaX : g[0] - v[0], _ = "deltaY" in p ? p.deltaY : g[1] - v[1], b, C = p.target, E = Math.abs(x) > Math.abs(_) ? "h" : "v";
    if ("touches" in p && E === "h" && C.type === "range")
      return !1;
    var S = Tb(E, C);
    if (!S)
      return !0;
    if (S ? b = E : (b = E === "v" ? "h" : "v", S = Tb(E, C)), !S)
      return !1;
    if (!r.current && "changedTouches" in p && (x || _) && (r.current = b), !b)
      return !0;
    var k = r.current || b;
    return Fj(k, y, p, k === "h" ? x : _);
  }, []), l = w.useCallback(function(p) {
    var y = p;
    if (!(!aa.length || aa[aa.length - 1] !== s)) {
      var v = "deltaY" in y ? Ab(y) : sf(y), g = t.current.filter(function(b) {
        return b.name === y.type && (b.target === y.target || y.target === b.shadowParent) && Rj(b.delta, v);
      })[0];
      if (g && g.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!g) {
        var x = (o.current.shards || []).map(Nb).filter(Boolean).filter(function(b) {
          return b.contains(y.target);
        }), _ = x.length > 0 ? a(y, x[0]) : !o.current.noIsolation;
        _ && y.cancelable && y.preventDefault();
      }
    }
  }, []), c = w.useCallback(function(p, y, v, g) {
    var x = { name: p, delta: y, target: v, should: g, shadowParent: zj(v) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(_) {
        return _ !== x;
      });
    }, 1);
  }, []), u = w.useCallback(function(p) {
    n.current = sf(p), r.current = void 0;
  }, []), f = w.useCallback(function(p) {
    c(p.type, Ab(p), p.target, a(p, e.lockRef.current));
  }, []), d = w.useCallback(function(p) {
    c(p.type, sf(p), p.target, a(p, e.lockRef.current));
  }, []);
  w.useEffect(function() {
    return aa.push(s), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: d
    }), document.addEventListener("wheel", l, oa), document.addEventListener("touchmove", l, oa), document.addEventListener("touchstart", u, oa), function() {
      aa = aa.filter(function(p) {
        return p !== s;
      }), document.removeEventListener("wheel", l, oa), document.removeEventListener("touchmove", l, oa), document.removeEventListener("touchstart", u, oa);
    };
  }, []);
  var h = e.removeScrollBar, m = e.inert;
  return w.createElement(
    w.Fragment,
    null,
    m ? w.createElement(s, { styles: $j(i) }) : null,
    h ? w.createElement(Nj, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function zj(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Hj = gj(a7, Bj);
var Mp = w.forwardRef(function(e, t) {
  return w.createElement(Lp, mr({}, e, { ref: t, sideCar: Hj }));
});
Mp.classNames = Lp.classNames;
var Op = "Popover", [d7, Bme] = us(Op, [
  bl
]), xu = bl(), [Uj, eo] = d7(Op), h7 = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: o = !1
  } = e, a = xu(t), l = w.useRef(null), [c, u] = w.useState(!1), [f, d] = ts({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: Op
  });
  return /* @__PURE__ */ A(yy, { ...a, children: /* @__PURE__ */ A(
    Uj,
    {
      scope: t,
      contentId: qi(),
      triggerRef: l,
      open: f,
      onOpenChange: d,
      onOpenToggle: w.useCallback(() => d((h) => !h), [d]),
      hasCustomAnchor: c,
      onCustomAnchorAdd: w.useCallback(() => u(!0), []),
      onCustomAnchorRemove: w.useCallback(() => u(!1), []),
      modal: o,
      children: n
    }
  ) });
};
h7.displayName = Op;
var p7 = "PopoverAnchor", m7 = w.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = eo(p7, n), s = xu(n), { onCustomAnchorAdd: o, onCustomAnchorRemove: a } = i;
    return w.useEffect(() => (o(), () => a()), [o, a]), /* @__PURE__ */ A(Ip, { ...s, ...r, ref: t });
  }
);
m7.displayName = p7;
var g7 = "PopoverTrigger", v7 = w.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = eo(g7, n), s = xu(n), o = _t(t, i.triggerRef), a = /* @__PURE__ */ A(
      Ye.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": C7(i.open),
        ...r,
        ref: o,
        onClick: ze(e.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? a : /* @__PURE__ */ A(Ip, { asChild: !0, ...s, children: a });
  }
);
v7.displayName = g7;
var by = "PopoverPortal", [jj, Wj] = d7(by, {
  forceMount: void 0
}), y7 = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: i } = e, s = eo(by, t);
  return /* @__PURE__ */ A(jj, { scope: t, forceMount: n, children: /* @__PURE__ */ A(Qs, { present: n || s.open, children: /* @__PURE__ */ A(yu, { asChild: !0, container: i, children: r }) }) });
};
y7.displayName = by;
var el = "PopoverContent", x7 = w.forwardRef(
  (e, t) => {
    const n = Wj(el, e.__scopePopover), { forceMount: r = n.forceMount, ...i } = e, s = eo(el, e.__scopePopover);
    return /* @__PURE__ */ A(Qs, { present: r || s.open, children: s.modal ? /* @__PURE__ */ A(Kj, { ...i, ref: t }) : /* @__PURE__ */ A(qj, { ...i, ref: t }) });
  }
);
x7.displayName = el;
var Jj = /* @__PURE__ */ Za("PopoverContent.RemoveScroll"), Kj = w.forwardRef(
  (e, t) => {
    const n = eo(el, e.__scopePopover), r = w.useRef(null), i = _t(t, r), s = w.useRef(!1);
    return w.useEffect(() => {
      const o = r.current;
      if (o) return _y(o);
    }, []), /* @__PURE__ */ A(Mp, { as: Jj, allowPinchZoom: !0, children: /* @__PURE__ */ A(
      w7,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: ze(e.onCloseAutoFocus, (o) => {
          var a;
          o.preventDefault(), s.current || (a = n.triggerRef.current) == null || a.focus();
        }),
        onPointerDownOutside: ze(
          e.onPointerDownOutside,
          (o) => {
            const a = o.detail.originalEvent, l = a.button === 0 && a.ctrlKey === !0, c = a.button === 2 || l;
            s.current = c;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: ze(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), qj = w.forwardRef(
  (e, t) => {
    const n = eo(el, e.__scopePopover), r = w.useRef(!1), i = w.useRef(!1);
    return /* @__PURE__ */ A(
      w7,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var o, a;
          (o = e.onCloseAutoFocus) == null || o.call(e, s), s.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = s.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), w7 = w.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: o,
      onEscapeKeyDown: a,
      onPointerDownOutside: l,
      onFocusOutside: c,
      onInteractOutside: u,
      ...f
    } = e, d = eo(el, n), h = xu(n);
    return ly(), /* @__PURE__ */ A(
      kp,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ A(
          gu,
          {
            asChild: !0,
            disableOutsidePointerEvents: o,
            onInteractOutside: u,
            onEscapeKeyDown: a,
            onPointerDownOutside: l,
            onFocusOutside: c,
            onDismiss: () => d.onOpenChange(!1),
            children: /* @__PURE__ */ A(
              xy,
              {
                "data-state": C7(d.open),
                role: "dialog",
                id: d.contentId,
                ...h,
                ...f,
                ref: t,
                style: {
                  ...f.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), _7 = "PopoverClose", Gj = w.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = eo(_7, n);
    return /* @__PURE__ */ A(
      Ye.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: ze(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
Gj.displayName = _7;
var Yj = "PopoverArrow", b7 = w.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = xu(n);
    return /* @__PURE__ */ A(wy, { ...i, ...r, ref: t });
  }
);
b7.displayName = Yj;
function C7(e) {
  return e ? "open" : "closed";
}
var E7 = h7, Xj = m7, Zj = v7, S7 = y7, k7 = x7, T7 = b7;
function A7(e) {
  const t = e + "CollectionProvider", [n, r] = us(t), [i, s] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (p) => {
    const { scope: y, children: v } = p, g = T.useRef(null), x = T.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ A(i, { scope: y, itemMap: x, collectionRef: g, children: v });
  };
  o.displayName = t;
  const a = e + "CollectionSlot", l = /* @__PURE__ */ Za(a), c = T.forwardRef(
    (p, y) => {
      const { scope: v, children: g } = p, x = s(a, v), _ = _t(y, x.collectionRef);
      return /* @__PURE__ */ A(l, { ref: _, children: g });
    }
  );
  c.displayName = a;
  const u = e + "CollectionItemSlot", f = "data-radix-collection-item", d = /* @__PURE__ */ Za(u), h = T.forwardRef(
    (p, y) => {
      const { scope: v, children: g, ...x } = p, _ = T.useRef(null), b = _t(y, _), C = s(u, v);
      return T.useEffect(() => (C.itemMap.set(_, { ref: _, ...x }), () => void C.itemMap.delete(_))), /* @__PURE__ */ A(d, { [f]: "", ref: b, children: g });
    }
  );
  h.displayName = u;
  function m(p) {
    const y = s(e + "CollectionConsumer", p);
    return T.useCallback(() => {
      const g = y.collectionRef.current;
      if (!g) return [];
      const x = Array.from(g.querySelectorAll(`[${f}]`));
      return Array.from(y.itemMap.values()).sort(
        (C, E) => x.indexOf(C.ref.current) - x.indexOf(E.ref.current)
      );
    }, [y.collectionRef, y.itemMap]);
  }
  return [
    { Provider: o, Slot: c, ItemSlot: h },
    m,
    r
  ];
}
var Qj = w.createContext(void 0);
function Pp(e) {
  const t = w.useContext(Qj);
  return e || t || "ltr";
}
var G1 = "rovingFocusGroup.onEntryFocus", eW = { bubbles: !1, cancelable: !0 }, wu = "RovingFocusGroup", [w0, N7, tW] = A7(wu), [nW, Dp] = us(
  wu,
  [tW]
), [rW, iW] = nW(wu), I7 = w.forwardRef(
  (e, t) => /* @__PURE__ */ A(w0.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ A(w0.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ A(sW, { ...e, ref: t }) }) })
);
I7.displayName = wu;
var sW = w.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: s,
    currentTabStopId: o,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: u = !1,
    ...f
  } = e, d = w.useRef(null), h = _t(t, d), m = Pp(s), [p, y] = ts({
    prop: o,
    defaultProp: a ?? null,
    onChange: l,
    caller: wu
  }), [v, g] = w.useState(!1), x = js(c), _ = N7(n), b = w.useRef(!1), [C, E] = w.useState(0);
  return w.useEffect(() => {
    const S = d.current;
    if (S)
      return S.addEventListener(G1, x), () => S.removeEventListener(G1, x);
  }, [x]), /* @__PURE__ */ A(
    rW,
    {
      scope: n,
      orientation: r,
      dir: m,
      loop: i,
      currentTabStopId: p,
      onItemFocus: w.useCallback(
        (S) => y(S),
        [y]
      ),
      onItemShiftTab: w.useCallback(() => g(!0), []),
      onFocusableItemAdd: w.useCallback(
        () => E((S) => S + 1),
        []
      ),
      onFocusableItemRemove: w.useCallback(
        () => E((S) => S - 1),
        []
      ),
      children: /* @__PURE__ */ A(
        Ye.div,
        {
          tabIndex: v || C === 0 ? -1 : 0,
          "data-orientation": r,
          ...f,
          ref: h,
          style: { outline: "none", ...e.style },
          onMouseDown: ze(e.onMouseDown, () => {
            b.current = !0;
          }),
          onFocus: ze(e.onFocus, (S) => {
            const k = !b.current;
            if (S.target === S.currentTarget && k && !v) {
              const M = new CustomEvent(G1, eW);
              if (S.currentTarget.dispatchEvent(M), !M.defaultPrevented) {
                const O = _().filter((W) => W.focusable), R = O.find((W) => W.active), I = O.find((W) => W.id === p), P = [R, I, ...O].filter(
                  Boolean
                ).map((W) => W.ref.current);
                O7(P, u);
              }
            }
            b.current = !1;
          }),
          onBlur: ze(e.onBlur, () => g(!1))
        }
      )
    }
  );
}), L7 = "RovingFocusGroupItem", M7 = w.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: s,
      children: o,
      ...a
    } = e, l = qi(), c = s || l, u = iW(L7, n), f = u.currentTabStopId === c, d = N7(n), { onFocusableItemAdd: h, onFocusableItemRemove: m, currentTabStopId: p } = u;
    return w.useEffect(() => {
      if (r)
        return h(), () => m();
    }, [r, h, m]), /* @__PURE__ */ A(
      w0.ItemSlot,
      {
        scope: n,
        id: c,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ A(
          Ye.span,
          {
            tabIndex: f ? 0 : -1,
            "data-orientation": u.orientation,
            ...a,
            ref: t,
            onMouseDown: ze(e.onMouseDown, (y) => {
              r ? u.onItemFocus(c) : y.preventDefault();
            }),
            onFocus: ze(e.onFocus, () => u.onItemFocus(c)),
            onKeyDown: ze(e.onKeyDown, (y) => {
              if (y.key === "Tab" && y.shiftKey) {
                u.onItemShiftTab();
                return;
              }
              if (y.target !== y.currentTarget) return;
              const v = lW(y, u.orientation, u.dir);
              if (v !== void 0) {
                if (y.metaKey || y.ctrlKey || y.altKey || y.shiftKey) return;
                y.preventDefault();
                let x = d().filter((_) => _.focusable).map((_) => _.ref.current);
                if (v === "last") x.reverse();
                else if (v === "prev" || v === "next") {
                  v === "prev" && x.reverse();
                  const _ = x.indexOf(y.currentTarget);
                  x = u.loop ? cW(x, _ + 1) : x.slice(_ + 1);
                }
                setTimeout(() => O7(x));
              }
            }),
            children: typeof o == "function" ? o({ isCurrentTabStop: f, hasTabStop: p != null }) : o
          }
        )
      }
    );
  }
);
M7.displayName = L7;
var oW = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function aW(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function lW(e, t, n) {
  const r = aW(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return oW[r];
}
function O7(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function cW(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var P7 = I7, Cy = M7, uW = "Separator", Ib = "horizontal", fW = ["horizontal", "vertical"], D7 = w.forwardRef((e, t) => {
  const { decorative: n, orientation: r = Ib, ...i } = e, s = dW(r) ? r : Ib, a = n ? { role: "none" } : { "aria-orientation": s === "vertical" ? s : void 0, role: "separator" };
  return /* @__PURE__ */ A(
    Ye.div,
    {
      "data-orientation": s,
      ...a,
      ...i,
      ref: t
    }
  );
});
D7.displayName = uW;
function dW(e) {
  return fW.includes(e);
}
var hW = D7, F7 = "Toggle", R7 = w.forwardRef((e, t) => {
  const { pressed: n, defaultPressed: r, onPressedChange: i, ...s } = e, [o, a] = ts({
    prop: n,
    onChange: i,
    defaultProp: r ?? !1,
    caller: F7
  });
  return /* @__PURE__ */ A(
    Ye.button,
    {
      type: "button",
      "aria-pressed": o,
      "data-state": o ? "on" : "off",
      "data-disabled": e.disabled ? "" : void 0,
      ...s,
      ref: t,
      onClick: ze(e.onClick, () => {
        e.disabled || a(!o);
      })
    }
  );
});
R7.displayName = F7;
var to = "ToggleGroup", [$7, V7] = us(to, [
  Dp
]), B7 = Dp(), Ey = T.forwardRef((e, t) => {
  const { type: n, ...r } = e;
  if (n === "single")
    return /* @__PURE__ */ A(pW, { ...r, ref: t });
  if (n === "multiple")
    return /* @__PURE__ */ A(mW, { ...r, ref: t });
  throw new Error(`Missing prop \`type\` expected on \`${to}\``);
});
Ey.displayName = to;
var [z7, H7] = $7(to), pW = T.forwardRef((e, t) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: i = () => {
    },
    ...s
  } = e, [o, a] = ts({
    prop: n,
    defaultProp: r ?? "",
    onChange: i,
    caller: to
  });
  return /* @__PURE__ */ A(
    z7,
    {
      scope: e.__scopeToggleGroup,
      type: "single",
      value: T.useMemo(() => o ? [o] : [], [o]),
      onItemActivate: a,
      onItemDeactivate: T.useCallback(() => a(""), [a]),
      children: /* @__PURE__ */ A(U7, { ...s, ref: t })
    }
  );
}), mW = T.forwardRef((e, t) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: i = () => {
    },
    ...s
  } = e, [o, a] = ts({
    prop: n,
    defaultProp: r ?? [],
    onChange: i,
    caller: to
  }), l = T.useCallback(
    (u) => a((f = []) => [...f, u]),
    [a]
  ), c = T.useCallback(
    (u) => a((f = []) => f.filter((d) => d !== u)),
    [a]
  );
  return /* @__PURE__ */ A(
    z7,
    {
      scope: e.__scopeToggleGroup,
      type: "multiple",
      value: o,
      onItemActivate: l,
      onItemDeactivate: c,
      children: /* @__PURE__ */ A(U7, { ...s, ref: t })
    }
  );
});
Ey.displayName = to;
var [gW, vW] = $7(to), U7 = T.forwardRef(
  (e, t) => {
    const {
      __scopeToggleGroup: n,
      disabled: r = !1,
      rovingFocus: i = !0,
      orientation: s,
      dir: o,
      loop: a = !0,
      ...l
    } = e, c = B7(n), u = Pp(o), f = { role: "group", dir: u, ...l };
    return /* @__PURE__ */ A(gW, { scope: n, rovingFocus: i, disabled: r, children: i ? /* @__PURE__ */ A(
      P7,
      {
        asChild: !0,
        ...c,
        orientation: s,
        dir: u,
        loop: a,
        children: /* @__PURE__ */ A(Ye.div, { ...f, ref: t })
      }
    ) : /* @__PURE__ */ A(Ye.div, { ...f, ref: t }) });
  }
), th = "ToggleGroupItem", j7 = T.forwardRef(
  (e, t) => {
    const n = H7(th, e.__scopeToggleGroup), r = vW(th, e.__scopeToggleGroup), i = B7(e.__scopeToggleGroup), s = n.value.includes(e.value), o = r.disabled || e.disabled, a = { ...e, pressed: s, disabled: o }, l = T.useRef(null);
    return r.rovingFocus ? /* @__PURE__ */ A(
      Cy,
      {
        asChild: !0,
        ...i,
        focusable: !o,
        active: s,
        ref: l,
        children: /* @__PURE__ */ A(Lb, { ...a, ref: t })
      }
    ) : /* @__PURE__ */ A(Lb, { ...a, ref: t });
  }
);
j7.displayName = th;
var Lb = T.forwardRef(
  (e, t) => {
    const { __scopeToggleGroup: n, value: r, ...i } = e, s = H7(th, n), o = { role: "radio", "aria-checked": e.pressed, "aria-pressed": void 0 }, a = s.type === "single" ? o : void 0;
    return /* @__PURE__ */ A(
      R7,
      {
        ...a,
        ...i,
        ref: t,
        onPressedChange: (l) => {
          l ? s.onItemActivate(r) : s.onItemDeactivate(r);
        }
      }
    );
  }
), yW = Ey, xW = j7, Sy = "Toolbar", [wW, zme] = us(Sy, [
  Dp,
  V7
]), ky = Dp(), W7 = V7(), [_W, J7] = wW(Sy), K7 = w.forwardRef(
  (e, t) => {
    const { __scopeToolbar: n, orientation: r = "horizontal", dir: i, loop: s = !0, ...o } = e, a = ky(n), l = Pp(i);
    return /* @__PURE__ */ A(_W, { scope: n, orientation: r, dir: l, children: /* @__PURE__ */ A(
      P7,
      {
        asChild: !0,
        ...a,
        orientation: r,
        dir: l,
        loop: s,
        children: /* @__PURE__ */ A(
          Ye.div,
          {
            role: "toolbar",
            "aria-orientation": r,
            dir: l,
            ...o,
            ref: t
          }
        )
      }
    ) });
  }
);
K7.displayName = Sy;
var q7 = "ToolbarSeparator", bW = w.forwardRef(
  (e, t) => {
    const { __scopeToolbar: n, ...r } = e, i = J7(q7, n);
    return /* @__PURE__ */ A(
      hW,
      {
        orientation: i.orientation === "horizontal" ? "vertical" : "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
bW.displayName = q7;
var CW = "ToolbarButton", Ty = w.forwardRef(
  (e, t) => {
    const { __scopeToolbar: n, ...r } = e, i = ky(n);
    return /* @__PURE__ */ A(Cy, { asChild: !0, ...i, focusable: !e.disabled, children: /* @__PURE__ */ A(Ye.button, { type: "button", ...r, ref: t }) });
  }
);
Ty.displayName = CW;
var EW = "ToolbarLink", SW = w.forwardRef(
  (e, t) => {
    const { __scopeToolbar: n, ...r } = e, i = ky(n);
    return /* @__PURE__ */ A(Cy, { asChild: !0, ...i, focusable: !0, children: /* @__PURE__ */ A(
      Ye.a,
      {
        ...r,
        ref: t,
        onKeyDown: ze(e.onKeyDown, (s) => {
          s.key === " " && s.currentTarget.click();
        })
      }
    ) });
  }
);
SW.displayName = EW;
var G7 = "ToolbarToggleGroup", Y7 = w.forwardRef(
  (e, t) => {
    const { __scopeToolbar: n, ...r } = e, i = J7(G7, n), s = W7(n);
    return /* @__PURE__ */ A(
      yW,
      {
        "data-orientation": i.orientation,
        dir: i.dir,
        ...s,
        ...r,
        ref: t,
        rovingFocus: !1
      }
    );
  }
);
Y7.displayName = G7;
var kW = "ToolbarToggleItem", X7 = w.forwardRef(
  (e, t) => {
    const { __scopeToolbar: n, ...r } = e, i = W7(n), s = { __scopeToolbar: e.__scopeToolbar };
    return /* @__PURE__ */ A(Ty, { asChild: !0, ...s, children: /* @__PURE__ */ A(xW, { ...i, ...r, ref: t }) });
  }
);
X7.displayName = kW;
var TW = K7, Z7 = Ty, Ay = Y7, AW = X7;
function Q7(e, t) {
  return e === null || e === t ? !1 : e.dataset.editorDialog !== void 0 || e.dataset.toolbarItem !== void 0 || e.dataset.editorDropdown ? !0 : Q7(e.parentElement, t);
}
const NW = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
let Zo = class e8 extends Wn {
  static getType() {
    return "link";
  }
  static clone(t) {
    return new e8(t.__url, { rel: t.__rel, target: t.__target, title: t.__title }, t.__key);
  }
  constructor(t = "", n = {}, r) {
    super(r);
    const { target: i = null, rel: s = null, title: o = null } = n;
    this.__url = t, this.__target = i, this.__rel = s, this.__title = o;
  }
  createDOM(t) {
    const n = document.createElement("a");
    return this.updateLinkDOM(null, n, t), Ur(n, t.theme.link), n;
  }
  updateLinkDOM(t, n, r) {
    if (T9(n)) {
      t && t.__url === this.__url || (n.href = this.sanitizeUrl(this.__url));
      for (const i of ["target", "rel", "title"]) {
        const s = `__${i}`, o = this[s];
        t && t[s] === o || (o ? n[i] = o : n.removeAttribute(i));
      }
    }
  }
  updateDOM(t, n, r) {
    return this.updateLinkDOM(t, n, r), !1;
  }
  static importDOM() {
    return { a: (t) => ({ conversion: IW, priority: 1 }) };
  }
  static importJSON(t) {
    return Ks().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setURL(t.url).setRel(t.rel || null).setTarget(t.target || null).setTitle(t.title || null);
  }
  sanitizeUrl(t) {
    t = Pb(t);
    try {
      const n = new URL(Pb(t));
      if (!NW.has(n.protocol)) return "about:blank";
    } catch {
      return t;
    }
    return t;
  }
  exportJSON() {
    return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), url: this.getURL() };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(t) {
    const n = this.getWritable();
    return n.__url = t, n;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(t) {
    const n = this.getWritable();
    return n.__target = t, n;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(t) {
    const n = this.getWritable();
    return n.__rel = t, n;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(t) {
    const n = this.getWritable();
    return n.__title = t, n;
  }
  insertNewAfter(t, n = !0) {
    const r = Ks(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(t, n, r) {
    if (!fe(n)) return !1;
    const i = n.anchor.getNode(), s = n.focus.getNode();
    return this.isParentOf(i) && this.isParentOf(s) && n.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function IW(e) {
  let t = null;
  if (T9(e)) {
    const n = e.textContent;
    (n !== null && n !== "" || e.children.length > 0) && (t = Ks(e.getAttribute("href") || "", { rel: e.getAttribute("rel"), target: e.getAttribute("target"), title: e.getAttribute("title") }));
  }
  return { node: t };
}
function Ks(e = "", t) {
  return Pn(new Zo(e, t));
}
function ur(e) {
  return e instanceof Zo;
}
let Fp = class t8 extends Zo {
  constructor(t = "", n = {}, r) {
    super(t, n, r), this.__isUnlinked = n.isUnlinked !== void 0 && n.isUnlinked !== null && n.isUnlinked;
  }
  static getType() {
    return "autolink";
  }
  static clone(t) {
    return new t8(t.__url, { isUnlinked: t.__isUnlinked, rel: t.__rel, target: t.__target, title: t.__title }, t.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(t) {
    const n = this.getWritable();
    return n.__isUnlinked = t, n;
  }
  createDOM(t) {
    return this.__isUnlinked ? document.createElement("span") : super.createDOM(t);
  }
  updateDOM(t, n, r) {
    return super.updateDOM(t, n, r) || t.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(t) {
    return _0().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setIsUnlinked(t.isUnlinked || !1);
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return { ...super.exportJSON(), isUnlinked: this.__isUnlinked };
  }
  insertNewAfter(t, n = !0) {
    const r = this.getParentOrThrow().insertNewAfter(t, n);
    if (te(r)) {
      const i = _0(this.__url, { isUnlinked: this.__isUnlinked, rel: this.__rel, target: this.__target, title: this.__title });
      return r.append(i), i;
    }
    return null;
  }
};
function _0(e = "", t) {
  return Pn(new Fp(e, t));
}
function oi(e) {
  return e instanceof Fp;
}
const tl = Pe("TOGGLE_LINK_COMMAND");
function Mb(e, t) {
  if (e.type === "element") {
    const n = e.getNode();
    return te(n) || function(r, ...i) {
      const s = new URL("https://lexical.dev/docs/error"), o = new URLSearchParams();
      o.append("code", r);
      for (const a of i) o.append("v", a);
      throw s.search = o.toString(), Error(`Minified Lexical error #${r}; visit ${s.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    }(252), n.getChildren()[e.offset + t] || null;
  }
  return null;
}
function Y1(e, t = {}) {
  const { target: n, title: r } = t, i = t.rel === void 0 ? "noreferrer" : t.rel, s = ge();
  if (s === null || !fe(s) && !Nt(s)) return;
  if (Nt(s)) {
    const c = s.getNodes();
    return c.length === 0 ? void 0 : void c.forEach((u) => {
      if (e === null) {
        const f = $r(u, (d) => !oi(d) && ur(d));
        f && (f.insertBefore(u), f.getChildren().length === 0 && f.remove());
      } else {
        const f = $r(u, (d) => !oi(d) && ur(d));
        if (f) f.setURL(e), n !== void 0 && f.setTarget(n), i !== void 0 && f.setRel(i);
        else {
          const d = Ks(e, { rel: i, target: n });
          u.insertBefore(d), d.append(u);
        }
      }
    });
  }
  const o = s.extract();
  if (e === null) return void o.forEach((c) => {
    const u = $r(c, (f) => !oi(f) && ur(f));
    if (u) {
      const f = u.getChildren();
      for (let d = 0; d < f.length; d++) u.insertBefore(f[d]);
      u.remove();
    }
  });
  const a = /* @__PURE__ */ new Set(), l = (c) => {
    a.has(c.getKey()) || (a.add(c.getKey()), c.setURL(e), n !== void 0 && c.setTarget(n), i !== void 0 && c.setRel(i), r !== void 0 && c.setTitle(r));
  };
  if (o.length === 1) {
    const c = Ob(o[0], ur);
    if (c !== null) return l(c);
  }
  (function(c) {
    const u = ge();
    if (!fe(u)) return c();
    const f = Do(u), d = f.isBackward(), h = Mb(f.anchor, d ? -1 : 0), m = Mb(f.focus, d ? 0 : -1);
    if (c(), h || m) {
      const p = ge();
      if (fe(p)) {
        const y = p.clone();
        if (h) {
          const v = h.getParent();
          v && y.anchor.set(v.getKey(), h.getIndexWithinParent() + (d ? 1 : 0), "element");
        }
        if (m) {
          const v = m.getParent();
          v && y.focus.set(v.getKey(), m.getIndexWithinParent() + (d ? 0 : 1), "element");
        }
        Ot(Do(y));
      }
    }
  })(() => {
    let c = null;
    for (const u of o) {
      if (!u.isAttached()) continue;
      const f = Ob(u, ur);
      if (f) {
        l(f);
        continue;
      }
      if (te(u)) {
        if (!u.isInline()) continue;
        if (ur(u)) {
          if (!(oi(u) || c !== null && c.getParentOrThrow().isParentOf(u))) {
            l(u), c = u;
            continue;
          }
          for (const h of u.getChildren()) u.insertBefore(h);
          u.remove();
          continue;
        }
      }
      const d = u.getPreviousSibling();
      ur(d) && d.is(c) ? d.append(u) : (c = Ks(e, { rel: i, target: n, title: r }), u.insertAfter(c), c.append(u));
    }
  });
}
function Ob(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
const LW = /^\+?[0-9\s()-]{5,}$/;
function Pb(e) {
  return e.match(/^[a-z][a-z0-9+.-]*:/i) || e.match(/^[/#.]/) ? e : e.includes("@") ? `mailto:${e}` : LW.test(e) ? `tel:${e}` : `https://${e}`;
}
const MW = {
  testNode: "link",
  visitNode({ mdastNode: e, actions: t }) {
    t.addAndStepInto(
      Ks(e.url, {
        title: e.title
      })
    );
  }
}, OW = {
  testLexicalNode: ur,
  visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
    t.addAndStepInto("link", { url: e.getURL(), title: e.getTitle() });
  }
};
function PW({ validateUrl: e, attributes: t }) {
  const [n] = vn();
  return Le(() => {
    if (!n.hasNodes([Zo])) throw new Error("LinkPlugin: LinkNode not registered on editor");
    return Dn(n.registerCommand(tl, (r) => {
      if (r === null) return Y1(r), !0;
      if (typeof r == "string") return !(e !== void 0 && !e(r)) && (Y1(r, t), !0);
      {
        const { url: i, target: s, rel: o, title: a } = r;
        return Y1(i, { ...t, rel: o, target: s, title: a }), !0;
      }
    }, xt), e !== void 0 ? n.registerCommand(Qc, (r) => {
      const i = ge();
      if (!fe(i) || i.isCollapsed() || !Ns(r, ClipboardEvent) || r.clipboardData === null) return !1;
      const s = r.clipboardData.getData("text");
      return !!e(s) && !i.getNodes().some((o) => te(o)) && (n.dispatchCommand(tl, { ...t, url: s }), r.preventDefault(), !0);
    }, xt) : () => {
    });
  }, [n, e, t]), null;
}
function Db(e, t = (n) => n) {
  return (n) => {
    const r = e.exec(n);
    return r === null ? null : { index: r.index, length: r[0].length, text: r[0], url: t(r[0]) };
  };
}
function n8(e, t) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n](e);
    if (r) return r;
  }
  return null;
}
const DW = /[.,;\s]/;
function nh(e) {
  return DW.test(e);
}
function r8(e) {
  return nh(e[e.length - 1]);
}
function b0(e) {
  return nh(e[0]);
}
function i8(e) {
  let t = e.getPreviousSibling();
  return te(t) && (t = t.getLastDescendant()), t === null || Rr(t) || ye(t) && r8(t.getTextContent());
}
function s8(e) {
  let t = e.getNextSibling();
  return te(t) && (t = t.getFirstDescendant()), t === null || Rr(t) || ye(t) && b0(t.getTextContent());
}
function FW(e, t, n, r) {
  return (e > 0 ? nh(n[e - 1]) : i8(r[0])) ? t < n.length ? nh(n[t]) : s8(r[r.length - 1]) : !1;
}
function RW(e, t, n) {
  const r = [], i = [], s = [];
  let o = 0, a = 0;
  const l = [...e];
  for (; l.length > 0; ) {
    const c = l[0], u = c.getTextContent().length, f = a;
    a + u <= t ? (r.push(c), o += u) : f >= n ? s.push(c) : i.push(c), a += u, l.shift();
  }
  return [o, r, i, s];
}
function $W(e, t, n, r) {
  const i = _0(r.url, r.attributes);
  if (e.length === 1) {
    let s, o = e[0];
    t === 0 ? [s, o] = o.splitText(n) : [, s, o] = o.splitText(t, n);
    const a = yt(r.text);
    return a.setFormat(s.getFormat()), a.setDetail(s.getDetail()), a.setStyle(s.getStyle()), i.append(a), s.replace(i), o;
  }
  if (e.length > 1) {
    const s = e[0];
    let o, a = s.getTextContent().length;
    t === 0 ? o = s : [, o] = s.splitText(t);
    const l = [];
    let c;
    for (let h = 1; h < e.length; h++) {
      const m = e[h], p = m.getTextContent().length, y = a;
      if (y < n) if (a + p <= n) l.push(m);
      else {
        const [v, g] = m.splitText(n - y);
        l.push(v), c = g;
      }
      a += p;
    }
    const u = ge(), f = u ? u.getNodes().find(ye) : void 0, d = yt(o.getTextContent());
    return d.setFormat(o.getFormat()), d.setDetail(o.getDetail()), d.setStyle(o.getStyle()), i.append(d, ...l), f && f === o && (fe(u) ? d.select(u.anchor.offset, u.focus.offset) : Nt(u) && d.select(0, d.getTextContent().length)), o.replace(i), c;
  }
}
function X1(e, t, n) {
  const r = e.getChildren(), i = r.length;
  for (let l = 0; l < i; l++) {
    const c = r[l];
    if (!ye(c) || !c.isSimpleText()) return jf(e), void n(null, e.getURL());
  }
  const s = e.getTextContent(), o = n8(s, t);
  if (o === null || o.text !== s || !i8(e) || !s8(e)) return jf(e), void n(null, e.getURL());
  const a = e.getURL();
  if (a !== o.url && (e.setURL(o.url), n(o.url, a)), o.attributes) {
    const l = e.getRel();
    l !== o.attributes.rel && (e.setRel(o.attributes.rel || null), n(o.attributes.rel || null, l));
    const c = e.getTarget();
    c !== o.attributes.target && (e.setTarget(o.attributes.target || null), n(o.attributes.target || null, c));
  }
}
function jf(e) {
  const t = e.getChildren();
  for (let n = t.length - 1; n >= 0; n--) e.insertAfter(t[n]);
  return e.remove(), t.map((n) => n.getLatest());
}
function VW(e, t, n) {
  Le(() => {
    e.hasNodes([Fp]) || function(i, ...s) {
      const o = new URL("https://lexical.dev/docs/error"), a = new URLSearchParams();
      a.append("code", i);
      for (const l of s) a.append("v", l);
      throw o.search = a.toString(), Error(`Minified Lexical error #${i}; visit ${o.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    }(77);
    const r = (i, s) => {
      n && n(i, s);
    };
    return Dn(e.registerNodeTransform(Ys, (i) => {
      const s = i.getParentOrThrow(), o = i.getPreviousSibling();
      if (oi(s) && !s.getIsUnlinked()) X1(s, t, r);
      else if (!ur(s)) {
        if (i.isSimpleText() && (b0(i.getTextContent()) || !oi(o))) {
          const a = function(l) {
            const c = [l];
            let u = l.getNextSibling();
            for (; u !== null && ye(u) && u.isSimpleText() && (c.push(u), !/[\s]/.test(u.getTextContent())); ) u = u.getNextSibling();
            return c;
          }(i);
          (function(l, c, u) {
            let f = [...l];
            const d = f.map((y) => y.getTextContent()).join("");
            let h, m = d, p = 0;
            for (; (h = n8(m, c)) && h !== null; ) {
              const y = h.index, v = y + h.length;
              if (FW(p + y, p + v, d, f)) {
                const [g, , x, _] = RW(f, p + y, p + v), b = $W(x, p + y - g, p + v - g, h);
                f = b ? [b, ..._] : _, u(h.url, null), p = 0;
              } else p += v;
              m = m.substring(v);
            }
          })(a, t, r);
        }
        (function(a, l, c) {
          const u = a.getPreviousSibling(), f = a.getNextSibling(), d = a.getTextContent();
          var h;
          !oi(u) || u.getIsUnlinked() || b0(d) && (h = d, !(u.isEmailURI() ? /^\.[a-zA-Z]{2,}/.test(h) : /^\.[a-zA-Z0-9]{1,}/.test(h))) || (u.append(a), X1(u, l, c), c(null, u.getURL())), !oi(f) || f.getIsUnlinked() || r8(d) || (jf(f), X1(f, l, c), c(null, f.getURL()));
        })(i, t, r);
      }
    }), e.registerCommand(tl, (i) => {
      const s = ge();
      return i !== null || !fe(s) || s.extract().forEach((o) => {
        const a = o.getParent();
        oi(a) && (a.setIsUnlinked(!a.getIsUnlinked()), a.markDirty());
      }), !1;
    }, xt));
  }, [e, t, n]);
}
function BW({ matchers: e, onChange: t }) {
  const [n] = vn();
  return VW(n, e, t), null;
}
const zW = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, HW = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/, UW = [
  Db(zW, (e) => e.startsWith("http") ? e : `https://${e}`),
  Db(HW, (e) => `mailto:${e}`)
], jW = () => /* @__PURE__ */ T.createElement(BW, { matchers: UW }), WW = Te(!1), JW = Jn({
  init(e, t) {
    const n = !!(t != null && t.disableAutoLink), r = t != null && t.validateUrl ? { validateUrl: t.validateUrl } : {};
    e.pubIn({
      [vl]: "link",
      [Er]: MW,
      [Yr]: [Zo, Fp],
      [Xr]: OW,
      [WW]: n,
      [Xo]: () => /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(PW, { ...r }), n ? null : /* @__PURE__ */ T.createElement(jW, null))
    });
  }
});
function KW(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var qW = ["color"], GW = /* @__PURE__ */ wi(function(e, t) {
  var n = e.color, r = n === void 0 ? "currentColor" : n, i = KW(e, qW);
  return c5("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i, {
    ref: t
  }), c5("path", {
    d: "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z",
    fill: r,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
const Fb = () => /* @__PURE__ */ T.createElement("div", { className: de.imagePlaceholder }, /* @__PURE__ */ T.createElement(GW, null));
function C0({ nodeKey: e, imageSource: t, initialImagePath: n, title: r, alt: i }) {
  const [s, o, a] = On(Tk, ir, Cr), [l] = vn(), c = It(Sk), u = Kn();
  return /* @__PURE__ */ T.createElement("div", { className: de.editImageToolbar }, /* @__PURE__ */ T.createElement(
    "button",
    {
      className: de.iconButton,
      type: "button",
      title: u("imageEditor.deleteImage", "Delete image"),
      disabled: a,
      onClick: (f) => {
        f.preventDefault(), l.update(() => {
          var d;
          (d = wt(e)) == null || d.remove();
        });
      }
    },
    o("delete_small")
  ), !s && /* @__PURE__ */ T.createElement(
    "button",
    {
      type: "button",
      className: rt(de.iconButton, de.editImageButton),
      title: u("imageEditor.editImage", "Edit image"),
      disabled: a,
      onClick: () => {
        c({
          nodeKey: e,
          initialValues: {
            src: n || t,
            title: r,
            altText: i
          }
        });
      }
    },
    o("settings")
  ));
}
var Rp = "Dialog", [o8, Hme] = us(Rp), [YW, Zr] = o8(Rp), a8 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: o = !0
  } = e, a = w.useRef(null), l = w.useRef(null), [c, u] = ts({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: Rp
  });
  return /* @__PURE__ */ A(
    YW,
    {
      scope: t,
      triggerRef: a,
      contentRef: l,
      contentId: qi(),
      titleId: qi(),
      descriptionId: qi(),
      open: c,
      onOpenChange: u,
      onOpenToggle: w.useCallback(() => u((f) => !f), [u]),
      modal: o,
      children: n
    }
  );
};
a8.displayName = Rp;
var l8 = "DialogTrigger", XW = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Zr(l8, n), s = _t(t, i.triggerRef);
    return /* @__PURE__ */ A(
      Ye.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": Ly(i.open),
        ...r,
        ref: s,
        onClick: ze(e.onClick, i.onOpenToggle)
      }
    );
  }
);
XW.displayName = l8;
var Ny = "DialogPortal", [ZW, c8] = o8(Ny, {
  forceMount: void 0
}), u8 = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, s = Zr(Ny, t);
  return /* @__PURE__ */ A(ZW, { scope: t, forceMount: n, children: w.Children.map(r, (o) => /* @__PURE__ */ A(Qs, { present: n || s.open, children: /* @__PURE__ */ A(yu, { asChild: !0, container: i, children: o }) })) });
};
u8.displayName = Ny;
var rh = "DialogOverlay", f8 = w.forwardRef(
  (e, t) => {
    const n = c8(rh, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, s = Zr(rh, e.__scopeDialog);
    return s.modal ? /* @__PURE__ */ A(Qs, { present: r || s.open, children: /* @__PURE__ */ A(eJ, { ...i, ref: t }) }) : null;
  }
);
f8.displayName = rh;
var QW = /* @__PURE__ */ Za("DialogOverlay.RemoveScroll"), eJ = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Zr(rh, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ A(Mp, { as: QW, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ A(
        Ye.div,
        {
          "data-state": Ly(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Ho = "DialogContent", d8 = w.forwardRef(
  (e, t) => {
    const n = c8(Ho, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, s = Zr(Ho, e.__scopeDialog);
    return /* @__PURE__ */ A(Qs, { present: r || s.open, children: s.modal ? /* @__PURE__ */ A(tJ, { ...i, ref: t }) : /* @__PURE__ */ A(nJ, { ...i, ref: t }) });
  }
);
d8.displayName = Ho;
var tJ = w.forwardRef(
  (e, t) => {
    const n = Zr(Ho, e.__scopeDialog), r = w.useRef(null), i = _t(t, n.contentRef, r);
    return w.useEffect(() => {
      const s = r.current;
      if (s) return _y(s);
    }, []), /* @__PURE__ */ A(
      h8,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: ze(e.onCloseAutoFocus, (s) => {
          var o;
          s.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: ze(e.onPointerDownOutside, (s) => {
          const o = s.detail.originalEvent, a = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || a) && s.preventDefault();
        }),
        onFocusOutside: ze(
          e.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), nJ = w.forwardRef(
  (e, t) => {
    const n = Zr(Ho, e.__scopeDialog), r = w.useRef(!1), i = w.useRef(!1);
    return /* @__PURE__ */ A(
      h8,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var o, a;
          (o = e.onCloseAutoFocus) == null || o.call(e, s), s.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = s.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), h8 = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...o } = e, a = Zr(Ho, n), l = w.useRef(null), c = _t(t, l);
    return ly(), /* @__PURE__ */ Oe(Ut, { children: [
      /* @__PURE__ */ A(
        kp,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ A(
            gu,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": Ly(a.open),
              ...o,
              ref: c,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ Oe(Ut, { children: [
        /* @__PURE__ */ A(iJ, { titleId: a.titleId }),
        /* @__PURE__ */ A(oJ, { contentRef: l, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), Iy = "DialogTitle", p8 = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Zr(Iy, n);
    return /* @__PURE__ */ A(Ye.h2, { id: i.titleId, ...r, ref: t });
  }
);
p8.displayName = Iy;
var m8 = "DialogDescription", rJ = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Zr(m8, n);
    return /* @__PURE__ */ A(Ye.p, { id: i.descriptionId, ...r, ref: t });
  }
);
rJ.displayName = m8;
var g8 = "DialogClose", v8 = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Zr(g8, n);
    return /* @__PURE__ */ A(
      Ye.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: ze(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
v8.displayName = g8;
function Ly(e) {
  return e ? "open" : "closed";
}
var y8 = "DialogTitleWarning", [Ume, x8] = oH(y8, {
  contentName: Ho,
  titleName: Iy,
  docsSlug: "dialog"
}), iJ = ({ titleId: e }) => {
  const t = x8(y8), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return w.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, sJ = "DialogDescriptionWarning", oJ = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${x8(sJ).contentName}}.`;
  return w.useEffect(() => {
    var s;
    const i = (s = e.current) == null ? void 0 : s.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, w8 = a8, _8 = u8, b8 = f8, C8 = d8, E8 = p8, S8 = v8, _u = (e) => e.type === "checkbox", wo = (e) => e instanceof Date, Cn = (e) => e == null;
const k8 = (e) => typeof e == "object";
var Rt = (e) => !Cn(e) && !Array.isArray(e) && k8(e) && !wo(e), T8 = (e) => Rt(e) && e.target ? _u(e.target) ? e.target.checked : e.target.value : e, aJ = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, A8 = (e, t) => e.has(aJ(t)), lJ = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return Rt(t) && t.hasOwnProperty("isPrototypeOf");
}, My = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function Ct(e) {
  let t;
  const n = Array.isArray(e), r = typeof FileList < "u" ? e instanceof FileList : !1;
  if (e instanceof Date)
    t = new Date(e);
  else if (!(My && (e instanceof Blob || r)) && (n || Rt(e)))
    if (t = n ? [] : Object.create(Object.getPrototypeOf(e)), !n && !lJ(e))
      t = e;
    else
      for (const i in e)
        e.hasOwnProperty(i) && (t[i] = Ct(e[i]));
  else
    return e;
  return t;
}
var $p = (e) => /^\w*$/.test(e), Et = (e) => e === void 0, Vp = (e) => Array.isArray(e) ? e.filter(Boolean) : [], Oy = (e) => Vp(e.replace(/["|']|\]/g, "").split(/\.|\[/)), _e = (e, t, n) => {
  if (!t || !Rt(e))
    return n;
  const r = ($p(t) ? [t] : Oy(t)).reduce((i, s) => Cn(i) ? i : i[s], e);
  return Et(r) || r === e ? Et(e[t]) ? n : e[t] : r;
}, Yn = (e) => typeof e == "boolean", pt = (e, t, n) => {
  let r = -1;
  const i = $p(t) ? [t] : Oy(t), s = i.length, o = s - 1;
  for (; ++r < s; ) {
    const a = i[r];
    let l = n;
    if (r !== o) {
      const c = e[a];
      l = Rt(c) || Array.isArray(c) ? c : isNaN(+i[r + 1]) ? {} : [];
    }
    if (a === "__proto__" || a === "constructor" || a === "prototype")
      return;
    e[a] = l, e = e[a];
  }
};
const ih = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, gr = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, Ii = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, N8 = T.createContext(null);
N8.displayName = "HookFormContext";
const Bp = () => T.useContext(N8);
var I8 = (e, t, n, r = !0) => {
  const i = {
    defaultValues: t._defaultValues
  };
  for (const s in e)
    Object.defineProperty(i, s, {
      get: () => {
        const o = s;
        return t._proxyFormState[o] !== gr.all && (t._proxyFormState[o] = !r || gr.all), n && (n[o] = !0), e[o];
      }
    });
  return i;
};
const zp = typeof window < "u" ? T.useLayoutEffect : T.useEffect;
function cJ(e) {
  const t = Bp(), { control: n = t.control, disabled: r, name: i, exact: s } = e || {}, [o, a] = T.useState(n._formState), l = T.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  });
  return zp(() => n._subscribe({
    name: i,
    formState: l.current,
    exact: s,
    callback: (c) => {
      !r && a({
        ...n._formState,
        ...c
      });
    }
  }), [i, r, s]), T.useEffect(() => {
    l.current.isValid && n._setValid(!0);
  }, [n]), T.useMemo(() => I8(o, n, l.current, !1), [o, n]);
}
var ui = (e) => typeof e == "string", L8 = (e, t, n, r, i) => ui(e) ? (r && t.watch.add(e), _e(n, e, i)) : Array.isArray(e) ? e.map((s) => (r && t.watch.add(s), _e(n, s))) : (r && (t.watchAll = !0), n), E0 = (e) => Cn(e) || !k8(e);
function Hi(e, t, n = /* @__PURE__ */ new WeakSet()) {
  if (E0(e) || E0(t))
    return e === t;
  if (wo(e) && wo(t))
    return e.getTime() === t.getTime();
  const r = Object.keys(e), i = Object.keys(t);
  if (r.length !== i.length)
    return !1;
  if (n.has(e) || n.has(t))
    return !0;
  n.add(e), n.add(t);
  for (const s of r) {
    const o = e[s];
    if (!i.includes(s))
      return !1;
    if (s !== "ref") {
      const a = t[s];
      if (wo(o) && wo(a) || Rt(o) && Rt(a) || Array.isArray(o) && Array.isArray(a) ? !Hi(o, a, n) : o !== a)
        return !1;
    }
  }
  return !0;
}
function uJ(e) {
  const t = Bp(), { control: n = t.control, name: r, defaultValue: i, disabled: s, exact: o, compute: a } = e || {}, l = T.useRef(i), c = T.useRef(a), u = T.useRef(void 0);
  c.current = a;
  const f = T.useMemo(() => n._getWatch(r, l.current), [n, r]), [d, h] = T.useState(c.current ? c.current(f) : f);
  return zp(() => n._subscribe({
    name: r,
    formState: {
      values: !0
    },
    exact: o,
    callback: (m) => {
      if (!s) {
        const p = L8(r, n._names, m.values || n._formValues, !1, l.current);
        if (c.current) {
          const y = c.current(p);
          Hi(y, u.current) || (h(y), u.current = y);
        } else
          h(p);
      }
    }
  }), [n, s, r, o]), T.useEffect(() => n._removeUnmounted()), d;
}
function fJ(e) {
  const t = Bp(), { name: n, disabled: r, control: i = t.control, shouldUnregister: s, defaultValue: o } = e, a = A8(i._names.array, n), l = T.useMemo(() => _e(i._formValues, n, _e(i._defaultValues, n, o)), [i, n, o]), c = uJ({
    control: i,
    name: n,
    defaultValue: l,
    exact: !0
  }), u = cJ({
    control: i,
    name: n,
    exact: !0
  }), f = T.useRef(e), d = T.useRef(i.register(n, {
    ...e.rules,
    value: c,
    ...Yn(e.disabled) ? { disabled: e.disabled } : {}
  }));
  f.current = e;
  const h = T.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: !0,
      get: () => !!_e(u.errors, n)
    },
    isDirty: {
      enumerable: !0,
      get: () => !!_e(u.dirtyFields, n)
    },
    isTouched: {
      enumerable: !0,
      get: () => !!_e(u.touchedFields, n)
    },
    isValidating: {
      enumerable: !0,
      get: () => !!_e(u.validatingFields, n)
    },
    error: {
      enumerable: !0,
      get: () => _e(u.errors, n)
    }
  }), [u, n]), m = T.useCallback((g) => d.current.onChange({
    target: {
      value: T8(g),
      name: n
    },
    type: ih.CHANGE
  }), [n]), p = T.useCallback(() => d.current.onBlur({
    target: {
      value: _e(i._formValues, n),
      name: n
    },
    type: ih.BLUR
  }), [n, i._formValues]), y = T.useCallback((g) => {
    const x = _e(i._fields, n);
    x && g && (x._f.ref = {
      focus: () => g.focus && g.focus(),
      select: () => g.select && g.select(),
      setCustomValidity: (_) => g.setCustomValidity(_),
      reportValidity: () => g.reportValidity()
    });
  }, [i._fields, n]), v = T.useMemo(() => ({
    name: n,
    value: c,
    ...Yn(r) || u.disabled ? { disabled: u.disabled || r } : {},
    onChange: m,
    onBlur: p,
    ref: y
  }), [n, r, u.disabled, m, p, y, c]);
  return T.useEffect(() => {
    const g = i._options.shouldUnregister || s;
    i.register(n, {
      ...f.current.rules,
      ...Yn(f.current.disabled) ? { disabled: f.current.disabled } : {}
    });
    const x = (_, b) => {
      const C = _e(i._fields, _);
      C && C._f && (C._f.mount = b);
    };
    if (x(n, !0), g) {
      const _ = Ct(_e(i._options.defaultValues, n));
      pt(i._defaultValues, n, _), Et(_e(i._formValues, n)) && pt(i._formValues, n, _);
    }
    return !a && i.register(n), () => {
      (a ? g && !i._state.action : g) ? i.unregister(n) : x(n, !1);
    };
  }, [n, i, a, s]), T.useEffect(() => {
    i._setDisabledField({
      disabled: r,
      name: n
    });
  }, [r, n, i]), T.useMemo(() => ({
    field: v,
    formState: u,
    fieldState: h
  }), [v, u, h]);
}
const dJ = (e) => e.render(fJ(e));
var hJ = (e, t, n, r, i) => t ? {
  ...n[e],
  types: {
    ...n[e] && n[e].types ? n[e].types : {},
    [r]: i || !0
  }
} : {}, zn = (e) => Array.isArray(e) ? e : [e], Rb = () => {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (i) => {
      for (const s of e)
        s.next && s.next(i);
    },
    subscribe: (i) => (e.push(i), {
      unsubscribe: () => {
        e = e.filter((s) => s !== i);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}, bn = (e) => Rt(e) && !Object.keys(e).length, Py = (e) => e.type === "file", Pr = (e) => typeof e == "function", sh = (e) => {
  if (!My)
    return !1;
  const t = e ? e.ownerDocument : 0;
  return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement);
}, M8 = (e) => e.type === "select-multiple", Dy = (e) => e.type === "radio", pJ = (e) => Dy(e) || _u(e), Z1 = (e) => sh(e) && e.isConnected;
function mJ(e, t) {
  const n = t.slice(0, -1).length;
  let r = 0;
  for (; r < n; )
    e = Et(e) ? r++ : e[t[r++]];
  return e;
}
function gJ(e) {
  for (const t in e)
    if (e.hasOwnProperty(t) && !Et(e[t]))
      return !1;
  return !0;
}
function Pt(e, t) {
  const n = Array.isArray(t) ? t : $p(t) ? [t] : Oy(t), r = n.length === 1 ? e : mJ(e, n), i = n.length - 1, s = n[i];
  return r && delete r[s], i !== 0 && (Rt(r) && bn(r) || Array.isArray(r) && gJ(r)) && Pt(e, n.slice(0, -1)), e;
}
var O8 = (e) => {
  for (const t in e)
    if (Pr(e[t]))
      return !0;
  return !1;
};
function oh(e, t = {}) {
  const n = Array.isArray(e);
  if (Rt(e) || n)
    for (const r in e)
      Array.isArray(e[r]) || Rt(e[r]) && !O8(e[r]) ? (t[r] = Array.isArray(e[r]) ? [] : {}, oh(e[r], t[r])) : Cn(e[r]) || (t[r] = !0);
  return t;
}
function P8(e, t, n) {
  const r = Array.isArray(e);
  if (Rt(e) || r)
    for (const i in e)
      Array.isArray(e[i]) || Rt(e[i]) && !O8(e[i]) ? Et(t) || E0(n[i]) ? n[i] = Array.isArray(e[i]) ? oh(e[i], []) : { ...oh(e[i]) } : P8(e[i], Cn(t) ? {} : t[i], n[i]) : n[i] = !Hi(e[i], t[i]);
  return n;
}
var Bl = (e, t) => P8(e, t, oh(t));
const $b = {
  value: !1,
  isValid: !1
}, Vb = { value: !0, isValid: !0 };
var D8 = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter((n) => n && n.checked && !n.disabled).map((n) => n.value);
      return { value: t, isValid: !!t.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !Et(e[0].attributes.value) ? Et(e[0].value) || e[0].value === "" ? Vb : { value: e[0].value, isValid: !0 } : Vb
    ) : $b;
  }
  return $b;
}, F8 = (e, { valueAsNumber: t, valueAsDate: n, setValueAs: r }) => Et(e) ? e : t ? e === "" ? NaN : e && +e : n && ui(e) ? new Date(e) : r ? r(e) : e;
const Bb = {
  isValid: !1,
  value: null
};
var R8 = (e) => Array.isArray(e) ? e.reduce((t, n) => n && n.checked && !n.disabled ? {
  isValid: !0,
  value: n.value
} : t, Bb) : Bb;
function zb(e) {
  const t = e.ref;
  return Py(t) ? t.files : Dy(t) ? R8(e.refs).value : M8(t) ? [...t.selectedOptions].map(({ value: n }) => n) : _u(t) ? D8(e.refs).value : F8(Et(t.value) ? e.ref.value : t.value, e);
}
var vJ = (e, t, n, r) => {
  const i = {};
  for (const s of e) {
    const o = _e(t, s);
    o && pt(i, s, o._f);
  }
  return {
    criteriaMode: n,
    names: [...e],
    fields: i,
    shouldUseNativeValidation: r
  };
}, ah = (e) => e instanceof RegExp, zl = (e) => Et(e) ? e : ah(e) ? e.source : Rt(e) ? ah(e.value) ? e.value.source : e.value : e, _a = (e) => ({
  isOnSubmit: !e || e === gr.onSubmit,
  isOnBlur: e === gr.onBlur,
  isOnChange: e === gr.onChange,
  isOnAll: e === gr.all,
  isOnTouch: e === gr.onTouched
});
const Hb = "AsyncFunction";
var yJ = (e) => !!e && !!e.validate && !!(Pr(e.validate) && e.validate.constructor.name === Hb || Rt(e.validate) && Object.values(e.validate).find((t) => t.constructor.name === Hb)), xJ = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate), S0 = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some((r) => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length))));
const Da = (e, t, n, r) => {
  for (const i of n || Object.keys(e)) {
    const s = _e(e, i);
    if (s) {
      const { _f: o, ...a } = s;
      if (o) {
        if (o.refs && o.refs[0] && t(o.refs[0], i) && !r)
          return !0;
        if (o.ref && t(o.ref, o.name) && !r)
          return !0;
        if (Da(a, t))
          break;
      } else if (Rt(a) && Da(a, t))
        break;
    }
  }
};
function Ub(e, t, n) {
  const r = _e(e, n);
  if (r || $p(n))
    return {
      error: r,
      name: n
    };
  const i = n.split(".");
  for (; i.length; ) {
    const s = i.join("."), o = _e(t, s), a = _e(e, s);
    if (o && !Array.isArray(o) && n !== s)
      return { name: n };
    if (a && a.type)
      return {
        name: s,
        error: a
      };
    if (a && a.root && a.root.type)
      return {
        name: `${s}.root`,
        error: a.root
      };
    i.pop();
  }
  return {
    name: n
  };
}
var wJ = (e, t, n, r) => {
  n(e);
  const { name: i, ...s } = e;
  return bn(s) || Object.keys(s).length >= Object.keys(t).length || Object.keys(s).find((o) => t[o] === (!r || gr.all));
}, _J = (e, t, n) => !e || !t || e === t || zn(e).some((r) => r && (n ? r === t : r.startsWith(t) || t.startsWith(r))), bJ = (e, t, n, r, i) => i.isOnAll ? !1 : !n && i.isOnTouch ? !(t || e) : (n ? r.isOnBlur : i.isOnBlur) ? !e : (n ? r.isOnChange : i.isOnChange) ? e : !0, CJ = (e, t) => !Vp(_e(e, t)).length && Pt(e, t), $8 = (e, t, n) => {
  const r = zn(_e(e, n));
  return pt(r, "root", t[n]), pt(e, n, r), e;
}, Wf = (e) => ui(e);
function jb(e, t, n = "validate") {
  if (Wf(e) || Array.isArray(e) && e.every(Wf) || Yn(e) && !e)
    return {
      type: n,
      message: Wf(e) ? e : "",
      ref: t
    };
}
var la = (e) => Rt(e) && !ah(e) ? e : {
  value: e,
  message: ""
}, k0 = async (e, t, n, r, i, s) => {
  const { ref: o, refs: a, required: l, maxLength: c, minLength: u, min: f, max: d, pattern: h, validate: m, name: p, valueAsNumber: y, mount: v } = e._f, g = _e(n, p);
  if (!v || t.has(p))
    return {};
  const x = a ? a[0] : o, _ = (R) => {
    i && x.reportValidity && (x.setCustomValidity(Yn(R) ? "" : R || ""), x.reportValidity());
  }, b = {}, C = Dy(o), E = _u(o), S = C || E, k = (y || Py(o)) && Et(o.value) && Et(g) || sh(o) && o.value === "" || g === "" || Array.isArray(g) && !g.length, M = hJ.bind(null, p, r, b), O = (R, I, H, P = Ii.maxLength, W = Ii.minLength) => {
    const G = R ? I : H;
    b[p] = {
      type: R ? P : W,
      message: G,
      ref: o,
      ...M(R ? P : W, G)
    };
  };
  if (s ? !Array.isArray(g) || !g.length : l && (!S && (k || Cn(g)) || Yn(g) && !g || E && !D8(a).isValid || C && !R8(a).isValid)) {
    const { value: R, message: I } = Wf(l) ? { value: !!l, message: l } : la(l);
    if (R && (b[p] = {
      type: Ii.required,
      message: I,
      ref: x,
      ...M(Ii.required, I)
    }, !r))
      return _(I), b;
  }
  if (!k && (!Cn(f) || !Cn(d))) {
    let R, I;
    const H = la(d), P = la(f);
    if (!Cn(g) && !isNaN(g)) {
      const W = o.valueAsNumber || g && +g;
      Cn(H.value) || (R = W > H.value), Cn(P.value) || (I = W < P.value);
    } else {
      const W = o.valueAsDate || new Date(g), G = (N) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + N), J = o.type == "time", X = o.type == "week";
      ui(H.value) && g && (R = J ? G(g) > G(H.value) : X ? g > H.value : W > new Date(H.value)), ui(P.value) && g && (I = J ? G(g) < G(P.value) : X ? g < P.value : W < new Date(P.value));
    }
    if ((R || I) && (O(!!R, H.message, P.message, Ii.max, Ii.min), !r))
      return _(b[p].message), b;
  }
  if ((c || u) && !k && (ui(g) || s && Array.isArray(g))) {
    const R = la(c), I = la(u), H = !Cn(R.value) && g.length > +R.value, P = !Cn(I.value) && g.length < +I.value;
    if ((H || P) && (O(H, R.message, I.message), !r))
      return _(b[p].message), b;
  }
  if (h && !k && ui(g)) {
    const { value: R, message: I } = la(h);
    if (ah(R) && !g.match(R) && (b[p] = {
      type: Ii.pattern,
      message: I,
      ref: o,
      ...M(Ii.pattern, I)
    }, !r))
      return _(I), b;
  }
  if (m) {
    if (Pr(m)) {
      const R = await m(g, n), I = jb(R, x);
      if (I && (b[p] = {
        ...I,
        ...M(Ii.validate, I.message)
      }, !r))
        return _(I.message), b;
    } else if (Rt(m)) {
      let R = {};
      for (const I in m) {
        if (!bn(R) && !r)
          break;
        const H = jb(await m[I](g, n), x, I);
        H && (R = {
          ...H,
          ...M(I, H.message)
        }, _(H.message), r && (b[p] = R));
      }
      if (!bn(R) && (b[p] = {
        ref: x,
        ...R
      }, !r))
        return b;
    }
  }
  return _(!0), b;
};
const EJ = {
  mode: gr.onSubmit,
  reValidateMode: gr.onChange,
  shouldFocusError: !0
};
function SJ(e = {}) {
  let t = {
    ...EJ,
    ...e
  }, n = {
    submitCount: 0,
    isDirty: !1,
    isReady: !1,
    isLoading: Pr(t.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: t.errors || {},
    disabled: t.disabled || !1
  }, r = {}, i = Rt(t.defaultValues) || Rt(t.values) ? Ct(t.defaultValues || t.values) || {} : {}, s = t.shouldUnregister ? {} : Ct(i), o = {
    action: !1,
    mount: !1,
    watch: !1
  }, a = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, l, c = 0;
  const u = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  };
  let f = {
    ...u
  };
  const d = {
    array: Rb(),
    state: Rb()
  }, h = t.criteriaMode === gr.all, m = (z) => (K) => {
    clearTimeout(c), c = setTimeout(z, K);
  }, p = async (z) => {
    if (!t.disabled && (u.isValid || f.isValid || z)) {
      const K = t.resolver ? bn((await E()).errors) : await k(r, !0);
      K !== n.isValid && d.state.next({
        isValid: K
      });
    }
  }, y = (z, K) => {
    !t.disabled && (u.isValidating || u.validatingFields || f.isValidating || f.validatingFields) && ((z || Array.from(a.mount)).forEach((Q) => {
      Q && (K ? pt(n.validatingFields, Q, K) : Pt(n.validatingFields, Q));
    }), d.state.next({
      validatingFields: n.validatingFields,
      isValidating: !bn(n.validatingFields)
    }));
  }, v = (z, K = [], Q, se, ne = !0, he = !0) => {
    if (se && Q && !t.disabled) {
      if (o.action = !0, he && Array.isArray(_e(r, z))) {
        const j = Q(_e(r, z), se.argA, se.argB);
        ne && pt(r, z, j);
      }
      if (he && Array.isArray(_e(n.errors, z))) {
        const j = Q(_e(n.errors, z), se.argA, se.argB);
        ne && pt(n.errors, z, j), CJ(n.errors, z);
      }
      if ((u.touchedFields || f.touchedFields) && he && Array.isArray(_e(n.touchedFields, z))) {
        const j = Q(_e(n.touchedFields, z), se.argA, se.argB);
        ne && pt(n.touchedFields, z, j);
      }
      (u.dirtyFields || f.dirtyFields) && (n.dirtyFields = Bl(i, s)), d.state.next({
        name: z,
        isDirty: O(z, K),
        dirtyFields: n.dirtyFields,
        errors: n.errors,
        isValid: n.isValid
      });
    } else
      pt(s, z, K);
  }, g = (z, K) => {
    pt(n.errors, z, K), d.state.next({
      errors: n.errors
    });
  }, x = (z) => {
    n.errors = z, d.state.next({
      errors: n.errors,
      isValid: !1
    });
  }, _ = (z, K, Q, se) => {
    const ne = _e(r, z);
    if (ne) {
      const he = _e(s, z, Et(Q) ? _e(i, z) : Q);
      Et(he) || se && se.defaultChecked || K ? pt(s, z, K ? he : zb(ne._f)) : H(z, he), o.mount && p();
    }
  }, b = (z, K, Q, se, ne) => {
    let he = !1, j = !1;
    const re = {
      name: z
    };
    if (!t.disabled) {
      if (!Q || se) {
        (u.isDirty || f.isDirty) && (j = n.isDirty, n.isDirty = re.isDirty = O(), he = j !== re.isDirty);
        const D = Hi(_e(i, z), K);
        j = !!_e(n.dirtyFields, z), D ? Pt(n.dirtyFields, z) : pt(n.dirtyFields, z, !0), re.dirtyFields = n.dirtyFields, he = he || (u.dirtyFields || f.dirtyFields) && j !== !D;
      }
      if (Q) {
        const D = _e(n.touchedFields, z);
        D || (pt(n.touchedFields, z, Q), re.touchedFields = n.touchedFields, he = he || (u.touchedFields || f.touchedFields) && D !== Q);
      }
      he && ne && d.state.next(re);
    }
    return he ? re : {};
  }, C = (z, K, Q, se) => {
    const ne = _e(n.errors, z), he = (u.isValid || f.isValid) && Yn(K) && n.isValid !== K;
    if (t.delayError && Q ? (l = m(() => g(z, Q)), l(t.delayError)) : (clearTimeout(c), l = null, Q ? pt(n.errors, z, Q) : Pt(n.errors, z)), (Q ? !Hi(ne, Q) : ne) || !bn(se) || he) {
      const j = {
        ...se,
        ...he && Yn(K) ? { isValid: K } : {},
        errors: n.errors,
        name: z
      };
      n = {
        ...n,
        ...j
      }, d.state.next(j);
    }
  }, E = async (z) => {
    y(z, !0);
    const K = await t.resolver(s, t.context, vJ(z || a.mount, r, t.criteriaMode, t.shouldUseNativeValidation));
    return y(z), K;
  }, S = async (z) => {
    const { errors: K } = await E(z);
    if (z)
      for (const Q of z) {
        const se = _e(K, Q);
        se ? pt(n.errors, Q, se) : Pt(n.errors, Q);
      }
    else
      n.errors = K;
    return K;
  }, k = async (z, K, Q = {
    valid: !0
  }) => {
    for (const se in z) {
      const ne = z[se];
      if (ne) {
        const { _f: he, ...j } = ne;
        if (he) {
          const re = a.array.has(he.name), D = ne._f && yJ(ne._f);
          D && u.validatingFields && y([se], !0);
          const Ie = await k0(ne, a.disabled, s, h, t.shouldUseNativeValidation && !K, re);
          if (D && u.validatingFields && y([se]), Ie[he.name] && (Q.valid = !1, K))
            break;
          !K && (_e(Ie, he.name) ? re ? $8(n.errors, Ie, he.name) : pt(n.errors, he.name, Ie[he.name]) : Pt(n.errors, he.name));
        }
        !bn(j) && await k(j, K, Q);
      }
    }
    return Q.valid;
  }, M = () => {
    for (const z of a.unMount) {
      const K = _e(r, z);
      K && (K._f.refs ? K._f.refs.every((Q) => !Z1(Q)) : !Z1(K._f.ref)) && q(z);
    }
    a.unMount = /* @__PURE__ */ new Set();
  }, O = (z, K) => !t.disabled && (z && K && pt(s, z, K), !Hi(N(), i)), R = (z, K, Q) => L8(z, a, {
    ...o.mount ? s : Et(K) ? i : ui(z) ? { [z]: K } : K
  }, Q, K), I = (z) => Vp(_e(o.mount ? s : i, z, t.shouldUnregister ? _e(i, z, []) : [])), H = (z, K, Q = {}) => {
    const se = _e(r, z);
    let ne = K;
    if (se) {
      const he = se._f;
      he && (!he.disabled && pt(s, z, F8(K, he)), ne = sh(he.ref) && Cn(K) ? "" : K, M8(he.ref) ? [...he.ref.options].forEach((j) => j.selected = ne.includes(j.value)) : he.refs ? _u(he.ref) ? he.refs.forEach((j) => {
        (!j.defaultChecked || !j.disabled) && (Array.isArray(ne) ? j.checked = !!ne.find((re) => re === j.value) : j.checked = ne === j.value || !!ne);
      }) : he.refs.forEach((j) => j.checked = j.value === ne) : Py(he.ref) ? he.ref.value = "" : (he.ref.value = ne, he.ref.type || d.state.next({
        name: z,
        values: Ct(s)
      })));
    }
    (Q.shouldDirty || Q.shouldTouch) && b(z, ne, Q.shouldTouch, Q.shouldDirty, !0), Q.shouldValidate && X(z);
  }, P = (z, K, Q) => {
    for (const se in K) {
      if (!K.hasOwnProperty(se))
        return;
      const ne = K[se], he = z + "." + se, j = _e(r, he);
      (a.array.has(z) || Rt(ne) || j && !j._f) && !wo(ne) ? P(he, ne, Q) : H(he, ne, Q);
    }
  }, W = (z, K, Q = {}) => {
    const se = _e(r, z), ne = a.array.has(z), he = Ct(K);
    pt(s, z, he), ne ? (d.array.next({
      name: z,
      values: Ct(s)
    }), (u.isDirty || u.dirtyFields || f.isDirty || f.dirtyFields) && Q.shouldDirty && d.state.next({
      name: z,
      dirtyFields: Bl(i, s),
      isDirty: O(z, he)
    })) : se && !se._f && !Cn(he) ? P(z, he, Q) : H(z, he, Q), S0(z, a) && d.state.next({ ...n, name: z }), d.state.next({
      name: o.mount ? z : void 0,
      values: Ct(s)
    });
  }, G = async (z) => {
    o.mount = !0;
    const K = z.target;
    let Q = K.name, se = !0;
    const ne = _e(r, Q), he = (D) => {
      se = Number.isNaN(D) || wo(D) && isNaN(D.getTime()) || Hi(D, _e(s, Q, D));
    }, j = _a(t.mode), re = _a(t.reValidateMode);
    if (ne) {
      let D, Ie;
      const Ue = K.type ? zb(ne._f) : T8(z), et = z.type === ih.BLUR || z.type === ih.FOCUS_OUT, Qt = !xJ(ne._f) && !t.resolver && !_e(n.errors, Q) && !ne._f.deps || bJ(et, _e(n.touchedFields, Q), n.isSubmitted, re, j), qt = S0(Q, a, et);
      pt(s, Q, Ue), et ? (!K || !K.readOnly) && (ne._f.onBlur && ne._f.onBlur(z), l && l(0)) : ne._f.onChange && ne._f.onChange(z);
      const ki = b(Q, Ue, et), so = !bn(ki) || qt;
      if (!et && d.state.next({
        name: Q,
        type: z.type,
        values: Ct(s)
      }), Qt)
        return (u.isValid || f.isValid) && (t.mode === "onBlur" ? et && p() : et || p()), so && d.state.next({ name: Q, ...qt ? {} : ki });
      if (!et && qt && d.state.next({ ...n }), t.resolver) {
        const { errors: dn } = await E([Q]);
        if (he(Ue), se) {
          const hs = Ub(n.errors, r, Q), sr = Ub(dn, r, hs.name || Q);
          D = sr.error, Q = sr.name, Ie = bn(dn);
        }
      } else
        y([Q], !0), D = (await k0(ne, a.disabled, s, h, t.shouldUseNativeValidation))[Q], y([Q]), he(Ue), se && (D ? Ie = !1 : (u.isValid || f.isValid) && (Ie = await k(r, !0)));
      se && (ne._f.deps && X(ne._f.deps), C(Q, Ie, D, ki));
    }
  }, J = (z, K) => {
    if (_e(n.errors, K) && z.focus)
      return z.focus(), 1;
  }, X = async (z, K = {}) => {
    let Q, se;
    const ne = zn(z);
    if (t.resolver) {
      const he = await S(Et(z) ? z : ne);
      Q = bn(he), se = z ? !ne.some((j) => _e(he, j)) : Q;
    } else z ? (se = (await Promise.all(ne.map(async (he) => {
      const j = _e(r, he);
      return await k(j && j._f ? { [he]: j } : j);
    }))).every(Boolean), !(!se && !n.isValid) && p()) : se = Q = await k(r);
    return d.state.next({
      ...!ui(z) || (u.isValid || f.isValid) && Q !== n.isValid ? {} : { name: z },
      ...t.resolver || !z ? { isValid: Q } : {},
      errors: n.errors
    }), K.shouldFocus && !se && Da(r, J, z ? ne : a.mount), se;
  }, N = (z) => {
    const K = {
      ...o.mount ? s : i
    };
    return Et(z) ? K : ui(z) ? _e(K, z) : z.map((Q) => _e(K, Q));
  }, U = (z, K) => ({
    invalid: !!_e((K || n).errors, z),
    isDirty: !!_e((K || n).dirtyFields, z),
    error: _e((K || n).errors, z),
    isValidating: !!_e(n.validatingFields, z),
    isTouched: !!_e((K || n).touchedFields, z)
  }), ee = (z) => {
    z && zn(z).forEach((K) => Pt(n.errors, K)), d.state.next({
      errors: z ? n.errors : {}
    });
  }, F = (z, K, Q) => {
    const se = (_e(r, z, { _f: {} })._f || {}).ref, ne = _e(n.errors, z) || {}, { ref: he, message: j, type: re, ...D } = ne;
    pt(n.errors, z, {
      ...D,
      ...K,
      ref: se
    }), d.state.next({
      name: z,
      errors: n.errors,
      isValid: !1
    }), Q && Q.shouldFocus && se && se.focus && se.focus();
  }, ue = (z, K) => Pr(z) ? d.state.subscribe({
    next: (Q) => "values" in Q && z(R(void 0, K), Q)
  }) : R(z, K, !0), pe = (z) => d.state.subscribe({
    next: (K) => {
      _J(z.name, K.name, z.exact) && wJ(K, z.formState || u, mt, z.reRenderRoot) && z.callback({
        values: { ...s },
        ...n,
        ...K,
        defaultValues: i
      });
    }
  }).unsubscribe, ce = (z) => (o.mount = !0, f = {
    ...f,
    ...z.formState
  }, pe({
    ...z,
    formState: f
  })), q = (z, K = {}) => {
    for (const Q of z ? zn(z) : a.mount)
      a.mount.delete(Q), a.array.delete(Q), K.keepValue || (Pt(r, Q), Pt(s, Q)), !K.keepError && Pt(n.errors, Q), !K.keepDirty && Pt(n.dirtyFields, Q), !K.keepTouched && Pt(n.touchedFields, Q), !K.keepIsValidating && Pt(n.validatingFields, Q), !t.shouldUnregister && !K.keepDefaultValue && Pt(i, Q);
    d.state.next({
      values: Ct(s)
    }), d.state.next({
      ...n,
      ...K.keepDirty ? { isDirty: O() } : {}
    }), !K.keepIsValid && p();
  }, Z = ({ disabled: z, name: K }) => {
    (Yn(z) && o.mount || z || a.disabled.has(K)) && (z ? a.disabled.add(K) : a.disabled.delete(K));
  }, oe = (z, K = {}) => {
    let Q = _e(r, z);
    const se = Yn(K.disabled) || Yn(t.disabled);
    return pt(r, z, {
      ...Q || {},
      _f: {
        ...Q && Q._f ? Q._f : { ref: { name: z } },
        name: z,
        mount: !0,
        ...K
      }
    }), a.mount.add(z), Q ? Z({
      disabled: Yn(K.disabled) ? K.disabled : t.disabled,
      name: z
    }) : _(z, !0, K.value), {
      ...se ? { disabled: K.disabled || t.disabled } : {},
      ...t.progressive ? {
        required: !!K.required,
        min: zl(K.min),
        max: zl(K.max),
        minLength: zl(K.minLength),
        maxLength: zl(K.maxLength),
        pattern: zl(K.pattern)
      } : {},
      name: z,
      onChange: G,
      onBlur: G,
      ref: (ne) => {
        if (ne) {
          oe(z, K), Q = _e(r, z);
          const he = Et(ne.value) && ne.querySelectorAll && ne.querySelectorAll("input,select,textarea")[0] || ne, j = pJ(he), re = Q._f.refs || [];
          if (j ? re.find((D) => D === he) : he === Q._f.ref)
            return;
          pt(r, z, {
            _f: {
              ...Q._f,
              ...j ? {
                refs: [
                  ...re.filter(Z1),
                  he,
                  ...Array.isArray(_e(i, z)) ? [{}] : []
                ],
                ref: { type: he.type, name: z }
              } : { ref: he }
            }
          }), _(z, !1, void 0, he);
        } else
          Q = _e(r, z, {}), Q._f && (Q._f.mount = !1), (t.shouldUnregister || K.shouldUnregister) && !(A8(a.array, z) && o.action) && a.unMount.add(z);
      }
    };
  }, le = () => t.shouldFocusError && Da(r, J, a.mount), ie = (z) => {
    Yn(z) && (d.state.next({ disabled: z }), Da(r, (K, Q) => {
      const se = _e(r, Q);
      se && (K.disabled = se._f.disabled || z, Array.isArray(se._f.refs) && se._f.refs.forEach((ne) => {
        ne.disabled = se._f.disabled || z;
      }));
    }, 0, !1));
  }, Y = (z, K) => async (Q) => {
    let se;
    Q && (Q.preventDefault && Q.preventDefault(), Q.persist && Q.persist());
    let ne = Ct(s);
    if (d.state.next({
      isSubmitting: !0
    }), t.resolver) {
      const { errors: he, values: j } = await E();
      n.errors = he, ne = Ct(j);
    } else
      await k(r);
    if (a.disabled.size)
      for (const he of a.disabled)
        Pt(ne, he);
    if (Pt(n.errors, "root"), bn(n.errors)) {
      d.state.next({
        errors: {}
      });
      try {
        await z(ne, Q);
      } catch (he) {
        se = he;
      }
    } else
      K && await K({ ...n.errors }, Q), le(), setTimeout(le);
    if (d.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: bn(n.errors) && !se,
      submitCount: n.submitCount + 1,
      errors: n.errors
    }), se)
      throw se;
  }, Ce = (z, K = {}) => {
    _e(r, z) && (Et(K.defaultValue) ? W(z, Ct(_e(i, z))) : (W(z, K.defaultValue), pt(i, z, Ct(K.defaultValue))), K.keepTouched || Pt(n.touchedFields, z), K.keepDirty || (Pt(n.dirtyFields, z), n.isDirty = K.defaultValue ? O(z, Ct(_e(i, z))) : O()), K.keepError || (Pt(n.errors, z), u.isValid && p()), d.state.next({ ...n }));
  }, Fe = (z, K = {}) => {
    const Q = z ? Ct(z) : i, se = Ct(Q), ne = bn(z), he = ne ? i : se;
    if (K.keepDefaultValues || (i = Q), !K.keepValues) {
      if (K.keepDirtyValues) {
        const j = /* @__PURE__ */ new Set([
          ...a.mount,
          ...Object.keys(Bl(i, s))
        ]);
        for (const re of Array.from(j))
          _e(n.dirtyFields, re) ? pt(he, re, _e(s, re)) : W(re, _e(he, re));
      } else {
        if (My && Et(z))
          for (const j of a.mount) {
            const re = _e(r, j);
            if (re && re._f) {
              const D = Array.isArray(re._f.refs) ? re._f.refs[0] : re._f.ref;
              if (sh(D)) {
                const Ie = D.closest("form");
                if (Ie) {
                  Ie.reset();
                  break;
                }
              }
            }
          }
        if (K.keepFieldsRef)
          for (const j of a.mount)
            W(j, _e(he, j));
        else
          r = {};
      }
      s = t.shouldUnregister ? K.keepDefaultValues ? Ct(i) : {} : Ct(he), d.array.next({
        values: { ...he }
      }), d.state.next({
        values: { ...he }
      });
    }
    a = {
      mount: K.keepDirtyValues ? a.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, o.mount = !u.isValid || !!K.keepIsValid || !!K.keepDirtyValues, o.watch = !!t.shouldUnregister, d.state.next({
      submitCount: K.keepSubmitCount ? n.submitCount : 0,
      isDirty: ne ? !1 : K.keepDirty ? n.isDirty : !!(K.keepDefaultValues && !Hi(z, i)),
      isSubmitted: K.keepIsSubmitted ? n.isSubmitted : !1,
      dirtyFields: ne ? {} : K.keepDirtyValues ? K.keepDefaultValues && s ? Bl(i, s) : n.dirtyFields : K.keepDefaultValues && z ? Bl(i, z) : K.keepDirty ? n.dirtyFields : {},
      touchedFields: K.keepTouched ? n.touchedFields : {},
      errors: K.keepErrors ? n.errors : {},
      isSubmitSuccessful: K.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1,
      isSubmitting: !1,
      defaultValues: i
    });
  }, je = (z, K) => Fe(Pr(z) ? z(s) : z, K), Ze = (z, K = {}) => {
    const Q = _e(r, z), se = Q && Q._f;
    if (se) {
      const ne = se.refs ? se.refs[0] : se.ref;
      ne.focus && (ne.focus(), K.shouldSelect && Pr(ne.select) && ne.select());
    }
  }, mt = (z) => {
    n = {
      ...n,
      ...z
    };
  }, bt = {
    control: {
      register: oe,
      unregister: q,
      getFieldState: U,
      handleSubmit: Y,
      setError: F,
      _subscribe: pe,
      _runSchema: E,
      _focusError: le,
      _getWatch: R,
      _getDirty: O,
      _setValid: p,
      _setFieldArray: v,
      _setDisabledField: Z,
      _setErrors: x,
      _getFieldArray: I,
      _reset: Fe,
      _resetDefaultValues: () => Pr(t.defaultValues) && t.defaultValues().then((z) => {
        je(z, t.resetOptions), d.state.next({
          isLoading: !1
        });
      }),
      _removeUnmounted: M,
      _disableForm: ie,
      _subjects: d,
      _proxyFormState: u,
      get _fields() {
        return r;
      },
      get _formValues() {
        return s;
      },
      get _state() {
        return o;
      },
      set _state(z) {
        o = z;
      },
      get _defaultValues() {
        return i;
      },
      get _names() {
        return a;
      },
      set _names(z) {
        a = z;
      },
      get _formState() {
        return n;
      },
      get _options() {
        return t;
      },
      set _options(z) {
        t = {
          ...t,
          ...z
        };
      }
    },
    subscribe: ce,
    trigger: X,
    register: oe,
    handleSubmit: Y,
    watch: ue,
    setValue: W,
    getValues: N,
    reset: je,
    resetField: Ce,
    clearErrors: ee,
    unregister: q,
    setError: F,
    setFocus: Ze,
    getFieldState: U
  };
  return {
    ...bt,
    formControl: bt
  };
}
var gs = () => {
  if (typeof crypto < "u" && crypto.randomUUID)
    return crypto.randomUUID();
  const e = typeof performance > "u" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
    const n = (Math.random() * 16 + e) % 16 | 0;
    return (t == "x" ? n : n & 3 | 8).toString(16);
  });
}, Q1 = (e, t, n = {}) => n.shouldFocus || Et(n.shouldFocus) ? n.focusName || `${e}.${Et(n.focusIndex) ? t : n.focusIndex}.` : "", em = (e, t) => [
  ...e,
  ...zn(t)
], tm = (e) => Array.isArray(e) ? e.map(() => {
}) : void 0;
function nm(e, t, n) {
  return [
    ...e.slice(0, t),
    ...zn(n),
    ...e.slice(t)
  ];
}
var rm = (e, t, n) => Array.isArray(e) ? (Et(e[n]) && (e[n] = void 0), e.splice(n, 0, e.splice(t, 1)[0]), e) : [], im = (e, t) => [
  ...zn(t),
  ...zn(e)
];
function kJ(e, t) {
  let n = 0;
  const r = [...e];
  for (const i of t)
    r.splice(i - n, 1), n++;
  return Vp(r).length ? r : [];
}
var sm = (e, t) => Et(t) ? [] : kJ(e, zn(t).sort((n, r) => n - r)), om = (e, t, n) => {
  [e[t], e[n]] = [e[n], e[t]];
}, Wb = (e, t, n) => (e[t] = n, e);
function TJ(e) {
  const t = Bp(), { control: n = t.control, name: r, keyName: i = "id", shouldUnregister: s, rules: o } = e, [a, l] = T.useState(n._getFieldArray(r)), c = T.useRef(n._getFieldArray(r).map(gs)), u = T.useRef(a), f = T.useRef(!1);
  u.current = a, n._names.array.add(r), T.useMemo(() => o && n.register(r, o), [n, o, r]), zp(() => n._subjects.array.subscribe({
    next: ({ values: b, name: C }) => {
      if (C === r || !C) {
        const E = _e(b, r);
        Array.isArray(E) && (l(E), c.current = E.map(gs));
      }
    }
  }).unsubscribe, [n, r]);
  const d = T.useCallback((b) => {
    f.current = !0, n._setFieldArray(r, b);
  }, [n, r]), h = (b, C) => {
    const E = zn(Ct(b)), S = em(n._getFieldArray(r), E);
    n._names.focus = Q1(r, S.length - 1, C), c.current = em(c.current, E.map(gs)), d(S), l(S), n._setFieldArray(r, S, em, {
      argA: tm(b)
    });
  }, m = (b, C) => {
    const E = zn(Ct(b)), S = im(n._getFieldArray(r), E);
    n._names.focus = Q1(r, 0, C), c.current = im(c.current, E.map(gs)), d(S), l(S), n._setFieldArray(r, S, im, {
      argA: tm(b)
    });
  }, p = (b) => {
    const C = sm(n._getFieldArray(r), b);
    c.current = sm(c.current, b), d(C), l(C), !Array.isArray(_e(n._fields, r)) && pt(n._fields, r, void 0), n._setFieldArray(r, C, sm, {
      argA: b
    });
  }, y = (b, C, E) => {
    const S = zn(Ct(C)), k = nm(n._getFieldArray(r), b, S);
    n._names.focus = Q1(r, b, E), c.current = nm(c.current, b, S.map(gs)), d(k), l(k), n._setFieldArray(r, k, nm, {
      argA: b,
      argB: tm(C)
    });
  }, v = (b, C) => {
    const E = n._getFieldArray(r);
    om(E, b, C), om(c.current, b, C), d(E), l(E), n._setFieldArray(r, E, om, {
      argA: b,
      argB: C
    }, !1);
  }, g = (b, C) => {
    const E = n._getFieldArray(r);
    rm(E, b, C), rm(c.current, b, C), d(E), l(E), n._setFieldArray(r, E, rm, {
      argA: b,
      argB: C
    }, !1);
  }, x = (b, C) => {
    const E = Ct(C), S = Wb(n._getFieldArray(r), b, E);
    c.current = [...S].map((k, M) => !k || M === b ? gs() : c.current[M]), d(S), l([...S]), n._setFieldArray(r, S, Wb, {
      argA: b,
      argB: E
    }, !0, !1);
  }, _ = (b) => {
    const C = zn(Ct(b));
    c.current = C.map(gs), d([...C]), l([...C]), n._setFieldArray(r, [...C], (E) => E, {}, !0, !1);
  };
  return T.useEffect(() => {
    if (n._state.action = !1, S0(r, n._names) && n._subjects.state.next({
      ...n._formState
    }), f.current && (!_a(n._options.mode).isOnSubmit || n._formState.isSubmitted) && !_a(n._options.reValidateMode).isOnSubmit)
      if (n._options.resolver)
        n._runSchema([r]).then((b) => {
          const C = _e(b.errors, r), E = _e(n._formState.errors, r);
          (E ? !C && E.type || C && (E.type !== C.type || E.message !== C.message) : C && C.type) && (C ? pt(n._formState.errors, r, C) : Pt(n._formState.errors, r), n._subjects.state.next({
            errors: n._formState.errors
          }));
        });
      else {
        const b = _e(n._fields, r);
        b && b._f && !(_a(n._options.reValidateMode).isOnSubmit && _a(n._options.mode).isOnSubmit) && k0(b, n._names.disabled, n._formValues, n._options.criteriaMode === gr.all, n._options.shouldUseNativeValidation, !0).then((C) => !bn(C) && n._subjects.state.next({
          errors: $8(n._formState.errors, C, r)
        }));
      }
    n._subjects.state.next({
      name: r,
      values: Ct(n._formValues)
    }), n._names.focus && Da(n._fields, (b, C) => {
      if (n._names.focus && C.startsWith(n._names.focus) && b.focus)
        return b.focus(), 1;
    }), n._names.focus = "", n._setValid(), f.current = !1;
  }, [a, r, n]), T.useEffect(() => (!_e(n._formValues, r) && n._setFieldArray(r), () => {
    const b = (C, E) => {
      const S = _e(n._fields, C);
      S && S._f && (S._f.mount = E);
    };
    n._options.shouldUnregister || s ? n.unregister(r) : b(r, !1);
  }), [r, n, i, s]), {
    swap: T.useCallback(v, [d, r, n]),
    move: T.useCallback(g, [d, r, n]),
    prepend: T.useCallback(m, [d, r, n]),
    append: T.useCallback(h, [d, r, n]),
    remove: T.useCallback(p, [d, r, n]),
    insert: T.useCallback(y, [d, r, n]),
    update: T.useCallback(x, [d, r, n]),
    replace: T.useCallback(_, [d, r, n]),
    fields: T.useMemo(() => a.map((b, C) => ({
      ...b,
      [i]: c.current[C] || gs()
    })), [a, i])
  };
}
function Hp(e = {}) {
  const t = T.useRef(void 0), n = T.useRef(void 0), [r, i] = T.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: Pr(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: e.errors || {},
    disabled: e.disabled || !1,
    isReady: !1,
    defaultValues: Pr(e.defaultValues) ? void 0 : e.defaultValues
  });
  if (!t.current)
    if (e.formControl)
      t.current = {
        ...e.formControl,
        formState: r
      }, e.defaultValues && !Pr(e.defaultValues) && e.formControl.reset(e.defaultValues, e.resetOptions);
    else {
      const { formControl: o, ...a } = SJ(e);
      t.current = {
        ...a,
        formState: r
      };
    }
  const s = t.current.control;
  return s._options = e, zp(() => {
    const o = s._subscribe({
      formState: s._proxyFormState,
      callback: () => i({ ...s._formState }),
      reRenderRoot: !0
    });
    return i((a) => ({
      ...a,
      isReady: !0
    })), s._formState.isReady = !0, o;
  }, [s]), T.useEffect(() => s._disableForm(e.disabled), [s, e.disabled]), T.useEffect(() => {
    e.mode && (s._options.mode = e.mode), e.reValidateMode && (s._options.reValidateMode = e.reValidateMode);
  }, [s, e.mode, e.reValidateMode]), T.useEffect(() => {
    e.errors && (s._setErrors(e.errors), s._focusError());
  }, [s, e.errors]), T.useEffect(() => {
    e.shouldUnregister && s._subjects.state.next({
      values: s._getWatch()
    });
  }, [s, e.shouldUnregister]), T.useEffect(() => {
    if (s._proxyFormState.isDirty) {
      const o = s._getDirty();
      o !== r.isDirty && s._subjects.state.next({
        isDirty: o
      });
    }
  }, [s, r.isDirty]), T.useEffect(() => {
    e.values && !Hi(e.values, n.current) ? (s._reset(e.values, {
      keepFieldsRef: !0,
      ...s._options.resetOptions
    }), n.current = e.values, i((o) => ({ ...o }))) : s._resetDefaultValues();
  }, [s, e.values]), T.useEffect(() => {
    s._state.mount || (s._setValid(), s._state.mount = !0), s._state.watch && (s._state.watch = !1, s._subjects.state.next({ ...s._formState })), s._removeUnmounted();
  }), t.current.formState = I8(r, s), t.current;
}
function ai(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Ke() {
  return Ke = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ke.apply(null, arguments);
}
function Jb(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function T0(e, t) {
  return T0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, T0(e, t);
}
function AJ(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, T0(e, t);
}
var A0 = { exports: {} }, of = { exports: {} }, at = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kb;
function NJ() {
  if (Kb) return at;
  Kb = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, p = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, g = e ? Symbol.for("react.scope") : 60119;
  function x(b) {
    if (typeof b == "object" && b !== null) {
      var C = b.$$typeof;
      switch (C) {
        case t:
          switch (b = b.type, b) {
            case l:
            case c:
            case r:
            case s:
            case i:
            case f:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case u:
                case m:
                case h:
                case o:
                  return b;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function _(b) {
    return x(b) === c;
  }
  return at.AsyncMode = l, at.ConcurrentMode = c, at.ContextConsumer = a, at.ContextProvider = o, at.Element = t, at.ForwardRef = u, at.Fragment = r, at.Lazy = m, at.Memo = h, at.Portal = n, at.Profiler = s, at.StrictMode = i, at.Suspense = f, at.isAsyncMode = function(b) {
    return _(b) || x(b) === l;
  }, at.isConcurrentMode = _, at.isContextConsumer = function(b) {
    return x(b) === a;
  }, at.isContextProvider = function(b) {
    return x(b) === o;
  }, at.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, at.isForwardRef = function(b) {
    return x(b) === u;
  }, at.isFragment = function(b) {
    return x(b) === r;
  }, at.isLazy = function(b) {
    return x(b) === m;
  }, at.isMemo = function(b) {
    return x(b) === h;
  }, at.isPortal = function(b) {
    return x(b) === n;
  }, at.isProfiler = function(b) {
    return x(b) === s;
  }, at.isStrictMode = function(b) {
    return x(b) === i;
  }, at.isSuspense = function(b) {
    return x(b) === f;
  }, at.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === c || b === s || b === i || b === f || b === d || typeof b == "object" && b !== null && (b.$$typeof === m || b.$$typeof === h || b.$$typeof === o || b.$$typeof === a || b.$$typeof === u || b.$$typeof === y || b.$$typeof === v || b.$$typeof === g || b.$$typeof === p);
  }, at.typeOf = x, at;
}
var lt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qb;
function IJ() {
  return qb || (qb = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, p = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, g = e ? Symbol.for("react.scope") : 60119;
    function x(Y) {
      return typeof Y == "string" || typeof Y == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Y === r || Y === c || Y === s || Y === i || Y === f || Y === d || typeof Y == "object" && Y !== null && (Y.$$typeof === m || Y.$$typeof === h || Y.$$typeof === o || Y.$$typeof === a || Y.$$typeof === u || Y.$$typeof === y || Y.$$typeof === v || Y.$$typeof === g || Y.$$typeof === p);
    }
    function _(Y) {
      if (typeof Y == "object" && Y !== null) {
        var Ce = Y.$$typeof;
        switch (Ce) {
          case t:
            var Fe = Y.type;
            switch (Fe) {
              case l:
              case c:
              case r:
              case s:
              case i:
              case f:
                return Fe;
              default:
                var je = Fe && Fe.$$typeof;
                switch (je) {
                  case a:
                  case u:
                  case m:
                  case h:
                  case o:
                    return je;
                  default:
                    return Ce;
                }
            }
          case n:
            return Ce;
        }
      }
    }
    var b = l, C = c, E = a, S = o, k = t, M = u, O = r, R = m, I = h, H = n, P = s, W = i, G = f, J = !1;
    function X(Y) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), N(Y) || _(Y) === l;
    }
    function N(Y) {
      return _(Y) === c;
    }
    function U(Y) {
      return _(Y) === a;
    }
    function ee(Y) {
      return _(Y) === o;
    }
    function F(Y) {
      return typeof Y == "object" && Y !== null && Y.$$typeof === t;
    }
    function ue(Y) {
      return _(Y) === u;
    }
    function pe(Y) {
      return _(Y) === r;
    }
    function ce(Y) {
      return _(Y) === m;
    }
    function q(Y) {
      return _(Y) === h;
    }
    function Z(Y) {
      return _(Y) === n;
    }
    function oe(Y) {
      return _(Y) === s;
    }
    function le(Y) {
      return _(Y) === i;
    }
    function ie(Y) {
      return _(Y) === f;
    }
    lt.AsyncMode = b, lt.ConcurrentMode = C, lt.ContextConsumer = E, lt.ContextProvider = S, lt.Element = k, lt.ForwardRef = M, lt.Fragment = O, lt.Lazy = R, lt.Memo = I, lt.Portal = H, lt.Profiler = P, lt.StrictMode = W, lt.Suspense = G, lt.isAsyncMode = X, lt.isConcurrentMode = N, lt.isContextConsumer = U, lt.isContextProvider = ee, lt.isElement = F, lt.isForwardRef = ue, lt.isFragment = pe, lt.isLazy = ce, lt.isMemo = q, lt.isPortal = Z, lt.isProfiler = oe, lt.isStrictMode = le, lt.isSuspense = ie, lt.isValidElementType = x, lt.typeOf = _;
  }()), lt;
}
var Gb;
function V8() {
  return Gb || (Gb = 1, process.env.NODE_ENV === "production" ? of.exports = NJ() : of.exports = IJ()), of.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var am, Yb;
function LJ() {
  if (Yb) return am;
  Yb = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(o).map(function(u) {
        return o[u];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        c[u] = u;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return am = i() ? Object.assign : function(s, o) {
    for (var a, l = r(s), c, u = 1; u < arguments.length; u++) {
      a = Object(arguments[u]);
      for (var f in a)
        t.call(a, f) && (l[f] = a[f]);
      if (e) {
        c = e(a);
        for (var d = 0; d < c.length; d++)
          n.call(a, c[d]) && (l[c[d]] = a[c[d]]);
      }
    }
    return l;
  }, am;
}
var lm, Xb;
function Fy() {
  if (Xb) return lm;
  Xb = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return lm = e, lm;
}
var cm, Zb;
function B8() {
  return Zb || (Zb = 1, cm = Function.call.bind(Object.prototype.hasOwnProperty)), cm;
}
var um, Qb;
function MJ() {
  if (Qb) return um;
  Qb = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Fy(), n = {}, r = B8();
    e = function(s) {
      var o = "Warning: " + s;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(s, o, a, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in s)
        if (r(s, u)) {
          var f;
          try {
            if (typeof s[u] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            f = s[u](o, u, l, a, null, t);
          } catch (m) {
            f = m;
          }
          if (f && !(f instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var h = c ? c() : "";
            e(
              "Failed " + a + " type: " + f.message + (h ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, um = i, um;
}
var fm, e4;
function OJ() {
  if (e4) return fm;
  e4 = 1;
  var e = V8(), t = LJ(), n = Fy(), r = B8(), i = MJ(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return fm = function(a, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function f(N) {
      var U = N && (c && N[c] || N[u]);
      if (typeof U == "function")
        return U;
    }
    var d = "<<anonymous>>", h = {
      array: v("array"),
      bigint: v("bigint"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: g(),
      arrayOf: x,
      element: _(),
      elementType: b(),
      instanceOf: C,
      node: M(),
      objectOf: S,
      oneOf: E,
      oneOfType: k,
      shape: R,
      exact: I
    };
    function m(N, U) {
      return N === U ? N !== 0 || 1 / N === 1 / U : N !== N && U !== U;
    }
    function p(N, U) {
      this.message = N, this.data = U && typeof U == "object" ? U : {}, this.stack = "";
    }
    p.prototype = Error.prototype;
    function y(N) {
      if (process.env.NODE_ENV !== "production")
        var U = {}, ee = 0;
      function F(pe, ce, q, Z, oe, le, ie) {
        if (Z = Z || d, le = le || q, ie !== n) {
          if (l) {
            var Y = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Y.name = "Invariant Violation", Y;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Ce = Z + ":" + q;
            !U[Ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            ee < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + le + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), U[Ce] = !0, ee++);
          }
        }
        return ce[q] == null ? pe ? ce[q] === null ? new p("The " + oe + " `" + le + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new p("The " + oe + " `" + le + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : N(ce, q, Z, oe, le);
      }
      var ue = F.bind(null, !1);
      return ue.isRequired = F.bind(null, !0), ue;
    }
    function v(N) {
      function U(ee, F, ue, pe, ce, q) {
        var Z = ee[F], oe = W(Z);
        if (oe !== N) {
          var le = G(Z);
          return new p(
            "Invalid " + pe + " `" + ce + "` of type " + ("`" + le + "` supplied to `" + ue + "`, expected ") + ("`" + N + "`."),
            { expectedType: N }
          );
        }
        return null;
      }
      return y(U);
    }
    function g() {
      return y(o);
    }
    function x(N) {
      function U(ee, F, ue, pe, ce) {
        if (typeof N != "function")
          return new p("Property `" + ce + "` of component `" + ue + "` has invalid PropType notation inside arrayOf.");
        var q = ee[F];
        if (!Array.isArray(q)) {
          var Z = W(q);
          return new p("Invalid " + pe + " `" + ce + "` of type " + ("`" + Z + "` supplied to `" + ue + "`, expected an array."));
        }
        for (var oe = 0; oe < q.length; oe++) {
          var le = N(q, oe, ue, pe, ce + "[" + oe + "]", n);
          if (le instanceof Error)
            return le;
        }
        return null;
      }
      return y(U);
    }
    function _() {
      function N(U, ee, F, ue, pe) {
        var ce = U[ee];
        if (!a(ce)) {
          var q = W(ce);
          return new p("Invalid " + ue + " `" + pe + "` of type " + ("`" + q + "` supplied to `" + F + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(N);
    }
    function b() {
      function N(U, ee, F, ue, pe) {
        var ce = U[ee];
        if (!e.isValidElementType(ce)) {
          var q = W(ce);
          return new p("Invalid " + ue + " `" + pe + "` of type " + ("`" + q + "` supplied to `" + F + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(N);
    }
    function C(N) {
      function U(ee, F, ue, pe, ce) {
        if (!(ee[F] instanceof N)) {
          var q = N.name || d, Z = X(ee[F]);
          return new p("Invalid " + pe + " `" + ce + "` of type " + ("`" + Z + "` supplied to `" + ue + "`, expected ") + ("instance of `" + q + "`."));
        }
        return null;
      }
      return y(U);
    }
    function E(N) {
      if (!Array.isArray(N))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), o;
      function U(ee, F, ue, pe, ce) {
        for (var q = ee[F], Z = 0; Z < N.length; Z++)
          if (m(q, N[Z]))
            return null;
        var oe = JSON.stringify(N, function(ie, Y) {
          var Ce = G(Y);
          return Ce === "symbol" ? String(Y) : Y;
        });
        return new p("Invalid " + pe + " `" + ce + "` of value `" + String(q) + "` " + ("supplied to `" + ue + "`, expected one of " + oe + "."));
      }
      return y(U);
    }
    function S(N) {
      function U(ee, F, ue, pe, ce) {
        if (typeof N != "function")
          return new p("Property `" + ce + "` of component `" + ue + "` has invalid PropType notation inside objectOf.");
        var q = ee[F], Z = W(q);
        if (Z !== "object")
          return new p("Invalid " + pe + " `" + ce + "` of type " + ("`" + Z + "` supplied to `" + ue + "`, expected an object."));
        for (var oe in q)
          if (r(q, oe)) {
            var le = N(q, oe, ue, pe, ce + "." + oe, n);
            if (le instanceof Error)
              return le;
          }
        return null;
      }
      return y(U);
    }
    function k(N) {
      if (!Array.isArray(N))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var U = 0; U < N.length; U++) {
        var ee = N[U];
        if (typeof ee != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + J(ee) + " at index " + U + "."
          ), o;
      }
      function F(ue, pe, ce, q, Z) {
        for (var oe = [], le = 0; le < N.length; le++) {
          var ie = N[le], Y = ie(ue, pe, ce, q, Z, n);
          if (Y == null)
            return null;
          Y.data && r(Y.data, "expectedType") && oe.push(Y.data.expectedType);
        }
        var Ce = oe.length > 0 ? ", expected one of type [" + oe.join(", ") + "]" : "";
        return new p("Invalid " + q + " `" + Z + "` supplied to " + ("`" + ce + "`" + Ce + "."));
      }
      return y(F);
    }
    function M() {
      function N(U, ee, F, ue, pe) {
        return H(U[ee]) ? null : new p("Invalid " + ue + " `" + pe + "` supplied to " + ("`" + F + "`, expected a ReactNode."));
      }
      return y(N);
    }
    function O(N, U, ee, F, ue) {
      return new p(
        (N || "React class") + ": " + U + " type `" + ee + "." + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ue + "`."
      );
    }
    function R(N) {
      function U(ee, F, ue, pe, ce) {
        var q = ee[F], Z = W(q);
        if (Z !== "object")
          return new p("Invalid " + pe + " `" + ce + "` of type `" + Z + "` " + ("supplied to `" + ue + "`, expected `object`."));
        for (var oe in N) {
          var le = N[oe];
          if (typeof le != "function")
            return O(ue, pe, ce, oe, G(le));
          var ie = le(q, oe, ue, pe, ce + "." + oe, n);
          if (ie)
            return ie;
        }
        return null;
      }
      return y(U);
    }
    function I(N) {
      function U(ee, F, ue, pe, ce) {
        var q = ee[F], Z = W(q);
        if (Z !== "object")
          return new p("Invalid " + pe + " `" + ce + "` of type `" + Z + "` " + ("supplied to `" + ue + "`, expected `object`."));
        var oe = t({}, ee[F], N);
        for (var le in oe) {
          var ie = N[le];
          if (r(N, le) && typeof ie != "function")
            return O(ue, pe, ce, le, G(ie));
          if (!ie)
            return new p(
              "Invalid " + pe + " `" + ce + "` key `" + le + "` supplied to `" + ue + "`.\nBad object: " + JSON.stringify(ee[F], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(N), null, "  ")
            );
          var Y = ie(q, le, ue, pe, ce + "." + le, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return y(U);
    }
    function H(N) {
      switch (typeof N) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !N;
        case "object":
          if (Array.isArray(N))
            return N.every(H);
          if (N === null || a(N))
            return !0;
          var U = f(N);
          if (U) {
            var ee = U.call(N), F;
            if (U !== N.entries) {
              for (; !(F = ee.next()).done; )
                if (!H(F.value))
                  return !1;
            } else
              for (; !(F = ee.next()).done; ) {
                var ue = F.value;
                if (ue && !H(ue[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function P(N, U) {
      return N === "symbol" ? !0 : U ? U["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && U instanceof Symbol : !1;
    }
    function W(N) {
      var U = typeof N;
      return Array.isArray(N) ? "array" : N instanceof RegExp ? "object" : P(U, N) ? "symbol" : U;
    }
    function G(N) {
      if (typeof N > "u" || N === null)
        return "" + N;
      var U = W(N);
      if (U === "object") {
        if (N instanceof Date)
          return "date";
        if (N instanceof RegExp)
          return "regexp";
      }
      return U;
    }
    function J(N) {
      var U = G(N);
      switch (U) {
        case "array":
        case "object":
          return "an " + U;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + U;
        default:
          return U;
      }
    }
    function X(N) {
      return !N.constructor || !N.constructor.name ? d : N.constructor.name;
    }
    return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
  }, fm;
}
var dm, t4;
function PJ() {
  if (t4) return dm;
  t4 = 1;
  var e = Fy();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, dm = function() {
    function r(o, a, l, c, u, f) {
      if (f !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, dm;
}
if (process.env.NODE_ENV !== "production") {
  var DJ = V8(), FJ = !0;
  A0.exports = OJ()(DJ.isElement, FJ);
} else
  A0.exports = PJ()();
var RJ = A0.exports;
const ae = /* @__PURE__ */ yl(RJ);
var N0 = { exports: {} }, ft = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var n4;
function $J() {
  if (n4) return ft;
  n4 = 1;
  var e = 60103, t = 60106, n = 60107, r = 60108, i = 60114, s = 60109, o = 60110, a = 60112, l = 60113, c = 60120, u = 60115, f = 60116, d = 60121, h = 60122, m = 60117, p = 60129, y = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var v = Symbol.for;
    e = v("react.element"), t = v("react.portal"), n = v("react.fragment"), r = v("react.strict_mode"), i = v("react.profiler"), s = v("react.provider"), o = v("react.context"), a = v("react.forward_ref"), l = v("react.suspense"), c = v("react.suspense_list"), u = v("react.memo"), f = v("react.lazy"), d = v("react.block"), h = v("react.server.block"), m = v("react.fundamental"), p = v("react.debug_trace_mode"), y = v("react.legacy_hidden");
  }
  function g(I) {
    if (typeof I == "object" && I !== null) {
      var H = I.$$typeof;
      switch (H) {
        case e:
          switch (I = I.type, I) {
            case n:
            case i:
            case r:
            case l:
            case c:
              return I;
            default:
              switch (I = I && I.$$typeof, I) {
                case o:
                case a:
                case f:
                case u:
                case s:
                  return I;
                default:
                  return H;
              }
          }
        case t:
          return H;
      }
    }
  }
  var x = s, _ = e, b = a, C = n, E = f, S = u, k = t, M = i, O = r, R = l;
  return ft.ContextConsumer = o, ft.ContextProvider = x, ft.Element = _, ft.ForwardRef = b, ft.Fragment = C, ft.Lazy = E, ft.Memo = S, ft.Portal = k, ft.Profiler = M, ft.StrictMode = O, ft.Suspense = R, ft.isAsyncMode = function() {
    return !1;
  }, ft.isConcurrentMode = function() {
    return !1;
  }, ft.isContextConsumer = function(I) {
    return g(I) === o;
  }, ft.isContextProvider = function(I) {
    return g(I) === s;
  }, ft.isElement = function(I) {
    return typeof I == "object" && I !== null && I.$$typeof === e;
  }, ft.isForwardRef = function(I) {
    return g(I) === a;
  }, ft.isFragment = function(I) {
    return g(I) === n;
  }, ft.isLazy = function(I) {
    return g(I) === f;
  }, ft.isMemo = function(I) {
    return g(I) === u;
  }, ft.isPortal = function(I) {
    return g(I) === t;
  }, ft.isProfiler = function(I) {
    return g(I) === i;
  }, ft.isStrictMode = function(I) {
    return g(I) === r;
  }, ft.isSuspense = function(I) {
    return g(I) === l;
  }, ft.isValidElementType = function(I) {
    return typeof I == "string" || typeof I == "function" || I === n || I === i || I === p || I === r || I === l || I === c || I === y || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === u || I.$$typeof === s || I.$$typeof === o || I.$$typeof === a || I.$$typeof === m || I.$$typeof === d || I[0] === h);
  }, ft.typeOf = g, ft;
}
var dt = {};
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var r4;
function VJ() {
  return r4 || (r4 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = 60103, t = 60106, n = 60107, r = 60108, i = 60114, s = 60109, o = 60110, a = 60112, l = 60113, c = 60120, u = 60115, f = 60116, d = 60121, h = 60122, m = 60117, p = 60129, y = 60131;
    if (typeof Symbol == "function" && Symbol.for) {
      var v = Symbol.for;
      e = v("react.element"), t = v("react.portal"), n = v("react.fragment"), r = v("react.strict_mode"), i = v("react.profiler"), s = v("react.provider"), o = v("react.context"), a = v("react.forward_ref"), l = v("react.suspense"), c = v("react.suspense_list"), u = v("react.memo"), f = v("react.lazy"), d = v("react.block"), h = v("react.server.block"), m = v("react.fundamental"), v("react.scope"), v("react.opaque.id"), p = v("react.debug_trace_mode"), v("react.offscreen"), y = v("react.legacy_hidden");
    }
    var g = !1;
    function x(ie) {
      return !!(typeof ie == "string" || typeof ie == "function" || ie === n || ie === i || ie === p || ie === r || ie === l || ie === c || ie === y || g || typeof ie == "object" && ie !== null && (ie.$$typeof === f || ie.$$typeof === u || ie.$$typeof === s || ie.$$typeof === o || ie.$$typeof === a || ie.$$typeof === m || ie.$$typeof === d || ie[0] === h));
    }
    function _(ie) {
      if (typeof ie == "object" && ie !== null) {
        var Y = ie.$$typeof;
        switch (Y) {
          case e:
            var Ce = ie.type;
            switch (Ce) {
              case n:
              case i:
              case r:
              case l:
              case c:
                return Ce;
              default:
                var Fe = Ce && Ce.$$typeof;
                switch (Fe) {
                  case o:
                  case a:
                  case f:
                  case u:
                  case s:
                    return Fe;
                  default:
                    return Y;
                }
            }
          case t:
            return Y;
        }
      }
    }
    var b = o, C = s, E = e, S = a, k = n, M = f, O = u, R = t, I = i, H = r, P = l, W = !1, G = !1;
    function J(ie) {
      return W || (W = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function X(ie) {
      return G || (G = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function N(ie) {
      return _(ie) === o;
    }
    function U(ie) {
      return _(ie) === s;
    }
    function ee(ie) {
      return typeof ie == "object" && ie !== null && ie.$$typeof === e;
    }
    function F(ie) {
      return _(ie) === a;
    }
    function ue(ie) {
      return _(ie) === n;
    }
    function pe(ie) {
      return _(ie) === f;
    }
    function ce(ie) {
      return _(ie) === u;
    }
    function q(ie) {
      return _(ie) === t;
    }
    function Z(ie) {
      return _(ie) === i;
    }
    function oe(ie) {
      return _(ie) === r;
    }
    function le(ie) {
      return _(ie) === l;
    }
    dt.ContextConsumer = b, dt.ContextProvider = C, dt.Element = E, dt.ForwardRef = S, dt.Fragment = k, dt.Lazy = M, dt.Memo = O, dt.Portal = R, dt.Profiler = I, dt.StrictMode = H, dt.Suspense = P, dt.isAsyncMode = J, dt.isConcurrentMode = X, dt.isContextConsumer = N, dt.isContextProvider = U, dt.isElement = ee, dt.isForwardRef = F, dt.isFragment = ue, dt.isLazy = pe, dt.isMemo = ce, dt.isPortal = q, dt.isProfiler = Z, dt.isStrictMode = oe, dt.isSuspense = le, dt.isValidElementType = x, dt.typeOf = _;
  }()), dt;
}
process.env.NODE_ENV === "production" ? N0.exports = $J() : N0.exports = VJ();
var i4 = N0.exports;
let s4 = (e) => typeof e == "object" && e != null && e.nodeType === 1, o4 = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", hm = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    let n = getComputedStyle(e, null);
    return o4(n.overflowY, t) || o4(n.overflowX, t) || ((r) => {
      let i = ((s) => {
        if (!s.ownerDocument || !s.ownerDocument.defaultView) return null;
        try {
          return s.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, af = (e, t, n, r, i, s, o, a) => s < e && o > t || s > e && o < t ? 0 : s <= e && a <= n || o >= t && a >= n ? s - e - r : o > t && a < n || s < e && a > n ? o - t + i : 0, BJ = (e) => {
  let t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
};
var zJ = (e, t) => {
  var n, r, i, s, o, a;
  if (typeof document > "u") return [];
  let { inline: l, boundary: c, skipOverflowHiddenElements: u } = t, f = typeof c == "function" ? c : (R) => R !== c;
  if (!s4(e)) throw new TypeError("Invalid target");
  let d = document.scrollingElement || document.documentElement, h = [], m = e;
  for (; s4(m) && f(m); ) {
    if (m = BJ(m), m === d) {
      h.push(m);
      break;
    }
    m != null && m === document.body && hm(m) && !hm(document.documentElement) || m != null && hm(m, u) && h.push(m);
  }
  let p = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, y = (s = (i = window.visualViewport) == null ? void 0 : i.height) != null ? s : innerHeight, v = (o = window.scrollX) != null ? o : pageXOffset, g = (a = window.scrollY) != null ? a : pageYOffset, { height: x, width: _, top: b, right: C, bottom: E, left: S } = e.getBoundingClientRect(), k = b, M = l === "center" ? S + _ / 2 : l === "end" ? C : S, O = [];
  for (let R = 0; R < h.length; R++) {
    let I = h[R], { height: H, width: P, top: W, right: G, bottom: J, left: X } = I.getBoundingClientRect();
    if (b >= 0 && S >= 0 && E <= y && C <= p && b >= W && E <= J && S >= X && C <= G) return O;
    let N = getComputedStyle(I), U = parseInt(N.borderLeftWidth, 10), ee = parseInt(N.borderTopWidth, 10), F = parseInt(N.borderRightWidth, 10), ue = parseInt(N.borderBottomWidth, 10), pe = 0, ce = 0, q = "offsetWidth" in I ? I.offsetWidth - I.clientWidth - U - F : 0, Z = "offsetHeight" in I ? I.offsetHeight - I.clientHeight - ee - ue : 0, oe = "offsetWidth" in I ? I.offsetWidth === 0 ? 0 : P / I.offsetWidth : 0, le = "offsetHeight" in I ? I.offsetHeight === 0 ? 0 : H / I.offsetHeight : 0;
    if (d === I) pe = af(g, g + y, y, ee, ue, g + k, g + k + x, x), ce = l === "start" ? M : l === "center" ? M - p / 2 : l === "end" ? M - p : af(v, v + p, p, U, F, v + M, v + M + _, _), pe = Math.max(0, pe + g), ce = Math.max(0, ce + v);
    else {
      pe = af(W, J, H, ee, ue + Z, k, k + x, x), ce = l === "start" ? M - X - U : l === "center" ? M - (X + P / 2) + q / 2 : l === "end" ? M - G + F + q : af(X, G, P, U, F + q, M, M + _, _);
      let { scrollLeft: ie, scrollTop: Y } = I;
      pe = Math.max(0, Math.min(Y + pe / le, I.scrollHeight - H / le + Z)), ce = Math.max(0, Math.min(ie + ce / oe, I.scrollWidth - P / oe + q)), k += Y - pe, M += ie - ce;
    }
    O.push({ el: I, top: pe, left: ce });
  }
  return O;
}, HJ = 0;
function a4(e) {
  return typeof e == "function" ? e : fr;
}
function fr() {
}
function z8(e, t) {
  if (e) {
    var n = zJ(e, {
      boundary: t
    });
    n.forEach(function(r) {
      var i = r.el, s = r.top, o = r.left;
      i.scrollTop = s, i.scrollLeft = o;
    });
  }
}
function l4(e, t, n) {
  var r = e === t || t instanceof n.Node && e.contains && e.contains(t);
  return r;
}
function Ry(e, t) {
  var n;
  function r() {
    n && clearTimeout(n);
  }
  function i() {
    for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
      o[a] = arguments[a];
    r(), n = setTimeout(function() {
      n = null, e.apply(void 0, o);
    }, t);
  }
  return i.cancel = r, i;
}
function Gt() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)
      s[o - 1] = arguments[o];
    return t.some(function(a) {
      return a && a.apply(void 0, [r].concat(s)), r.preventDownshiftDefault || r.hasOwnProperty("nativeEvent") && r.nativeEvent.preventDownshiftDefault;
    });
  };
}
function ba() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    t.forEach(function(i) {
      typeof i == "function" ? i(r) : i && (i.current = r);
    });
  };
}
function H8() {
  return String(HJ++);
}
function U8(e) {
  var t = e.isOpen, n = e.resultCount, r = e.previousResultCount;
  return t ? n ? n !== r ? n + " result" + (n === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select." : "" : "No results are available." : "";
}
function c4(e, t) {
  return e = Array.isArray(e) ? (
    /* istanbul ignore next (preact) */
    e[0]
  ) : e, !e && t ? t : e;
}
function j8(e) {
  return typeof e.type == "string";
}
function W8(e) {
  return e.props;
}
function UJ(e, t) {
  console.error('The property "' + t + '" is required in "' + e + '"');
}
var jJ = ["highlightedIndex", "inputValue", "isOpen", "selectedItem", "type"];
function lf(e) {
  e === void 0 && (e = {});
  var t = {};
  return jJ.forEach(function(n) {
    e.hasOwnProperty(n) && (t[n] = e[n]);
  }), t;
}
function lh(e, t) {
  return Object.keys(e).reduce(function(n, r) {
    return n[r] = ch(t, r) ? t[r] : e[r], n;
  }, {});
}
function ch(e, t) {
  return e[t] !== void 0;
}
function I0(e) {
  var t = e.key, n = e.keyCode;
  return n >= 37 && n <= 40 && t.indexOf("Arrow") !== 0 ? "Arrow" + t : t;
}
function WJ(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function _o(e, t, n, r, i) {
  if (i === void 0 && (i = !0), n === 0)
    return -1;
  var s = n - 1;
  (typeof t != "number" || t < 0 || t >= n) && (t = e > 0 ? -1 : s + 1);
  var o = t + e;
  o < 0 ? o = i ? s : 0 : o > s && (o = i ? 0 : s);
  var a = Uo(e, o, n, r, i);
  return a === -1 ? t >= n ? -1 : t : a;
}
function Uo(e, t, n, r, i) {
  var s = r(t);
  if (!s || !s.hasAttribute("disabled"))
    return t;
  if (e > 0) {
    for (var o = t + 1; o < n; o++)
      if (!r(o).hasAttribute("disabled"))
        return o;
  } else
    for (var a = t - 1; a >= 0; a--)
      if (!r(a).hasAttribute("disabled"))
        return a;
  return i ? e > 0 ? Uo(1, 0, n, r, !1) : Uo(-1, n - 1, n, r, !1) : -1;
}
function uh(e, t, n, r) {
  return r === void 0 && (r = !0), t.some(function(i) {
    return i && (l4(i, e, n) || r && l4(i, n.document.activeElement, n));
  });
}
var $y = fr;
process.env.NODE_ENV !== "production" && ($y = function(t, n, r) {
  var i = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
  Object.keys(t).forEach(function(s) {
    n[s] !== void 0 && r[s] === void 0 ? console.error('downshift: A component has changed the controlled prop "' + s + '" to be uncontrolled. ' + i) : n[s] === void 0 && r[s] !== void 0 && console.error('downshift: A component has changed the uncontrolled prop "' + s + '" to be controlled. ' + i);
  });
});
var JJ = Ry(function(e) {
  K8(e).textContent = "";
}, 500);
function J8(e, t) {
  var n = K8(t);
  e && (n.textContent = e, JJ(t));
}
function K8(e) {
  e === void 0 && (e = document);
  var t = e.getElementById("a11y-status-message");
  return t || (t = e.createElement("div"), t.setAttribute("id", "a11y-status-message"), t.setAttribute("role", "status"), t.setAttribute("aria-live", "polite"), t.setAttribute("aria-relevant", "additions text"), Object.assign(t.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  }), e.body.appendChild(t), t);
}
var q8 = process.env.NODE_ENV !== "production" ? "__autocomplete_unknown__" : 0, G8 = process.env.NODE_ENV !== "production" ? "__autocomplete_mouseup__" : 1, Y8 = process.env.NODE_ENV !== "production" ? "__autocomplete_item_mouseenter__" : 2, Jf = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_arrow_up__" : 3, Kf = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_arrow_down__" : 4, X8 = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_escape__" : 5, Z8 = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_enter__" : 6, Q8 = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_home__" : 7, ek = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_end__" : 8, tk = process.env.NODE_ENV !== "production" ? "__autocomplete_click_item__" : 9, nk = process.env.NODE_ENV !== "production" ? "__autocomplete_blur_input__" : 10, rk = process.env.NODE_ENV !== "production" ? "__autocomplete_change_input__" : 11, ik = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_space_button__" : 12, L0 = process.env.NODE_ENV !== "production" ? "__autocomplete_click_button__" : 13, sk = process.env.NODE_ENV !== "production" ? "__autocomplete_blur_button__" : 14, ok = process.env.NODE_ENV !== "production" ? "__autocomplete_controlled_prop_updated_selected_item__" : 15, ak = process.env.NODE_ENV !== "production" ? "__autocomplete_touchend__" : 16, KJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  unknown: q8,
  mouseUp: G8,
  itemMouseEnter: Y8,
  keyDownArrowUp: Jf,
  keyDownArrowDown: Kf,
  keyDownEscape: X8,
  keyDownEnter: Z8,
  keyDownHome: Q8,
  keyDownEnd: ek,
  clickItem: tk,
  blurInput: nk,
  changeInput: rk,
  keyDownSpaceButton: ik,
  clickButton: L0,
  blurButton: sk,
  controlledPropUpdatedSelectedItem: ok,
  touchEnd: ak
}), qJ = ["refKey", "ref"], GJ = ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"], YJ = ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"], XJ = ["refKey", "ref"], ZJ = ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"], QJ = /* @__PURE__ */ function() {
  var e = /* @__PURE__ */ function(t) {
    AJ(n, t);
    function n(i) {
      var s;
      s = t.call(this, i) || this, s.id = s.props.id || "downshift-" + H8(), s.menuId = s.props.menuId || s.id + "-menu", s.labelId = s.props.labelId || s.id + "-label", s.inputId = s.props.inputId || s.id + "-input", s.getItemId = s.props.getItemId || function(g) {
        return s.id + "-item-" + g;
      }, s.input = null, s.items = [], s.itemCount = null, s.previousResultCount = 0, s.timeoutIds = [], s.internalSetTimeout = function(g, x) {
        var _ = setTimeout(function() {
          s.timeoutIds = s.timeoutIds.filter(function(b) {
            return b !== _;
          }), g();
        }, x);
        s.timeoutIds.push(_);
      }, s.setItemCount = function(g) {
        s.itemCount = g;
      }, s.unsetItemCount = function() {
        s.itemCount = null;
      }, s.setHighlightedIndex = function(g, x) {
        g === void 0 && (g = s.props.defaultHighlightedIndex), x === void 0 && (x = {}), x = lf(x), s.internalSetState(Ke({
          highlightedIndex: g
        }, x));
      }, s.clearSelection = function(g) {
        s.internalSetState({
          selectedItem: null,
          inputValue: "",
          highlightedIndex: s.props.defaultHighlightedIndex,
          isOpen: s.props.defaultIsOpen
        }, g);
      }, s.selectItem = function(g, x, _) {
        x = lf(x), s.internalSetState(Ke({
          isOpen: s.props.defaultIsOpen,
          highlightedIndex: s.props.defaultHighlightedIndex,
          selectedItem: g,
          inputValue: s.props.itemToString(g)
        }, x), _);
      }, s.selectItemAtIndex = function(g, x, _) {
        var b = s.items[g];
        b != null && s.selectItem(b, x, _);
      }, s.selectHighlightedItem = function(g, x) {
        return s.selectItemAtIndex(s.getState().highlightedIndex, g, x);
      }, s.internalSetState = function(g, x) {
        var _, b, C = {}, E = typeof g == "function";
        return !E && g.hasOwnProperty("inputValue") && s.props.onInputValueChange(g.inputValue, Ke({}, s.getStateAndHelpers(), g)), s.setState(function(S) {
          S = s.getState(S);
          var k = E ? g(S) : g;
          k = s.props.stateReducer(S, k), _ = k.hasOwnProperty("selectedItem");
          var M = {};
          return _ && k.selectedItem !== S.selectedItem && (b = k.selectedItem), k.type = k.type || q8, Object.keys(k).forEach(function(O) {
            S[O] !== k[O] && (C[O] = k[O]), O !== "type" && (k[O], ch(s.props, O) || (M[O] = k[O]));
          }), E && k.hasOwnProperty("inputValue") && s.props.onInputValueChange(k.inputValue, Ke({}, s.getStateAndHelpers(), k)), M;
        }, function() {
          a4(x)();
          var S = Object.keys(C).length > 1;
          S && s.props.onStateChange(C, s.getStateAndHelpers()), _ && s.props.onSelect(g.selectedItem, s.getStateAndHelpers()), b !== void 0 && s.props.onChange(b, s.getStateAndHelpers()), s.props.onUserAction(C, s.getStateAndHelpers());
        });
      }, s.rootRef = function(g) {
        return s._rootNode = g;
      }, s.getRootProps = function(g, x) {
        var _, b = g === void 0 ? {} : g, C = b.refKey, E = C === void 0 ? "ref" : C, S = b.ref, k = ai(b, qJ), M = x === void 0 ? {} : x, O = M.suppressRefError, R = O === void 0 ? !1 : O;
        s.getRootProps.called = !0, s.getRootProps.refKey = E, s.getRootProps.suppressRefError = R;
        var I = s.getState(), H = I.isOpen;
        return Ke((_ = {}, _[E] = ba(S, s.rootRef), _.role = "combobox", _["aria-expanded"] = H, _["aria-haspopup"] = "listbox", _["aria-owns"] = H ? s.menuId : null, _["aria-labelledby"] = s.labelId, _), k);
      }, s.keyDownHandlers = {
        ArrowDown: function(x) {
          var _ = this;
          if (x.preventDefault(), this.getState().isOpen) {
            var b = x.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(b, {
              type: Kf
            });
          } else
            this.internalSetState({
              isOpen: !0,
              type: Kf
            }, function() {
              var C = _.getItemCount();
              if (C > 0) {
                var E = _.getState(), S = E.highlightedIndex, k = _o(1, S, C, function(M) {
                  return _.getItemNodeFromIndex(M);
                });
                _.setHighlightedIndex(k, {
                  type: Kf
                });
              }
            });
        },
        ArrowUp: function(x) {
          var _ = this;
          if (x.preventDefault(), this.getState().isOpen) {
            var b = x.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(b, {
              type: Jf
            });
          } else
            this.internalSetState({
              isOpen: !0,
              type: Jf
            }, function() {
              var C = _.getItemCount();
              if (C > 0) {
                var E = _.getState(), S = E.highlightedIndex, k = _o(-1, S, C, function(M) {
                  return _.getItemNodeFromIndex(M);
                });
                _.setHighlightedIndex(k, {
                  type: Jf
                });
              }
            });
        },
        Enter: function(x) {
          if (x.which !== 229) {
            var _ = this.getState(), b = _.isOpen, C = _.highlightedIndex;
            if (b && C != null) {
              x.preventDefault();
              var E = this.items[C], S = this.getItemNodeFromIndex(C);
              if (E == null || S && S.hasAttribute("disabled"))
                return;
              this.selectHighlightedItem({
                type: Z8
              });
            }
          }
        },
        Escape: function(x) {
          x.preventDefault(), this.reset(Ke({
            type: X8
          }, !this.state.isOpen && {
            selectedItem: null,
            inputValue: ""
          }));
        }
      }, s.buttonKeyDownHandlers = Ke({}, s.keyDownHandlers, {
        " ": function(x) {
          x.preventDefault(), this.toggleMenu({
            type: ik
          });
        }
      }), s.inputKeyDownHandlers = Ke({}, s.keyDownHandlers, {
        Home: function(x) {
          var _ = this, b = this.getState(), C = b.isOpen;
          if (C) {
            x.preventDefault();
            var E = this.getItemCount();
            if (!(E <= 0 || !C)) {
              var S = Uo(1, 0, E, function(k) {
                return _.getItemNodeFromIndex(k);
              }, !1);
              this.setHighlightedIndex(S, {
                type: Q8
              });
            }
          }
        },
        End: function(x) {
          var _ = this, b = this.getState(), C = b.isOpen;
          if (C) {
            x.preventDefault();
            var E = this.getItemCount();
            if (!(E <= 0 || !C)) {
              var S = Uo(-1, E - 1, E, function(k) {
                return _.getItemNodeFromIndex(k);
              }, !1);
              this.setHighlightedIndex(S, {
                type: ek
              });
            }
          }
        }
      }), s.getToggleButtonProps = function(g) {
        var x = g === void 0 ? {} : g, _ = x.onClick;
        x.onPress;
        var b = x.onKeyDown, C = x.onKeyUp, E = x.onBlur, S = ai(x, GJ), k = s.getState(), M = k.isOpen, O = {
          onClick: Gt(_, s.buttonHandleClick),
          onKeyDown: Gt(b, s.buttonHandleKeyDown),
          onKeyUp: Gt(C, s.buttonHandleKeyUp),
          onBlur: Gt(E, s.buttonHandleBlur)
        }, R = S.disabled ? {} : O;
        return Ke({
          type: "button",
          role: "button",
          "aria-label": M ? "close menu" : "open menu",
          "aria-haspopup": !0,
          "data-toggle": !0
        }, R, S);
      }, s.buttonHandleKeyUp = function(g) {
        g.preventDefault();
      }, s.buttonHandleKeyDown = function(g) {
        var x = I0(g);
        s.buttonKeyDownHandlers[x] && s.buttonKeyDownHandlers[x].call(Jb(s), g);
      }, s.buttonHandleClick = function(g) {
        g.preventDefault(), s.props.environment.document.activeElement === s.props.environment.document.body && g.target.focus(), process.env.NODE_ENV === "test" ? s.toggleMenu({
          type: L0
        }) : s.internalSetTimeout(function() {
          return s.toggleMenu({
            type: L0
          });
        });
      }, s.buttonHandleBlur = function(g) {
        var x = g.target;
        s.internalSetTimeout(function() {
          !s.isMouseDown && (s.props.environment.document.activeElement == null || s.props.environment.document.activeElement.id !== s.inputId) && s.props.environment.document.activeElement !== x && s.reset({
            type: sk
          });
        });
      }, s.getLabelProps = function(g) {
        return Ke({
          htmlFor: s.inputId,
          id: s.labelId
        }, g);
      }, s.getInputProps = function(g) {
        var x = g === void 0 ? {} : g, _ = x.onKeyDown, b = x.onBlur, C = x.onChange, E = x.onInput;
        x.onChangeText;
        var S = ai(x, YJ), k, M = {};
        k = "onChange";
        var O = s.getState(), R = O.inputValue, I = O.isOpen, H = O.highlightedIndex;
        if (!S.disabled) {
          var P;
          M = (P = {}, P[k] = Gt(C, E, s.inputHandleChange), P.onKeyDown = Gt(_, s.inputHandleKeyDown), P.onBlur = Gt(b, s.inputHandleBlur), P);
        }
        return Ke({
          "aria-autocomplete": "list",
          "aria-activedescendant": I && typeof H == "number" && H >= 0 ? s.getItemId(H) : null,
          "aria-controls": I ? s.menuId : null,
          "aria-labelledby": S && S["aria-label"] ? void 0 : s.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: "off",
          value: R,
          id: s.inputId
        }, M, S);
      }, s.inputHandleKeyDown = function(g) {
        var x = I0(g);
        x && s.inputKeyDownHandlers[x] && s.inputKeyDownHandlers[x].call(Jb(s), g);
      }, s.inputHandleChange = function(g) {
        s.internalSetState({
          type: rk,
          isOpen: !0,
          inputValue: g.target.value,
          highlightedIndex: s.props.defaultHighlightedIndex
        });
      }, s.inputHandleBlur = function() {
        s.internalSetTimeout(function() {
          var g = s.props.environment.document && !!s.props.environment.document.activeElement && !!s.props.environment.document.activeElement.dataset && s.props.environment.document.activeElement.dataset.toggle && s._rootNode && s._rootNode.contains(s.props.environment.document.activeElement);
          !s.isMouseDown && !g && s.reset({
            type: nk
          });
        });
      }, s.menuRef = function(g) {
        s._menuNode = g;
      }, s.getMenuProps = function(g, x) {
        var _, b = g === void 0 ? {} : g, C = b.refKey, E = C === void 0 ? "ref" : C, S = b.ref, k = ai(b, XJ), M = x === void 0 ? {} : x, O = M.suppressRefError, R = O === void 0 ? !1 : O;
        return s.getMenuProps.called = !0, s.getMenuProps.refKey = E, s.getMenuProps.suppressRefError = R, Ke((_ = {}, _[E] = ba(S, s.menuRef), _.role = "listbox", _["aria-labelledby"] = k && k["aria-label"] ? null : s.labelId, _.id = s.menuId, _), k);
      }, s.getItemProps = function(g) {
        var x, _ = g === void 0 ? {} : g, b = _.onMouseMove, C = _.onMouseDown, E = _.onClick;
        _.onPress;
        var S = _.index, k = _.item, M = k === void 0 ? process.env.NODE_ENV === "production" ? (
          /* istanbul ignore next */
          void 0
        ) : UJ("getItemProps", "item") : k, O = ai(_, ZJ);
        S === void 0 ? (s.items.push(M), S = s.items.indexOf(M)) : s.items[S] = M;
        var R = "onClick", I = E, H = (x = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: Gt(b, function() {
            S !== s.getState().highlightedIndex && (s.setHighlightedIndex(S, {
              type: Y8
            }), s.avoidScrolling = !0, s.internalSetTimeout(function() {
              return s.avoidScrolling = !1;
            }, 250));
          }),
          onMouseDown: Gt(C, function(W) {
            W.preventDefault();
          })
        }, x[R] = Gt(I, function() {
          s.selectItemAtIndex(S, {
            type: tk
          });
        }), x), P = O.disabled ? {
          onMouseDown: H.onMouseDown
        } : H;
        return Ke({
          id: s.getItemId(S),
          role: "option",
          "aria-selected": s.getState().highlightedIndex === S
        }, P, O);
      }, s.clearItems = function() {
        s.items = [];
      }, s.reset = function(g, x) {
        g === void 0 && (g = {}), g = lf(g), s.internalSetState(function(_) {
          var b = _.selectedItem;
          return Ke({
            isOpen: s.props.defaultIsOpen,
            highlightedIndex: s.props.defaultHighlightedIndex,
            inputValue: s.props.itemToString(b)
          }, g);
        }, x);
      }, s.toggleMenu = function(g, x) {
        g === void 0 && (g = {}), g = lf(g), s.internalSetState(function(_) {
          var b = _.isOpen;
          return Ke({
            isOpen: !b
          }, b && {
            highlightedIndex: s.props.defaultHighlightedIndex
          }, g);
        }, function() {
          var _ = s.getState(), b = _.isOpen, C = _.highlightedIndex;
          b && s.getItemCount() > 0 && typeof C == "number" && s.setHighlightedIndex(C, g), a4(x)();
        });
      }, s.openMenu = function(g) {
        s.internalSetState({
          isOpen: !0
        }, g);
      }, s.closeMenu = function(g) {
        s.internalSetState({
          isOpen: !1
        }, g);
      }, s.updateStatus = Ry(function() {
        var g = s.getState(), x = s.items[g.highlightedIndex], _ = s.getItemCount(), b = s.props.getA11yStatusMessage(Ke({
          itemToString: s.props.itemToString,
          previousResultCount: s.previousResultCount,
          resultCount: _,
          highlightedItem: x
        }, g));
        s.previousResultCount = _, J8(b, s.props.environment.document);
      }, 200);
      var o = s.props, a = o.defaultHighlightedIndex, l = o.initialHighlightedIndex, c = l === void 0 ? a : l, u = o.defaultIsOpen, f = o.initialIsOpen, d = f === void 0 ? u : f, h = o.initialInputValue, m = h === void 0 ? "" : h, p = o.initialSelectedItem, y = p === void 0 ? null : p, v = s.getState({
        highlightedIndex: c,
        isOpen: d,
        inputValue: m,
        selectedItem: y
      });
      return v.selectedItem != null && s.props.initialInputValue === void 0 && (v.inputValue = s.props.itemToString(v.selectedItem)), s.state = v, s;
    }
    var r = n.prototype;
    return r.internalClearTimeouts = function() {
      this.timeoutIds.forEach(function(s) {
        clearTimeout(s);
      }), this.timeoutIds = [];
    }, r.getState = function(s) {
      return s === void 0 && (s = this.state), lh(s, this.props);
    }, r.getItemCount = function() {
      var s = this.items.length;
      return this.itemCount != null ? s = this.itemCount : this.props.itemCount !== void 0 && (s = this.props.itemCount), s;
    }, r.getItemNodeFromIndex = function(s) {
      return this.props.environment.document.getElementById(this.getItemId(s));
    }, r.scrollHighlightedItemIntoView = function() {
      {
        var s = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(s, this._menuNode);
      }
    }, r.moveHighlightedIndex = function(s, o) {
      var a = this, l = this.getItemCount(), c = this.getState(), u = c.highlightedIndex;
      if (l > 0) {
        var f = _o(s, u, l, function(d) {
          return a.getItemNodeFromIndex(d);
        });
        this.setHighlightedIndex(f, o);
      }
    }, r.getStateAndHelpers = function() {
      var s = this.getState(), o = s.highlightedIndex, a = s.inputValue, l = s.selectedItem, c = s.isOpen, u = this.props.itemToString, f = this.id, d = this.getRootProps, h = this.getToggleButtonProps, m = this.getLabelProps, p = this.getMenuProps, y = this.getInputProps, v = this.getItemProps, g = this.openMenu, x = this.closeMenu, _ = this.toggleMenu, b = this.selectItem, C = this.selectItemAtIndex, E = this.selectHighlightedItem, S = this.setHighlightedIndex, k = this.clearSelection, M = this.clearItems, O = this.reset, R = this.setItemCount, I = this.unsetItemCount, H = this.internalSetState;
      return {
        // prop getters
        getRootProps: d,
        getToggleButtonProps: h,
        getLabelProps: m,
        getMenuProps: p,
        getInputProps: y,
        getItemProps: v,
        // actions
        reset: O,
        openMenu: g,
        closeMenu: x,
        toggleMenu: _,
        selectItem: b,
        selectItemAtIndex: C,
        selectHighlightedItem: E,
        setHighlightedIndex: S,
        clearSelection: k,
        clearItems: M,
        setItemCount: R,
        unsetItemCount: I,
        setState: H,
        // props
        itemToString: u,
        // derived
        id: f,
        // state
        highlightedIndex: o,
        inputValue: a,
        isOpen: c,
        selectedItem: l
      };
    }, r.componentDidMount = function() {
      var s = this;
      process.env.NODE_ENV !== "production" && this.getMenuProps.called && !this.getMenuProps.suppressRefError && u4(this._menuNode, this.getMenuProps);
      {
        var o = function() {
          s.isMouseDown = !0;
        }, a = function(h) {
          s.isMouseDown = !1;
          var m = uh(h.target, [s._rootNode, s._menuNode], s.props.environment);
          !m && s.getState().isOpen && s.reset({
            type: G8
          }, function() {
            return s.props.onOuterClick(s.getStateAndHelpers());
          });
        }, l = function() {
          s.isTouchMove = !1;
        }, c = function() {
          s.isTouchMove = !0;
        }, u = function(h) {
          var m = uh(h.target, [s._rootNode, s._menuNode], s.props.environment, !1);
          !s.isTouchMove && !m && s.getState().isOpen && s.reset({
            type: ak
          }, function() {
            return s.props.onOuterClick(s.getStateAndHelpers());
          });
        }, f = this.props.environment;
        f.addEventListener("mousedown", o), f.addEventListener("mouseup", a), f.addEventListener("touchstart", l), f.addEventListener("touchmove", c), f.addEventListener("touchend", u), this.cleanup = function() {
          s.internalClearTimeouts(), s.updateStatus.cancel(), f.removeEventListener("mousedown", o), f.removeEventListener("mouseup", a), f.removeEventListener("touchstart", l), f.removeEventListener("touchmove", c), f.removeEventListener("touchend", u);
        };
      }
    }, r.shouldScroll = function(s, o) {
      var a = this.props.highlightedIndex === void 0 ? this.getState() : this.props, l = a.highlightedIndex, c = o.highlightedIndex === void 0 ? s : o, u = c.highlightedIndex, f = l && this.getState().isOpen && !s.isOpen, d = l !== u;
      return f || d;
    }, r.componentDidUpdate = function(s, o) {
      process.env.NODE_ENV !== "production" && ($y(this.state, s, this.props), this.getMenuProps.called && !this.getMenuProps.suppressRefError && u4(this._menuNode, this.getMenuProps)), ch(this.props, "selectedItem") && this.props.selectedItemChanged(s.selectedItem, this.props.selectedItem) && this.internalSetState({
        type: ok,
        inputValue: this.props.itemToString(this.props.selectedItem)
      }), !this.avoidScrolling && this.shouldScroll(o, s) && this.scrollHighlightedItemIntoView(), this.updateStatus();
    }, r.componentWillUnmount = function() {
      this.cleanup();
    }, r.render = function() {
      var s = c4(this.props.children, fr);
      this.clearItems(), this.getRootProps.called = !1, this.getRootProps.refKey = void 0, this.getRootProps.suppressRefError = void 0, this.getMenuProps.called = !1, this.getMenuProps.refKey = void 0, this.getMenuProps.suppressRefError = void 0, this.getLabelProps.called = !1, this.getInputProps.called = !1;
      var o = c4(s(this.getStateAndHelpers()));
      if (!o)
        return null;
      if (this.getRootProps.called || this.props.suppressRefError)
        return process.env.NODE_ENV !== "production" && !this.getRootProps.suppressRefError && !this.props.suppressRefError && eK(o, this.getRootProps), o;
      if (j8(o))
        return /* @__PURE__ */ OI(o, this.getRootProps(W8(o)));
      if (process.env.NODE_ENV !== "production")
        throw new Error("downshift: If you return a non-DOM element, you must apply the getRootProps function");
    }, n;
  }(PI);
  return e.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: !1,
    getA11yStatusMessage: U8,
    itemToString: function(n) {
      return n == null ? "" : (process.env.NODE_ENV !== "production" && WJ(n) && !n.hasOwnProperty("toString") && console.warn("downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.", "The object that was passed:", n), String(n));
    },
    onStateChange: fr,
    onInputValueChange: fr,
    onUserAction: fr,
    onChange: fr,
    onSelect: fr,
    onOuterClick: fr,
    selectedItemChanged: function(n, r) {
      return n !== r;
    },
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window > "u" ? {} : window
    ),
    stateReducer: function(n, r) {
      return r;
    },
    suppressRefError: !1,
    scrollIntoView: z8
  }, e.stateChangeTypes = KJ, e;
}();
process.env.NODE_ENV !== "production" && (QJ.propTypes = {
  children: ae.func,
  defaultHighlightedIndex: ae.number,
  defaultIsOpen: ae.bool,
  initialHighlightedIndex: ae.number,
  initialSelectedItem: ae.any,
  initialInputValue: ae.string,
  initialIsOpen: ae.bool,
  getA11yStatusMessage: ae.func,
  itemToString: ae.func,
  onChange: ae.func,
  onSelect: ae.func,
  onStateChange: ae.func,
  onInputValueChange: ae.func,
  onUserAction: ae.func,
  onOuterClick: ae.func,
  selectedItemChanged: ae.func,
  stateReducer: ae.func,
  itemCount: ae.number,
  id: ae.string,
  environment: ae.shape({
    addEventListener: ae.func,
    removeEventListener: ae.func,
    document: ae.shape({
      getElementById: ae.func,
      activeElement: ae.any,
      body: ae.any
    })
  }),
  suppressRefError: ae.bool,
  scrollIntoView: ae.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: ae.any,
  isOpen: ae.bool,
  inputValue: ae.string,
  highlightedIndex: ae.number,
  labelId: ae.string,
  inputId: ae.string,
  menuId: ae.string,
  getItemId: ae.func
  /* eslint-enable react/no-unused-prop-types */
});
function u4(e, t) {
  var n = t.refKey;
  e || console.error('downshift: The ref prop "' + n + '" from getMenuProps was not applied correctly on your menu element.');
}
function eK(e, t) {
  var n = t.refKey, r = n !== "ref", i = !j8(e);
  i && !r && !i4.isForwardRef(e) ? console.error("downshift: You returned a non-DOM element. You must specify a refKey in getRootProps") : !i && r && console.error('downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "' + n + '"'), !i4.isForwardRef(e) && !W8(e)[n] && console.error('downshift: You must apply the ref prop "' + n + '" from getRootProps onto your root element.');
}
var tK = ["isInitialMount", "highlightedIndex", "items", "environment"], lk = {
  highlightedIndex: -1,
  isOpen: !1,
  selectedItem: null,
  inputValue: ""
};
function nK(e, t, n) {
  var r = e.props, i = e.type, s = {};
  Object.keys(t).forEach(function(o) {
    rK(o, e, t, n), n[o] !== t[o] && (s[o] = n[o]);
  }), r.onStateChange && Object.keys(s).length && r.onStateChange(Ke({
    type: i
  }, s));
}
function rK(e, t, n, r) {
  var i = t.props, s = t.type, o = "on" + Vy(e) + "Change";
  i[o] && r[e] !== void 0 && r[e] !== n[e] && i[o](Ke({
    type: s
  }, r));
}
function iK(e, t) {
  return t.changes;
}
function sK(e) {
  var t = e.selectedItem, n = e.itemToString;
  return t ? n(t) + " has been selected." : "";
}
var oK = Ry(function(e, t) {
  J8(e(), t);
}, 200), aK = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? Ko : Le;
function lK(e) {
  var t = e.id, n = t === void 0 ? "downshift-" + H8() : t, r = e.labelId, i = e.menuId, s = e.getItemId, o = e.toggleButtonId, a = e.inputId, l = $e({
    labelId: r || n + "-label",
    menuId: i || n + "-menu",
    getItemId: s || function(c) {
      return n + "-item-" + c;
    },
    toggleButtonId: o || n + "-toggle-button",
    inputId: a || n + "-input"
  });
  return l.current;
}
function cK(e, t, n, r) {
  var i, s;
  if (e === void 0) {
    if (t === void 0)
      throw new Error(r);
    i = n[t], s = t;
  } else
    s = t === void 0 ? n.indexOf(e) : t, i = e;
  return [i, s];
}
function uK(e) {
  return e ? String(e) : "";
}
function Vy(e) {
  return "" + e.slice(0, 1).toUpperCase() + e.slice(1);
}
function ck(e) {
  var t = $e(e);
  return t.current = e, t;
}
function fK(e, t, n) {
  var r = $e(), i = $e(), s = Ht(function(d, h) {
    i.current = h, d = lh(d, h.props);
    var m = e(d, h), p = h.props.stateReducer(d, Ke({}, h, {
      changes: m
    }));
    return p;
  }, [e]), o = rC(s, t), a = o[0], l = o[1], c = ck(n), u = Ht(function(d) {
    return l(Ke({
      props: c.current
    }, d));
  }, [c]), f = i.current;
  return Le(function() {
    f && r.current && r.current !== a && nK(f, lh(r.current, f.props), a), r.current = a;
  }, [a, n, f]), [a, u];
}
var fc = {
  itemToString: uK,
  stateReducer: iK,
  getA11ySelectionMessage: sK,
  scrollIntoView: z8,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window > "u" ? {} : window
  )
};
function fi(e, t, n) {
  n === void 0 && (n = lk);
  var r = e["default" + Vy(t)];
  return r !== void 0 ? r : n[t];
}
function cf(e, t, n) {
  n === void 0 && (n = lk);
  var r = e[t];
  if (r !== void 0)
    return r;
  var i = e["initial" + Vy(t)];
  return i !== void 0 ? i : fi(e, t, n);
}
function dK(e) {
  var t = cf(e, "selectedItem"), n = cf(e, "isOpen"), r = cf(e, "highlightedIndex"), i = cf(e, "inputValue");
  return {
    highlightedIndex: r < 0 && t && n ? e.items.indexOf(t) : r,
    isOpen: n,
    selectedItem: t,
    inputValue: i
  };
}
function dc(e, t, n) {
  var r = e.items, i = e.initialHighlightedIndex, s = e.defaultHighlightedIndex, o = t.selectedItem, a = t.highlightedIndex;
  return r.length === 0 ? -1 : i !== void 0 && a === i ? i : s !== void 0 ? s : o ? r.indexOf(o) : n === 0 ? -1 : n < 0 ? r.length - 1 : 0;
}
function hK(e, t, n, r) {
  var i = $e({
    isMouseDown: !1,
    isTouchMove: !1
  });
  return Le(function() {
    if ((n == null ? void 0 : n.addEventListener) != null) {
      var s = function() {
        i.current.isMouseDown = !0;
      }, o = function(f) {
        i.current.isMouseDown = !1, e && !uh(f.target, t.map(function(d) {
          return d.current;
        }), n) && r();
      }, a = function() {
        i.current.isTouchMove = !1;
      }, l = function() {
        i.current.isTouchMove = !0;
      }, c = function(f) {
        e && !i.current.isTouchMove && !uh(f.target, t.map(function(d) {
          return d.current;
        }), n, !1) && r();
      };
      return n.addEventListener("mousedown", s), n.addEventListener("mouseup", o), n.addEventListener("touchstart", a), n.addEventListener("touchmove", l), n.addEventListener("touchend", c), function() {
        n.removeEventListener("mousedown", s), n.removeEventListener("mouseup", o), n.removeEventListener("touchstart", a), n.removeEventListener("touchmove", l), n.removeEventListener("touchend", c);
      };
    }
  }, [e, n]), i;
}
var uk = function() {
  return fr;
};
process.env.NODE_ENV !== "production" && (uk = function() {
  for (var t = $e(!0), n = arguments.length, r = new Array(n), i = 0; i < n; i++)
    r[i] = arguments[i];
  var s = $e(r.reduce(function(a, l) {
    return a[l] = {}, a;
  }, {}));
  Le(function() {
    Object.keys(s.current).forEach(function(a) {
      var l = s.current[a];
      if (t.current && !Object.keys(l).length) {
        console.error("downshift: You forgot to call the " + a + " getter function on your component / element.");
        return;
      }
      var c = l.suppressRefError, u = l.refKey, f = l.elementRef;
      (!f || !f.current) && !c && console.error('downshift: The ref prop "' + u + '" from ' + a + " was not applied correctly on your element.");
    }), t.current = !1;
  });
  var o = Ht(function(a, l, c, u) {
    s.current[a] = {
      suppressRefError: l,
      refKey: c,
      elementRef: u
    };
  }, []);
  return o;
});
function f4(e, t, n) {
  var r = n.isInitialMount, i = n.highlightedIndex, s = n.items, o = n.environment, a = ai(n, tK);
  Le(function() {
    r || oK(function() {
      return e(Ke({
        highlightedIndex: i,
        highlightedItem: s[i],
        resultCount: s.length
      }, a));
    }, o.document);
  }, t);
}
function pK(e) {
  var t = e.highlightedIndex, n = e.isOpen, r = e.itemRefs, i = e.getItemNodeFromIndex, s = e.menuElement, o = e.scrollIntoView, a = $e(!0);
  return aK(function() {
    t < 0 || !n || !Object.keys(r.current).length || (a.current === !1 ? a.current = !0 : o(i(t), s));
  }, [t]), a;
}
var fk = fr;
process.env.NODE_ENV !== "production" && (fk = function(t) {
  var n = t.isInitialMount, r = t.props, i = t.state, s = $e(r);
  Le(function() {
    n || ($y(i, s.current, r), s.current = r);
  }, [i, r, n]);
});
function d4(e, t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = ((r = e.items) == null ? void 0 : r.length) && t >= 0;
  return Ke({
    isOpen: !1,
    highlightedIndex: -1
  }, i && Ke({
    selectedItem: e.items[t],
    isOpen: fi(e, "isOpen"),
    highlightedIndex: fi(e, "highlightedIndex")
  }, n && {
    inputValue: e.itemToString(e.items[t])
  }));
}
function mK(e, t, n) {
  var r = t.type, i = t.props, s;
  switch (r) {
    case n.ItemMouseMove:
      s = {
        highlightedIndex: t.disabled ? -1 : t.index
      };
      break;
    case n.MenuMouseLeave:
      s = {
        highlightedIndex: -1
      };
      break;
    case n.ToggleButtonClick:
    case n.FunctionToggleMenu:
      s = {
        isOpen: !e.isOpen,
        highlightedIndex: e.isOpen ? -1 : dc(i, e, 0)
      };
      break;
    case n.FunctionOpenMenu:
      s = {
        isOpen: !0,
        highlightedIndex: dc(i, e, 0)
      };
      break;
    case n.FunctionCloseMenu:
      s = {
        isOpen: !1
      };
      break;
    case n.FunctionSetHighlightedIndex:
      s = {
        highlightedIndex: t.highlightedIndex
      };
      break;
    case n.FunctionSetInputValue:
      s = {
        inputValue: t.inputValue
      };
      break;
    case n.FunctionReset:
      s = {
        highlightedIndex: fi(i, "highlightedIndex"),
        isOpen: fi(i, "isOpen"),
        selectedItem: fi(i, "selectedItem"),
        inputValue: fi(i, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return Ke({}, e, s);
}
ae.array.isRequired, ae.func, ae.func, ae.func, ae.number, ae.number, ae.number, ae.bool, ae.bool, ae.bool, ae.any, ae.any, ae.any, ae.string, ae.string, ae.string, ae.func, ae.string, ae.func, ae.func, ae.func, ae.func, ae.func, ae.shape({
  addEventListener: ae.func,
  removeEventListener: ae.func,
  document: ae.shape({
    getElementById: ae.func,
    activeElement: ae.any,
    body: ae.any
  })
});
function gK(e) {
  var t = e.isOpen, n = e.resultCount, r = e.previousResultCount;
  return t ? n ? n !== r ? "".concat(n, " result").concat(n === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.") : "" : "No results are available." : "";
}
mr(mr({}, fc), { getA11yStatusMessage: gK });
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
var By = process.env.NODE_ENV !== "production" ? "__input_keydown_arrow_down__" : 0, zy = process.env.NODE_ENV !== "production" ? "__input_keydown_arrow_up__" : 1, Hy = process.env.NODE_ENV !== "production" ? "__input_keydown_escape__" : 2, Uy = process.env.NODE_ENV !== "production" ? "__input_keydown_home__" : 3, jy = process.env.NODE_ENV !== "production" ? "__input_keydown_end__" : 4, Wy = process.env.NODE_ENV !== "production" ? "__input_keydown_page_up__" : 5, Jy = process.env.NODE_ENV !== "production" ? "__input_keydown_page_down__" : 6, Ky = process.env.NODE_ENV !== "production" ? "__input_keydown_enter__" : 7, qy = process.env.NODE_ENV !== "production" ? "__input_change__" : 8, fh = process.env.NODE_ENV !== "production" ? "__input_blur__" : 9, Gy = process.env.NODE_ENV !== "production" ? "__input_focus__" : 10, dk = process.env.NODE_ENV !== "production" ? "__menu_mouse_leave__" : 11, hk = process.env.NODE_ENV !== "production" ? "__item_mouse_move__" : 12, Yy = process.env.NODE_ENV !== "production" ? "__item_click__" : 13, pk = process.env.NODE_ENV !== "production" ? "__togglebutton_click__" : 14, mk = process.env.NODE_ENV !== "production" ? "__function_toggle_menu__" : 15, gk = process.env.NODE_ENV !== "production" ? "__function_open_menu__" : 16, vk = process.env.NODE_ENV !== "production" ? "__function_close_menu__" : 17, yk = process.env.NODE_ENV !== "production" ? "__function_set_highlighted_index__" : 18, Xy = process.env.NODE_ENV !== "production" ? "__function_select_item__" : 19, xk = process.env.NODE_ENV !== "production" ? "__function_set_input_value__" : 20, wk = process.env.NODE_ENV !== "production" ? "__function_reset__" : 21, Zy = process.env.NODE_ENV !== "production" ? "__controlled_prop_updated_selected_item__" : 22, _k = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  InputKeyDownArrowDown: By,
  InputKeyDownArrowUp: zy,
  InputKeyDownEscape: Hy,
  InputKeyDownHome: Uy,
  InputKeyDownEnd: jy,
  InputKeyDownPageUp: Wy,
  InputKeyDownPageDown: Jy,
  InputKeyDownEnter: Ky,
  InputChange: qy,
  InputBlur: fh,
  InputFocus: Gy,
  MenuMouseLeave: dk,
  ItemMouseMove: hk,
  ItemClick: Yy,
  ToggleButtonClick: pk,
  FunctionToggleMenu: mk,
  FunctionOpenMenu: gk,
  FunctionCloseMenu: vk,
  FunctionSetHighlightedIndex: yk,
  FunctionSelectItem: Xy,
  FunctionSetInputValue: xk,
  FunctionReset: wk,
  ControlledPropUpdatedSelectedItem: Zy
});
function vK(e) {
  var t = dK(e), n = t.selectedItem, r = t.inputValue;
  return r === "" && n && e.defaultInputValue === void 0 && e.initialInputValue === void 0 && e.inputValue === void 0 && (r = e.itemToString(n)), Ke({}, t, {
    inputValue: r
  });
}
var yK = {
  items: ae.array.isRequired,
  itemToString: ae.func,
  selectedItemChanged: ae.func,
  getA11yStatusMessage: ae.func,
  getA11ySelectionMessage: ae.func,
  highlightedIndex: ae.number,
  defaultHighlightedIndex: ae.number,
  initialHighlightedIndex: ae.number,
  isOpen: ae.bool,
  defaultIsOpen: ae.bool,
  initialIsOpen: ae.bool,
  selectedItem: ae.any,
  initialSelectedItem: ae.any,
  defaultSelectedItem: ae.any,
  inputValue: ae.string,
  defaultInputValue: ae.string,
  initialInputValue: ae.string,
  id: ae.string,
  labelId: ae.string,
  menuId: ae.string,
  getItemId: ae.func,
  inputId: ae.string,
  toggleButtonId: ae.string,
  stateReducer: ae.func,
  onSelectedItemChange: ae.func,
  onHighlightedIndexChange: ae.func,
  onStateChange: ae.func,
  onIsOpenChange: ae.func,
  onInputValueChange: ae.func,
  environment: ae.shape({
    addEventListener: ae.func,
    removeEventListener: ae.func,
    document: ae.shape({
      getElementById: ae.func,
      activeElement: ae.any,
      body: ae.any
    })
  })
};
function xK(e, t, n) {
  var r = $e(), i = fK(e, t, n), s = i[0], o = i[1];
  return Le(function() {
    ch(n, "selectedItem") && (n.selectedItemChanged(r.current, n.selectedItem) && o({
      type: Zy,
      inputValue: n.itemToString(n.selectedItem)
    }), r.current = s.selectedItem === r.current ? n.selectedItem : s.selectedItem);
  }, [s.selectedItem, n.selectedItem]), [lh(s, n), o];
}
var bk = fr;
process.env.NODE_ENV !== "production" && (bk = function(t, n) {
  ae.checkPropTypes(yK, t, "prop", n.name);
});
var wK = Ke({}, fc, {
  selectedItemChanged: function(t, n) {
    return t !== n;
  },
  getA11yStatusMessage: U8
});
function _K(e, t) {
  var n, r = t.type, i = t.props, s = t.altKey, o;
  switch (r) {
    case Yy:
      o = {
        isOpen: fi(i, "isOpen"),
        highlightedIndex: fi(i, "highlightedIndex"),
        selectedItem: i.items[t.index],
        inputValue: i.itemToString(i.items[t.index])
      };
      break;
    case By:
      e.isOpen ? o = {
        highlightedIndex: _o(1, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !0)
      } : o = {
        highlightedIndex: s && e.selectedItem == null ? -1 : dc(i, e, 1, t.getItemNodeFromIndex),
        isOpen: i.items.length >= 0
      };
      break;
    case zy:
      e.isOpen ? s ? o = d4(i, e.highlightedIndex) : o = {
        highlightedIndex: _o(-1, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !0)
      } : o = {
        highlightedIndex: dc(i, e, -1, t.getItemNodeFromIndex),
        isOpen: i.items.length >= 0
      };
      break;
    case Ky:
      o = d4(i, e.highlightedIndex);
      break;
    case Hy:
      o = Ke({
        isOpen: !1,
        highlightedIndex: -1
      }, !e.isOpen && {
        selectedItem: null,
        inputValue: ""
      });
      break;
    case Wy:
      o = {
        highlightedIndex: _o(-10, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !1)
      };
      break;
    case Jy:
      o = {
        highlightedIndex: _o(10, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !1)
      };
      break;
    case Uy:
      o = {
        highlightedIndex: Uo(1, 0, i.items.length, t.getItemNodeFromIndex, !1)
      };
      break;
    case jy:
      o = {
        highlightedIndex: Uo(-1, i.items.length - 1, i.items.length, t.getItemNodeFromIndex, !1)
      };
      break;
    case fh:
      o = Ke({
        isOpen: !1,
        highlightedIndex: -1
      }, e.highlightedIndex >= 0 && ((n = i.items) == null ? void 0 : n.length) && t.selectItem && {
        selectedItem: i.items[e.highlightedIndex],
        inputValue: i.itemToString(i.items[e.highlightedIndex])
      });
      break;
    case qy:
      o = {
        isOpen: !0,
        highlightedIndex: fi(i, "highlightedIndex"),
        inputValue: t.inputValue
      };
      break;
    case Gy:
      o = {
        isOpen: !0,
        highlightedIndex: dc(i, e, 0)
      };
      break;
    case Xy:
      o = {
        selectedItem: t.selectedItem,
        inputValue: i.itemToString(t.selectedItem)
      };
      break;
    case Zy:
      o = {
        inputValue: t.inputValue
      };
      break;
    default:
      return mK(e, t, _k);
  }
  return Ke({}, e, o);
}
var bK = ["onMouseLeave", "refKey", "ref"], CK = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"], EK = ["onClick", "onPress", "refKey", "ref"], SK = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
Qy.stateChangeTypes = _k;
function Qy(e) {
  e === void 0 && (e = {}), bk(e, Qy);
  var t = Ke({}, wK, e), n = t.initialIsOpen, r = t.defaultIsOpen, i = t.items, s = t.scrollIntoView, o = t.environment, a = t.getA11yStatusMessage, l = t.getA11ySelectionMessage, c = t.itemToString, u = vK(t), f = xK(_K, u, t), d = f[0], h = f[1], m = d.isOpen, p = d.highlightedIndex, y = d.selectedItem, v = d.inputValue, g = $e(null), x = $e({}), _ = $e(null), b = $e(null), C = $e(!0), E = lK(t), S = $e(), k = ck({
    state: d,
    props: t
  }), M = Ht(function(q) {
    return x.current[E.getItemId(q)];
  }, [E]);
  f4(a, [m, p, v, i], Ke({
    isInitialMount: C.current,
    previousResultCount: S.current,
    items: i,
    environment: o,
    itemToString: c
  }, d)), f4(l, [y], Ke({
    isInitialMount: C.current,
    previousResultCount: S.current,
    items: i,
    environment: o,
    itemToString: c
  }, d));
  var O = pK({
    menuElement: g.current,
    highlightedIndex: p,
    isOpen: m,
    itemRefs: x,
    scrollIntoView: s,
    getItemNodeFromIndex: M
  });
  fk({
    isInitialMount: C.current,
    props: t,
    state: d
  }), Le(function() {
    var q = n || r || m;
    q && _.current && _.current.focus();
  }, []), Le(function() {
    C.current || (S.current = i.length);
  });
  var R = hK(m, [_, g, b], o, function() {
    h({
      type: fh,
      selectItem: !1
    });
  }), I = uk("getInputProps", "getMenuProps");
  Le(function() {
    return C.current = !1, function() {
      C.current = !0;
    };
  }, []), Le(function() {
    var q;
    if (!m)
      x.current = {};
    else if (((q = o.document) == null ? void 0 : q.activeElement) !== _.current) {
      var Z;
      _ == null || (Z = _.current) == null || Z.focus();
    }
  }, [m, o]);
  var H = Jo(function() {
    return {
      ArrowDown: function(Z) {
        Z.preventDefault(), h({
          type: By,
          altKey: Z.altKey,
          getItemNodeFromIndex: M
        });
      },
      ArrowUp: function(Z) {
        Z.preventDefault(), h({
          type: zy,
          altKey: Z.altKey,
          getItemNodeFromIndex: M
        });
      },
      Home: function(Z) {
        k.current.state.isOpen && (Z.preventDefault(), h({
          type: Uy,
          getItemNodeFromIndex: M
        }));
      },
      End: function(Z) {
        k.current.state.isOpen && (Z.preventDefault(), h({
          type: jy,
          getItemNodeFromIndex: M
        }));
      },
      Escape: function(Z) {
        var oe = k.current.state;
        (oe.isOpen || oe.inputValue || oe.selectedItem || oe.highlightedIndex > -1) && (Z.preventDefault(), h({
          type: Hy
        }));
      },
      Enter: function(Z) {
        var oe = k.current.state;
        !oe.isOpen || Z.which === 229 || (Z.preventDefault(), h({
          type: Ky,
          getItemNodeFromIndex: M
        }));
      },
      PageUp: function(Z) {
        k.current.state.isOpen && (Z.preventDefault(), h({
          type: Wy,
          getItemNodeFromIndex: M
        }));
      },
      PageDown: function(Z) {
        k.current.state.isOpen && (Z.preventDefault(), h({
          type: Jy,
          getItemNodeFromIndex: M
        }));
      }
    };
  }, [h, k, M]), P = Ht(function(q) {
    return Ke({
      id: E.labelId,
      htmlFor: E.inputId
    }, q);
  }, [E]), W = Ht(function(q, Z) {
    var oe, le = q === void 0 ? {} : q, ie = le.onMouseLeave, Y = le.refKey, Ce = Y === void 0 ? "ref" : Y, Fe = le.ref, je = ai(le, bK), Ze = Z === void 0 ? {} : Z, mt = Ze.suppressRefError, xn = mt === void 0 ? !1 : mt;
    return I("getMenuProps", xn, Ce, g), Ke((oe = {}, oe[Ce] = ba(Fe, function(bt) {
      g.current = bt;
    }), oe.id = E.menuId, oe.role = "listbox", oe["aria-labelledby"] = je && je["aria-label"] ? void 0 : "" + E.labelId, oe.onMouseLeave = Gt(ie, function() {
      h({
        type: dk
      });
    }), oe), je);
  }, [h, I, E]), G = Ht(function(q) {
    var Z, oe, le = q === void 0 ? {} : q, ie = le.item, Y = le.index, Ce = le.refKey, Fe = Ce === void 0 ? "ref" : Ce, je = le.ref, Ze = le.onMouseMove, mt = le.onMouseDown, xn = le.onClick;
    le.onPress;
    var bt = le.disabled, z = ai(le, CK), K = k.current, Q = K.props, se = K.state, ne = cK(ie, Y, Q.items, "Pass either item or index to getItemProps!"), he = ne[1], j = "onClick", re = xn, D = function() {
      he !== se.highlightedIndex && (O.current = !1, h({
        type: hk,
        index: he,
        disabled: bt
      }));
    }, Ie = function() {
      h({
        type: Yy,
        index: he
      });
    }, Ue = function(Qt) {
      return Qt.preventDefault();
    };
    return Ke((Z = {}, Z[Fe] = ba(je, function(et) {
      et && (x.current[E.getItemId(he)] = et);
    }), Z.disabled = bt, Z.role = "option", Z["aria-selected"] = "" + (he === se.highlightedIndex), Z.id = E.getItemId(he), Z), !bt && (oe = {}, oe[j] = Gt(re, Ie), oe), {
      onMouseMove: Gt(Ze, D),
      onMouseDown: Gt(mt, Ue)
    }, z);
  }, [h, k, O, E]), J = Ht(function(q) {
    var Z, oe = q === void 0 ? {} : q, le = oe.onClick;
    oe.onPress;
    var ie = oe.refKey, Y = ie === void 0 ? "ref" : ie, Ce = oe.ref, Fe = ai(oe, EK), je = k.current.state, Ze = function() {
      h({
        type: pk
      });
    };
    return Ke((Z = {}, Z[Y] = ba(Ce, function(mt) {
      b.current = mt;
    }), Z["aria-controls"] = E.menuId, Z["aria-expanded"] = je.isOpen, Z.id = E.toggleButtonId, Z.tabIndex = -1, Z), !Fe.disabled && Ke({}, {
      onClick: Gt(le, Ze)
    }), Fe);
  }, [h, k, E]), X = Ht(function(q, Z) {
    var oe, le = q === void 0 ? {} : q, ie = le.onKeyDown, Y = le.onChange, Ce = le.onInput, Fe = le.onFocus, je = le.onBlur;
    le.onChangeText;
    var Ze = le.refKey, mt = Ze === void 0 ? "ref" : Ze, xn = le.ref, bt = ai(le, SK), z = Z === void 0 ? {} : Z, K = z.suppressRefError, Q = K === void 0 ? !1 : K;
    I("getInputProps", Q, mt, _);
    var se = k.current.state, ne = function(Qt) {
      var qt = I0(Qt);
      qt && H[qt] && H[qt](Qt);
    }, he = function(Qt) {
      h({
        type: qy,
        inputValue: Qt.target.value
      });
    }, j = function(Qt) {
      if (se.isOpen && !R.current.isMouseDown) {
        var qt = Qt.relatedTarget === null && o.document.activeElement !== o.document.body;
        h({
          type: fh,
          selectItem: !qt
        });
      }
    }, re = function() {
      se.isOpen || h({
        type: Gy
      });
    }, D = "onChange", Ie = {};
    if (!bt.disabled) {
      var Ue;
      Ie = (Ue = {}, Ue[D] = Gt(Y, Ce, he), Ue.onKeyDown = Gt(ie, ne), Ue.onBlur = Gt(je, j), Ue.onFocus = Gt(Fe, re), Ue);
    }
    return Ke((oe = {}, oe[mt] = ba(xn, function(et) {
      _.current = et;
    }), oe["aria-activedescendant"] = se.isOpen && se.highlightedIndex > -1 ? E.getItemId(se.highlightedIndex) : "", oe["aria-autocomplete"] = "list", oe["aria-controls"] = E.menuId, oe["aria-expanded"] = se.isOpen, oe["aria-labelledby"] = bt && bt["aria-label"] ? void 0 : "" + E.labelId, oe.autoComplete = "off", oe.id = E.inputId, oe.role = "combobox", oe.value = se.inputValue, oe), Ie, bt);
  }, [I, k, E, H, h, R, o]), N = Ht(function() {
    h({
      type: mk
    });
  }, [h]), U = Ht(function() {
    h({
      type: vk
    });
  }, [h]), ee = Ht(function() {
    h({
      type: gk
    });
  }, [h]), F = Ht(function(q) {
    h({
      type: yk,
      highlightedIndex: q
    });
  }, [h]), ue = Ht(function(q) {
    h({
      type: Xy,
      selectedItem: q
    });
  }, [h]), pe = Ht(function(q) {
    h({
      type: xk,
      inputValue: q
    });
  }, [h]), ce = Ht(function() {
    h({
      type: wk
    });
  }, [h]);
  return {
    // prop getters.
    getItemProps: G,
    getLabelProps: P,
    getMenuProps: W,
    getInputProps: X,
    getToggleButtonProps: J,
    // actions.
    toggleMenu: N,
    openMenu: ee,
    closeMenu: U,
    setHighlightedIndex: F,
    setInputValue: pe,
    selectItem: ue,
    reset: ce,
    // state.
    highlightedIndex: p,
    isOpen: m,
    selectedItem: y,
    inputValue: v
  };
}
ae.array, ae.array, ae.array, ae.func, ae.func, ae.func, ae.number, ae.number, ae.number, ae.func, ae.func, ae.string, ae.string, ae.shape({
  addEventListener: ae.func,
  removeEventListener: ae.func,
  document: ae.shape({
    getElementById: ae.func,
    activeElement: ae.any,
    body: ae.any
  })
});
fc.itemToString, fc.stateReducer, fc.environment;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
const h4 = 20, Ck = (e) => e.suggestions.length > 0 ? /* @__PURE__ */ T.createElement(kK, { ...e }) : /* @__PURE__ */ T.createElement("input", { className: de.textInput, size: 40, autoFocus: !0, ...e.register(e.inputName) }), kK = ({
  autofocus: e,
  suggestions: t,
  control: n,
  inputName: r,
  placeholder: i,
  initialInputValue: s,
  setValue: o
}) => {
  const [a, l] = T.useState(t.slice(0, h4)), c = mn(ir), u = t.length > 0, { isOpen: f, getToggleButtonProps: d, getMenuProps: h, getInputProps: m, highlightedIndex: p, getItemProps: y, selectedItem: v } = Qy({
    initialInputValue: s,
    onInputValueChange({ inputValue: x = "" }) {
      o(r, x), x = x.toLowerCase() || "";
      const _ = [];
      for (const b of t)
        if (b.toLowerCase().includes(x) && (_.push(b), _.length >= h4))
          break;
      l(_);
    },
    items: a,
    itemToString(x) {
      return x ?? "";
    }
  }), g = f && a.length > 0;
  return /* @__PURE__ */ T.createElement("div", { className: de.downshiftAutocompleteContainer }, /* @__PURE__ */ T.createElement("div", { "data-visible-dropdown": g, className: de.downshiftInputWrapper }, /* @__PURE__ */ T.createElement(
    dJ,
    {
      name: r,
      control: n,
      render: ({ field: x }) => {
        const _ = m();
        return /* @__PURE__ */ T.createElement(
          "input",
          {
            ..._,
            name: x.name,
            placeholder: i,
            className: de.downshiftInput,
            size: 30,
            "data-editor-dialog": !0,
            autoFocus: e
          }
        );
      }
    }
  ), u && /* @__PURE__ */ T.createElement("button", { "aria-label": "toggle menu", type: "button", ...d() }, c("arrow_drop_down"))), /* @__PURE__ */ T.createElement("div", { className: de.downshiftAutocompleteContainer }, /* @__PURE__ */ T.createElement("ul", { ...h(), "data-visible": g }, a.map((x, _) => /* @__PURE__ */ T.createElement(
    "li",
    {
      "data-selected": v === x,
      "data-highlighted": p === _,
      key: `${x}${_}`,
      ...y({ item: x, index: _ })
    },
    x
  )))));
}, TK = () => {
  const [e, t, n, r] = On(
    M0,
    ko,
    Yo,
    Ls
  ), i = It(Ak), s = It(kk), o = Kn(), { register: a, handleSubmit: l, control: c, setValue: u, reset: f } = Hp({
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    values: t.type === "editing" ? t.initialValues : {}
  });
  return t.type === "inactive" ? null : /* @__PURE__ */ T.createElement(
    w8,
    {
      open: !0,
      onOpenChange: (d) => {
        d || (s(), f({ src: "", title: "", altText: "" }));
      }
    },
    /* @__PURE__ */ T.createElement(_8, { container: n == null ? void 0 : n.current }, /* @__PURE__ */ T.createElement(b8, { className: de.dialogOverlay }), /* @__PURE__ */ T.createElement(
      C8,
      {
        className: de.dialogContent,
        onOpenAutoFocus: (d) => {
          d.preventDefault();
        }
      },
      /* @__PURE__ */ T.createElement(E8, null, o("uploadImage.dialogTitle", "Upload an image")),
      /* @__PURE__ */ T.createElement(
        "form",
        {
          onSubmit: async (d) => {
            d.preventDefault(), d.stopPropagation(), await l(i)(d), f({ src: "", title: "", altText: "" });
          },
          className: de.multiFieldForm
        },
        r === null ? /* @__PURE__ */ T.createElement("input", { type: "hidden", accept: "image/*", ...a("file") }) : /* @__PURE__ */ T.createElement("div", { className: de.formField }, /* @__PURE__ */ T.createElement("label", { htmlFor: "file" }, o("uploadImage.uploadInstructions", "Upload an image from your device:")), /* @__PURE__ */ T.createElement("input", { type: "file", accept: "image/*", ...a("file") })),
        /* @__PURE__ */ T.createElement("div", { className: de.formField }, /* @__PURE__ */ T.createElement("label", { htmlFor: "src" }, r !== null ? o("uploadImage.addViaUrlInstructions", "Or add an image from an URL:") : o("uploadImage.addViaUrlInstructionsNoUpload", "Add an image from an URL:")), /* @__PURE__ */ T.createElement(
          Ck,
          {
            register: a,
            initialInputValue: t.type === "editing" ? t.initialValues.src ?? "" : "",
            inputName: "src",
            suggestions: e,
            setValue: u,
            control: c,
            placeholder: o("uploadImage.autoCompletePlaceholder", "Select or paste an image src")
          }
        )),
        /* @__PURE__ */ T.createElement("div", { className: de.formField }, /* @__PURE__ */ T.createElement("label", { htmlFor: "alt" }, o("uploadImage.alt", "Alt:")), /* @__PURE__ */ T.createElement("input", { type: "text", ...a("altText"), className: de.textInput })),
        /* @__PURE__ */ T.createElement("div", { className: de.formField }, /* @__PURE__ */ T.createElement("label", { htmlFor: "title" }, o("uploadImage.title", "Title:")), /* @__PURE__ */ T.createElement("input", { type: "text", ...a("title"), className: de.textInput })),
        /* @__PURE__ */ T.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } }, /* @__PURE__ */ T.createElement(
          "button",
          {
            type: "submit",
            title: o("dialogControls.save", "Save"),
            "aria-label": o("dialogControls.save", "Save"),
            className: rt(de.primaryButton)
          },
          o("dialogControls.save", "Save")
        ), /* @__PURE__ */ T.createElement(S8, { asChild: !0 }, /* @__PURE__ */ T.createElement(
          "button",
          {
            type: "reset",
            title: o("dialogControls.cancel", "Cancel"),
            "aria-label": o("dialogControls.cancel", "Cancel"),
            className: rt(de.secondaryButton)
          },
          o("dialogControls.cancel", "Cancel")
        )))
      )
    ))
  );
};
function pm(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
const gt = {
  east: 1,
  north: 8,
  south: 2,
  west: 4
};
function AK({
  onResizeStart: e,
  onResizeEnd: t,
  imageRef: n,
  maxWidth: r,
  editor: i
}) {
  const s = $e(null), o = $e({
    priority: "",
    value: "default"
  }), a = $e({
    currentHeight: 0,
    currentWidth: 0,
    direction: 0,
    isResizing: !1,
    ratio: 0,
    startHeight: 0,
    startWidth: 0,
    startX: 0,
    startY: 0
  }), l = i.getRootElement(), c = r || (l !== null ? l.getBoundingClientRect().width - 20 : 100), u = l !== null ? l.getBoundingClientRect().height - 20 : 100, f = 100, d = 100, h = (g) => {
    const x = g === gt.east || g === gt.west, _ = g === gt.north || g === gt.south, b = g & gt.north && g & gt.west || g & gt.south && g & gt.east, C = x ? "ew" : _ ? "ns" : b ? "nwse" : "nesw";
    l !== null && l.style.setProperty("cursor", `${C}-resize`, "important"), document.body !== null && (document.body.style.setProperty("cursor", `${C}-resize`, "important"), o.current.value = document.body.style.getPropertyValue("-webkit-user-select"), o.current.priority = document.body.style.getPropertyPriority("-webkit-user-select"), document.body.style.setProperty("-webkit-user-select", "none", "important"));
  }, m = () => {
    l !== null && l.style.setProperty("cursor", "text"), document.body !== null && (document.body.style.setProperty("cursor", "default"), document.body.style.setProperty("-webkit-user-select", o.current.value, o.current.priority));
  }, p = (g, x) => {
    if (!i.isEditable())
      return;
    const _ = n.current, b = s.current;
    if (_ !== null && b !== null) {
      g.preventDefault();
      const { width: C, height: E } = _.getBoundingClientRect(), S = a.current;
      S.startWidth = C, S.startHeight = E, S.ratio = C / E, S.currentWidth = C, S.currentHeight = E, S.startX = g.clientX, S.startY = g.clientY, S.isResizing = !0, S.direction = x, h(x), e(), b.classList.add(de.imageControlWrapperResizing), _.style.height = `${E}px`, _.style.width = `${C}px`, document.addEventListener("pointermove", y), document.addEventListener("pointerup", v);
    }
  }, y = (g) => {
    const x = n.current, _ = a.current, b = _.direction & (gt.east | gt.west), C = _.direction & (gt.south | gt.north);
    if (x !== null && _.isResizing)
      if (b && C) {
        let E = Math.floor(_.startX - g.clientX);
        E = _.direction & gt.east ? -E : E;
        const S = pm(_.startWidth + E, f, c), k = S / _.ratio;
        x.style.width = `${S}px`, x.style.height = `${k}px`, _.currentHeight = k, _.currentWidth = S;
      } else if (C) {
        let E = Math.floor(_.startY - g.clientY);
        E = _.direction & gt.south ? -E : E;
        const S = pm(_.startHeight + E, d, u);
        x.style.height = `${S}px`, _.currentHeight = S;
      } else {
        let E = Math.floor(_.startX - g.clientX);
        E = _.direction & gt.east ? -E : E;
        const S = pm(_.startWidth + E, f, c);
        x.style.width = `${S}px`, _.currentWidth = S;
      }
  }, v = () => {
    const g = n.current, x = a.current, _ = s.current;
    if (g !== null && _ !== null && x.isResizing) {
      const b = x.currentWidth, C = x.currentHeight;
      x.startWidth = 0, x.startHeight = 0, x.ratio = 0, x.startX = 0, x.startY = 0, x.currentWidth = 0, x.currentHeight = 0, x.isResizing = !1, _.classList.remove(de.imageControlWrapperResizing), m(), t(b, C), document.removeEventListener("pointermove", y), document.removeEventListener("pointerup", v);
    }
  };
  return /* @__PURE__ */ w.createElement("div", { ref: s }, /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerN),
      onPointerDown: (g) => {
        p(g, gt.north);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerNe),
      onPointerDown: (g) => {
        p(g, gt.north | gt.east);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerE),
      onPointerDown: (g) => {
        p(g, gt.east);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerSe),
      onPointerDown: (g) => {
        p(g, gt.south | gt.east);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerS),
      onPointerDown: (g) => {
        p(g, gt.south);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerSw),
      onPointerDown: (g) => {
        p(g, gt.south | gt.west);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerW),
      onPointerDown: (g) => {
        p(g, gt.west);
      }
    }
  ), /* @__PURE__ */ w.createElement(
    "div",
    {
      className: rt(de.imageResizer, de.imageResizerNw),
      onPointerDown: (g) => {
        p(g, gt.north | gt.west);
      }
    }
  ));
}
const NK = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(
  /* xml */
  `
    <svg id="imgLoadError" xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect x="0" y="0" width="100" height="100" fill="none" stroke="red" stroke-width="4" stroke-dasharray="4" />
      <text x="50" y="55" text-anchor="middle" font-size="20" fill="red">⚠️</text>
    </svg>
`
), IK = {
  __cache: {},
  read(e) {
    if (this.__cache[e] || (this.__cache[e] = new Promise((t) => {
      const n = new Image();
      n.onerror = () => {
        this.__cache[e] = NK, t();
      }, n.onload = () => {
        this.__cache[e] = e, t();
      }, n.src = e;
    })), this.__cache[e] instanceof Promise)
      throw this.__cache[e];
    return this.__cache[e];
  }
};
function LK({
  title: e,
  alt: t,
  className: n,
  imageRef: r,
  src: i,
  width: s,
  height: o
}) {
  return /* @__PURE__ */ T.createElement(
    "img",
    {
      className: n ?? void 0,
      alt: t,
      src: IK.read(i),
      title: e,
      ref: r,
      draggable: "false",
      width: s,
      height: o
    }
  );
}
function MK({ src: e, title: t, alt: n, nodeKey: r, width: i, height: s, rest: o }) {
  const [a, l, c, u, f] = On(
    D0,
    O0,
    P0,
    Cr,
    F0
  ), d = T.useRef(null), h = T.useRef(null), [m, p, y] = xS(r), [v] = vn(), [g, x] = T.useState(null), _ = T.useRef(null), [b, C] = T.useState(!1), [E, S] = T.useState(null), [k, M] = T.useState(null), O = T.useCallback(
    (X) => {
      if (m && Nt(ge())) {
        X.preventDefault();
        const U = wt(r);
        dh(U) && U.remove();
      }
      return !1;
    },
    [m, r]
  ), R = T.useCallback(
    (X) => {
      const N = ge(), U = h.current;
      return m && Nt(N) && N.getNodes().length === 1 && U !== null && U !== document.activeElement ? (X.preventDefault(), U.focus(), !0) : !1;
    },
    [m]
  ), I = T.useCallback(
    (X) => h.current === X.target ? (Ot(null), v.update(() => {
      p(!0);
      const N = v.getRootElement();
      N !== null && N.focus();
    }), !0) : !1,
    [v, p]
  );
  T.useEffect(() => {
    c ? (async () => {
      k || M(e);
      const N = await c(e);
      S(N);
    })().catch((N) => {
      console.error(N);
    }) : S(e);
  }, [e, c, k]), T.useEffect(() => {
    let X = !0;
    const N = Dn(
      v.registerUpdateListener(({ editorState: U }) => {
        X && x(U.read(() => ge()));
      }),
      v.registerCommand(
        Zc,
        (U, ee) => (_.current = ee, !1),
        xt
      ),
      v.registerCommand(
        ep,
        (U) => {
          const ee = U;
          return b ? !0 : ee.target === d.current ? (ee.shiftKey ? p(!m) : (y(), p(!0)), !0) : !1;
        },
        xt
      ),
      v.registerCommand(
        ip,
        (U) => U.target === d.current ? (U.preventDefault(), !0) : !1,
        xt
      ),
      v.registerCommand(lv, O, xt),
      v.registerCommand(rp, O, xt),
      v.registerCommand(Nc, R, xt),
      v.registerCommand(eu, I, xt)
    );
    return () => {
      X = !1, N();
    };
  }, [y, v, b, m, r, O, R, I, p]);
  const H = (X, N) => {
    setTimeout(() => {
      C(!1);
    }, 200), v.update(() => {
      const U = wt(r);
      dh(U) && U.setWidthAndHeight(X, N);
    });
  }, P = () => {
    C(!0);
  }, W = Nt(g), G = m, J = T.useMemo(() => {
    if (o.length === 0)
      return null;
    const X = o.find((N) => N.type === "mdxJsxAttribute" && (N.name === "class" || N.name === "className"));
    return X ? X.value : null;
  }, [o]);
  return E !== null ? /* @__PURE__ */ T.createElement(T.Suspense, { fallback: a ? /* @__PURE__ */ T.createElement(a, null) : null }, /* @__PURE__ */ T.createElement("div", { className: de.imageWrapper, "data-editor-block-type": "image" }, /* @__PURE__ */ T.createElement("div", { draggable: W }, /* @__PURE__ */ T.createElement(
    LK,
    {
      width: i,
      height: s,
      className: rt(
        {
          [de.focusedImage]: G
        },
        J
      ),
      src: E,
      title: t ?? "",
      alt: n ?? "",
      imageRef: d
    }
  )), W && G && !l && /* @__PURE__ */ T.createElement(AK, { editor: v, imageRef: d, onResizeStart: P, onResizeEnd: H }), u || /* @__PURE__ */ T.createElement(
    f,
    {
      nodeKey: r,
      imageSource: E,
      initialImagePath: k,
      title: t ?? "",
      alt: n ?? ""
    }
  ))) : null;
}
var OK = Object.defineProperty, PK = (e, t, n) => t in e ? OK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ca = (e, t, n) => (PK(e, typeof t != "symbol" ? t + "" : t, n), n);
function DK(e) {
  if (e instanceof HTMLImageElement) {
    const { alt: t, src: n, title: r, width: i, height: s } = e;
    return { node: Qo({ altText: t, src: n, title: r, width: i, height: s }) };
  }
  return null;
}
class bu extends bi {
  /**
   * Constructs a new {@link ImageNode} with the specified image parameters.
   * Use {@link $createImageNode} to construct one.
   */
  constructor(t, n, r, i, s, o, a) {
    super(a), ca(this, "__src"), ca(this, "__altText"), ca(this, "__title"), ca(this, "__width"), ca(this, "__height"), ca(this, "__rest"), this.__src = t, this.__title = r, this.__altText = n, this.__width = i || "inherit", this.__height = s || "inherit", this.__rest = o ?? [];
  }
  /** @internal */
  static getType() {
    return "image";
  }
  /** @internal */
  static clone(t) {
    return new bu(t.__src, t.__altText, t.__title, t.__width, t.__height, t.__rest, t.__key);
  }
  /** @internal */
  static importJSON(t) {
    const { altText: n, title: r, src: i, width: s, rest: o, height: a } = t;
    return Qo({
      altText: n,
      title: r,
      src: i,
      height: a,
      width: s,
      rest: o
    });
  }
  /** @internal */
  exportDOM() {
    const t = document.createElement("img");
    return t.setAttribute("src", this.__src), t.setAttribute("alt", this.__altText), this.__title && t.setAttribute("title", this.__title), this.__width && t.setAttribute("width", this.__width.toString()), this.__height && t.setAttribute("height", this.__height.toString()), { element: t };
  }
  /** @internal */
  static importDOM() {
    return {
      img: () => ({
        conversion: DK,
        priority: 0
      })
    };
  }
  /** @internal */
  exportJSON() {
    return {
      altText: this.getAltText(),
      title: this.getTitle(),
      height: this.__height === "inherit" ? 0 : this.__height,
      width: this.__width === "inherit" ? 0 : this.__width,
      src: this.getSrc(),
      rest: this.__rest,
      type: "image",
      version: 1
    };
  }
  /**
   * Sets the image dimensions
   */
  setWidthAndHeight(t, n) {
    const r = this.getWritable();
    r.__width = t, r.__height = n;
  }
  /** @internal */
  createDOM(t) {
    const n = document.createElement("span"), i = t.theme.image;
    return i !== void 0 && (n.className = i), n;
  }
  /** @internal */
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  getTitle() {
    return this.__title;
  }
  getHeight() {
    return this.__height;
  }
  getWidth() {
    return this.__width;
  }
  getRest() {
    return this.__rest;
  }
  setTitle(t) {
    this.getWritable().__title = t;
  }
  setSrc(t) {
    this.getWritable().__src = t;
  }
  setAltText(t) {
    this.getWritable().__altText = t ?? "";
  }
  /** @internal */
  shouldBeSerializedAsElement() {
    return this.__width !== "inherit" || this.__height !== "inherit" || this.__rest.length > 0;
  }
  /** @internal */
  decorate(t) {
    return /* @__PURE__ */ T.createElement(
      MK,
      {
        src: this.getSrc(),
        title: this.getTitle(),
        nodeKey: this.getKey(),
        width: this.__width,
        height: this.__height,
        alt: this.__altText,
        rest: this.__rest
      }
    );
  }
}
function Qo(e) {
  const { altText: t, title: n, src: r, key: i, width: s, height: o, rest: a } = e;
  return new bu(r, t, n, s, o, a, i);
}
function dh(e) {
  return e instanceof bu;
}
const FK = {
  testLexicalNode: dh,
  visitLexicalNode({ mdastParent: e, lexicalNode: t, actions: n }) {
    if (t.shouldBeSerializedAsElement()) {
      const r = new Image();
      t.getHeight() !== "inherit" && (r.height = t.getHeight()), t.getWidth() !== "inherit" && (r.width = t.getWidth()), t.getAltText() && (r.alt = t.getAltText()), t.getTitle() && (r.title = t.getTitle());
      for (const i of t.getRest())
        i.type === "mdxJsxAttribute" && typeof i.value == "string" && r.setAttribute(i.name, i.value);
      n.appendToParent(e, {
        type: "html",
        value: r.outerHTML.replace(/>$/, ` src="${t.getSrc()}" />`)
      });
    } else
      n.appendToParent(e, {
        type: "image",
        url: t.getSrc(),
        alt: t.getAltText(),
        title: t.getTitle()
      });
  }
}, RK = {
  testNode: "image",
  visitNode({ mdastNode: e, actions: t }) {
    t.addAndStepInto(
      Qo({
        src: e.url,
        altText: e.alt ?? "",
        title: e.title ?? ""
      })
    );
  }
}, $K = {
  testNode: (e) => e.type === "html" && e.value.trim().startsWith("<img"),
  visitNode({ mdastNode: e, lexicalParent: t }) {
    const n = document.createElement("div");
    n.innerHTML = e.value;
    const r = n.querySelector("img");
    if (!r)
      throw new Error("Invalid HTML image");
    const i = r.src, s = r.alt, o = r.title, a = r.width, l = r.height, c = Qo({
      src: i || "",
      altText: s,
      title: o,
      width: a,
      height: l
    });
    if (t.getType() === "root") {
      const u = st();
      u.append(c), t.append(u);
    } else
      t.append(c);
  }
};
function Hl(e, t) {
  const n = e.attributes.find((r) => r.type === "mdxJsxAttribute" && r.name === t);
  if (n)
    return n.value;
}
const VK = {
  testNode: (e) => (e.type === "mdxJsxTextElement" || e.type === "mdxJsxFlowElement") && e.name === "img",
  visitNode({ mdastNode: e, lexicalParent: t }) {
    const n = Hl(e, "src");
    if (!n)
      return;
    const r = Hl(e, "alt") ?? "", i = Hl(e, "title"), s = Hl(e, "height"), o = Hl(e, "width"), a = e.attributes.filter((c) => c.type === "mdxJsxAttribute" && !["src", "alt", "title", "height", "width"].includes(c.name)), l = Qo({
      src: n,
      altText: r,
      title: i,
      width: o ? parseInt(o, 10) : void 0,
      height: s ? parseInt(s, 10) : void 0,
      rest: a
    });
    if (t.getType() === "root") {
      const c = st();
      c.append(l), t.append(c);
    } else
      t.append(l);
  }
}, ex = Bt((e) => {
  e.sub(e.pipe(ex, Tt(Ft)), ([t, n]) => {
    n == null || n.update(() => {
      const r = Qo({ altText: t.altText ?? "", src: t.src, title: t.title ?? "" });
      dl([r]), Jt(r.getParentOrThrow()) && zv(r, st).selectEnd();
    });
  });
}), BK = Bt((e) => {
  e.sub(e.pipe(BK, Tt(Ls)), ([t, n]) => {
    const r = (i) => {
      e.pub(ex, { ...t, src: i });
    };
    "file" in t ? n == null || n(t.file).then(r).catch((i) => {
      throw i;
    }) : r(t.src);
  });
}), M0 = Te([]), O0 = Te(!1), Ls = Te(null), P0 = Te(null), D0 = Te(null), ko = Te(
  { type: "inactive" },
  (e) => {
    e.sub(
      e.pipe(Ak, Tt(Ft, Ls, ko)),
      ([t, n, r, i]) => {
        const s = i.type === "editing" ? (o) => {
          n == null || n.update(() => {
            const { nodeKey: a } = i, l = wt(a);
            l.setTitle(t.title), l.setAltText(t.altText), l.setSrc(o);
          }), e.pub(ko, { type: "inactive" });
        } : (o) => {
          e.pub(ex, { ...t, src: o }), e.pub(ko, { type: "inactive" });
        };
        t.file && t.file.length > 0 ? r == null || r(t.file.item(0)).then(s).catch((o) => {
          throw o;
        }) : t.src && s(t.src);
      }
    ), e.pub(Oc, (t) => {
      const n = e.getValue(Ls);
      return Dn(
        t.registerCommand(
          hh,
          (r) => {
            const i = Qo(r);
            return dl([i]), Jt(i.getParentOrThrow()) && zv(i, st).selectEnd(), !0;
          },
          qe
        ),
        t.registerCommand(
          ip,
          (r) => jK(r),
          Ld
        ),
        t.registerCommand(
          fv,
          (r) => WK(r, !!n),
          xt
        ),
        t.registerCommand(
          uv,
          (r) => JK(r, t, e.getValue(Ls)),
          Ld
        ),
        t.registerCommand(
          Qc,
          (r) => {
            var i, s;
            if (!n) {
              let c = Array.from(((i = r.clipboardData) == null ? void 0 : i.items) ?? []);
              return c = c.filter((u) => u.type.includes("text")), !c.length || c.length === 0;
            }
            const o = Array.from(((s = r.clipboardData) == null ? void 0 : s.items) ?? []);
            if (o.some((c) => !c.type.includes("image")) || !o.length || o.length === 0)
              return !1;
            const l = e.getValue(Ls);
            return Promise.all(o.map((c) => l(c.getAsFile()))).then((c) => {
              c.forEach((u) => {
                t.dispatchCommand(hh, {
                  src: u,
                  altText: ""
                });
              });
            }).catch((c) => {
              throw c;
            }), !0;
          },
          zr
        )
      );
    });
  }
), Ek = _i((e) => {
  e.link(e.pipe(Ek, yE({ type: "new" })), ko);
}), Sk = Bt((e) => {
  e.link(
    e.pipe(
      Sk,
      Ds((t) => ({ type: "editing", ...t }))
    ),
    ko
  );
}), kk = _i((e) => {
  e.link(e.pipe(kk, yE({ type: "inactive" })), ko);
}), Tk = Te(!1), Ak = Bt(), F0 = Te(C0), zK = Jn({
  init(e, t) {
    e.pubIn({
      [Er]: [RK, $K, VK],
      [Yr]: bu,
      [Xr]: FK,
      [Xo]: (t == null ? void 0 : t.ImageDialog) ?? TK,
      [Ls]: (t == null ? void 0 : t.imageUploadHandler) ?? null,
      [M0]: (t == null ? void 0 : t.imageAutocompleteSuggestions) ?? [],
      [O0]: !!(t != null && t.disableImageResize),
      [Tk]: !!(t != null && t.disableImageSettingsButton),
      [P0]: (t == null ? void 0 : t.imagePreviewHandler) ?? null,
      [F0]: (t == null ? void 0 : t.EditImageToolbar) ?? C0,
      [D0]: (t == null ? void 0 : t.imagePlaceholder) ?? Fb
    });
  },
  update(e, t) {
    e.pubIn({
      [Ls]: (t == null ? void 0 : t.imageUploadHandler) ?? null,
      [M0]: (t == null ? void 0 : t.imageAutocompleteSuggestions) ?? [],
      [O0]: !!(t != null && t.disableImageResize),
      [P0]: (t == null ? void 0 : t.imagePreviewHandler) ?? null,
      [F0]: (t == null ? void 0 : t.EditImageToolbar) ?? C0,
      [D0]: (t == null ? void 0 : t.imagePlaceholder) ?? Fb
    });
  }
}), HK = (e) => vS ? (e ?? window).getSelection() : null, hh = Pe("INSERT_IMAGE_COMMAND"), UK = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
function jK(e) {
  const t = tx();
  if (!t)
    return !1;
  const n = e.dataTransfer;
  if (!n)
    return !1;
  n.setData("text/plain", "_");
  const r = document.createElement("img");
  return r.src = UK, n.setDragImage(r, 0, 0), n.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: t.__altText,
        title: t.__title,
        key: t.getKey(),
        src: t.__src
      },
      type: "image"
    })
  ), !0;
}
function WK(e, t) {
  var n;
  if (t) {
    let i = Array.from(((n = e.dataTransfer) == null ? void 0 : n.items) ?? []);
    if (i = i.filter((s) => s.type.includes("image")), i.length > 0)
      return e.preventDefault(), !0;
  }
  return tx() ? (Nk(e) || e.preventDefault(), !0) : !1;
}
function JK(e, t, n) {
  var r;
  let i = Array.from(((r = e.dataTransfer) == null ? void 0 : r.items) ?? []);
  if (i = i.filter((a) => a.type.includes("image")), i.length > 0 && n !== null)
    return e.preventDefault(), Promise.all(
      i.map((a) => a.kind === "string" ? new Promise((l) => {
        a.getAsString(l);
      }) : n(a.getAsFile()))
    ).then((a) => {
      a.forEach((l) => {
        t.dispatchCommand(hh, {
          src: l,
          altText: ""
        });
      });
    }).catch((a) => {
      throw a;
    }), !0;
  const s = tx();
  if (!s)
    return !1;
  const o = KK(e);
  if (!o)
    return !1;
  if (e.preventDefault(), Nk(e)) {
    const a = qK(e);
    s.remove();
    const l = fl();
    a != null && l.applyDOMRange(a), Ot(l), t.dispatchCommand(hh, o);
  }
  return !0;
}
function tx() {
  const e = ge();
  if (!Nt(e))
    return null;
  const n = e.getNodes()[0];
  return dh(n) ? n : null;
}
function KK(e) {
  var t;
  const n = (t = e.dataTransfer) == null ? void 0 : t.getData("application/x-lexical-drag");
  if (!n)
    return null;
  const { type: r, data: i } = JSON.parse(n);
  return r !== "image" ? null : i;
}
function Nk(e) {
  const t = e.target;
  return !!(t && t instanceof HTMLElement && t.parentElement);
}
function qK(e) {
  let t;
  const n = e.target, r = n == null ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView, i = HK(r);
  if (document.caretRangeFromPoint)
    t = document.caretRangeFromPoint(e.clientX, e.clientY);
  else if (e.rangeParent && i !== null)
    i.collapse(e.rangeParent, e.rangeOffset ?? 0), t = i.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return t;
}
var Ik = { exports: {} };
(function(e) {
  (function() {
    var t;
    t = e.exports = i, t.format = i, t.vsprintf = r, typeof console < "u" && typeof console.log == "function" && (t.printf = n);
    function n() {
      console.log(i.apply(null, arguments));
    }
    function r(s, o) {
      return i.apply(null, [s].concat(o));
    }
    function i(s) {
      for (var o = 1, a = [].slice.call(arguments), l = 0, c = s.length, u = "", f, d = !1, h, m, p = !1, y, v = function() {
        return a[o++];
      }, g = function() {
        for (var x = ""; /\d/.test(s[l]); )
          x += s[l++], f = s[l];
        return x.length > 0 ? parseInt(x) : null;
      }; l < c; ++l)
        if (f = s[l], d)
          switch (d = !1, f == "." ? (p = !1, f = s[++l]) : f == "0" && s[l + 1] == "." ? (p = !0, l += 2, f = s[l]) : p = !0, y = g(), f) {
            case "b":
              u += parseInt(v(), 10).toString(2);
              break;
            case "c":
              h = v(), typeof h == "string" || h instanceof String ? u += h : u += String.fromCharCode(parseInt(h, 10));
              break;
            case "d":
              u += parseInt(v(), 10);
              break;
            case "f":
              m = String(parseFloat(v()).toFixed(y || 6)), u += p ? m : m.replace(/^0/, "");
              break;
            case "j":
              u += JSON.stringify(v());
              break;
            case "o":
              u += "0" + parseInt(v(), 10).toString(8);
              break;
            case "s":
              u += v();
              break;
            case "x":
              u += "0x" + parseInt(v(), 10).toString(16);
              break;
            case "X":
              u += "0x" + parseInt(v(), 10).toString(16).toUpperCase();
              break;
            default:
              u += f;
              break;
          }
        else f === "%" ? d = !0 : u += f;
      return u;
    }
  })();
})(Ik);
var GK = Ik.exports;
const YK = /* @__PURE__ */ yl(GK), uf = Object.assign(uo(Error), {
  eval: uo(EvalError),
  range: uo(RangeError),
  reference: uo(ReferenceError),
  syntax: uo(SyntaxError),
  type: uo(TypeError),
  uri: uo(URIError)
});
function uo(e) {
  return t.displayName = e.displayName || e.name, t;
  function t(n, ...r) {
    const i = n && YK(n, ...r);
    return new e(i);
  }
}
const ff = {}.hasOwnProperty, p4 = {
  yaml: "-",
  toml: "+"
};
function nx(e) {
  const t = [];
  let n = -1;
  const r = Array.isArray(e) ? e : e ? [e] : ["yaml"];
  for (; ++n < r.length; )
    t[n] = XK(r[n]);
  return t;
}
function XK(e) {
  let t = e;
  if (typeof t == "string") {
    if (!ff.call(p4, t))
      throw uf("Missing matter definition for `%s`", t);
    t = {
      type: t,
      marker: p4[t]
    };
  } else if (typeof t != "object")
    throw uf("Expected matter to be an object, not `%j`", t);
  if (!ff.call(t, "type"))
    throw uf("Missing `type` in matter `%j`", t);
  if (!ff.call(t, "fence") && !ff.call(t, "marker"))
    throw uf("Missing `marker` or `fence` in matter `%j`", t);
  return t;
}
function ZK(e) {
  const t = nx(e), n = {};
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r], s = R0(i, "open").charCodeAt(0), o = QK(i), a = n[s];
    Array.isArray(a) ? a.push(o) : n[s] = [o];
  }
  return {
    flow: n
  };
}
function QK(e) {
  const t = e.anywhere, n = (
    /** @type {TokenType} */
    e.type
  ), r = (
    /** @type {TokenType} */
    n + "Fence"
  ), i = (
    /** @type {TokenType} */
    r + "Sequence"
  ), s = (
    /** @type {TokenType} */
    n + "Value"
  ), o = {
    tokenize: u,
    partial: !0
  };
  let a, l = 0;
  return {
    tokenize: c,
    concrete: !0
  };
  function c(f, d, h) {
    const m = this;
    return p;
    function p(E) {
      const S = m.now();
      return (
        // Indent not allowed.
        S.column === 1 && // Normally, only allowed in first line.
        (S.line === 1 || t) && (a = R0(e, "open"), l = 0, E === a.charCodeAt(l)) ? (f.enter(n), f.enter(r), f.enter(i), y(E)) : h(E)
      );
    }
    function y(E) {
      return l === a.length ? (f.exit(i), He(E) ? (f.enter("whitespace"), v(E)) : g(E)) : E === a.charCodeAt(l++) ? (f.consume(E), y) : h(E);
    }
    function v(E) {
      return He(E) ? (f.consume(E), v) : (f.exit("whitespace"), g(E));
    }
    function g(E) {
      return be(E) ? (f.exit(r), f.enter("lineEnding"), f.consume(E), f.exit("lineEnding"), a = R0(e, "close"), l = 0, f.attempt(o, C, x)) : h(E);
    }
    function x(E) {
      return E === null || be(E) ? b(E) : (f.enter(s), _(E));
    }
    function _(E) {
      return E === null || be(E) ? (f.exit(s), b(E)) : (f.consume(E), _);
    }
    function b(E) {
      return E === null ? h(E) : (f.enter("lineEnding"), f.consume(E), f.exit("lineEnding"), f.attempt(o, C, x));
    }
    function C(E) {
      return f.exit(n), d(E);
    }
  }
  function u(f, d, h) {
    let m = 0;
    return p;
    function p(x) {
      return x === a.charCodeAt(m) ? (f.enter(r), f.enter(i), y(x)) : h(x);
    }
    function y(x) {
      return m === a.length ? (f.exit(i), He(x) ? (f.enter("whitespace"), v(x)) : g(x)) : x === a.charCodeAt(m++) ? (f.consume(x), y) : h(x);
    }
    function v(x) {
      return He(x) ? (f.consume(x), v) : (f.exit("whitespace"), g(x));
    }
    function g(x) {
      return x === null || be(x) ? (f.exit(r), d(x)) : h(x);
    }
  }
}
function R0(e, t) {
  return e.marker ? m4(e.marker, t).repeat(3) : (
    // @ts-expect-error: They’re mutually exclusive.
    m4(e.fence, t)
  );
}
function m4(e, t) {
  return typeof e == "string" ? e : e[t];
}
function eq(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function tq(e) {
  const t = nx(e), n = {}, r = {};
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i];
    n[s.type] = nq(s), r[s.type] = rq, r[s.type + "Value"] = iq;
  }
  return { enter: n, exit: r };
}
function nq(e) {
  return t;
  function t(n) {
    this.enter({ type: e.type, value: "" }, n), this.buffer();
  }
}
function rq(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  this.exit(e), n.value = t.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function iq(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function sq(e) {
  const t = [], n = {}, r = nx(e);
  let i = -1;
  for (; ++i < r.length; ) {
    const s = r[i];
    n[s.type] = oq(s);
    const o = $0(s, "open");
    t.push({
      atBreak: !0,
      character: o.charAt(0),
      after: eq(o.charAt(1))
    });
  }
  return { unsafe: t, handlers: n };
}
function oq(e) {
  const t = $0(e, "open"), n = $0(e, "close");
  return r;
  function r(i) {
    return t + (i.value ? `
` + i.value : "") + `
` + n;
  }
}
function $0(e, t) {
  return e.marker ? g4(e.marker, t).repeat(3) : (
    // @ts-expect-error: They’re mutually exclusive.
    g4(e.fence, t)
  );
}
function g4(e, t) {
  return typeof e == "string" ? e : e[t];
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function Lk(e) {
  return typeof e > "u" || e === null;
}
function aq(e) {
  return typeof e == "object" && e !== null;
}
function lq(e) {
  return Array.isArray(e) ? e : Lk(e) ? [] : [e];
}
function cq(e, t) {
  var n, r, i, s;
  if (t)
    for (s = Object.keys(t), n = 0, r = s.length; n < r; n += 1)
      i = s[n], e[i] = t[i];
  return e;
}
function uq(e, t) {
  var n = "", r;
  for (r = 0; r < t; r += 1)
    n += e;
  return n;
}
function fq(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
var dq = Lk, hq = aq, pq = lq, mq = uq, gq = fq, vq = cq, Zt = {
  isNothing: dq,
  isObject: hq,
  toArray: pq,
  repeat: mq,
  isNegativeZero: gq,
  extend: vq
};
function Mk(e, t) {
  var n = "", r = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '), n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (n += `

` + e.mark.snippet), r + " " + n) : r;
}
function $c(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = Mk(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
$c.prototype = Object.create(Error.prototype);
$c.prototype.constructor = $c;
$c.prototype.toString = function(t) {
  return this.name + ": " + Mk(this, t);
};
var En = $c;
function mm(e, t, n, r, i) {
  var s = "", o = "", a = Math.floor(i / 2) - 1;
  return r - t > a && (s = " ... ", t = r - a + s.length), n - r > a && (o = " ...", n = r + a - o.length), {
    str: s + e.slice(t, n).replace(/\t/g, "→") + o,
    pos: r - t + s.length
    // relative position
  };
}
function gm(e, t) {
  return Zt.repeat(" ", t - e.length) + e;
}
function yq(e, t) {
  if (t = Object.create(t || null), !e.buffer) return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], s, o = -1; s = n.exec(e.buffer); )
    i.push(s.index), r.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = r.length - 2);
  o < 0 && (o = r.length - 1);
  var a = "", l, c, u = Math.min(e.line + t.linesAfter, i.length).toString().length, f = t.maxLength - (t.indent + u + 3);
  for (l = 1; l <= t.linesBefore && !(o - l < 0); l++)
    c = mm(
      e.buffer,
      r[o - l],
      i[o - l],
      e.position - (r[o] - r[o - l]),
      f
    ), a = Zt.repeat(" ", t.indent) + gm((e.line - l + 1).toString(), u) + " | " + c.str + `
` + a;
  for (c = mm(e.buffer, r[o], i[o], e.position, f), a += Zt.repeat(" ", t.indent) + gm((e.line + 1).toString(), u) + " | " + c.str + `
`, a += Zt.repeat("-", t.indent + u + 3 + c.pos) + `^
`, l = 1; l <= t.linesAfter && !(o + l >= i.length); l++)
    c = mm(
      e.buffer,
      r[o + l],
      i[o + l],
      e.position - (r[o] - r[o + l]),
      f
    ), a += Zt.repeat(" ", t.indent) + gm((e.line + l + 1).toString(), u) + " | " + c.str + `
`;
  return a.replace(/\n$/, "");
}
var xq = yq, wq = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], _q = [
  "scalar",
  "sequence",
  "mapping"
];
function bq(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(n) {
    e[n].forEach(function(r) {
      t[String(r)] = n;
    });
  }), t;
}
function Cq(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(n) {
    if (wq.indexOf(n) === -1)
      throw new En('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(n) {
    return n;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = bq(t.styleAliases || null), _q.indexOf(this.kind) === -1)
    throw new En('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var fn = Cq;
function v4(e, t) {
  var n = [];
  return e[t].forEach(function(r) {
    var i = n.length;
    n.forEach(function(s, o) {
      s.tag === r.tag && s.kind === r.kind && s.multi === r.multi && (i = o);
    }), n[i] = r;
  }), n;
}
function Eq() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, n;
  function r(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, n = arguments.length; t < n; t += 1)
    arguments[t].forEach(r);
  return e;
}
function V0(e) {
  return this.extend(e);
}
V0.prototype.extend = function(t) {
  var n = [], r = [];
  if (t instanceof fn)
    r.push(t);
  else if (Array.isArray(t))
    r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
  else
    throw new En("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(s) {
    if (!(s instanceof fn))
      throw new En("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new En("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new En("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(s) {
    if (!(s instanceof fn))
      throw new En("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(V0.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = v4(i, "implicit"), i.compiledExplicit = v4(i, "explicit"), i.compiledTypeMap = Eq(i.compiledImplicit, i.compiledExplicit), i;
};
var Ok = V0, Pk = new fn("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), Dk = new fn("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), Fk = new fn("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), Rk = new Ok({
  explicit: [
    Pk,
    Dk,
    Fk
  ]
});
function Sq(e) {
  if (e === null) return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function kq() {
  return null;
}
function Tq(e) {
  return e === null;
}
var $k = new fn("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: Sq,
  construct: kq,
  predicate: Tq,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function Aq(e) {
  if (e === null) return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function Nq(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function Iq(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Vk = new fn("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Aq,
  construct: Nq,
  predicate: Iq,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function Lq(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function Mq(e) {
  return 48 <= e && e <= 55;
}
function Oq(e) {
  return 48 <= e && e <= 57;
}
function Pq(e) {
  if (e === null) return !1;
  var t = e.length, n = 0, r = !1, i;
  if (!t) return !1;
  if (i = e[n], (i === "-" || i === "+") && (i = e[++n]), i === "0") {
    if (n + 1 === t) return !0;
    if (i = e[++n], i === "b") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!Lq(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!Mq(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < t; n++)
    if (i = e[n], i !== "_") {
      if (!Oq(e.charCodeAt(n)))
        return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function Dq(e) {
  var t = e, n = 1, r;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), r = t[0], (r === "-" || r === "+") && (r === "-" && (n = -1), t = t.slice(1), r = t[0]), t === "0") return 0;
  if (r === "0") {
    if (t[1] === "b") return n * parseInt(t.slice(2), 2);
    if (t[1] === "x") return n * parseInt(t.slice(2), 16);
    if (t[1] === "o") return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function Fq(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !Zt.isNegativeZero(e);
}
var Bk = new fn("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: Pq,
  construct: Dq,
  predicate: Fq,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), Rq = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function $q(e) {
  return !(e === null || !Rq.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function Vq(e) {
  var t, n;
  return t = e.replace(/_/g, "").toLowerCase(), n = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : n * parseFloat(t, 10);
}
var Bq = /^[-+]?[0-9]+e/;
function zq(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Zt.isNegativeZero(e))
    return "-0.0";
  return n = e.toString(10), Bq.test(n) ? n.replace("e", ".e") : n;
}
function Hq(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Zt.isNegativeZero(e));
}
var zk = new fn("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: $q,
  construct: Vq,
  predicate: Hq,
  represent: zq,
  defaultStyle: "lowercase"
}), Hk = Rk.extend({
  implicit: [
    $k,
    Vk,
    Bk,
    zk
  ]
}), Uk = Hk, jk = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Wk = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function Uq(e) {
  return e === null ? !1 : jk.exec(e) !== null || Wk.exec(e) !== null;
}
function jq(e) {
  var t, n, r, i, s, o, a, l = 0, c = null, u, f, d;
  if (t = jk.exec(e), t === null && (t = Wk.exec(e)), t === null) throw new Error("Date resolve error");
  if (n = +t[1], r = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(n, r, i));
  if (s = +t[4], o = +t[5], a = +t[6], t[7]) {
    for (l = t[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return t[9] && (u = +t[10], f = +(t[11] || 0), c = (u * 60 + f) * 6e4, t[9] === "-" && (c = -c)), d = new Date(Date.UTC(n, r, i, s, o, a, l)), c && d.setTime(d.getTime() - c), d;
}
function Wq(e) {
  return e.toISOString();
}
var Jk = new fn("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: Uq,
  construct: jq,
  instanceOf: Date,
  represent: Wq
});
function Jq(e) {
  return e === "<<" || e === null;
}
var Kk = new fn("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: Jq
}), rx = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function Kq(e) {
  if (e === null) return !1;
  var t, n, r = 0, i = e.length, s = rx;
  for (n = 0; n < i; n++)
    if (t = s.indexOf(e.charAt(n)), !(t > 64)) {
      if (t < 0) return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function qq(e) {
  var t, n, r = e.replace(/[\r\n=]/g, ""), i = r.length, s = rx, o = 0, a = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(r.charAt(t));
  return n = i % 4 * 6, n === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : n === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : n === 12 && a.push(o >> 4 & 255), new Uint8Array(a);
}
function Gq(e) {
  var t = "", n = 0, r, i, s = e.length, o = rx;
  for (r = 0; r < s; r++)
    r % 3 === 0 && r && (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]), n = (n << 8) + e[r];
  return i = s % 3, i === 0 ? (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]) : i === 2 ? (t += o[n >> 10 & 63], t += o[n >> 4 & 63], t += o[n << 2 & 63], t += o[64]) : i === 1 && (t += o[n >> 2 & 63], t += o[n << 4 & 63], t += o[64], t += o[64]), t;
}
function Yq(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var qk = new fn("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: Kq,
  construct: qq,
  predicate: Yq,
  represent: Gq
}), Xq = Object.prototype.hasOwnProperty, Zq = Object.prototype.toString;
function Qq(e) {
  if (e === null) return !0;
  var t = [], n, r, i, s, o, a = e;
  for (n = 0, r = a.length; n < r; n += 1) {
    if (i = a[n], o = !1, Zq.call(i) !== "[object Object]") return !1;
    for (s in i)
      if (Xq.call(i, s))
        if (!o) o = !0;
        else return !1;
    if (!o) return !1;
    if (t.indexOf(s) === -1) t.push(s);
    else return !1;
  }
  return !0;
}
function eG(e) {
  return e !== null ? e : [];
}
var Gk = new fn("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Qq,
  construct: eG
}), tG = Object.prototype.toString;
function nG(e) {
  if (e === null) return !0;
  var t, n, r, i, s, o = e;
  for (s = new Array(o.length), t = 0, n = o.length; t < n; t += 1) {
    if (r = o[t], tG.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1)) return !1;
    s[t] = [i[0], r[i[0]]];
  }
  return !0;
}
function rG(e) {
  if (e === null) return [];
  var t, n, r, i, s, o = e;
  for (s = new Array(o.length), t = 0, n = o.length; t < n; t += 1)
    r = o[t], i = Object.keys(r), s[t] = [i[0], r[i[0]]];
  return s;
}
var Yk = new fn("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: nG,
  construct: rG
}), iG = Object.prototype.hasOwnProperty;
function sG(e) {
  if (e === null) return !0;
  var t, n = e;
  for (t in n)
    if (iG.call(n, t) && n[t] !== null)
      return !1;
  return !0;
}
function oG(e) {
  return e !== null ? e : {};
}
var Xk = new fn("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: sG,
  construct: oG
}), ix = Uk.extend({
  implicit: [
    Jk,
    Kk
  ],
  explicit: [
    qk,
    Gk,
    Yk,
    Xk
  ]
}), qs = Object.prototype.hasOwnProperty, ph = 1, Zk = 2, Qk = 3, mh = 4, vm = 1, aG = 2, y4 = 3, lG = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, cG = /[\x85\u2028\u2029]/, uG = /[,\[\]\{\}]/, eT = /^(?:!|!!|![a-z\-]+!)$/i, tT = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function x4(e) {
  return Object.prototype.toString.call(e);
}
function mi(e) {
  return e === 10 || e === 13;
}
function To(e) {
  return e === 9 || e === 32;
}
function Hn(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Ca(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function fG(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function dG(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function hG(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function w4(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function pG(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var nT = new Array(256), rT = new Array(256);
for (var ua = 0; ua < 256; ua++)
  nT[ua] = w4(ua) ? 1 : 0, rT[ua] = w4(ua);
function mG(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || ix, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function iT(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return n.snippet = xq(n), new En(t, n);
}
function Me(e, t) {
  throw iT(e, t);
}
function gh(e, t) {
  e.onWarning && e.onWarning.call(null, iT(e, t));
}
var _4 = {
  YAML: function(t, n, r) {
    var i, s, o;
    t.version !== null && Me(t, "duplication of %YAML directive"), r.length !== 1 && Me(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && Me(t, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && Me(t, "unacceptable YAML version of the document"), t.version = r[0], t.checkLineBreaks = o < 2, o !== 1 && o !== 2 && gh(t, "unsupported YAML version of the document");
  },
  TAG: function(t, n, r) {
    var i, s;
    r.length !== 2 && Me(t, "TAG directive accepts exactly two arguments"), i = r[0], s = r[1], eT.test(i) || Me(t, "ill-formed tag handle (first argument) of the TAG directive"), qs.call(t.tagMap, i) && Me(t, 'there is a previously declared suffix for "' + i + '" tag handle'), tT.test(s) || Me(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      Me(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[i] = s;
  }
};
function Fs(e, t, n, r) {
  var i, s, o, a;
  if (t < n) {
    if (a = e.input.slice(t, n), r)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || Me(e, "expected valid JSON character");
    else lG.test(a) && Me(e, "the stream contains non-printable characters");
    e.result += a;
  }
}
function b4(e, t, n, r) {
  var i, s, o, a;
  for (Zt.isObject(n) || Me(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, a = i.length; o < a; o += 1)
    s = i[o], qs.call(t, s) || (t[s] = n[s], r[s] = !0);
}
function Ea(e, t, n, r, i, s, o, a, l) {
  var c, u;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, u = i.length; c < u; c += 1)
      Array.isArray(i[c]) && Me(e, "nested arrays are not supported inside keys"), typeof i == "object" && x4(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (typeof i == "object" && x4(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (c = 0, u = s.length; c < u; c += 1)
        b4(e, t, s[c], n);
    else
      b4(e, t, s, n);
  else
    !e.json && !qs.call(n, i) && qs.call(t, i) && (e.line = o || e.line, e.lineStart = a || e.lineStart, e.position = l || e.position, Me(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[i] = s, delete n[i];
  return t;
}
function sx(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : Me(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function jt(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; To(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (mi(i))
      for (sx(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && e.lineIndent < n && gh(e, "deficient indentation"), r;
}
function Up(e) {
  var t = e.position, n;
  return n = e.input.charCodeAt(t), !!((n === 45 || n === 46) && n === e.input.charCodeAt(t + 1) && n === e.input.charCodeAt(t + 2) && (t += 3, n = e.input.charCodeAt(t), n === 0 || Hn(n)));
}
function ox(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Zt.repeat(`
`, t - 1));
}
function gG(e, t, n) {
  var r, i, s, o, a, l, c, u, f = e.kind, d = e.result, h;
  if (h = e.input.charCodeAt(e.position), Hn(h) || Ca(h) || h === 35 || h === 38 || h === 42 || h === 33 || h === 124 || h === 62 || h === 39 || h === 34 || h === 37 || h === 64 || h === 96 || (h === 63 || h === 45) && (i = e.input.charCodeAt(e.position + 1), Hn(i) || n && Ca(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = o = e.position, a = !1; h !== 0; ) {
    if (h === 58) {
      if (i = e.input.charCodeAt(e.position + 1), Hn(i) || n && Ca(i))
        break;
    } else if (h === 35) {
      if (r = e.input.charCodeAt(e.position - 1), Hn(r))
        break;
    } else {
      if (e.position === e.lineStart && Up(e) || n && Ca(h))
        break;
      if (mi(h))
        if (l = e.line, c = e.lineStart, u = e.lineIndent, jt(e, !1, -1), e.lineIndent >= t) {
          a = !0, h = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = l, e.lineStart = c, e.lineIndent = u;
          break;
        }
    }
    a && (Fs(e, s, o, !1), ox(e, e.line - l), s = o = e.position, a = !1), To(h) || (o = e.position + 1), h = e.input.charCodeAt(++e.position);
  }
  return Fs(e, s, o, !1), e.result ? !0 : (e.kind = f, e.result = d, !1);
}
function vG(e, t) {
  var n, r, i;
  if (n = e.input.charCodeAt(e.position), n !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if (Fs(e, r, e.position, !0), n = e.input.charCodeAt(++e.position), n === 39)
        r = e.position, e.position++, i = e.position;
      else
        return !0;
    else mi(n) ? (Fs(e, r, i, !0), ox(e, jt(e, !1, t)), r = i = e.position) : e.position === e.lineStart && Up(e) ? Me(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  Me(e, "unexpected end of the stream within a single quoted scalar");
}
function yG(e, t) {
  var n, r, i, s, o, a;
  if (a = e.input.charCodeAt(e.position), a !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; (a = e.input.charCodeAt(e.position)) !== 0; ) {
    if (a === 34)
      return Fs(e, n, e.position, !0), e.position++, !0;
    if (a === 92) {
      if (Fs(e, n, e.position, !0), a = e.input.charCodeAt(++e.position), mi(a))
        jt(e, !1, t);
      else if (a < 256 && nT[a])
        e.result += rT[a], e.position++;
      else if ((o = dG(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = e.input.charCodeAt(++e.position), (o = fG(a)) >= 0 ? s = (s << 4) + o : Me(e, "expected hexadecimal character");
        e.result += pG(s), e.position++;
      } else
        Me(e, "unknown escape sequence");
      n = r = e.position;
    } else mi(a) ? (Fs(e, n, r, !0), ox(e, jt(e, !1, t)), n = r = e.position) : e.position === e.lineStart && Up(e) ? Me(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
  }
  Me(e, "unexpected end of the stream within a double quoted scalar");
}
function xG(e, t) {
  var n = !0, r, i, s, o = e.tag, a, l = e.anchor, c, u, f, d, h, m = /* @__PURE__ */ Object.create(null), p, y, v, g;
  if (g = e.input.charCodeAt(e.position), g === 91)
    u = 93, h = !1, a = [];
  else if (g === 123)
    u = 125, h = !0, a = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), g = e.input.charCodeAt(++e.position); g !== 0; ) {
    if (jt(e, !0, t), g = e.input.charCodeAt(e.position), g === u)
      return e.position++, e.tag = o, e.anchor = l, e.kind = h ? "mapping" : "sequence", e.result = a, !0;
    n ? g === 44 && Me(e, "expected the node content, but found ','") : Me(e, "missed comma between flow collection entries"), y = p = v = null, f = d = !1, g === 63 && (c = e.input.charCodeAt(e.position + 1), Hn(c) && (f = d = !0, e.position++, jt(e, !0, t))), r = e.line, i = e.lineStart, s = e.position, nl(e, t, ph, !1, !0), y = e.tag, p = e.result, jt(e, !0, t), g = e.input.charCodeAt(e.position), (d || e.line === r) && g === 58 && (f = !0, g = e.input.charCodeAt(++e.position), jt(e, !0, t), nl(e, t, ph, !1, !0), v = e.result), h ? Ea(e, a, m, y, p, v, r, i, s) : f ? a.push(Ea(e, null, m, y, p, v, r, i, s)) : a.push(p), jt(e, !0, t), g = e.input.charCodeAt(e.position), g === 44 ? (n = !0, g = e.input.charCodeAt(++e.position)) : n = !1;
  }
  Me(e, "unexpected end of the stream within a flow collection");
}
function wG(e, t) {
  var n, r, i = vm, s = !1, o = !1, a = t, l = 0, c = !1, u, f;
  if (f = e.input.charCodeAt(e.position), f === 124)
    r = !1;
  else if (f === 62)
    r = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (f = e.input.charCodeAt(++e.position), f === 43 || f === 45)
      vm === i ? i = f === 43 ? y4 : aG : Me(e, "repeat of a chomping mode identifier");
    else if ((u = hG(f)) >= 0)
      u === 0 ? Me(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? Me(e, "repeat of an indentation width identifier") : (a = t + u - 1, o = !0);
    else
      break;
  if (To(f)) {
    do
      f = e.input.charCodeAt(++e.position);
    while (To(f));
    if (f === 35)
      do
        f = e.input.charCodeAt(++e.position);
      while (!mi(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (sx(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position); (!o || e.lineIndent < a) && f === 32; )
      e.lineIndent++, f = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > a && (a = e.lineIndent), mi(f)) {
      l++;
      continue;
    }
    if (e.lineIndent < a) {
      i === y4 ? e.result += Zt.repeat(`
`, s ? 1 + l : l) : i === vm && s && (e.result += `
`);
      break;
    }
    for (r ? To(f) ? (c = !0, e.result += Zt.repeat(`
`, s ? 1 + l : l)) : c ? (c = !1, e.result += Zt.repeat(`
`, l + 1)) : l === 0 ? s && (e.result += " ") : e.result += Zt.repeat(`
`, l) : e.result += Zt.repeat(`
`, s ? 1 + l : l), s = !0, o = !0, l = 0, n = e.position; !mi(f) && f !== 0; )
      f = e.input.charCodeAt(++e.position);
    Fs(e, n, e.position, !1);
  }
  return !0;
}
function C4(e, t) {
  var n, r = e.tag, i = e.anchor, s = [], o, a = !1, l;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), l = e.input.charCodeAt(e.position); l !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Me(e, "tab characters must not be used in indentation")), !(l !== 45 || (o = e.input.charCodeAt(e.position + 1), !Hn(o)))); ) {
    if (a = !0, e.position++, jt(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), l = e.input.charCodeAt(e.position);
      continue;
    }
    if (n = e.line, nl(e, t, Qk, !1, !0), s.push(e.result), jt(e, !0, -1), l = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && l !== 0)
      Me(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return a ? (e.tag = r, e.anchor = i, e.kind = "sequence", e.result = s, !0) : !1;
}
function _G(e, t, n) {
  var r, i, s, o, a, l, c = e.tag, u = e.anchor, f = {}, d = /* @__PURE__ */ Object.create(null), h = null, m = null, p = null, y = !1, v = !1, g;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = f), g = e.input.charCodeAt(e.position); g !== 0; ) {
    if (!y && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Me(e, "tab characters must not be used in indentation")), r = e.input.charCodeAt(e.position + 1), s = e.line, (g === 63 || g === 58) && Hn(r))
      g === 63 ? (y && (Ea(e, f, d, h, m, null, o, a, l), h = m = p = null), v = !0, y = !0, i = !0) : y ? (y = !1, i = !0) : Me(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, g = r;
    else {
      if (o = e.line, a = e.lineStart, l = e.position, !nl(e, n, Zk, !1, !0))
        break;
      if (e.line === s) {
        for (g = e.input.charCodeAt(e.position); To(g); )
          g = e.input.charCodeAt(++e.position);
        if (g === 58)
          g = e.input.charCodeAt(++e.position), Hn(g) || Me(e, "a whitespace character is expected after the key-value separator within a block mapping"), y && (Ea(e, f, d, h, m, null, o, a, l), h = m = p = null), v = !0, y = !1, i = !1, h = e.tag, m = e.result;
        else if (v)
          Me(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = c, e.anchor = u, !0;
      } else if (v)
        Me(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = c, e.anchor = u, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (y && (o = e.line, a = e.lineStart, l = e.position), nl(e, t, mh, !0, i) && (y ? m = e.result : p = e.result), y || (Ea(e, f, d, h, m, p, o, a, l), h = m = p = null), jt(e, !0, -1), g = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && g !== 0)
      Me(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return y && Ea(e, f, d, h, m, null, o, a, l), v && (e.tag = c, e.anchor = u, e.kind = "mapping", e.result = f), v;
}
function bG(e) {
  var t, n = !1, r = !1, i, s, o;
  if (o = e.input.charCodeAt(e.position), o !== 33) return !1;
  if (e.tag !== null && Me(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (n = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (r = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, n) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), o = e.input.charCodeAt(++e.position)) : Me(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !Hn(o); )
      o === 33 && (r ? Me(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), eT.test(i) || Me(e, "named tag handle cannot contain such characters"), r = !0, t = e.position + 1)), o = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), uG.test(s) && Me(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !tT.test(s) && Me(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    Me(e, "tag name is malformed: " + s);
  }
  return n ? e.tag = s : qs.call(e.tagMap, i) ? e.tag = e.tagMap[i] + s : i === "!" ? e.tag = "!" + s : i === "!!" ? e.tag = "tag:yaml.org,2002:" + s : Me(e, 'undeclared tag handle "' + i + '"'), !0;
}
function CG(e) {
  var t, n;
  if (n = e.input.charCodeAt(e.position), n !== 38) return !1;
  for (e.anchor !== null && Me(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !Hn(n) && !Ca(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && Me(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function EG(e) {
  var t, n, r;
  if (r = e.input.charCodeAt(e.position), r !== 42) return !1;
  for (r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Hn(r) && !Ca(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && Me(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), qs.call(e.anchorMap, n) || Me(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], jt(e, !0, -1), !0;
}
function nl(e, t, n, r, i) {
  var s, o, a, l = 1, c = !1, u = !1, f, d, h, m, p, y;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = o = a = mh === n || Qk === n, r && jt(e, !0, -1) && (c = !0, e.lineIndent > t ? l = 1 : e.lineIndent === t ? l = 0 : e.lineIndent < t && (l = -1)), l === 1)
    for (; bG(e) || CG(e); )
      jt(e, !0, -1) ? (c = !0, a = s, e.lineIndent > t ? l = 1 : e.lineIndent === t ? l = 0 : e.lineIndent < t && (l = -1)) : a = !1;
  if (a && (a = c || i), (l === 1 || mh === n) && (ph === n || Zk === n ? p = t : p = t + 1, y = e.position - e.lineStart, l === 1 ? a && (C4(e, y) || _G(e, y, p)) || xG(e, p) ? u = !0 : (o && wG(e, p) || vG(e, p) || yG(e, p) ? u = !0 : EG(e) ? (u = !0, (e.tag !== null || e.anchor !== null) && Me(e, "alias node should not have any properties")) : gG(e, p, ph === n) && (u = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : l === 0 && (u = a && C4(e, y))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && Me(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), f = 0, d = e.implicitTypes.length; f < d; f += 1)
      if (m = e.implicitTypes[f], m.resolve(e.result)) {
        e.result = m.construct(e.result), e.tag = m.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (qs.call(e.typeMap[e.kind || "fallback"], e.tag))
      m = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (m = null, h = e.typeMap.multi[e.kind || "fallback"], f = 0, d = h.length; f < d; f += 1)
        if (e.tag.slice(0, h[f].tag.length) === h[f].tag) {
          m = h[f];
          break;
        }
    m || Me(e, "unknown tag !<" + e.tag + ">"), e.result !== null && m.kind !== e.kind && Me(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + m.kind + '", not "' + e.kind + '"'), m.resolve(e.result, e.tag) ? (e.result = m.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : Me(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || u;
}
function SG(e) {
  var t = e.position, n, r, i, s = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (jt(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = e.input.charCodeAt(++e.position), n = e.position; o !== 0 && !Hn(o); )
      o = e.input.charCodeAt(++e.position);
    for (r = e.input.slice(n, e.position), i = [], r.length < 1 && Me(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; To(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !mi(o));
        break;
      }
      if (mi(o)) break;
      for (n = e.position; o !== 0 && !Hn(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    o !== 0 && sx(e), qs.call(_4, r) ? _4[r](e, r, i) : gh(e, 'unknown document directive "' + r + '"');
  }
  if (jt(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, jt(e, !0, -1)) : s && Me(e, "directives end mark is expected"), nl(e, e.lineIndent - 1, mh, !1, !0), jt(e, !0, -1), e.checkLineBreaks && cG.test(e.input.slice(t, e.position)) && gh(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Up(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, jt(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    Me(e, "end of the stream or a document separator is expected");
  else
    return;
}
function sT(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new mG(e, t), r = e.indexOf("\0");
  for (r !== -1 && (n.position = r, Me(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    SG(n);
  return n.documents;
}
function kG(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && (n = t, t = null);
  var r = sT(e, n);
  if (typeof t != "function")
    return r;
  for (var i = 0, s = r.length; i < s; i += 1)
    t(r[i]);
}
function TG(e, t) {
  var n = sT(e, t);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new En("expected a single document in the stream, but found more");
  }
}
var AG = kG, NG = TG, oT = {
  loadAll: AG,
  load: NG
}, aT = Object.prototype.toString, lT = Object.prototype.hasOwnProperty, ax = 65279, IG = 9, Vc = 10, LG = 13, MG = 32, OG = 33, PG = 34, B0 = 35, DG = 37, FG = 38, RG = 39, $G = 42, cT = 44, VG = 45, vh = 58, BG = 61, zG = 62, HG = 63, UG = 64, uT = 91, fT = 93, jG = 96, dT = 123, WG = 124, hT = 125, yn = {};
yn[0] = "\\0";
yn[7] = "\\a";
yn[8] = "\\b";
yn[9] = "\\t";
yn[10] = "\\n";
yn[11] = "\\v";
yn[12] = "\\f";
yn[13] = "\\r";
yn[27] = "\\e";
yn[34] = '\\"';
yn[92] = "\\\\";
yn[133] = "\\N";
yn[160] = "\\_";
yn[8232] = "\\L";
yn[8233] = "\\P";
var JG = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], KG = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function qG(e, t) {
  var n, r, i, s, o, a, l;
  if (t === null) return {};
  for (n = {}, r = Object.keys(t), i = 0, s = r.length; i < s; i += 1)
    o = r[i], a = String(t[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), l = e.compiledTypeMap.fallback[o], l && lT.call(l.styleAliases, a) && (a = l.styleAliases[a]), n[o] = a;
  return n;
}
function GG(e) {
  var t, n, r;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    n = "x", r = 2;
  else if (e <= 65535)
    n = "u", r = 4;
  else if (e <= 4294967295)
    n = "U", r = 8;
  else
    throw new En("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + Zt.repeat("0", r - t.length) + t;
}
var YG = 1, Bc = 2;
function XG(e) {
  this.schema = e.schema || ix, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = Zt.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = qG(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Bc : YG, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function E4(e, t) {
  for (var n = Zt.repeat(" ", t), r = 0, i = -1, s = "", o, a = e.length; r < a; )
    i = e.indexOf(`
`, r), i === -1 ? (o = e.slice(r), r = a) : (o = e.slice(r, i + 1), r = i + 1), o.length && o !== `
` && (s += n), s += o;
  return s;
}
function z0(e, t) {
  return `
` + Zt.repeat(" ", e.indent * t);
}
function ZG(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1)
    if (i = e.implicitTypes[n], i.resolve(t))
      return !0;
  return !1;
}
function yh(e) {
  return e === MG || e === IG;
}
function zc(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== ax || 65536 <= e && e <= 1114111;
}
function S4(e) {
  return zc(e) && e !== ax && e !== LG && e !== Vc;
}
function k4(e, t, n) {
  var r = S4(e), i = r && !yh(e);
  return (
    // ns-plain-safe
    (n ? (
      // c = flow-in
      r
    ) : r && e !== cT && e !== uT && e !== fT && e !== dT && e !== hT) && e !== B0 && !(t === vh && !i) || S4(t) && !yh(t) && e === B0 || t === vh && i
  );
}
function QG(e) {
  return zc(e) && e !== ax && !yh(e) && e !== VG && e !== HG && e !== vh && e !== cT && e !== uT && e !== fT && e !== dT && e !== hT && e !== B0 && e !== FG && e !== $G && e !== OG && e !== WG && e !== BG && e !== zG && e !== RG && e !== PG && e !== DG && e !== UG && e !== jG;
}
function eY(e) {
  return !yh(e) && e !== vh;
}
function Yl(e, t) {
  var n = e.charCodeAt(t), r;
  return n >= 55296 && n <= 56319 && t + 1 < e.length && (r = e.charCodeAt(t + 1), r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n;
}
function pT(e) {
  var t = /^\n* /;
  return t.test(e);
}
var mT = 1, H0 = 2, gT = 3, vT = 4, va = 5;
function tY(e, t, n, r, i, s, o, a) {
  var l, c = 0, u = null, f = !1, d = !1, h = r !== -1, m = -1, p = QG(Yl(e, 0)) && eY(Yl(e, e.length - 1));
  if (t || o)
    for (l = 0; l < e.length; c >= 65536 ? l += 2 : l++) {
      if (c = Yl(e, l), !zc(c))
        return va;
      p = p && k4(c, u, a), u = c;
    }
  else {
    for (l = 0; l < e.length; c >= 65536 ? l += 2 : l++) {
      if (c = Yl(e, l), c === Vc)
        f = !0, h && (d = d || // Foldable line = too long, and not more-indented.
        l - m - 1 > r && e[m + 1] !== " ", m = l);
      else if (!zc(c))
        return va;
      p = p && k4(c, u, a), u = c;
    }
    d = d || h && l - m - 1 > r && e[m + 1] !== " ";
  }
  return !f && !d ? p && !o && !i(e) ? mT : s === Bc ? va : H0 : n > 9 && pT(e) ? va : o ? s === Bc ? va : H0 : d ? vT : gT;
}
function nY(e, t, n, r, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Bc ? '""' : "''";
    if (!e.noCompatMode && (JG.indexOf(t) !== -1 || KG.test(t)))
      return e.quotingType === Bc ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, n), o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), a = r || e.flowLevel > -1 && n >= e.flowLevel;
    function l(c) {
      return ZG(e, c);
    }
    switch (tY(
      t,
      a,
      e.indent,
      o,
      l,
      e.quotingType,
      e.forceQuotes && !r,
      i
    )) {
      case mT:
        return t;
      case H0:
        return "'" + t.replace(/'/g, "''") + "'";
      case gT:
        return "|" + T4(t, e.indent) + A4(E4(t, s));
      case vT:
        return ">" + T4(t, e.indent) + A4(E4(rY(t, o), s));
      case va:
        return '"' + iY(t) + '"';
      default:
        throw new En("impossible error: invalid scalar style");
    }
  }();
}
function T4(e, t) {
  var n = pT(e) ? String(t) : "", r = e[e.length - 1] === `
`, i = r && (e[e.length - 2] === `
` || e === `
`), s = i ? "+" : r ? "" : "-";
  return n + s + `
`;
}
function A4(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function rY(e, t) {
  for (var n = /(\n+)([^\n]*)/g, r = function() {
    var c = e.indexOf(`
`);
    return c = c !== -1 ? c : e.length, n.lastIndex = c, N4(e.slice(0, c), t);
  }(), i = e[0] === `
` || e[0] === " ", s, o; o = n.exec(e); ) {
    var a = o[1], l = o[2];
    s = l[0] === " ", r += a + (!i && !s && l !== "" ? `
` : "") + N4(l, t), i = s;
  }
  return r;
}
function N4(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var n = / [^ ]/g, r, i = 0, s, o = 0, a = 0, l = ""; r = n.exec(e); )
    a = r.index, a - i > t && (s = o > i ? o : a, l += `
` + e.slice(i, s), i = s + 1), o = a;
  return l += `
`, e.length - i > t && o > i ? l += e.slice(i, o) + `
` + e.slice(o + 1) : l += e.slice(i), l.slice(1);
}
function iY(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? i += 2 : i++)
    n = Yl(e, i), r = yn[n], !r && zc(n) ? (t += e[i], n >= 65536 && (t += e[i + 1])) : t += r || GG(n);
  return t;
}
function sY(e, t, n) {
  var r = "", i = e.tag, s, o, a;
  for (s = 0, o = n.length; s < o; s += 1)
    a = n[s], e.replacer && (a = e.replacer.call(n, String(s), a)), (ns(e, t, a, !1, !1) || typeof a > "u" && ns(e, t, null, !1, !1)) && (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), r += e.dump);
  e.tag = i, e.dump = "[" + r + "]";
}
function I4(e, t, n, r) {
  var i = "", s = e.tag, o, a, l;
  for (o = 0, a = n.length; o < a; o += 1)
    l = n[o], e.replacer && (l = e.replacer.call(n, String(o), l)), (ns(e, t + 1, l, !0, !0, !1, !0) || typeof l > "u" && ns(e, t + 1, null, !0, !0, !1, !0)) && ((!r || i !== "") && (i += z0(e, t)), e.dump && Vc === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = s, e.dump = i || "[]";
}
function oY(e, t, n) {
  var r = "", i = e.tag, s = Object.keys(n), o, a, l, c, u;
  for (o = 0, a = s.length; o < a; o += 1)
    u = "", r !== "" && (u += ", "), e.condenseFlow && (u += '"'), l = s[o], c = n[l], e.replacer && (c = e.replacer.call(n, l, c)), ns(e, t, l, !1, !1) && (e.dump.length > 1024 && (u += "? "), u += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), ns(e, t, c, !1, !1) && (u += e.dump, r += u));
  e.tag = i, e.dump = "{" + r + "}";
}
function aY(e, t, n, r) {
  var i = "", s = e.tag, o = Object.keys(n), a, l, c, u, f, d;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new En("sortKeys must be a boolean or a function");
  for (a = 0, l = o.length; a < l; a += 1)
    d = "", (!r || i !== "") && (d += z0(e, t)), c = o[a], u = n[c], e.replacer && (u = e.replacer.call(n, c, u)), ns(e, t + 1, c, !0, !0, !0) && (f = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, f && (e.dump && Vc === e.dump.charCodeAt(0) ? d += "?" : d += "? "), d += e.dump, f && (d += z0(e, t)), ns(e, t + 1, u, !0, f) && (e.dump && Vc === e.dump.charCodeAt(0) ? d += ":" : d += ": ", d += e.dump, i += d));
  e.tag = s, e.dump = i || "{}";
}
function L4(e, t, n) {
  var r, i, s, o, a, l;
  for (i = n ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (a = i[s], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof t == "object" && t instanceof a.instanceOf) && (!a.predicate || a.predicate(t))) {
      if (n ? a.multi && a.representName ? e.tag = a.representName(t) : e.tag = a.tag : e.tag = "?", a.represent) {
        if (l = e.styleMap[a.tag] || a.defaultStyle, aT.call(a.represent) === "[object Function]")
          r = a.represent(t, l);
        else if (lT.call(a.represent, l))
          r = a.represent[l](t, l);
        else
          throw new En("!<" + a.tag + '> tag resolver accepts not "' + l + '" style');
        e.dump = r;
      }
      return !0;
    }
  return !1;
}
function ns(e, t, n, r, i, s, o) {
  e.tag = null, e.dump = n, L4(e, n, !1) || L4(e, n, !0);
  var a = aT.call(e.dump), l = r, c;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var u = a === "[object Object]" || a === "[object Array]", f, d;
  if (u && (f = e.duplicates.indexOf(n), d = f !== -1), (e.tag !== null && e.tag !== "?" || d || e.indent !== 2 && t > 0) && (i = !1), d && e.usedDuplicates[f])
    e.dump = "*ref_" + f;
  else {
    if (u && d && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0), a === "[object Object]")
      r && Object.keys(e.dump).length !== 0 ? (aY(e, t, e.dump, i), d && (e.dump = "&ref_" + f + e.dump)) : (oY(e, t, e.dump), d && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object Array]")
      r && e.dump.length !== 0 ? (e.noArrayIndent && !o && t > 0 ? I4(e, t - 1, e.dump, i) : I4(e, t, e.dump, i), d && (e.dump = "&ref_" + f + e.dump)) : (sY(e, t, e.dump), d && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object String]")
      e.tag !== "?" && nY(e, e.dump, t, s, l);
    else {
      if (a === "[object Undefined]")
        return !1;
      if (e.skipInvalid) return !1;
      throw new En("unacceptable kind of an object to dump " + a);
    }
    e.tag !== null && e.tag !== "?" && (c = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? c = "!" + c : c.slice(0, 18) === "tag:yaml.org,2002:" ? c = "!!" + c.slice(18) : c = "!<" + c + ">", e.dump = c + " " + e.dump);
  }
  return !0;
}
function lY(e, t) {
  var n = [], r = [], i, s;
  for (U0(e, n, r), i = 0, s = r.length; i < s; i += 1)
    t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(s);
}
function U0(e, t, n) {
  var r, i, s;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, s = e.length; i < s; i += 1)
        U0(e[i], t, n);
    else
      for (r = Object.keys(e), i = 0, s = r.length; i < s; i += 1)
        U0(e[r[i]], t, n);
}
function cY(e, t) {
  t = t || {};
  var n = new XG(t);
  n.noRefs || lY(e, n);
  var r = e;
  return n.replacer && (r = n.replacer.call({ "": r }, "", r)), ns(n, 0, r, !0, !0) ? n.dump + `
` : "";
}
var uY = cY, fY = {
  dump: uY
};
function lx(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
var dY = fn, hY = Ok, pY = Rk, mY = Hk, gY = Uk, vY = ix, yY = oT.load, xY = oT.loadAll, wY = fY.dump, _Y = En, bY = {
  binary: qk,
  float: zk,
  map: Fk,
  null: $k,
  pairs: Yk,
  set: Xk,
  timestamp: Jk,
  bool: Vk,
  int: Bk,
  merge: Kk,
  omap: Gk,
  seq: Dk,
  str: Pk
}, CY = lx("safeLoad", "load"), EY = lx("safeLoadAll", "loadAll"), SY = lx("safeDump", "dump"), M4 = {
  Type: dY,
  Schema: hY,
  FAILSAFE_SCHEMA: pY,
  JSON_SCHEMA: mY,
  CORE_SCHEMA: gY,
  DEFAULT_SCHEMA: vY,
  load: yY,
  loadAll: xY,
  dump: wY,
  YAMLException: _Y,
  types: bY,
  safeLoad: CY,
  safeLoadAll: EY,
  safeDump: SY
};
const kY = ({ yaml: e, onChange: t }) => {
  const [n, r, i, s] = On(
    Cr,
    Yo,
    ir,
    xh
  ), o = Kn(), a = It(xh), l = It(yT), c = T.useMemo(() => e ? Object.entries(M4.load(e)).map(([v, g]) => ({ key: v, value: g })) : [], [e]), { register: u, control: f, handleSubmit: d } = Hp({
    defaultValues: {
      yamlConfig: c
    }
  }), { fields: h, append: m, remove: p } = TJ({
    control: f,
    name: "yamlConfig"
  }), y = T.useCallback(
    ({ yamlConfig: v }) => {
      if (v.length === 0) {
        l(), a(!1);
        return;
      }
      const g = v.reduce((x, { key: _, value: b }) => (_ && b && (x[_] = b), x), {});
      t(M4.dump(g).trim()), a(!1);
    },
    [t, a, l]
  );
  return /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(
    w8,
    {
      open: s,
      onOpenChange: (v) => {
        a(v);
      }
    },
    /* @__PURE__ */ T.createElement(_8, { container: r == null ? void 0 : r.current }, /* @__PURE__ */ T.createElement(b8, { className: de.dialogOverlay }), /* @__PURE__ */ T.createElement(C8, { className: de.largeDialogContent, "data-editor-type": "frontmatter" }, /* @__PURE__ */ T.createElement(E8, { className: de.dialogTitle }, o("frontmatterEditor.title", "Edit document frontmatter")), /* @__PURE__ */ T.createElement(
      "form",
      {
        onSubmit: (v) => {
          d(y)(v), v.stopPropagation();
        },
        onReset: (v) => {
          v.stopPropagation(), a(!1);
        }
      },
      /* @__PURE__ */ T.createElement("table", { className: de.propertyEditorTable }, /* @__PURE__ */ T.createElement("colgroup", null, /* @__PURE__ */ T.createElement("col", null), /* @__PURE__ */ T.createElement("col", null), /* @__PURE__ */ T.createElement("col", null)), /* @__PURE__ */ T.createElement("thead", null, /* @__PURE__ */ T.createElement("tr", null, /* @__PURE__ */ T.createElement("th", null, o("frontmatterEditor.key", "Key")), /* @__PURE__ */ T.createElement("th", null, o("frontmatterEditor.value", "Value")), /* @__PURE__ */ T.createElement("th", null))), /* @__PURE__ */ T.createElement("tbody", null, h.map((v, g) => /* @__PURE__ */ T.createElement("tr", { key: v.id }, /* @__PURE__ */ T.createElement("td", null, /* @__PURE__ */ T.createElement(O4, { ...u(`yamlConfig.${g}.key`, { required: !0 }), autofocusIfEmpty: !0, readOnly: n })), /* @__PURE__ */ T.createElement("td", null, /* @__PURE__ */ T.createElement(O4, { ...u(`yamlConfig.${g}.value`, { required: !0 }), readOnly: n })), /* @__PURE__ */ T.createElement("td", null, /* @__PURE__ */ T.createElement(
        "button",
        {
          type: "button",
          onClick: () => {
            p(g);
          },
          className: de.iconButton,
          disabled: n
        },
        i("delete_big")
      ))))), /* @__PURE__ */ T.createElement("tfoot", null, /* @__PURE__ */ T.createElement("tr", null, /* @__PURE__ */ T.createElement("td", null, /* @__PURE__ */ T.createElement(
        "button",
        {
          disabled: n,
          className: rt(de.primaryButton, de.smallButton),
          type: "button",
          onClick: () => {
            m({ key: "", value: "" });
          }
        },
        o("frontmatterEditor.addEntry", "Add entry")
      ))))),
      /* @__PURE__ */ T.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } }, /* @__PURE__ */ T.createElement("button", { type: "submit", className: de.primaryButton }, o("dialogControls.save", "Save")), /* @__PURE__ */ T.createElement("button", { type: "reset", className: de.secondaryButton }, o("dialogControls.cancel", "Cancel")))
    ), /* @__PURE__ */ T.createElement(S8, { asChild: !0 }, /* @__PURE__ */ T.createElement("button", { className: de.dialogCloseButton, "aria-label": o("dialogControls.cancel", "Cancel") }, i("close")))))
  ));
}, O4 = T.forwardRef(({ className: e, autofocusIfEmpty: t, ...n }, r) => /* @__PURE__ */ T.createElement("input", { className: rt(de.propertyEditorInput, e), ...n, ref: r }));
var TY = Object.defineProperty, AY = (e, t, n) => t in e ? TY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, NY = (e, t, n) => (AY(e, t + "", n), n);
class Cu extends bi {
  constructor(t, n) {
    super(n), NY(this, "__yaml"), this.__yaml = t;
  }
  static getType() {
    return "frontmatter";
  }
  static clone(t) {
    return new Cu(t.__yaml, t.__key);
  }
  static importJSON(t) {
    const { yaml: n } = t;
    return jp(n);
  }
  exportJSON() {
    return {
      yaml: this.getYaml(),
      type: "frontmatter",
      version: 1
    };
  }
  // View
  createDOM(t) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getYaml() {
    return this.getLatest().__yaml;
  }
  setYaml(t) {
    t !== this.__yaml && (this.getWritable().__yaml = t);
  }
  decorate(t) {
    return /* @__PURE__ */ T.createElement(
      kY,
      {
        yaml: this.getYaml(),
        onChange: (n) => {
          t.update(() => {
            this.setYaml(n);
          });
        }
      }
    );
  }
  isKeyboardSelectable() {
    return !1;
  }
}
function jp(e) {
  return new Cu(e);
}
function Ao(e) {
  return e instanceof Cu;
}
const IY = {
  testLexicalNode: Ao,
  visitLexicalNode: ({ actions: e, lexicalNode: t }) => {
    e.addAndStepInto("yaml", { value: t.getYaml() });
  }
}, LY = {
  testNode: "yaml",
  visitNode({ mdastNode: e, actions: t }) {
    t.addAndStepInto(jp(e.value));
  }
}, xh = Te(!1), MY = _i((e) => {
  e.sub(e.pipe(MY, Tt(Gr)), ([, t]) => {
    t == null || t.update(() => {
      const n = Xe().getFirstChild();
      if (!Ao(n)) {
        const r = jp('"": ""');
        n ? n.insertBefore(r) : Xe().append(r);
      }
    }), e.pub(xh, !0);
  });
}), yT = _i((e) => {
  e.sub(e.pipe(yT, Tt(Gr)), ([, t]) => {
    t == null || t.update(() => {
      const n = Xe().getFirstChild();
      Ao(n) && n.remove();
    }), e.pub(xh, !1);
  });
}), OY = Te(!1, (e) => {
  e.pub(Cp, (t) => t.registerUpdateListener(({ editorState: n }) => {
    n.read(() => {
      e.pub(OY, Ao(Xe().getFirstChild()));
    });
  }));
}), PY = Jn({
  init: (e) => {
    e.pubIn({
      [Ya]: tq("yaml"),
      [Ga]: ZK(),
      [Yr]: Cu,
      [Er]: LY,
      [Xr]: IY,
      [pu]: sq("yaml"),
      [Cp]: (t) => t.registerCommand(
        rv,
        (n) => {
          let r = !1;
          return t.read(() => {
            const i = ge();
            if (fe(i))
              if (i.isCollapsed() && i.anchor.offset === 0 && i.focus.offset === 0 && n.key === "Backspace") {
                let s = i.getNodes()[0];
                ye(s) && (s = s.getParent());
                const o = s == null ? void 0 : s.getPreviousSibling();
                Ao(o) && (r = !0, n.preventDefault());
              } else {
                const s = i.getNodes()[0];
                if (Ao(s)) {
                  const o = s.getYaml();
                  setTimeout(() => {
                    t.update(
                      () => {
                        const a = Xe().getFirstChild();
                        Ao(a) || Xe().splice(0, 0, [jp(o)]);
                      },
                      { discrete: !0 }
                    );
                  });
                }
              }
          }), !!r;
        },
        zr
      )
    });
  }
}), DY = {
  testNode: "blockquote",
  visitNode({ actions: e }) {
    e.addAndStepInto(au());
  }
}, FY = {
  testLexicalNode: Jg,
  visitLexicalNode: ({ lexicalNode: e, mdastParent: t, actions: n }) => {
    const r = { type: "paragraph", children: [] };
    n.appendToParent(t, { type: "blockquote", children: [r] }), n.visitChildren(e, r);
  }
}, RY = Jn({
  init(e) {
    e.pubIn({
      [vl]: "quote",
      [Er]: DY,
      [Yr]: ml,
      [Xr]: FY
    });
  }
});
function $Y() {
  return {
    enter: {
      mdxFlowExpression: BY,
      mdxTextExpression: zY
    },
    exit: {
      mdxFlowExpression: P4,
      mdxFlowExpressionChunk: D4,
      mdxTextExpression: P4,
      mdxTextExpressionChunk: D4
    }
  };
}
function VY() {
  return {
    handlers: {
      mdxFlowExpression: F4,
      mdxTextExpression: F4
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "{" }
    ]
  };
}
function BY(e) {
  this.enter({ type: "mdxFlowExpression", value: "" }, e), this.buffer();
}
function zY(e) {
  this.enter({ type: "mdxTextExpression", value: "" }, e), this.buffer();
}
function P4(e) {
  const t = this.resume(), n = e.estree, r = this.stack[this.stack.length - 1];
  r.type === "mdxFlowExpression" || r.type, this.exit(e), r.value = t, n && (r.data = { estree: n });
}
function D4(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function F4(e, t, n) {
  const r = e.value || "";
  return "{" + n.indentLines(r, function(s, o, a) {
    return (o === 0 || a ? "" : "  ") + s;
  }) + "}";
}
function HY() {
  return {
    enter: { mdxjsEsm: jY },
    exit: { mdxjsEsm: WY, mdxjsEsmData: JY }
  };
}
function UY() {
  return { handlers: { mdxjsEsm: KY } };
}
function jY(e) {
  this.enter({ type: "mdxjsEsm", value: "" }, e), this.buffer();
}
function WY(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, this.exit(e);
  const r = e.estree;
  n.value = t, r && (n.data = { estree: r });
}
function JY(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function KY(e) {
  return e.value || "";
}
function xT() {
  return [
    $Y(),
    Vd(),
    HY()
  ];
}
function cx(e) {
  return {
    extensions: [
      VY(),
      Hv(e),
      UY()
    ]
  };
}
var qY = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], wT = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], GY = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", _T = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", ym = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, xm = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", YY = {
  5: xm,
  "5module": xm + " export import",
  6: xm + " const class extends export import super"
}, XY = /^in(stanceof)?$/, ZY = new RegExp("[" + _T + "]"), QY = new RegExp("[" + _T + GY + "]");
function j0(e, t) {
  for (var n = 65536, r = 0; r < t.length; r += 2) {
    if (n += t[r], n > e)
      return !1;
    if (n += t[r + 1], n >= e)
      return !0;
  }
  return !1;
}
function Jr(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && ZY.test(String.fromCharCode(e)) : t === !1 ? !1 : j0(e, wT);
}
function rs(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && QY.test(String.fromCharCode(e)) : t === !1 ? !1 : j0(e, wT) || j0(e, qY);
}
var nt = function(t, n) {
  n === void 0 && (n = {}), this.label = t, this.keyword = n.keyword, this.beforeExpr = !!n.beforeExpr, this.startsExpr = !!n.startsExpr, this.isLoop = !!n.isLoop, this.isAssign = !!n.isAssign, this.prefix = !!n.prefix, this.postfix = !!n.postfix, this.binop = n.binop || null, this.updateContext = null;
};
function ar(e, t) {
  return new nt(e, { beforeExpr: !0, binop: t });
}
var lr = { beforeExpr: !0 }, $n = { startsExpr: !0 }, Wp = {};
function tt(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, Wp[e] = new nt(e, t);
}
var L = {
  num: new nt("num", $n),
  regexp: new nt("regexp", $n),
  string: new nt("string", $n),
  name: new nt("name", $n),
  privateId: new nt("privateId", $n),
  eof: new nt("eof"),
  // Punctuation token types.
  bracketL: new nt("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new nt("]"),
  braceL: new nt("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new nt("}"),
  parenL: new nt("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new nt(")"),
  comma: new nt(",", lr),
  semi: new nt(";", lr),
  colon: new nt(":", lr),
  dot: new nt("."),
  question: new nt("?", lr),
  questionDot: new nt("?."),
  arrow: new nt("=>", lr),
  template: new nt("template"),
  invalidTemplate: new nt("invalidTemplate"),
  ellipsis: new nt("...", lr),
  backQuote: new nt("`", $n),
  dollarBraceL: new nt("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new nt("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new nt("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new nt("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new nt("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: ar("||", 1),
  logicalAND: ar("&&", 2),
  bitwiseOR: ar("|", 3),
  bitwiseXOR: ar("^", 4),
  bitwiseAND: ar("&", 5),
  equality: ar("==/!=/===/!==", 6),
  relational: ar("</>/<=/>=", 7),
  bitShift: ar("<</>>/>>>", 8),
  plusMin: new nt("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: ar("%", 10),
  star: ar("*", 10),
  slash: ar("/", 10),
  starstar: new nt("**", { beforeExpr: !0 }),
  coalesce: ar("??", 1),
  // Keyword token types.
  _break: tt("break"),
  _case: tt("case", lr),
  _catch: tt("catch"),
  _continue: tt("continue"),
  _debugger: tt("debugger"),
  _default: tt("default", lr),
  _do: tt("do", { isLoop: !0, beforeExpr: !0 }),
  _else: tt("else", lr),
  _finally: tt("finally"),
  _for: tt("for", { isLoop: !0 }),
  _function: tt("function", $n),
  _if: tt("if"),
  _return: tt("return", lr),
  _switch: tt("switch"),
  _throw: tt("throw", lr),
  _try: tt("try"),
  _var: tt("var"),
  _const: tt("const"),
  _while: tt("while", { isLoop: !0 }),
  _with: tt("with"),
  _new: tt("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: tt("this", $n),
  _super: tt("super", $n),
  _class: tt("class", $n),
  _extends: tt("extends", lr),
  _export: tt("export"),
  _import: tt("import", $n),
  _null: tt("null", $n),
  _true: tt("true", $n),
  _false: tt("false", $n),
  _in: tt("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: tt("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: tt("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: tt("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: tt("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, Mn = /\r\n?|\n|\u2028|\u2029/, bT = new RegExp(Mn.source, "g");
function ea(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function CT(e, t, n) {
  n === void 0 && (n = e.length);
  for (var r = t; r < n; r++) {
    var i = e.charCodeAt(r);
    if (ea(i))
      return r < n - 1 && i === 13 && e.charCodeAt(r + 1) === 10 ? r + 2 : r + 1;
  }
  return -1;
}
var ux = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, pn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ET = Object.prototype, eX = ET.hasOwnProperty, tX = ET.toString, Cl = Object.hasOwn || function(e, t) {
  return eX.call(e, t);
}, R4 = Array.isArray || function(e) {
  return tX.call(e) === "[object Array]";
}, $4 = /* @__PURE__ */ Object.create(null);
function Ms(e) {
  return $4[e] || ($4[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function is(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
var nX = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, rl = function(t, n) {
  this.line = t, this.column = n;
};
rl.prototype.offset = function(t) {
  return new rl(this.line, this.column + t);
};
var Eu = function(t, n, r) {
  this.start = n, this.end = r, t.sourceFile !== null && (this.source = t.sourceFile);
};
function fx(e, t) {
  for (var n = 1, r = 0; ; ) {
    var i = CT(e, r, t);
    if (i < 0)
      return new rl(n, t - r);
    ++n, r = i;
  }
}
var wh = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: !1,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: !1,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: !0,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
}, V4 = !1;
function rX(e) {
  var t = {};
  for (var n in wh)
    t[n] = e && Cl(e, n) ? e[n] : wh[n];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!V4 && typeof console == "object" && console.warn && (V4 = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14), R4(t.onToken)) {
    var r = t.onToken;
    t.onToken = function(i) {
      return r.push(i);
    };
  }
  return R4(t.onComment) && (t.onComment = iX(t, t.onComment)), t;
}
function iX(e, t) {
  return function(n, r, i, s, o, a) {
    var l = {
      type: n ? "Block" : "Line",
      value: r,
      start: i,
      end: s
    };
    e.locations && (l.loc = new Eu(this, o, a)), e.ranges && (l.range = [i, s]), t.push(l);
  };
}
var Hc = 1, El = 2, dx = 4, ST = 8, hx = 16, kT = 32, Jp = 64, TT = 128, ta = 256, Su = 512, Kp = Hc | El | ta;
function px(e, t) {
  return El | (e ? dx : 0) | (t ? ST : 0);
}
var _h = 0, mx = 1, fs = 2, AT = 3, NT = 4, IT = 5, Mt = function(t, n, r) {
  this.options = t = rX(t), this.sourceFile = t.sourceFile, this.keywords = Ms(YY[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var i = "";
  t.allowReserved !== !0 && (i = ym[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (i += " await")), this.reservedWords = Ms(i);
  var s = (i ? i + " " : "") + ym.strict;
  this.reservedWordsStrict = Ms(s), this.reservedWordsStrictBind = Ms(s + " " + ym.strictBind), this.input = String(n), this.containsEsc = !1, r ? (this.pos = r, this.lineStart = this.input.lastIndexOf(`
`, r - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Mn).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = L.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Hc), this.regexpState = null, this.privateNameStack = [];
}, Ei = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
Mt.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
Ei.inFunction.get = function() {
  return (this.currentVarScope().flags & El) > 0;
};
Ei.inGenerator.get = function() {
  return (this.currentVarScope().flags & ST) > 0;
};
Ei.inAsync.get = function() {
  return (this.currentVarScope().flags & dx) > 0;
};
Ei.canAwait.get = function() {
  for (var e = this.scopeStack.length - 1; e >= 0; e--) {
    var t = this.scopeStack[e], n = t.flags;
    if (n & (ta | Su))
      return !1;
    if (n & El)
      return (n & dx) > 0;
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
Ei.allowSuper.get = function() {
  var e = this.currentThisScope(), t = e.flags;
  return (t & Jp) > 0 || this.options.allowSuperOutsideMethod;
};
Ei.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & TT) > 0;
};
Ei.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
Ei.allowNewDotTarget.get = function() {
  for (var e = this.scopeStack.length - 1; e >= 0; e--) {
    var t = this.scopeStack[e], n = t.flags;
    if (n & (ta | Su) || n & El && !(n & hx))
      return !0;
  }
  return !1;
};
Ei.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & ta) > 0;
};
Mt.extend = function() {
  for (var t = [], n = arguments.length; n--; ) t[n] = arguments[n];
  for (var r = this, i = 0; i < t.length; i++)
    r = t[i](r);
  return r;
};
Mt.parse = function(t, n) {
  return new this(n, t).parse();
};
Mt.parseExpressionAt = function(t, n, r) {
  var i = new this(r, t, n);
  return i.nextToken(), i.parseExpression();
};
Mt.tokenizer = function(t, n) {
  return new this(n, t);
};
Object.defineProperties(Mt.prototype, Ei);
var Rn = Mt.prototype, sX = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
Rn.strictDirective = function(e) {
  if (this.options.ecmaVersion < 5)
    return !1;
  for (; ; ) {
    pn.lastIndex = e, e += pn.exec(this.input)[0].length;
    var t = sX.exec(this.input.slice(e));
    if (!t)
      return !1;
    if ((t[1] || t[2]) === "use strict") {
      pn.lastIndex = e + t[0].length;
      var n = pn.exec(this.input), r = n.index + n[0].length, i = this.input.charAt(r);
      return i === ";" || i === "}" || Mn.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(i) || i === "!" && this.input.charAt(r + 1) === "=");
    }
    e += t[0].length, pn.lastIndex = e, e += pn.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
Rn.eat = function(e) {
  return this.type === e ? (this.next(), !0) : !1;
};
Rn.isContextual = function(e) {
  return this.type === L.name && this.value === e && !this.containsEsc;
};
Rn.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), !0) : !1;
};
Rn.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
Rn.canInsertSemicolon = function() {
  return this.type === L.eof || this.type === L.braceR || Mn.test(this.input.slice(this.lastTokEnd, this.start));
};
Rn.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
Rn.semicolon = function() {
  !this.eat(L.semi) && !this.insertSemicolon() && this.unexpected();
};
Rn.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
};
Rn.expect = function(e) {
  this.eat(e) || this.unexpected();
};
Rn.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
var qp = function() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
Rn.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var n = t ? e.parenthesizedAssign : e.parenthesizedBind;
    n > -1 && this.raiseRecoverable(n, t ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
Rn.checkExpressionErrors = function(e, t) {
  if (!e)
    return !1;
  var n = e.shorthandAssign, r = e.doubleProto;
  if (!t)
    return n >= 0 || r >= 0;
  n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), r >= 0 && this.raiseRecoverable(r, "Redefinition of __proto__ property");
};
Rn.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
Rn.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var Ne = Mt.prototype;
Ne.parseTopLevel = function(e) {
  var t = /* @__PURE__ */ Object.create(null);
  for (e.body || (e.body = []); this.type !== L.eof; ) {
    var n = this.parseStatement(null, !0, t);
    e.body.push(n);
  }
  if (this.inModule)
    for (var r = 0, i = Object.keys(this.undefinedExports); r < i.length; r += 1) {
      var s = i[r];
      this.raiseRecoverable(this.undefinedExports[s].start, "Export '" + s + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var gx = { kind: "loop" }, oX = { kind: "switch" };
Ne.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  pn.lastIndex = this.pos;
  var t = pn.exec(this.input), n = this.pos + t[0].length, r = this.input.charCodeAt(n);
  if (r === 91 || r === 92)
    return !0;
  if (e)
    return !1;
  if (r === 123 || r > 55295 && r < 56320)
    return !0;
  if (Jr(r, !0)) {
    for (var i = n + 1; rs(r = this.input.charCodeAt(i), !0); )
      ++i;
    if (r === 92 || r > 55295 && r < 56320)
      return !0;
    var s = this.input.slice(n, i);
    if (!XY.test(s))
      return !0;
  }
  return !1;
};
Ne.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  pn.lastIndex = this.pos;
  var e = pn.exec(this.input), t = this.pos + e[0].length, n;
  return !Mn.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(rs(n = this.input.charCodeAt(t + 8)) || n > 55295 && n < 56320));
};
Ne.isUsingKeyword = function(e, t) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(e ? "await" : "using"))
    return !1;
  pn.lastIndex = this.pos;
  var n = pn.exec(this.input), r = this.pos + n[0].length;
  if (Mn.test(this.input.slice(this.pos, r)))
    return !1;
  if (e) {
    var i = r + 5, s;
    if (this.input.slice(r, i) !== "using" || i === this.input.length || rs(s = this.input.charCodeAt(i)) || s > 55295 && s < 56320)
      return !1;
    pn.lastIndex = i;
    var o = pn.exec(this.input);
    if (o && Mn.test(this.input.slice(i, i + o[0].length)))
      return !1;
  }
  if (t) {
    var a = r + 2, l;
    if (this.input.slice(r, a) === "of" && (a === this.input.length || !rs(l = this.input.charCodeAt(a)) && !(l > 55295 && l < 56320)))
      return !1;
  }
  var c = this.input.charCodeAt(r);
  return Jr(c, !0) || c === 92;
};
Ne.isAwaitUsing = function(e) {
  return this.isUsingKeyword(!0, e);
};
Ne.isUsing = function(e) {
  return this.isUsingKeyword(!1, e);
};
Ne.parseStatement = function(e, t, n) {
  var r = this.type, i = this.startNode(), s;
  switch (this.isLet(e) && (r = L._var, s = "let"), r) {
    case L._break:
    case L._continue:
      return this.parseBreakContinueStatement(i, r.keyword);
    case L._debugger:
      return this.parseDebuggerStatement(i);
    case L._do:
      return this.parseDoStatement(i);
    case L._for:
      return this.parseForStatement(i);
    case L._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(i, !1, !e);
    case L._class:
      return e && this.unexpected(), this.parseClass(i, !0);
    case L._if:
      return this.parseIfStatement(i);
    case L._return:
      return this.parseReturnStatement(i);
    case L._switch:
      return this.parseSwitchStatement(i);
    case L._throw:
      return this.parseThrowStatement(i);
    case L._try:
      return this.parseTryStatement(i);
    case L._const:
    case L._var:
      return s = s || this.value, e && s !== "var" && this.unexpected(), this.parseVarStatement(i, s);
    case L._while:
      return this.parseWhileStatement(i);
    case L._with:
      return this.parseWithStatement(i);
    case L.braceL:
      return this.parseBlock(!0, i);
    case L.semi:
      return this.parseEmptyStatement(i);
    case L._export:
    case L._import:
      if (this.options.ecmaVersion > 10 && r === L._import) {
        pn.lastIndex = this.pos;
        var o = pn.exec(this.input), a = this.pos + o[0].length, l = this.input.charCodeAt(a);
        if (l === 40 || l === 46)
          return this.parseExpressionStatement(i, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === L._import ? this.parseImport(i) : this.parseExport(i, n);
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(i, !0, !e);
      var c = this.isAwaitUsing(!1) ? "await using" : this.isUsing(!1) ? "using" : null;
      if (c)
        return t && this.options.sourceType === "script" && this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`"), c === "await using" && (this.canAwait || this.raise(this.start, "Await using cannot appear outside of async function"), this.next()), this.next(), this.parseVar(i, !1, c), this.semicolon(), this.finishNode(i, "VariableDeclaration");
      var u = this.value, f = this.parseExpression();
      return r === L.name && f.type === "Identifier" && this.eat(L.colon) ? this.parseLabeledStatement(i, u, f, e) : this.parseExpressionStatement(i, f);
  }
};
Ne.parseBreakContinueStatement = function(e, t) {
  var n = t === "break";
  this.next(), this.eat(L.semi) || this.insertSemicolon() ? e.label = null : this.type !== L.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var r = 0; r < this.labels.length; ++r) {
    var i = this.labels[r];
    if ((e.label == null || i.name === e.label.name) && (i.kind != null && (n || i.kind === "loop") || e.label && n))
      break;
  }
  return r === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, n ? "BreakStatement" : "ContinueStatement");
};
Ne.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
Ne.parseDoStatement = function(e) {
  return this.next(), this.labels.push(gx), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(L._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(L.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
Ne.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(gx), this.enterScope(0), this.expect(L.parenL), this.type === L.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var n = this.isLet();
  if (this.type === L._var || this.type === L._const || n) {
    var r = this.startNode(), i = n ? "let" : this.value;
    return this.next(), this.parseVar(r, !0, i), this.finishNode(r, "VariableDeclaration"), this.parseForAfterInit(e, r, t);
  }
  var s = this.isContextual("let"), o = !1, a = this.isUsing(!0) ? "using" : this.isAwaitUsing(!0) ? "await using" : null;
  if (a) {
    var l = this.startNode();
    return this.next(), a === "await using" && this.next(), this.parseVar(l, !0, a), this.finishNode(l, "VariableDeclaration"), this.parseForAfterInit(e, l, t);
  }
  var c = this.containsEsc, u = new qp(), f = this.start, d = t > -1 ? this.parseExprSubscripts(u, "await") : this.parseExpression(!0, u);
  return this.type === L._in || (o = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === L._in && this.unexpected(t), e.await = !0) : o && this.options.ecmaVersion >= 8 && (d.start === f && !c && d.type === "Identifier" && d.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (e.await = !1)), s && o && this.raise(d.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(d, !1, u), this.checkLValPattern(d), this.parseForIn(e, d)) : (this.checkExpressionErrors(u, !0), t > -1 && this.unexpected(t), this.parseFor(e, d));
};
Ne.parseForAfterInit = function(e, t, n) {
  return (this.type === L._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && t.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === L._in ? n > -1 && this.unexpected(n) : e.await = n > -1), this.parseForIn(e, t)) : (n > -1 && this.unexpected(n), this.parseFor(e, t));
};
Ne.parseFunctionStatement = function(e, t, n) {
  return this.next(), this.parseFunction(e, hc | (n ? 0 : W0), !1, t);
};
Ne.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(L._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
Ne.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(L.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
Ne.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(L.braceL), this.labels.push(oX), this.enterScope(0);
  for (var t, n = !1; this.type !== L.braceR; )
    if (this.type === L._case || this.type === L._default) {
      var r = this.type === L._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), r ? t.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, t.test = null), this.expect(L.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
Ne.parseThrowStatement = function(e) {
  return this.next(), Mn.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var aX = [];
Ne.parseCatchClauseParam = function() {
  var e = this.parseBindingAtom(), t = e.type === "Identifier";
  return this.enterScope(t ? kT : 0), this.checkLValPattern(e, t ? NT : fs), this.expect(L.parenR), e;
};
Ne.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === L._catch) {
    var t = this.startNode();
    this.next(), this.eat(L.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(L._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
Ne.parseVarStatement = function(e, t, n) {
  return this.next(), this.parseVar(e, !1, t, n), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
Ne.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(gx), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
Ne.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
Ne.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
Ne.parseLabeledStatement = function(e, t, n, r) {
  for (var i = 0, s = this.labels; i < s.length; i += 1) {
    var o = s[i];
    o.name === t && this.raise(n.start, "Label '" + t + "' is already declared");
  }
  for (var a = this.type.isLoop ? "loop" : this.type === L._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var c = this.labels[l];
    if (c.statementStart === e.start)
      c.statementStart = this.start, c.kind = a;
    else
      break;
  }
  return this.labels.push({ name: t, kind: a, statementStart: this.start }), e.body = this.parseStatement(r ? r.indexOf("label") === -1 ? r + "label" : r : "label"), this.labels.pop(), e.label = n, this.finishNode(e, "LabeledStatement");
};
Ne.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
Ne.parseBlock = function(e, t, n) {
  for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(L.braceL), e && this.enterScope(0); this.type !== L.braceR; ) {
    var r = this.parseStatement(null);
    t.body.push(r);
  }
  return n && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
Ne.parseFor = function(e, t) {
  return e.init = t, this.expect(L.semi), e.test = this.type === L.semi ? null : this.parseExpression(), this.expect(L.semi), e.update = this.type === L.parenR ? null : this.parseExpression(), this.expect(L.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
Ne.parseForIn = function(e, t) {
  var n = this.type === L._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!n || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
    t.start,
    (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ), e.left = t, e.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(L.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
};
Ne.parseVar = function(e, t, n, r) {
  for (e.declarations = [], e.kind = n; ; ) {
    var i = this.startNode();
    if (this.parseVarId(i, n), this.eat(L.eq) ? i.init = this.parseMaybeAssign(t) : !r && n === "const" && !(this.type === L._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !r && (n === "using" || n === "await using") && this.options.ecmaVersion >= 17 && this.type !== L._in && !this.isContextual("of") ? this.raise(this.lastTokEnd, "Missing initializer in " + n + " declaration") : !r && i.id.type !== "Identifier" && !(t && (this.type === L._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(L.comma))
      break;
  }
  return e;
};
Ne.parseVarId = function(e, t) {
  e.id = t === "using" || t === "await using" ? this.parseIdent() : this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? mx : fs, !1);
};
var hc = 1, W0 = 2, LT = 4;
Ne.parseFunction = function(e, t, n, r, i) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !r) && (this.type === L.star && t & W0 && this.unexpected(), e.generator = this.eat(L.star)), this.options.ecmaVersion >= 8 && (e.async = !!r), t & hc && (e.id = t & LT && this.type !== L.name ? null : this.parseIdent(), e.id && !(t & W0) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? mx : fs : AT));
  var s = this.yieldPos, o = this.awaitPos, a = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(px(e.async, e.generator)), t & hc || (e.id = this.type === L.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, n, !1, i), this.yieldPos = s, this.awaitPos = o, this.awaitIdentPos = a, this.finishNode(e, t & hc ? "FunctionDeclaration" : "FunctionExpression");
};
Ne.parseFunctionParams = function(e) {
  this.expect(L.parenL), e.params = this.parseBindingList(L.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
Ne.parseClass = function(e, t) {
  this.next();
  var n = this.strict;
  this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
  var r = this.enterClassBody(), i = this.startNode(), s = !1;
  for (i.body = [], this.expect(L.braceL); this.type !== L.braceR; ) {
    var o = this.parseClassElement(e.superClass !== null);
    o && (i.body.push(o), o.type === "MethodDefinition" && o.kind === "constructor" ? (s && this.raiseRecoverable(o.start, "Duplicate constructor in the same class"), s = !0) : o.key && o.key.type === "PrivateIdentifier" && lX(r, o) && this.raiseRecoverable(o.key.start, "Identifier '#" + o.key.name + "' has already been declared"));
  }
  return this.strict = n, this.next(), e.body = this.finishNode(i, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
Ne.parseClassElement = function(e) {
  if (this.eat(L.semi))
    return null;
  var t = this.options.ecmaVersion, n = this.startNode(), r = "", i = !1, s = !1, o = "method", a = !1;
  if (this.eatContextual("static")) {
    if (t >= 13 && this.eat(L.braceL))
      return this.parseClassStaticBlock(n), n;
    this.isClassElementNameStart() || this.type === L.star ? a = !0 : r = "static";
  }
  if (n.static = a, !r && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === L.star) && !this.canInsertSemicolon() ? s = !0 : r = "async"), !r && (t >= 9 || !s) && this.eat(L.star) && (i = !0), !r && !s && !i) {
    var l = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? o = l : r = l);
  }
  if (r ? (n.computed = !1, n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), n.key.name = r, this.finishNode(n.key, "Identifier")) : this.parseClassElementName(n), t < 13 || this.type === L.parenL || o !== "method" || i || s) {
    var c = !n.static && bh(n, "constructor"), u = c && e;
    c && o !== "method" && this.raise(n.key.start, "Constructor can't have get/set modifier"), n.kind = c ? "constructor" : o, this.parseClassMethod(n, i, s, u);
  } else
    this.parseClassField(n);
  return n;
};
Ne.isClassElementNameStart = function() {
  return this.type === L.name || this.type === L.privateId || this.type === L.num || this.type === L.string || this.type === L.bracketL || this.type.keyword;
};
Ne.parseClassElementName = function(e) {
  this.type === L.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
};
Ne.parseClassMethod = function(e, t, n, r) {
  var i = e.key;
  e.kind === "constructor" ? (t && this.raise(i.start, "Constructor can't be a generator"), n && this.raise(i.start, "Constructor can't be an async method")) : e.static && bh(e, "prototype") && this.raise(i.start, "Classes may not have a static property named prototype");
  var s = e.value = this.parseMethod(t, n, r);
  return e.kind === "get" && s.params.length !== 0 && this.raiseRecoverable(s.start, "getter should have no params"), e.kind === "set" && s.params.length !== 1 && this.raiseRecoverable(s.start, "setter should have exactly one param"), e.kind === "set" && s.params[0].type === "RestElement" && this.raiseRecoverable(s.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
};
Ne.parseClassField = function(e) {
  return bh(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && bh(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(L.eq) ? (this.enterScope(Su | Jp), e.value = this.parseMaybeAssign(), this.exitScope()) : e.value = null, this.semicolon(), this.finishNode(e, "PropertyDefinition");
};
Ne.parseClassStaticBlock = function(e) {
  e.body = [];
  var t = this.labels;
  for (this.labels = [], this.enterScope(ta | Jp); this.type !== L.braceR; ) {
    var n = this.parseStatement(null);
    e.body.push(n);
  }
  return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
};
Ne.parseClassId = function(e, t) {
  this.type === L.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, fs, !1)) : (t === !0 && this.unexpected(), e.id = null);
};
Ne.parseClassSuper = function(e) {
  e.superClass = this.eat(L._extends) ? this.parseExprSubscripts(null, !1) : null;
};
Ne.enterClassBody = function() {
  var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  return this.privateNameStack.push(e), e.declared;
};
Ne.exitClassBody = function() {
  var e = this.privateNameStack.pop(), t = e.declared, n = e.used;
  if (this.options.checkPrivateFields)
    for (var r = this.privateNameStack.length, i = r === 0 ? null : this.privateNameStack[r - 1], s = 0; s < n.length; ++s) {
      var o = n[s];
      Cl(t, o.name) || (i ? i.used.push(o) : this.raiseRecoverable(o.start, "Private field '#" + o.name + "' must be declared in an enclosing class"));
    }
};
function lX(e, t) {
  var n = t.key.name, r = e[n], i = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (i = (t.static ? "s" : "i") + t.kind), r === "iget" && i === "iset" || r === "iset" && i === "iget" || r === "sget" && i === "sset" || r === "sset" && i === "sget" ? (e[n] = "true", !1) : r ? !0 : (e[n] = i, !1);
}
function bh(e, t) {
  var n = e.computed, r = e.key;
  return !n && (r.type === "Identifier" && r.name === t || r.type === "Literal" && r.value === t);
}
Ne.parseExportAllDeclaration = function(e, t) {
  return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== L.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
};
Ne.parseExport = function(e, t) {
  if (this.next(), this.eat(L.star))
    return this.parseExportAllDeclaration(e, t);
  if (this.eat(L._default))
    return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
  if (this.shouldParseExportStatement())
    e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null, this.options.ecmaVersion >= 16 && (e.attributes = []);
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== L.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
    else {
      for (var n = 0, r = e.specifiers; n < r.length; n += 1) {
        var i = r[n];
        this.checkUnreserved(i.local), this.checkLocalExport(i.local), i.local.type === "Literal" && this.raise(i.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      e.source = null, this.options.ecmaVersion >= 16 && (e.attributes = []);
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
Ne.parseExportDeclaration = function(e) {
  return this.parseStatement(null);
};
Ne.parseExportDefaultDeclaration = function() {
  var e;
  if (this.type === L._function || (e = this.isAsyncFunction())) {
    var t = this.startNode();
    return this.next(), e && this.next(), this.parseFunction(t, hc | LT, !1, e);
  } else if (this.type === L._class) {
    var n = this.startNode();
    return this.parseClass(n, "nullableID");
  } else {
    var r = this.parseMaybeAssign();
    return this.semicolon(), r;
  }
};
Ne.checkExport = function(e, t, n) {
  e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), Cl(e, t) && this.raiseRecoverable(n, "Duplicate export '" + t + "'"), e[t] = !0);
};
Ne.checkPatternExport = function(e, t) {
  var n = t.type;
  if (n === "Identifier")
    this.checkExport(e, t, t.start);
  else if (n === "ObjectPattern")
    for (var r = 0, i = t.properties; r < i.length; r += 1) {
      var s = i[r];
      this.checkPatternExport(e, s);
    }
  else if (n === "ArrayPattern")
    for (var o = 0, a = t.elements; o < a.length; o += 1) {
      var l = a[o];
      l && this.checkPatternExport(e, l);
    }
  else n === "Property" ? this.checkPatternExport(e, t.value) : n === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : n === "RestElement" && this.checkPatternExport(e, t.argument);
};
Ne.checkVariableExport = function(e, t) {
  if (e)
    for (var n = 0, r = t; n < r.length; n += 1) {
      var i = r[n];
      this.checkPatternExport(e, i.id);
    }
};
Ne.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
Ne.parseExportSpecifier = function(e) {
  var t = this.startNode();
  return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
    e,
    t.exported,
    t.exported.start
  ), this.finishNode(t, "ExportSpecifier");
};
Ne.parseExportSpecifiers = function(e) {
  var t = [], n = !0;
  for (this.expect(L.braceL); !this.eat(L.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(L.comma), this.afterTrailingComma(L.braceR))
      break;
    t.push(this.parseExportSpecifier(e));
  }
  return t;
};
Ne.parseImport = function(e) {
  return this.next(), this.type === L.string ? (e.specifiers = aX, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === L.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
Ne.parseImportSpecifier = function() {
  var e = this.startNode();
  return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported), this.checkLValSimple(e.local, fs), this.finishNode(e, "ImportSpecifier");
};
Ne.parseImportDefaultSpecifier = function() {
  var e = this.startNode();
  return e.local = this.parseIdent(), this.checkLValSimple(e.local, fs), this.finishNode(e, "ImportDefaultSpecifier");
};
Ne.parseImportNamespaceSpecifier = function() {
  var e = this.startNode();
  return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, fs), this.finishNode(e, "ImportNamespaceSpecifier");
};
Ne.parseImportSpecifiers = function() {
  var e = [], t = !0;
  if (this.type === L.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(L.comma)))
    return e;
  if (this.type === L.star)
    return e.push(this.parseImportNamespaceSpecifier()), e;
  for (this.expect(L.braceL); !this.eat(L.braceR); ) {
    if (t)
      t = !1;
    else if (this.expect(L.comma), this.afterTrailingComma(L.braceR))
      break;
    e.push(this.parseImportSpecifier());
  }
  return e;
};
Ne.parseWithClause = function() {
  var e = [];
  if (!this.eat(L._with))
    return e;
  this.expect(L.braceL);
  for (var t = {}, n = !0; !this.eat(L.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(L.comma), this.afterTrailingComma(L.braceR))
      break;
    var r = this.parseImportAttribute(), i = r.key.type === "Identifier" ? r.key.name : r.key.value;
    Cl(t, i) && this.raiseRecoverable(r.key.start, "Duplicate attribute key '" + i + "'"), t[i] = !0, e.push(r);
  }
  return e;
};
Ne.parseImportAttribute = function() {
  var e = this.startNode();
  return e.key = this.type === L.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(L.colon), this.type !== L.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
};
Ne.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === L.string) {
    var e = this.parseLiteral(this.value);
    return nX.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
  }
  return this.parseIdent(!0);
};
Ne.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
Ne.isDirectiveCandidate = function(e) {
  return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var kr = Mt.prototype;
kr.toAssignable = function(e, t, n) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", n && this.checkPatternErrors(n, !0);
        for (var r = 0, i = e.properties; r < i.length; r += 1) {
          var s = i[r];
          this.toAssignable(s, t), s.type === "RestElement" && (s.argument.type === "ArrayPattern" || s.argument.type === "ObjectPattern") && this.raise(s.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, n);
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else n && this.checkPatternErrors(n, !0);
  return e;
};
kr.toAssignableList = function(e, t) {
  for (var n = e.length, r = 0; r < n; r++) {
    var i = e[r];
    i && this.toAssignable(i, t);
  }
  if (n) {
    var s = e[n - 1];
    this.options.ecmaVersion === 6 && t && s && s.type === "RestElement" && s.argument.type !== "Identifier" && this.unexpected(s.argument.start);
  }
  return e;
};
kr.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
};
kr.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== L.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
kr.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case L.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(L.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
      case L.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
kr.parseBindingList = function(e, t, n, r) {
  for (var i = [], s = !0; !this.eat(e); )
    if (s ? s = !1 : this.expect(L.comma), t && this.type === L.comma)
      i.push(null);
    else {
      if (n && this.afterTrailingComma(e))
        break;
      if (this.type === L.ellipsis) {
        var o = this.parseRestBinding();
        this.parseBindingListItem(o), i.push(o), this.type === L.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else
        i.push(this.parseAssignableListItem(r));
    }
  return i;
};
kr.parseAssignableListItem = function(e) {
  var t = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(t), t;
};
kr.parseBindingListItem = function(e) {
  return e;
};
kr.parseMaybeDefault = function(e, t, n) {
  if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(L.eq))
    return n;
  var r = this.startNodeAt(e, t);
  return r.left = n, r.right = this.parseMaybeAssign(), this.finishNode(r, "AssignmentPattern");
};
kr.checkLValSimple = function(e, t, n) {
  t === void 0 && (t = _h);
  var r = t !== _h;
  switch (e.type) {
    case "Identifier":
      this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (r ? "Binding " : "Assigning to ") + e.name + " in strict mode"), r && (t === fs && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), n && (Cl(n, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), n[e.name] = !0), t !== IT && this.declareName(e.name, t, e.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      r && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return r && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, n);
    default:
      this.raise(e.start, (r ? "Binding" : "Assigning to") + " rvalue");
  }
};
kr.checkLValPattern = function(e, t, n) {
  switch (t === void 0 && (t = _h), e.type) {
    case "ObjectPattern":
      for (var r = 0, i = e.properties; r < i.length; r += 1) {
        var s = i[r];
        this.checkLValInnerPattern(s, t, n);
      }
      break;
    case "ArrayPattern":
      for (var o = 0, a = e.elements; o < a.length; o += 1) {
        var l = a[o];
        l && this.checkLValInnerPattern(l, t, n);
      }
      break;
    default:
      this.checkLValSimple(e, t, n);
  }
};
kr.checkLValInnerPattern = function(e, t, n) {
  switch (t === void 0 && (t = _h), e.type) {
    case "Property":
      this.checkLValInnerPattern(e.value, t, n);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(e.left, t, n);
      break;
    case "RestElement":
      this.checkLValPattern(e.argument, t, n);
      break;
    default:
      this.checkLValPattern(e, t, n);
  }
};
var cr = function(t, n, r, i, s) {
  this.token = t, this.isExpr = !!n, this.preserveSpace = !!r, this.override = i, this.generator = !!s;
}, kt = {
  b_stat: new cr("{", !1),
  b_expr: new cr("{", !0),
  b_tmpl: new cr("${", !1),
  p_stat: new cr("(", !1),
  p_expr: new cr("(", !0),
  q_tmpl: new cr("`", !0, !0, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new cr("function", !1),
  f_expr: new cr("function", !0),
  f_expr_gen: new cr("function", !0, !1, null, !0),
  f_gen: new cr("function", !1, !1, null, !0)
}, Sl = Mt.prototype;
Sl.initialContext = function() {
  return [kt.b_stat];
};
Sl.curContext = function() {
  return this.context[this.context.length - 1];
};
Sl.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === kt.f_expr || t === kt.f_stat ? !0 : e === L.colon && (t === kt.b_stat || t === kt.b_expr) ? !t.isExpr : e === L._return || e === L.name && this.exprAllowed ? Mn.test(this.input.slice(this.lastTokEnd, this.start)) : e === L._else || e === L.semi || e === L.eof || e === L.parenR || e === L.arrow ? !0 : e === L.braceL ? t === kt.b_stat : e === L._var || e === L._const || e === L.name ? !1 : !this.exprAllowed;
};
Sl.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return !1;
};
Sl.updateContext = function(e) {
  var t, n = this.type;
  n.keyword && e === L.dot ? this.exprAllowed = !1 : (t = n.updateContext) ? t.call(this, e) : this.exprAllowed = n.beforeExpr;
};
Sl.overrideContext = function(e) {
  this.curContext() !== e && (this.context[this.context.length - 1] = e);
};
L.parenR.updateContext = L.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var e = this.context.pop();
  e === kt.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
L.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? kt.b_stat : kt.b_expr), this.exprAllowed = !0;
};
L.dollarBraceL.updateContext = function() {
  this.context.push(kt.b_tmpl), this.exprAllowed = !0;
};
L.parenL.updateContext = function(e) {
  var t = e === L._if || e === L._for || e === L._with || e === L._while;
  this.context.push(t ? kt.p_stat : kt.p_expr), this.exprAllowed = !0;
};
L.incDec.updateContext = function() {
};
L._function.updateContext = L._class.updateContext = function(e) {
  e.beforeExpr && e !== L._else && !(e === L.semi && this.curContext() !== kt.p_stat) && !(e === L._return && Mn.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === L.colon || e === L.braceL) && this.curContext() === kt.b_stat) ? this.context.push(kt.f_expr) : this.context.push(kt.f_stat), this.exprAllowed = !1;
};
L.colon.updateContext = function() {
  this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
};
L.backQuote.updateContext = function() {
  this.curContext() === kt.q_tmpl ? this.context.pop() : this.context.push(kt.q_tmpl), this.exprAllowed = !1;
};
L.star.updateContext = function(e) {
  if (e === L._function) {
    var t = this.context.length - 1;
    this.context[t] === kt.f_expr ? this.context[t] = kt.f_expr_gen : this.context[t] = kt.f_gen;
  }
  this.exprAllowed = !0;
};
L.name.updateContext = function(e) {
  var t = !1;
  this.options.ecmaVersion >= 6 && e !== L.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t;
};
var Be = Mt.prototype;
Be.checkPropClash = function(e, t, n) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var r = e.key, i;
    switch (r.type) {
      case "Identifier":
        i = r.name;
        break;
      case "Literal":
        i = String(r.value);
        break;
      default:
        return;
    }
    var s = e.kind;
    if (this.options.ecmaVersion >= 6) {
      i === "__proto__" && s === "init" && (t.proto && (n ? n.doubleProto < 0 && (n.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")), t.proto = !0);
      return;
    }
    i = "$" + i;
    var o = t[i];
    if (o) {
      var a;
      s === "init" ? a = this.strict && o.init || o.get || o.set : a = o.init || o[s], a && this.raiseRecoverable(r.start, "Redefinition of property");
    } else
      o = t[i] = {
        init: !1,
        get: !1,
        set: !1
      };
    o[s] = !0;
  }
};
Be.parseExpression = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseMaybeAssign(e, t);
  if (this.type === L.comma) {
    var s = this.startNodeAt(n, r);
    for (s.expressions = [i]; this.eat(L.comma); )
      s.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(s, "SequenceExpression");
  }
  return i;
};
Be.parseMaybeAssign = function(e, t, n) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = !1;
  }
  var r = !1, i = -1, s = -1, o = -1;
  t ? (i = t.parenthesizedAssign, s = t.trailingComma, o = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new qp(), r = !0);
  var a = this.start, l = this.startLoc;
  (this.type === L.parenL || this.type === L.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
  var c = this.parseMaybeConditional(e, t);
  if (n && (c = n.call(this, c, a, l)), this.type.isAssign) {
    var u = this.startNodeAt(a, l);
    return u.operator = this.value, this.type === L.eq && (c = this.toAssignable(c, !1, t)), r || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= c.start && (t.shorthandAssign = -1), this.type === L.eq ? this.checkLValPattern(c) : this.checkLValSimple(c), u.left = c, this.next(), u.right = this.parseMaybeAssign(e), o > -1 && (t.doubleProto = o), this.finishNode(u, "AssignmentExpression");
  } else
    r && this.checkExpressionErrors(t, !0);
  return i > -1 && (t.parenthesizedAssign = i), s > -1 && (t.trailingComma = s), c;
};
Be.parseMaybeConditional = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return i;
  if (this.eat(L.question)) {
    var s = this.startNodeAt(n, r);
    return s.test = i, s.consequent = this.parseMaybeAssign(), this.expect(L.colon), s.alternate = this.parseMaybeAssign(e), this.finishNode(s, "ConditionalExpression");
  }
  return i;
};
Be.parseExprOps = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseMaybeUnary(t, !1, !1, e);
  return this.checkExpressionErrors(t) || i.start === n && i.type === "ArrowFunctionExpression" ? i : this.parseExprOp(i, n, r, -1, e);
};
Be.parseExprOp = function(e, t, n, r, i) {
  var s = this.type.binop;
  if (s != null && (!i || this.type !== L._in) && s > r) {
    var o = this.type === L.logicalOR || this.type === L.logicalAND, a = this.type === L.coalesce;
    a && (s = L.logicalAND.binop);
    var l = this.value;
    this.next();
    var c = this.start, u = this.startLoc, f = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, i), c, u, s, i), d = this.buildBinary(t, n, e, f, l, o || a);
    return (o && this.type === L.coalesce || a && (this.type === L.logicalOR || this.type === L.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(d, t, n, r, i);
  }
  return e;
};
Be.buildBinary = function(e, t, n, r, i, s) {
  r.type === "PrivateIdentifier" && this.raise(r.start, "Private identifier can only be left side of binary expression");
  var o = this.startNodeAt(e, t);
  return o.left = n, o.operator = i, o.right = r, this.finishNode(o, s ? "LogicalExpression" : "BinaryExpression");
};
Be.parseMaybeUnary = function(e, t, n, r) {
  var i = this.start, s = this.startLoc, o;
  if (this.isContextual("await") && this.canAwait)
    o = this.parseAwait(r), t = !0;
  else if (this.type.prefix) {
    var a = this.startNode(), l = this.type === L.incDec;
    a.operator = this.value, a.prefix = !0, this.next(), a.argument = this.parseMaybeUnary(null, !0, l, r), this.checkExpressionErrors(e, !0), l ? this.checkLValSimple(a.argument) : this.strict && a.operator === "delete" && MT(a.argument) ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : a.operator === "delete" && J0(a.argument) ? this.raiseRecoverable(a.start, "Private fields can not be deleted") : t = !0, o = this.finishNode(a, l ? "UpdateExpression" : "UnaryExpression");
  } else if (!t && this.type === L.privateId)
    (r || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), o = this.parsePrivateIdent(), this.type !== L._in && this.unexpected();
  else {
    if (o = this.parseExprSubscripts(e, r), this.checkExpressionErrors(e))
      return o;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var c = this.startNodeAt(i, s);
      c.operator = this.value, c.prefix = !1, c.argument = o, this.checkLValSimple(o), this.next(), o = this.finishNode(c, "UpdateExpression");
    }
  }
  if (!n && this.eat(L.starstar))
    if (t)
      this.unexpected(this.lastTokStart);
    else
      return this.buildBinary(i, s, o, this.parseMaybeUnary(null, !1, !1, r), "**", !1);
  else
    return o;
};
function MT(e) {
  return e.type === "Identifier" || e.type === "ParenthesizedExpression" && MT(e.expression);
}
function J0(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && J0(e.expression) || e.type === "ParenthesizedExpression" && J0(e.expression);
}
Be.parseExprSubscripts = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseExprAtom(e, t);
  if (i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return i;
  var s = this.parseSubscripts(i, n, r, !1, t);
  return e && s.type === "MemberExpression" && (e.parenthesizedAssign >= s.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= s.start && (e.parenthesizedBind = -1), e.trailingComma >= s.start && (e.trailingComma = -1)), s;
};
Be.parseSubscripts = function(e, t, n, r, i) {
  for (var s = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, o = !1; ; ) {
    var a = this.parseSubscript(e, t, n, r, s, o, i);
    if (a.optional && (o = !0), a === e || a.type === "ArrowFunctionExpression") {
      if (o) {
        var l = this.startNodeAt(t, n);
        l.expression = a, a = this.finishNode(l, "ChainExpression");
      }
      return a;
    }
    e = a;
  }
};
Be.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(L.arrow);
};
Be.parseSubscriptAsyncArrow = function(e, t, n, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), n, !0, r);
};
Be.parseSubscript = function(e, t, n, r, i, s, o) {
  var a = this.options.ecmaVersion >= 11, l = a && this.eat(L.questionDot);
  r && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var c = this.eat(L.bracketL);
  if (c || l && this.type !== L.parenL && this.type !== L.backQuote || this.eat(L.dot)) {
    var u = this.startNodeAt(t, n);
    u.object = e, c ? (u.property = this.parseExpression(), this.expect(L.bracketR)) : this.type === L.privateId && e.type !== "Super" ? u.property = this.parsePrivateIdent() : u.property = this.parseIdent(this.options.allowReserved !== "never"), u.computed = !!c, a && (u.optional = l), e = this.finishNode(u, "MemberExpression");
  } else if (!r && this.eat(L.parenL)) {
    var f = new qp(), d = this.yieldPos, h = this.awaitPos, m = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var p = this.parseExprList(L.parenR, this.options.ecmaVersion >= 8, !1, f);
    if (i && !l && this.shouldParseAsyncArrow())
      return this.checkPatternErrors(f, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = d, this.awaitPos = h, this.awaitIdentPos = m, this.parseSubscriptAsyncArrow(t, n, p, o);
    this.checkExpressionErrors(f, !0), this.yieldPos = d || this.yieldPos, this.awaitPos = h || this.awaitPos, this.awaitIdentPos = m || this.awaitIdentPos;
    var y = this.startNodeAt(t, n);
    y.callee = e, y.arguments = p, a && (y.optional = l), e = this.finishNode(y, "CallExpression");
  } else if (this.type === L.backQuote) {
    (l || s) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var v = this.startNodeAt(t, n);
    v.tag = e, v.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(v, "TaggedTemplateExpression");
  }
  return e;
};
Be.parseExprAtom = function(e, t, n) {
  this.type === L.slash && this.readRegexp();
  var r, i = this.potentialArrowAt === this.start;
  switch (this.type) {
    case L._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === L.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== L.dot && this.type !== L.bracketL && this.type !== L.parenL && this.unexpected(), this.finishNode(r, "Super");
    case L._this:
      return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
    case L.name:
      var s = this.start, o = this.startLoc, a = this.containsEsc, l = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !a && l.name === "async" && !this.canInsertSemicolon() && this.eat(L._function))
        return this.overrideContext(kt.f_expr), this.parseFunction(this.startNodeAt(s, o), 0, !1, !0, t);
      if (i && !this.canInsertSemicolon()) {
        if (this.eat(L.arrow))
          return this.parseArrowExpression(this.startNodeAt(s, o), [l], !1, t);
        if (this.options.ecmaVersion >= 8 && l.name === "async" && this.type === L.name && !a && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
          return l = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(L.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, o), [l], !0, t);
      }
      return l;
    case L.regexp:
      var c = this.value;
      return r = this.parseLiteral(c.value), r.regex = { pattern: c.pattern, flags: c.flags }, r;
    case L.num:
    case L.string:
      return this.parseLiteral(this.value);
    case L._null:
    case L._true:
    case L._false:
      return r = this.startNode(), r.value = this.type === L._null ? null : this.type === L._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal");
    case L.parenL:
      var u = this.start, f = this.parseParenAndDistinguishExpression(i, t);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(f) && (e.parenthesizedAssign = u), e.parenthesizedBind < 0 && (e.parenthesizedBind = u)), f;
    case L.bracketL:
      return r = this.startNode(), this.next(), r.elements = this.parseExprList(L.bracketR, !0, !0, e), this.finishNode(r, "ArrayExpression");
    case L.braceL:
      return this.overrideContext(kt.b_expr), this.parseObj(!1, e);
    case L._function:
      return r = this.startNode(), this.next(), this.parseFunction(r, 0);
    case L._class:
      return this.parseClass(this.startNode(), !1);
    case L._new:
      return this.parseNew();
    case L.backQuote:
      return this.parseTemplate();
    case L._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(n) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
Be.parseExprAtomDefault = function() {
  this.unexpected();
};
Be.parseExprImport = function(e) {
  var t = this.startNode();
  if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === L.parenL && !e)
    return this.parseDynamicImport(t);
  if (this.type === L.dot) {
    var n = this.startNodeAt(t.start, t.loc && t.loc.start);
    return n.name = "import", t.meta = this.finishNode(n, "Identifier"), this.parseImportMeta(t);
  } else
    this.unexpected();
};
Be.parseDynamicImport = function(e) {
  if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
    this.eat(L.parenR) ? e.options = null : (this.expect(L.comma), this.afterTrailingComma(L.parenR) ? e.options = null : (e.options = this.parseMaybeAssign(), this.eat(L.parenR) || (this.expect(L.comma), this.afterTrailingComma(L.parenR) || this.unexpected())));
  else if (!this.eat(L.parenR)) {
    var t = this.start;
    this.eat(L.comma) && this.eat(L.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
  }
  return this.finishNode(e, "ImportExpression");
};
Be.parseImportMeta = function(e) {
  this.next();
  var t = this.containsEsc;
  return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
};
Be.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.value != null ? t.value.toString() : t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
};
Be.parseParenExpression = function() {
  this.expect(L.parenL);
  var e = this.parseExpression();
  return this.expect(L.parenR), e;
};
Be.shouldParseArrow = function(e) {
  return !this.canInsertSemicolon();
};
Be.parseParenAndDistinguishExpression = function(e, t) {
  var n = this.start, r = this.startLoc, i, s = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var o = this.start, a = this.startLoc, l = [], c = !0, u = !1, f = new qp(), d = this.yieldPos, h = this.awaitPos, m;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== L.parenR; )
      if (c ? c = !1 : this.expect(L.comma), s && this.afterTrailingComma(L.parenR, !0)) {
        u = !0;
        break;
      } else if (this.type === L.ellipsis) {
        m = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === L.comma && this.raiseRecoverable(
          this.start,
          "Comma is not permitted after the rest element"
        );
        break;
      } else
        l.push(this.parseMaybeAssign(!1, f, this.parseParenItem));
    var p = this.lastTokEnd, y = this.lastTokEndLoc;
    if (this.expect(L.parenR), e && this.shouldParseArrow(l) && this.eat(L.arrow))
      return this.checkPatternErrors(f, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = d, this.awaitPos = h, this.parseParenArrowList(n, r, l, t);
    (!l.length || u) && this.unexpected(this.lastTokStart), m && this.unexpected(m), this.checkExpressionErrors(f, !0), this.yieldPos = d || this.yieldPos, this.awaitPos = h || this.awaitPos, l.length > 1 ? (i = this.startNodeAt(o, a), i.expressions = l, this.finishNodeAt(i, "SequenceExpression", p, y)) : i = l[0];
  } else
    i = this.parseParenExpression();
  if (this.options.preserveParens) {
    var v = this.startNodeAt(n, r);
    return v.expression = i, this.finishNode(v, "ParenthesizedExpression");
  } else
    return i;
};
Be.parseParenItem = function(e) {
  return e;
};
Be.parseParenArrowList = function(e, t, n, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), n, !1, r);
};
var cX = [];
Be.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var e = this.startNode();
  if (this.next(), this.options.ecmaVersion >= 6 && this.type === L.dot) {
    var t = this.startNodeAt(e.start, e.loc && e.loc.start);
    t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
    var n = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
  }
  var r = this.start, i = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), r, i, !0, !1), this.eat(L.parenL) ? e.arguments = this.parseExprList(L.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = cX, this.finishNode(e, "NewExpression");
};
Be.parseTemplateElement = function(e) {
  var t = e.isTagged, n = this.startNode();
  return this.type === L.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
    raw: this.value.replace(/\r\n?/g, `
`),
    cooked: null
  }) : n.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), n.tail = this.type === L.backQuote, this.finishNode(n, "TemplateElement");
};
Be.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = !1);
  var n = this.startNode();
  this.next(), n.expressions = [];
  var r = this.parseTemplateElement({ isTagged: t });
  for (n.quasis = [r]; !r.tail; )
    this.type === L.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(L.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(L.braceR), n.quasis.push(r = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(n, "TemplateLiteral");
};
Be.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === L.name || this.type === L.num || this.type === L.string || this.type === L.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === L.star) && !Mn.test(this.input.slice(this.lastTokEnd, this.start));
};
Be.parseObj = function(e, t) {
  var n = this.startNode(), r = !0, i = {};
  for (n.properties = [], this.next(); !this.eat(L.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(L.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(L.braceR))
      break;
    var s = this.parseProperty(e, t);
    e || this.checkPropClash(s, i, t), n.properties.push(s);
  }
  return this.finishNode(n, e ? "ObjectPattern" : "ObjectExpression");
};
Be.parseProperty = function(e, t) {
  var n = this.startNode(), r, i, s, o;
  if (this.options.ecmaVersion >= 9 && this.eat(L.ellipsis))
    return e ? (n.argument = this.parseIdent(!1), this.type === L.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(n, "RestElement")) : (n.argument = this.parseMaybeAssign(!1, t), this.type === L.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(n, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (n.method = !1, n.shorthand = !1, (e || t) && (s = this.start, o = this.startLoc), e || (r = this.eat(L.star)));
  var a = this.containsEsc;
  return this.parsePropertyName(n), !e && !a && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(n) ? (i = !0, r = this.options.ecmaVersion >= 9 && this.eat(L.star), this.parsePropertyName(n)) : i = !1, this.parsePropertyValue(n, e, r, i, s, o, t, a), this.finishNode(n, "Property");
};
Be.parseGetterSetter = function(e) {
  var t = e.key.name;
  this.parsePropertyName(e), e.value = this.parseMethod(!1), e.kind = t;
  var n = e.kind === "get" ? 0 : 1;
  if (e.value.params.length !== n) {
    var r = e.value.start;
    e.kind === "get" ? this.raiseRecoverable(r, "getter should have no params") : this.raiseRecoverable(r, "setter should have exactly one param");
  } else
    e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
};
Be.parsePropertyValue = function(e, t, n, r, i, s, o, a) {
  (n || r) && this.type === L.colon && this.unexpected(), this.eat(L.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === L.parenL ? (t && this.unexpected(), e.method = !0, e.value = this.parseMethod(n, r), e.kind = "init") : !t && !a && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== L.comma && this.type !== L.braceR && this.type !== L.eq ? ((n || r) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((n || r) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = i), t ? e.value = this.parseMaybeDefault(i, s, this.copyNode(e.key)) : this.type === L.eq && o ? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start), e.value = this.parseMaybeDefault(i, s, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.kind = "init", e.shorthand = !0) : this.unexpected();
};
Be.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(L.bracketL))
      return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(L.bracketR), e.key;
    e.computed = !1;
  }
  return e.key = this.type === L.num || this.type === L.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
Be.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
};
Be.parseMethod = function(e, t, n) {
  var r = this.startNode(), i = this.yieldPos, s = this.awaitPos, o = this.awaitIdentPos;
  return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = e), this.options.ecmaVersion >= 8 && (r.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(px(t, r.generator) | Jp | (n ? TT : 0)), this.expect(L.parenL), r.params = this.parseBindingList(L.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(r, !1, !0, !1), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = o, this.finishNode(r, "FunctionExpression");
};
Be.parseArrowExpression = function(e, t, n, r) {
  var i = this.yieldPos, s = this.awaitPos, o = this.awaitIdentPos;
  return this.enterScope(px(n, !1) | hx), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, r), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = o, this.finishNode(e, "ArrowFunctionExpression");
};
Be.parseFunctionBody = function(e, t, n, r) {
  var i = t && this.type !== L.braceL, s = this.strict, o = !1;
  if (i)
    e.body = this.parseMaybeAssign(r), e.expression = !0, this.checkParams(e, !1);
  else {
    var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!s || a) && (o = this.strictDirective(this.end), o && a && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var l = this.labels;
    this.labels = [], o && (this.strict = !0), this.checkParams(e, !s && !o && !t && !n && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, IT), e.body = this.parseBlock(!1, void 0, o && !s), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = l;
  }
  this.exitScope();
};
Be.isSimpleParamList = function(e) {
  for (var t = 0, n = e; t < n.length; t += 1) {
    var r = n[t];
    if (r.type !== "Identifier")
      return !1;
  }
  return !0;
};
Be.checkParams = function(e, t) {
  for (var n = /* @__PURE__ */ Object.create(null), r = 0, i = e.params; r < i.length; r += 1) {
    var s = i[r];
    this.checkLValInnerPattern(s, mx, t ? null : n);
  }
};
Be.parseExprList = function(e, t, n, r) {
  for (var i = [], s = !0; !this.eat(e); ) {
    if (s)
      s = !1;
    else if (this.expect(L.comma), t && this.afterTrailingComma(e))
      break;
    var o = void 0;
    n && this.type === L.comma ? o = null : this.type === L.ellipsis ? (o = this.parseSpread(r), r && this.type === L.comma && r.trailingComma < 0 && (r.trailingComma = this.start)) : o = this.parseMaybeAssign(!1, r), i.push(o);
  }
  return i;
};
Be.checkUnreserved = function(e) {
  var t = e.start, n = e.end, r = e.name;
  if (this.inGenerator && r === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), !(this.currentThisScope().flags & Kp) && r === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (r === "arguments" || r === "await") && this.raise(t, "Cannot use " + r + " in class static initialization block"), this.keywords.test(r) && this.raise(t, "Unexpected keyword '" + r + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, n).indexOf("\\") !== -1)) {
    var i = this.strict ? this.reservedWordsStrict : this.reservedWords;
    i.test(r) && (!this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + r + "' is reserved"));
  }
};
Be.parseIdent = function(e) {
  var t = this.parseIdentNode();
  return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = t.start)), t;
};
Be.parseIdentNode = function() {
  var e = this.startNode();
  return this.type === L.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = L.name) : this.unexpected(), e;
};
Be.parsePrivateIdent = function() {
  var e = this.startNode();
  return this.type === L.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
};
Be.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === L.semi || this.canInsertSemicolon() || this.type !== L.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(L.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
Be.parseAwait = function(e) {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
};
var Ch = Mt.prototype;
Ch.raise = function(e, t) {
  var n = fx(this.input, e);
  t += " (" + n.line + ":" + n.column + ")", this.sourceFile && (t += " in " + this.sourceFile);
  var r = new SyntaxError(t);
  throw r.pos = e, r.loc = n, r.raisedAt = this.pos, r;
};
Ch.raiseRecoverable = Ch.raise;
Ch.curPosition = function() {
  if (this.options.locations)
    return new rl(this.curLine, this.pos - this.lineStart);
};
var no = Mt.prototype, uX = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [];
};
no.enterScope = function(e) {
  this.scopeStack.push(new uX(e));
};
no.exitScope = function() {
  this.scopeStack.pop();
};
no.treatFunctionsAsVarInScope = function(e) {
  return e.flags & El || !this.inModule && e.flags & Hc;
};
no.declareName = function(e, t, n) {
  var r = !1;
  if (t === fs) {
    var i = this.currentScope();
    r = i.lexical.indexOf(e) > -1 || i.functions.indexOf(e) > -1 || i.var.indexOf(e) > -1, i.lexical.push(e), this.inModule && i.flags & Hc && delete this.undefinedExports[e];
  } else if (t === NT) {
    var s = this.currentScope();
    s.lexical.push(e);
  } else if (t === AT) {
    var o = this.currentScope();
    this.treatFunctionsAsVar ? r = o.lexical.indexOf(e) > -1 : r = o.lexical.indexOf(e) > -1 || o.var.indexOf(e) > -1, o.functions.push(e);
  } else
    for (var a = this.scopeStack.length - 1; a >= 0; --a) {
      var l = this.scopeStack[a];
      if (l.lexical.indexOf(e) > -1 && !(l.flags & kT && l.lexical[0] === e) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(e) > -1) {
        r = !0;
        break;
      }
      if (l.var.push(e), this.inModule && l.flags & Hc && delete this.undefinedExports[e], l.flags & Kp)
        break;
    }
  r && this.raiseRecoverable(n, "Identifier '" + e + "' has already been declared");
};
no.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
no.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
no.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & (Kp | Su | ta))
      return t;
  }
};
no.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & (Kp | Su | ta) && !(t.flags & hx))
      return t;
  }
};
var ku = function(t, n, r) {
  this.type = "", this.start = n, this.end = 0, t.options.locations && (this.loc = new Eu(t, r)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [n, 0]);
}, Tu = Mt.prototype;
Tu.startNode = function() {
  return new ku(this, this.start, this.startLoc);
};
Tu.startNodeAt = function(e, t) {
  return new ku(this, e, t);
};
function OT(e, t, n, r) {
  return e.type = t, e.end = n, this.options.locations && (e.loc.end = r), this.options.ranges && (e.range[1] = n), e;
}
Tu.finishNode = function(e, t) {
  return OT.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
Tu.finishNodeAt = function(e, t, n, r) {
  return OT.call(this, e, t, n, r);
};
Tu.copyNode = function(e) {
  var t = new ku(this, e.start, this.startLoc);
  for (var n in e)
    t[n] = e[n];
  return t;
};
var fX = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", PT = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", DT = PT + " Extended_Pictographic", FT = DT, RT = FT + " EBase EComp EMod EPres ExtPict", $T = RT, dX = $T, hX = {
  9: PT,
  10: DT,
  11: FT,
  12: RT,
  13: $T,
  14: dX
}, pX = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", mX = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: pX
}, B4 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", VT = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", BT = VT + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", zT = BT + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", HT = zT + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", UT = HT + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", gX = UT + " " + fX, vX = {
  9: VT,
  10: BT,
  11: zT,
  12: HT,
  13: UT,
  14: gX
}, jT = {};
function yX(e) {
  var t = jT[e] = {
    binary: Ms(hX[e] + " " + B4),
    binaryOfStrings: Ms(mX[e]),
    nonBinary: {
      General_Category: Ms(B4),
      Script: Ms(vX[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
for (var wm = 0, z4 = [9, 10, 11, 12, 13, 14]; wm < z4.length; wm += 1) {
  var xX = z4[wm];
  yX(xX);
}
var Ae = Mt.prototype, Eh = function(t, n) {
  this.parent = t, this.base = n || this;
};
Eh.prototype.separatedFrom = function(t) {
  for (var n = this; n; n = n.parent)
    for (var r = t; r; r = r.parent)
      if (n.base === r.base && n !== r)
        return !0;
  return !1;
};
Eh.prototype.sibling = function() {
  return new Eh(this.parent, this.base);
};
var Si = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = jT[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
};
Si.prototype.reset = function(t, n, r) {
  var i = r.indexOf("v") !== -1, s = r.indexOf("u") !== -1;
  this.start = t | 0, this.source = n + "", this.flags = r, i && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = s && this.parser.options.ecmaVersion >= 9);
};
Si.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
Si.prototype.at = function(t, n) {
  n === void 0 && (n = !1);
  var r = this.source, i = r.length;
  if (t >= i)
    return -1;
  var s = r.charCodeAt(t);
  if (!(n || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= i)
    return s;
  var o = r.charCodeAt(t + 1);
  return o >= 56320 && o <= 57343 ? (s << 10) + o - 56613888 : s;
};
Si.prototype.nextIndex = function(t, n) {
  n === void 0 && (n = !1);
  var r = this.source, i = r.length;
  if (t >= i)
    return i;
  var s = r.charCodeAt(t), o;
  return !(n || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= i || (o = r.charCodeAt(t + 1)) < 56320 || o > 57343 ? t + 1 : t + 2;
};
Si.prototype.current = function(t) {
  return t === void 0 && (t = !1), this.at(this.pos, t);
};
Si.prototype.lookahead = function(t) {
  return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
};
Si.prototype.advance = function(t) {
  t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
};
Si.prototype.eat = function(t, n) {
  return n === void 0 && (n = !1), this.current(n) === t ? (this.advance(n), !0) : !1;
};
Si.prototype.eatChars = function(t, n) {
  n === void 0 && (n = !1);
  for (var r = this.pos, i = 0, s = t; i < s.length; i += 1) {
    var o = s[i], a = this.at(r, n);
    if (a === -1 || a !== o)
      return !1;
    r = this.nextIndex(r, n);
  }
  return this.pos = r, !0;
};
Ae.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, n = e.flags, r = !1, i = !1, s = 0; s < n.length; s++) {
    var o = n.charAt(s);
    t.indexOf(o) === -1 && this.raise(e.start, "Invalid regular expression flag"), n.indexOf(o, s + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag"), o === "u" && (r = !0), o === "v" && (i = !0);
  }
  this.options.ecmaVersion >= 15 && r && i && this.raise(e.start, "Invalid regular expression flag");
};
function wX(e) {
  for (var t in e)
    return !0;
  return !1;
}
Ae.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && wX(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
};
Ae.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames = /* @__PURE__ */ Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* ] */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, n = e.backReferenceNames; t < n.length; t += 1) {
    var r = n[t];
    e.groupNames[r] || e.raise("Invalid named capture referenced");
  }
};
Ae.regexp_disjunction = function(e) {
  var t = this.options.ecmaVersion >= 16;
  for (t && (e.branchID = new Eh(e.branchID, null)), this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
  t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
Ae.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
Ae.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
};
Ae.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = !1, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return !0;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return !0;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var n = !1;
    if (this.options.ecmaVersion >= 9 && (n = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !n, !0;
  }
  return e.pos = t, !1;
};
Ae.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), !0) : !1;
};
Ae.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
Ae.regexp_eatBracedQuantifier = function(e, t) {
  var n = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var r = 0, i = -1;
    if (this.regexp_eatDecimalDigits(e) && (r = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return i !== -1 && i < r && !t && e.raise("numbers out of order in {} quantifier"), !0;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = n;
  }
  return !1;
};
Ae.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
Ae.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
Ae.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var n = this.regexp_eatModifiers(e), r = e.eat(
          45
          /* - */
        );
        if (n || r) {
          for (var i = 0; i < n.length; i++) {
            var s = n.charAt(i);
            n.indexOf(s, i + 1) > -1 && e.raise("Duplicate regular expression modifiers");
          }
          if (r) {
            var o = this.regexp_eatModifiers(e);
            !n && !o && e.current() === 58 && e.raise("Invalid regular expression modifiers");
            for (var a = 0; a < o.length; a++) {
              var l = o.charAt(a);
              (o.indexOf(l, a + 1) > -1 || n.indexOf(l) > -1) && e.raise("Duplicate regular expression modifiers");
            }
          }
        }
      }
      if (e.eat(
        58
        /* : */
      )) {
        if (this.regexp_disjunction(e), e.eat(
          41
          /* ) */
        ))
          return !0;
        e.raise("Unterminated group");
      }
    }
    e.pos = t;
  }
  return !1;
};
Ae.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, !0;
    e.raise("Unterminated group");
  }
  return !1;
};
Ae.regexp_eatModifiers = function(e) {
  for (var t = "", n = 0; (n = e.current()) !== -1 && _X(n); )
    t += is(n), e.advance();
  return t;
};
function _X(e) {
  return e === 105 || e === 109 || e === 115;
}
Ae.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
Ae.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
};
Ae.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return WT(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function WT(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
Ae.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, n = 0; (n = e.current()) !== -1 && !WT(n); )
    e.advance();
  return e.pos !== t;
};
Ae.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
};
Ae.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    this.regexp_eatGroupName(e) || e.raise("Invalid group");
    var t = this.options.ecmaVersion >= 16, n = e.groupNames[e.lastStringValue];
    if (n)
      if (t)
        for (var r = 0, i = n; r < i.length; r += 1) {
          var s = i[r];
          s.separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
        }
      else
        e.raise("Duplicate capture group name");
    t ? (n || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
  }
};
Ae.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return !0;
    e.raise("Invalid capture group name");
  }
  return !1;
};
Ae.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += is(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += is(e.lastIntValue);
    return !0;
  }
  return !1;
};
Ae.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, n = this.options.ecmaVersion >= 11, r = e.current(n);
  return e.advance(n), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (r = e.lastIntValue), bX(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function bX(e) {
  return Jr(e, !0) || e === 36 || e === 95;
}
Ae.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, n = this.options.ecmaVersion >= 11, r = e.current(n);
  return e.advance(n), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (r = e.lastIntValue), CX(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function CX(e) {
  return rs(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
Ae.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
};
Ae.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var n = e.lastIntValue;
    if (e.switchU)
      return n > e.maxBackReference && (e.maxBackReference = n), !0;
    if (n <= e.numCapturingParens)
      return !0;
    e.pos = t;
  }
  return !1;
};
Ae.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), !0;
    e.raise("Invalid named reference");
  }
  return !1;
};
Ae.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
Ae.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
Ae.regexp_eatZero = function(e) {
  return e.current() === 48 && !Gp(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
};
Ae.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
};
Ae.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return JT(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
function JT(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
Ae.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
  t === void 0 && (t = !1);
  var n = e.pos, r = t || e.switchU;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var i = e.lastIntValue;
      if (r && i >= 55296 && i <= 56319) {
        var s = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var o = e.lastIntValue;
          if (o >= 56320 && o <= 57343)
            return e.lastIntValue = (i - 55296) * 1024 + (o - 56320) + 65536, !0;
        }
        e.pos = s, e.lastIntValue = i;
      }
      return !0;
    }
    if (r && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && EX(e.lastIntValue))
      return !0;
    r && e.raise("Invalid unicode escape"), e.pos = n;
  }
  return !1;
};
function EX(e) {
  return e >= 0 && e <= 1114111;
}
Ae.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, !0) : !1;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
Ae.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return !0;
  }
  return !1;
};
var KT = 0, ss = 1, vr = 2;
Ae.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (SX(t))
    return e.lastIntValue = -1, e.advance(), ss;
  var n = !1;
  if (e.switchU && this.options.ecmaVersion >= 9 && ((n = t === 80) || t === 112)) {
    e.lastIntValue = -1, e.advance();
    var r;
    if (e.eat(
      123
      /* { */
    ) && (r = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
      125
      /* } */
    ))
      return n && r === vr && e.raise("Invalid property name"), r;
    e.raise("Invalid property name");
  }
  return KT;
};
function SX(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
Ae.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var n = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var r = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, n, r), ss;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var i = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, i);
  }
  return KT;
};
Ae.regexp_validateUnicodePropertyNameAndValue = function(e, t, n) {
  Cl(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(n) || e.raise("Invalid property value");
};
Ae.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  if (e.unicodeProperties.binary.test(t))
    return ss;
  if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
    return vr;
  e.raise("Invalid property name");
};
Ae.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; qT(t = e.current()); )
    e.lastStringValue += is(t), e.advance();
  return e.lastStringValue !== "";
};
function qT(e) {
  return JT(e) || e === 95;
}
Ae.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; kX(t = e.current()); )
    e.lastStringValue += is(t), e.advance();
  return e.lastStringValue !== "";
};
function kX(e) {
  return qT(e) || Gp(e);
}
Ae.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
Ae.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    var t = e.eat(
      94
      /* ^ */
    ), n = this.regexp_classContents(e);
    return e.eat(
      93
      /* ] */
    ) || e.raise("Unterminated character class"), t && n === vr && e.raise("Negated character class may contain strings"), !0;
  }
  return !1;
};
Ae.regexp_classContents = function(e) {
  return e.current() === 93 ? ss : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), ss);
};
Ae.regexp_nonEmptyClassRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var n = e.lastIntValue;
      e.switchU && (t === -1 || n === -1) && e.raise("Invalid character class"), t !== -1 && n !== -1 && t > n && e.raise("Range out of order in character class");
    }
  }
};
Ae.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return !0;
    if (e.switchU) {
      var n = e.current();
      (n === 99 || XT(n)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var r = e.current();
  return r !== 93 ? (e.lastIntValue = r, e.advance(), !0) : !1;
};
Ae.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, !0;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, !0;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return !0;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
Ae.regexp_classSetExpression = function(e) {
  var t = ss, n;
  if (!this.regexp_eatClassSetRange(e)) if (n = this.regexp_eatClassSetOperand(e)) {
    n === vr && (t = vr);
    for (var r = e.pos; e.eatChars(
      [38, 38]
      /* && */
    ); ) {
      if (e.current() !== 38 && (n = this.regexp_eatClassSetOperand(e))) {
        n !== vr && (t = ss);
        continue;
      }
      e.raise("Invalid character in character class");
    }
    if (r !== e.pos)
      return t;
    for (; e.eatChars(
      [45, 45]
      /* -- */
    ); )
      this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
    if (r !== e.pos)
      return t;
  } else
    e.raise("Invalid character in character class");
  for (; ; )
    if (!this.regexp_eatClassSetRange(e)) {
      if (n = this.regexp_eatClassSetOperand(e), !n)
        return t;
      n === vr && (t = vr);
    }
};
Ae.regexp_eatClassSetRange = function(e) {
  var t = e.pos;
  if (this.regexp_eatClassSetCharacter(e)) {
    var n = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(e)) {
      var r = e.lastIntValue;
      return n !== -1 && r !== -1 && n > r && e.raise("Range out of order in character class"), !0;
    }
    e.pos = t;
  }
  return !1;
};
Ae.regexp_eatClassSetOperand = function(e) {
  return this.regexp_eatClassSetCharacter(e) ? ss : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
};
Ae.regexp_eatNestedClass = function(e) {
  var t = e.pos;
  if (e.eat(
    91
    /* [ */
  )) {
    var n = e.eat(
      94
      /* ^ */
    ), r = this.regexp_classContents(e);
    if (e.eat(
      93
      /* ] */
    ))
      return n && r === vr && e.raise("Negated character class may contain strings"), r;
    e.pos = t;
  }
  if (e.eat(
    92
    /* \ */
  )) {
    var i = this.regexp_eatCharacterClassEscape(e);
    if (i)
      return i;
    e.pos = t;
  }
  return null;
};
Ae.regexp_eatClassStringDisjunction = function(e) {
  var t = e.pos;
  if (e.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (e.eat(
      123
      /* { */
    )) {
      var n = this.regexp_classStringDisjunctionContents(e);
      if (e.eat(
        125
        /* } */
      ))
        return n;
    } else
      e.raise("Invalid escape");
    e.pos = t;
  }
  return null;
};
Ae.regexp_classStringDisjunctionContents = function(e) {
  for (var t = this.regexp_classString(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_classString(e) === vr && (t = vr);
  return t;
};
Ae.regexp_classString = function(e) {
  for (var t = 0; this.regexp_eatClassSetCharacter(e); )
    t++;
  return t === 1 ? ss : vr;
};
Ae.regexp_eatClassSetCharacter = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  ))
    return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
      98
      /* b */
    ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
  var n = e.current();
  return n < 0 || n === e.lookahead() && TX(n) || AX(n) ? !1 : (e.advance(), e.lastIntValue = n, !0);
};
function TX(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function AX(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
Ae.regexp_eatClassSetReservedPunctuator = function(e) {
  var t = e.current();
  return NX(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function NX(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
Ae.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return Gp(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
Ae.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return !0;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return !1;
};
Ae.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, n = 0;
  for (e.lastIntValue = 0; Gp(n = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (n - 48), e.advance();
  return e.pos !== t;
};
function Gp(e) {
  return e >= 48 && e <= 57;
}
Ae.regexp_eatHexDigits = function(e) {
  var t = e.pos, n = 0;
  for (e.lastIntValue = 0; GT(n = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + YT(n), e.advance();
  return e.pos !== t;
};
function GT(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function YT(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
Ae.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var n = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + n * 8 + e.lastIntValue : e.lastIntValue = t * 8 + n;
    } else
      e.lastIntValue = t;
    return !0;
  }
  return !1;
};
Ae.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return XT(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
};
function XT(e) {
  return e >= 48 && e <= 55;
}
Ae.regexp_eatFixedHexDigits = function(e, t) {
  var n = e.pos;
  e.lastIntValue = 0;
  for (var r = 0; r < t; ++r) {
    var i = e.current();
    if (!GT(i))
      return e.pos = n, !1;
    e.lastIntValue = 16 * e.lastIntValue + YT(i), e.advance();
  }
  return !0;
};
var Yp = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new Eu(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
}, Qe = Mt.prototype;
Qe.next = function(e) {
  !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Yp(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
Qe.getToken = function() {
  return this.next(), new Yp(this);
};
typeof Symbol < "u" && (Qe[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === L.eof,
        value: t
      };
    }
  };
});
Qe.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(L.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
Qe.readToken = function(e) {
  return Jr(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
Qe.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 56320)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
};
Qe.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, n = this.input.indexOf("*/", this.pos += 2);
  if (n === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations)
    for (var r = void 0, i = t; (r = CT(this.input, i, this.pos)) > -1; )
      ++this.curLine, i = this.lineStart = r;
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(t + 2, n),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
Qe.skipLineComment = function(e) {
  for (var t = this.pos, n = this.options.onComment && this.curPosition(), r = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !ea(r); )
    r = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    n,
    this.curPosition()
  );
};
Qe.skipSpace = function() {
  e: for (; this.pos < this.input.length; ) {
    var e = this.input.charCodeAt(this.pos);
    switch (e) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break e;
        }
        break;
      default:
        if (e > 8 && e < 14 || e >= 5760 && ux.test(String.fromCharCode(e)))
          ++this.pos;
        else
          break e;
    }
  }
};
Qe.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var n = this.type;
  this.type = e, this.value = t, this.updateContext(n);
};
Qe.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(!0);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(L.ellipsis)) : (++this.pos, this.finishToken(L.dot));
};
Qe.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(L.assign, 2) : this.finishOp(L.slash, 1);
};
Qe.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), n = 1, r = e === 42 ? L.star : L.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++n, r = L.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(L.assign, n + 1) : this.finishOp(r, n);
};
Qe.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t === e) {
    if (this.options.ecmaVersion >= 12) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n === 61)
        return this.finishOp(L.assign, 3);
    }
    return this.finishOp(e === 124 ? L.logicalOR : L.logicalAND, 2);
  }
  return t === 61 ? this.finishOp(L.assign, 2) : this.finishOp(e === 124 ? L.bitwiseOR : L.bitwiseAND, 1);
};
Qe.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(L.assign, 2) : this.finishOp(L.bitwiseXOR, 1);
};
Qe.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Mn.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(L.incDec, 2) : t === 61 ? this.finishOp(L.assign, 2) : this.finishOp(L.plusMin, 1);
};
Qe.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), n = 1;
  return t === e ? (n = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + n) === 61 ? this.finishOp(L.assign, n + 1) : this.finishOp(L.bitShift, n)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (n = 2), this.finishOp(L.relational, n));
};
Qe.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(L.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(L.arrow)) : this.finishOp(e === 61 ? L.eq : L.prefix, 1);
};
Qe.readToken_question = function() {
  var e = this.options.ecmaVersion;
  if (e >= 11) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === 46) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n < 48 || n > 57)
        return this.finishOp(L.questionDot, 2);
    }
    if (t === 63) {
      if (e >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61)
          return this.finishOp(L.assign, 3);
      }
      return this.finishOp(L.coalesce, 2);
    }
  }
  return this.finishOp(L.question, 1);
};
Qe.readToken_numberSign = function() {
  var e = this.options.ecmaVersion, t = 35;
  if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), Jr(t, !0) || t === 92))
    return this.finishToken(L.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + is(t) + "'");
};
Qe.getTokenFromCode = function(e) {
  switch (e) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(L.parenL);
    case 41:
      return ++this.pos, this.finishToken(L.parenR);
    case 59:
      return ++this.pos, this.finishToken(L.semi);
    case 44:
      return ++this.pos, this.finishToken(L.comma);
    case 91:
      return ++this.pos, this.finishToken(L.bracketL);
    case 93:
      return ++this.pos, this.finishToken(L.bracketR);
    case 123:
      return ++this.pos, this.finishToken(L.braceL);
    case 125:
      return ++this.pos, this.finishToken(L.braceR);
    case 58:
      return ++this.pos, this.finishToken(L.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(L.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(e);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(L.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + is(e) + "'");
};
Qe.finishOp = function(e, t) {
  var n = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, n);
};
Qe.readRegexp = function() {
  for (var e, t, n = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
    var r = this.input.charAt(this.pos);
    if (Mn.test(r) && this.raise(n, "Unterminated regular expression"), e)
      e = !1;
    else {
      if (r === "[")
        t = !0;
      else if (r === "]" && t)
        t = !1;
      else if (r === "/" && !t)
        break;
      e = r === "\\";
    }
    ++this.pos;
  }
  var i = this.input.slice(n, this.pos);
  ++this.pos;
  var s = this.pos, o = this.readWord1();
  this.containsEsc && this.unexpected(s);
  var a = this.regexpState || (this.regexpState = new Si(this));
  a.reset(n, i, o), this.validateRegExpFlags(a), this.validateRegExpPattern(a);
  var l = null;
  try {
    l = new RegExp(i, o);
  } catch {
  }
  return this.finishToken(L.regexp, { pattern: i, flags: o, value: l });
};
Qe.readInt = function(e, t, n) {
  for (var r = this.options.ecmaVersion >= 12 && t === void 0, i = n && this.input.charCodeAt(this.pos) === 48, s = this.pos, o = 0, a = 0, l = 0, c = t ?? 1 / 0; l < c; ++l, ++this.pos) {
    var u = this.input.charCodeAt(this.pos), f = void 0;
    if (r && u === 95) {
      i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), a === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), a = u;
      continue;
    }
    if (u >= 97 ? f = u - 97 + 10 : u >= 65 ? f = u - 65 + 10 : u >= 48 && u <= 57 ? f = u - 48 : f = 1 / 0, f >= e)
      break;
    a = u, o = o * e + f;
  }
  return r && a === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === s || t != null && this.pos - s !== t ? null : o;
};
function IX(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function ZT(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
Qe.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var n = this.readInt(e);
  return n == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (n = ZT(this.input.slice(t, this.pos)), ++this.pos) : Jr(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(L.num, n);
};
Qe.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
  var n = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  n && this.strict && this.raise(t, "Invalid number");
  var r = this.input.charCodeAt(this.pos);
  if (!n && !e && this.options.ecmaVersion >= 11 && r === 110) {
    var i = ZT(this.input.slice(t, this.pos));
    return ++this.pos, Jr(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(L.num, i);
  }
  n && /[89]/.test(this.input.slice(t, this.pos)) && (n = !1), r === 46 && !n && (++this.pos, this.readInt(10), r = this.input.charCodeAt(this.pos)), (r === 69 || r === 101) && !n && (r = this.input.charCodeAt(++this.pos), (r === 43 || r === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), Jr(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = IX(this.input.slice(t, this.pos), n);
  return this.finishToken(L.num, s);
};
Qe.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var n = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(n, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
Qe.readString = function(e) {
  for (var t = "", n = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var r = this.input.charCodeAt(this.pos);
    if (r === e)
      break;
    r === 92 ? (t += this.input.slice(n, this.pos), t += this.readEscapedChar(!1), n = this.pos) : r === 8232 || r === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (ea(r) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(n, this.pos++), this.finishToken(L.string, t);
};
var QT = {};
Qe.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === QT)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = !1;
};
Qe.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw QT;
  this.raise(e, t);
};
Qe.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var n = this.input.charCodeAt(this.pos);
    if (n === 96 || n === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === L.template || this.type === L.invalidTemplate) ? n === 36 ? (this.pos += 2, this.finishToken(L.dollarBraceL)) : (++this.pos, this.finishToken(L.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(L.template, e));
    if (n === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
    else if (ea(n)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, n) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(n);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
Qe.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken(L.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        this.input[this.pos + 1] === `
` && ++this.pos;
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine, this.lineStart = this.pos + 1;
        break;
    }
  this.raise(this.start, "Unterminated template");
};
Qe.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return is(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (this.strict && this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      ), e) {
        var n = this.pos - 1;
        this.invalidStringToken(
          n,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (t >= 48 && t <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(r, 8);
        return i > 255 && (r = r.slice(0, -1), i = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), (r !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - r.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(i);
      }
      return ea(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
  }
};
Qe.readHexChar = function(e) {
  var t = this.pos, n = this.readInt(16, e);
  return n === null && this.invalidStringToken(t, "Bad character escape sequence"), n;
};
Qe.readWord1 = function() {
  this.containsEsc = !1;
  for (var e = "", t = !0, n = this.pos, r = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var i = this.fullCharCodeAtPos();
    if (rs(i, r))
      this.pos += i <= 65535 ? 1 : 2;
    else if (i === 92) {
      this.containsEsc = !0, e += this.input.slice(n, this.pos);
      var s = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var o = this.readCodePoint();
      (t ? Jr : rs)(o, r) || this.invalidStringToken(s, "Invalid Unicode escape"), e += is(o), n = this.pos;
    } else
      break;
    t = !1;
  }
  return e + this.input.slice(n, this.pos);
};
Qe.readWord = function() {
  var e = this.readWord1(), t = L.name;
  return this.keywords.test(e) && (t = Wp[e]), this.finishToken(t, e);
};
var eA = "8.15.0";
Mt.acorn = {
  Parser: Mt,
  version: eA,
  defaultOptions: wh,
  Position: rl,
  SourceLocation: Eu,
  getLineInfo: fx,
  Node: ku,
  TokenType: nt,
  tokTypes: L,
  keywordTypes: Wp,
  TokContext: cr,
  tokContexts: kt,
  isIdentifierChar: rs,
  isIdentifierStart: Jr,
  Token: Yp,
  isNewLine: ea,
  lineBreak: Mn,
  lineBreakG: bT,
  nonASCIIwhitespace: ux
};
function LX(e, t) {
  return Mt.parse(e, t);
}
function MX(e, t, n) {
  return Mt.parseExpressionAt(e, t, n);
}
function OX(e, t) {
  return Mt.tokenizer(e, t);
}
const PX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Node: ku,
  Parser: Mt,
  Position: rl,
  SourceLocation: Eu,
  TokContext: cr,
  Token: Yp,
  TokenType: nt,
  defaultOptions: wh,
  getLineInfo: fx,
  isIdentifierChar: rs,
  isIdentifierStart: Jr,
  isNewLine: ea,
  keywordTypes: Wp,
  lineBreak: Mn,
  lineBreakG: bT,
  nonASCIIwhitespace: ux,
  parse: LX,
  parseExpressionAt: MX,
  tokContexts: kt,
  tokTypes: L,
  tokenizer: OX,
  version: eA
}, Symbol.toStringTag, { value: "Module" }));
var tA = { exports: {} }, DX = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
};
const H4 = /* @__PURE__ */ UV(PX);
(function(e) {
  const t = DX, n = /^[\da-fA-F]+$/, r = /^\d+$/, i = /* @__PURE__ */ new WeakMap();
  function s(l) {
    l = l.Parser.acorn || l;
    let c = i.get(l);
    if (!c) {
      const u = l.tokTypes, f = l.TokContext, d = l.TokenType, h = new f("<tag", !1), m = new f("</tag", !1), p = new f("<tag>...</tag>", !0, !0), y = {
        tc_oTag: h,
        tc_cTag: m,
        tc_expr: p
      }, v = {
        jsxName: new d("jsxName"),
        jsxText: new d("jsxText", { beforeExpr: !0 }),
        jsxTagStart: new d("jsxTagStart", { startsExpr: !0 }),
        jsxTagEnd: new d("jsxTagEnd")
      };
      v.jsxTagStart.updateContext = function() {
        this.context.push(p), this.context.push(h), this.exprAllowed = !1;
      }, v.jsxTagEnd.updateContext = function(g) {
        let x = this.context.pop();
        x === h && g === u.slash || x === m ? (this.context.pop(), this.exprAllowed = this.curContext() === p) : this.exprAllowed = !0;
      }, c = { tokContexts: y, tokTypes: v }, i.set(l, c);
    }
    return c;
  }
  function o(l) {
    if (!l)
      return l;
    if (l.type === "JSXIdentifier")
      return l.name;
    if (l.type === "JSXNamespacedName")
      return l.namespace.name + ":" + l.name.name;
    if (l.type === "JSXMemberExpression")
      return o(l.object) + "." + o(l.property);
  }
  e.exports = function(l) {
    return l = l || {}, function(c) {
      return a({
        allowNamespaces: l.allowNamespaces !== !1,
        allowNamespacedObjects: !!l.allowNamespacedObjects
      }, c);
    };
  }, Object.defineProperty(e.exports, "tokTypes", {
    get: function() {
      return s(H4).tokTypes;
    },
    configurable: !0,
    enumerable: !0
  });
  function a(l, c) {
    const u = c.acorn || H4, f = s(u), d = u.tokTypes, h = f.tokTypes, m = u.tokContexts, p = f.tokContexts.tc_oTag, y = f.tokContexts.tc_cTag, v = f.tokContexts.tc_expr, g = u.isNewLine, x = u.isIdentifierStart, _ = u.isIdentifierChar;
    return class extends c {
      // Expose actual `tokTypes` and `tokContexts` to other plugins.
      static get acornJsx() {
        return f;
      }
      // Reads inline JSX contents token.
      jsx_readToken() {
        let b = "", C = this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
          let E = this.input.charCodeAt(this.pos);
          switch (E) {
            case 60:
            case 123:
              return this.pos === this.start ? E === 60 && this.exprAllowed ? (++this.pos, this.finishToken(h.jsxTagStart)) : this.getTokenFromCode(E) : (b += this.input.slice(C, this.pos), this.finishToken(h.jsxText, b));
            case 38:
              b += this.input.slice(C, this.pos), b += this.jsx_readEntity(), C = this.pos;
              break;
            case 62:
            case 125:
              this.raise(
                this.pos,
                "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (E === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
              );
            default:
              g(E) ? (b += this.input.slice(C, this.pos), b += this.jsx_readNewLine(!0), C = this.pos) : ++this.pos;
          }
        }
      }
      jsx_readNewLine(b) {
        let C = this.input.charCodeAt(this.pos), E;
        return ++this.pos, C === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, E = b ? `
` : `\r
`) : E = String.fromCharCode(C), this.options.locations && (++this.curLine, this.lineStart = this.pos), E;
      }
      jsx_readString(b) {
        let C = "", E = ++this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          let S = this.input.charCodeAt(this.pos);
          if (S === b) break;
          S === 38 ? (C += this.input.slice(E, this.pos), C += this.jsx_readEntity(), E = this.pos) : g(S) ? (C += this.input.slice(E, this.pos), C += this.jsx_readNewLine(!1), E = this.pos) : ++this.pos;
        }
        return C += this.input.slice(E, this.pos++), this.finishToken(d.string, C);
      }
      jsx_readEntity() {
        let b = "", C = 0, E, S = this.input[this.pos];
        S !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
        let k = ++this.pos;
        for (; this.pos < this.input.length && C++ < 10; ) {
          if (S = this.input[this.pos++], S === ";") {
            b[0] === "#" ? b[1] === "x" ? (b = b.substr(2), n.test(b) && (E = String.fromCharCode(parseInt(b, 16)))) : (b = b.substr(1), r.test(b) && (E = String.fromCharCode(parseInt(b, 10)))) : E = t[b];
            break;
          }
          b += S;
        }
        return E || (this.pos = k, "&");
      }
      // Read a JSX identifier (valid tag or attribute name).
      //
      // Optimized version since JSX identifiers can't contain
      // escape characters and so can be read as single slice.
      // Also assumes that first character was already checked
      // by isIdentifierStart in readToken.
      jsx_readWord() {
        let b, C = this.pos;
        do
          b = this.input.charCodeAt(++this.pos);
        while (_(b) || b === 45);
        return this.finishToken(h.jsxName, this.input.slice(C, this.pos));
      }
      // Parse next token as JSX identifier
      jsx_parseIdentifier() {
        let b = this.startNode();
        return this.type === h.jsxName ? b.name = this.value : this.type.keyword ? b.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(b, "JSXIdentifier");
      }
      // Parse namespaced identifier.
      jsx_parseNamespacedName() {
        let b = this.start, C = this.startLoc, E = this.jsx_parseIdentifier();
        if (!l.allowNamespaces || !this.eat(d.colon)) return E;
        var S = this.startNodeAt(b, C);
        return S.namespace = E, S.name = this.jsx_parseIdentifier(), this.finishNode(S, "JSXNamespacedName");
      }
      // Parses element name in any form - namespaced, member
      // or single identifier.
      jsx_parseElementName() {
        if (this.type === h.jsxTagEnd) return "";
        let b = this.start, C = this.startLoc, E = this.jsx_parseNamespacedName();
        for (this.type === d.dot && E.type === "JSXNamespacedName" && !l.allowNamespacedObjects && this.unexpected(); this.eat(d.dot); ) {
          let S = this.startNodeAt(b, C);
          S.object = E, S.property = this.jsx_parseIdentifier(), E = this.finishNode(S, "JSXMemberExpression");
        }
        return E;
      }
      // Parses any type of JSX attribute value.
      jsx_parseAttributeValue() {
        switch (this.type) {
          case d.braceL:
            let b = this.jsx_parseExpressionContainer();
            return b.expression.type === "JSXEmptyExpression" && this.raise(b.start, "JSX attributes must only be assigned a non-empty expression"), b;
          case h.jsxTagStart:
          case d.string:
            return this.parseExprAtom();
          default:
            this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
      // JSXEmptyExpression is unique type since it doesn't actually parse anything,
      // and so it should start at the end of last read token (left brace) and finish
      // at the beginning of the next one (right brace).
      jsx_parseEmptyExpression() {
        let b = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
        return this.finishNodeAt(b, "JSXEmptyExpression", this.start, this.startLoc);
      }
      // Parses JSX expression enclosed into curly brackets.
      jsx_parseExpressionContainer() {
        let b = this.startNode();
        return this.next(), b.expression = this.type === d.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(d.braceR), this.finishNode(b, "JSXExpressionContainer");
      }
      // Parses following JSX attribute name-value pair.
      jsx_parseAttribute() {
        let b = this.startNode();
        return this.eat(d.braceL) ? (this.expect(d.ellipsis), b.argument = this.parseMaybeAssign(), this.expect(d.braceR), this.finishNode(b, "JSXSpreadAttribute")) : (b.name = this.jsx_parseNamespacedName(), b.value = this.eat(d.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(b, "JSXAttribute"));
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(b, C) {
        let E = this.startNodeAt(b, C);
        E.attributes = [];
        let S = this.jsx_parseElementName();
        for (S && (E.name = S); this.type !== d.slash && this.type !== h.jsxTagEnd; )
          E.attributes.push(this.jsx_parseAttribute());
        return E.selfClosing = this.eat(d.slash), this.expect(h.jsxTagEnd), this.finishNode(E, S ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      // Parses JSX closing tag starting after '</'.
      jsx_parseClosingElementAt(b, C) {
        let E = this.startNodeAt(b, C), S = this.jsx_parseElementName();
        return S && (E.name = S), this.expect(h.jsxTagEnd), this.finishNode(E, S ? "JSXClosingElement" : "JSXClosingFragment");
      }
      // Parses entire JSX element, including it's opening tag
      // (starting after '<'), attributes, contents and closing tag.
      jsx_parseElementAt(b, C) {
        let E = this.startNodeAt(b, C), S = [], k = this.jsx_parseOpeningElementAt(b, C), M = null;
        if (!k.selfClosing) {
          e: for (; ; )
            switch (this.type) {
              case h.jsxTagStart:
                if (b = this.start, C = this.startLoc, this.next(), this.eat(d.slash)) {
                  M = this.jsx_parseClosingElementAt(b, C);
                  break e;
                }
                S.push(this.jsx_parseElementAt(b, C));
                break;
              case h.jsxText:
                S.push(this.parseExprAtom());
                break;
              case d.braceL:
                S.push(this.jsx_parseExpressionContainer());
                break;
              default:
                this.unexpected();
            }
          o(M.name) !== o(k.name) && this.raise(
            M.start,
            "Expected corresponding JSX closing tag for <" + o(k.name) + ">"
          );
        }
        let O = k.name ? "Element" : "Fragment";
        return E["opening" + O] = k, E["closing" + O] = M, E.children = S, this.type === d.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(E, "JSX" + O);
      }
      // Parse JSX text
      jsx_parseText() {
        let b = this.parseLiteral(this.value);
        return b.type = "JSXText", b;
      }
      // Parses entire JSX element from current position.
      jsx_parseElement() {
        let b = this.start, C = this.startLoc;
        return this.next(), this.jsx_parseElementAt(b, C);
      }
      parseExprAtom(b) {
        return this.type === h.jsxText ? this.jsx_parseText() : this.type === h.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(b);
      }
      readToken(b) {
        let C = this.curContext();
        if (C === v) return this.jsx_readToken();
        if (C === p || C === y) {
          if (x(b)) return this.jsx_readWord();
          if (b == 62)
            return ++this.pos, this.finishToken(h.jsxTagEnd);
          if ((b === 34 || b === 39) && C == p)
            return this.jsx_readString(b);
        }
        return b === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(h.jsxTagStart)) : super.readToken(b);
      }
      updateContext(b) {
        if (this.type == d.braceL) {
          var C = this.curContext();
          C == p ? this.context.push(m.b_expr) : C == v ? this.context.push(m.b_tmpl) : super.updateContext(b), this.exprAllowed = !0;
        } else if (this.type === d.slash && b === h.jsxTagStart)
          this.context.length -= 2, this.context.push(y), this.exprAllowed = !1;
        else
          return super.updateContext(b);
      }
    };
  }
})(tA);
var FX = tA.exports;
const nA = /* @__PURE__ */ yl(FX);
function RX(e) {
  const t = e || {}, n = t.addResult, r = t.acorn, i = t.spread;
  let s = t.allowEmpty, o;
  if (s == null && (s = !0), r) {
    if (!r.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    o = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, t.acornOptions);
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      123: {
        name: "mdxFlowExpression",
        tokenize: a,
        concrete: !0
      }
    },
    text: {
      123: {
        name: "mdxTextExpression",
        tokenize: l
      }
    }
  };
  function a(c, u, f) {
    const d = this;
    return h;
    function h(v) {
      return m(v);
    }
    function m(v) {
      return Bd.call(d, c, p, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", r, o, n, i, s)(v);
    }
    function p(v) {
      return He(v) ? Ge(c, y, "whitespace")(v) : y(v);
    }
    function y(v) {
      const g = d.parser.constructs.flow[60], _ = (Array.isArray(g) ? g : (
        /* c8 ignore next 3 -- always a list when normalized. */
        g ? [g] : []
      )).find(function(b) {
        return b.name === "mdxJsxFlowTag";
      });
      return v === 60 && _ ? c.attempt(_, y, f)(v) : v === null || be(v) ? u(v) : f(v);
    }
  }
  function l(c, u) {
    const f = this;
    return d;
    function d(h) {
      return Bd.call(f, c, u, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", r, o, n, i, s, !0)(h);
    }
  }
}
const $X = {
  tokenize: zX,
  partial: !0
}, U4 = "https://github.com/micromark/micromark-extension-mdxjs-esm", VX = /* @__PURE__ */ new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);
function BX(e) {
  const t = {
    tokenize: i,
    concrete: !0
  };
  if (!e || !e.acorn || !e.acorn.parse)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  const n = e.acorn, r = Object.assign({
    ecmaVersion: 2024,
    sourceType: "module"
  }, e.acornOptions, {
    locations: !0
  });
  return {
    flow: {
      101: t,
      105: t
    }
  };
  function i(s, o, a) {
    const l = this, c = l.parser.definedModuleSpecifiers || (l.parser.definedModuleSpecifiers = []), u = this.events.length + 1;
    let f = "";
    return l.interrupt ? a : d;
    function d(g) {
      return l.now().column > 1 ? a(g) : (s.enter("mdxjsEsm"), s.enter("mdxjsEsmData"), s.consume(g), f += String.fromCharCode(g), h);
    }
    function h(g) {
      return er(g) ? (s.consume(g), f += String.fromCharCode(g), h) : (f === "import" || f === "export") && g === 32 ? (s.consume(g), m) : a(g);
    }
    function m(g) {
      return g === null || be(g) ? (s.exit("mdxjsEsmData"), p(g)) : (s.consume(g), m);
    }
    function p(g) {
      return g === null ? v(g) : be(g) ? s.check($X, v, y)(g) : (s.enter("mdxjsEsmData"), m(g));
    }
    function y(g) {
      return s.enter("lineEnding"), s.consume(g), s.exit("lineEnding"), p;
    }
    function v(g) {
      const x = i6(l.events.slice(u), {
        acorn: n,
        acornOptions: r,
        tokenTypes: ["mdxjsEsmData"],
        prefix: c.length > 0 ? "var " + c.join(",") + `
` : ""
      });
      if (x.error) {
        if (g !== null && x.swallow)
          return y(g);
        const b = new ot("Could not parse import/exports with acorn", {
          cause: x.error,
          place: {
            line: x.error.loc.line,
            column: x.error.loc.column + 1,
            offset: x.error.pos
          },
          ruleId: "acorn",
          source: "micromark-extension-mdxjs-esm"
        });
        throw b.url = U4 + "#could-not-parse-importexports-with-acorn", b;
      }
      c.length > 0 && x.estree.body.shift();
      let _ = -1;
      for (; ++_ < x.estree.body.length; ) {
        const b = x.estree.body[_];
        if (!VX.has(b.type)) {
          const C = new ot("Unexpected `" + b.type + "` in code: only import/exports are supported", {
            place: ji(b),
            ruleId: "non-esm",
            source: "micromark-extension-mdxjs-esm"
          });
          throw C.url = U4 + "#unexpected-type-in-code-only-importexports-are-supported", C;
        }
        if (b.type === "ImportDeclaration" && !l.interrupt) {
          let C = -1;
          for (; ++C < b.specifiers.length; ) {
            const E = b.specifiers[C];
            c.push(E.local.name);
          }
        }
      }
      return Object.assign(s.exit("mdxjsEsm"), e.addResult ? {
        estree: x.estree
      } : void 0), o(g);
    }
  }
}
function zX(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), e.attempt(uu, t, n);
  }
}
function rA(e) {
  const t = Object.assign(
    {
      acorn: Mt.extend(nA()),
      acornOptions: { ecmaVersion: 2024, sourceType: "module" },
      addResult: !0
    },
    e
  );
  return L6([
    BX(t),
    RX(t),
    zd(t),
    o6()
  ]);
}
const vx = T.createContext(void 0);
function yx() {
  const e = T.useContext(vx);
  if (!e)
    throw new Error("useNestedEditor must be used within a NestedEditorsProvider");
  return e;
}
function kl() {
  const { parentEditor: e, mdastNode: t, lexicalNode: n } = yx();
  return function(i) {
    e.update(
      () => {
        k9("history-push");
        const s = wt(n.getKey());
        s && s.setMdastNode({ ...t, ...i });
      },
      { discrete: !0 }
    ), e.dispatchCommand(du, void 0);
  };
}
function HX() {
  const { parentEditor: e, lexicalNode: t } = yx();
  return () => {
    e.update(() => {
      const n = wt(t.getKey());
      n.selectNext(), n.remove();
    });
  };
}
const xx = function(e) {
  const { getContent: t, getUpdatedMdastNode: n, contentEditableProps: r, block: i = !1 } = e, { mdastNode: s, lexicalNode: o, focusEmitter: a } = yx(), l = kl(), c = HX(), u = t(s), f = Yc(), [
    d,
    h,
    m,
    p,
    y,
    v,
    g,
    x,
    _,
    b
  ] = On(
    Gr,
    Qv,
    ty,
    ey,
    qa,
    Mc,
    hu,
    ny,
    oS,
    qd
  ), C = It(eS), [E] = T.useState(() => p9({
    nodes: p,
    theme: f.getValue(qd)
  }));
  return T.useEffect(() => {
    a.subscribe(() => {
      E.focus();
    });
  }, [E, a]), T.useEffect(() => {
    E.update(() => {
      Xe().clear();
      let S = u;
      i ? S.length === 0 && (S = [{ type: "paragraph", children: [] }]) : S = [{ type: "paragraph", children: u }], U6({
        root: Xe(),
        mdastRoot: {
          type: "root",
          children: S
        },
        visitors: h,
        directiveDescriptors: v,
        codeBlockEditorDescriptors: g,
        jsxComponentDescriptors: y
      });
    });
  }, [E, i, h]), T.useEffect(() => {
    function S() {
      E.getEditorState().read(() => {
        const k = A6({
          root: Xe(),
          visitors: m,
          jsxComponentDescriptors: y,
          jsxIsAvailable: x,
          addImportStatements: !1
        }), M = i ? k.children : k.children[0].children;
        l(n(structuredClone(s), M));
      });
    }
    return Dn(
      E.registerCommand(
        hv,
        () => (C({ editorType: "lexical", rootNode: o }), !1),
        xt
      ),
      E.registerCommand(
        pv,
        (k) => {
          const M = k.relatedTarget;
          return Q7(M, d.getRootElement()) ? !1 : (S(), C(null), !0);
        },
        qe
      ),
      // triggered by codemirror
      E.registerCommand(
        du,
        () => (S(), !0),
        qe
      ),
      E.registerCommand(
        Zc,
        () => (C({ editorType: "lexical", rootNode: o }), !1),
        Ld
      ),
      E.registerCommand(
        rp,
        (k, M) => {
          const O = M.getRootElement();
          return (O == null ? void 0 : O.innerText) === `
` ? (c(), !0) : !1;
        },
        zr
      )
    );
  }, [
    i,
    E,
    m,
    n,
    y,
    x,
    o,
    s,
    c,
    C,
    l,
    d
  ]), /* @__PURE__ */ T.createElement(sH, { initialEditor: E, initialTheme: b }, /* @__PURE__ */ T.createElement(
    hS,
    {
      contentEditable: /* @__PURE__ */ T.createElement(dS, { ...r, className: rt(de.nestedEditor, r == null ? void 0 : r.className) }),
      placeholder: null,
      ErrorBoundary: mS
    }
  ), /* @__PURE__ */ T.createElement(W6, null), _.map((S, k) => /* @__PURE__ */ T.createElement(S, { key: k })));
};
function wx() {
  let e = Ta;
  return {
    publish: () => {
      e();
    },
    subscribe: (t) => {
      e = t;
    }
  };
}
var UX = Object.defineProperty, jX = (e, t, n) => t in e ? UX(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, df = (e, t, n) => (jX(e, typeof t != "symbol" ? t + "" : t, n), n);
class Au extends bi {
  constructor(t, n, r) {
    super(r), df(this, "__mdastNode"), df(this, "__focusEmitter", wx()), df(this, "__importStatement"), df(this, "select", () => {
      this.__focusEmitter.publish();
    }), this.__mdastNode = t, this.__importStatement = n;
  }
  static getType() {
    return "jsx";
  }
  static clone(t) {
    return new Au(structuredClone(t.__mdastNode), structuredClone(t.__importStatement), t.__key);
  }
  static importJSON(t) {
    return Uc(t.mdastNode, t.importStatement);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  getImportStatement() {
    return this.__importStatement;
  }
  exportJSON() {
    return {
      mdastNode: this.getMdastNode(),
      importStatement: this.getImportStatement(),
      type: "jsx",
      version: 1
    };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "mdxJsxTextElement" ? "span" : "div");
  }
  updateDOM() {
    return !1;
  }
  setMdastNode(t) {
    this.getWritable().__mdastNode = t;
  }
  decorate(t, n) {
    return /* @__PURE__ */ T.createElement(
      WX,
      {
        lexicalJsxNode: this,
        config: n,
        mdastNode: this.getMdastNode(),
        parentEditor: t,
        focusEmitter: this.__focusEmitter
      }
    );
  }
  isInline() {
    return this.__mdastNode.type === "mdxJsxTextElement";
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function WX(e) {
  const { mdastNode: t } = e, n = mn(qa), r = n.find((s) => s.name === t.name) ?? n.find((s) => s.name === "*");
  if (!r)
    throw new Error(`No JSX descriptor found for ${t.name}`);
  const i = r.Editor;
  return /* @__PURE__ */ T.createElement(
    vx.Provider,
    {
      value: {
        config: e.config,
        focusEmitter: e.focusEmitter,
        mdastNode: t,
        parentEditor: e.parentEditor,
        lexicalNode: e.lexicalJsxNode
      }
    },
    /* @__PURE__ */ T.createElement(i, { descriptor: r, mdastNode: t })
  );
}
function Uc(e, t) {
  return new Au(e, t);
}
function JX(e) {
  return e instanceof Au;
}
const KX = {
  testLexicalNode: JX,
  visitLexicalNode({ actions: e, mdastParent: t, lexicalNode: n }) {
    function r(o) {
      "children" in o && o.children instanceof Array && o.children.forEach((a) => {
        oZ(a) && !T6.includes(a.name.toLowerCase()) && e.registerReferredComponent(a.name), r(a);
      });
    }
    const i = n.getMdastNode(), s = n.getImportStatement();
    e.registerReferredComponent(i.name, s), r(i), e.appendToParent(t, i);
  },
  priority: -200
}, qX = {
  testNode: "mdxjsEsm",
  visitNode() {
  }
}, GX = {
  testNode: (e, { jsxComponentDescriptors: t }) => e.type === "mdxJsxTextElement" || e.type === "mdxJsxFlowElement" ? (t.find((r) => r.name === e.name) ?? t.find((r) => r.name === "*")) !== void 0 : !1,
  visitNode({ lexicalParent: e, mdastNode: t, descriptors: { jsxComponentDescriptors: n }, metaData: r }) {
    const i = n.find((s) => s.name === t.name) ?? n.find((s) => s.name === "*");
    if ((i == null ? void 0 : i.kind) === "text" && t.type === "mdxJsxFlowElement") {
      const s = { ...t, type: "mdxJsxTextElement" }, o = st();
      o.append(Uc(s, t.name ? r.importDeclarations[t.name] : void 0)), e.append(o);
    } else
      e.append(
        Uc(t, t.name ? r.importDeclarations[t.name] : void 0)
      );
  },
  priority: -200
};
var YX = Object.defineProperty, XX = (e, t, n) => t in e ? YX(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, j4 = (e, t, n) => (XX(e, typeof t != "symbol" ? t + "" : t, n), n);
class Nu extends bi {
  /**
   * Constructs a new {@link GenericHTMLNode} with the specified MDAST HTML node as the object to edit.
   */
  constructor(t, n, r) {
    super(r), j4(this, "__value"), j4(this, "__mdastType"), this.__value = t, this.__mdastType = n;
  }
  /** @internal */
  static getType() {
    return "mdx-expression";
  }
  /** @internal */
  static clone(t) {
    return new Nu(t.__value, t.__mdastType, t.__key);
  }
  getValue() {
    return this.__value;
  }
  getMdastType() {
    return this.__mdastType;
  }
  // View
  createDOM() {
    const t = document.createElement("span");
    return t.classList.add(en.mdxExpression), t;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    return {
      element: n
    };
  }
  static importJSON(t) {
    return iA(t.value, t.mdastType);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      value: this.getValue(),
      mdastType: this.getMdastType(),
      type: "mdx-expression",
      version: 1
    };
  }
  /*
    // Mutation
    insertNewAfter(selection?: RangeSelection, restoreSelection = true): ParagraphNode | GenericHTMLNode {
      const anchorOffet = selection ? selection.anchor.offset : 0
      const newElement =
        anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const direction = this.getDirection()
      newElement.setDirection(direction)
      this.insertAfter(newElement, restoreSelection)
      return newElement
    }
  
    collapseAtStart(): true {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const children = this.getChildren()
      children.forEach((child) => newElement.append(child))
      this.replace(newElement)
      return true
    }*/
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__mdastType === "mdxTextExpression";
  }
  decorate(t) {
    return /* @__PURE__ */ T.createElement(T.Fragment, null, "{", /* @__PURE__ */ T.createElement("span", { className: de.inputSizer, "data-value": this.getValue() }, /* @__PURE__ */ T.createElement(
      "input",
      {
        size: 1,
        onKeyDown: (n) => {
          (n.target.value === "" && n.key === "Backspace" || n.key === "Delete") && (n.stopPropagation(), n.nativeEvent.stopImmediatePropagation(), n.preventDefault(), t.update(() => {
            this.selectPrevious(), this.remove();
          }));
        },
        onChange: (n) => {
          n.target.parentElement.dataset.value = n.target.value, t.update(() => {
            this.getWritable().__value = n.target.value;
          });
        },
        type: "text",
        value: this.getValue()
      }
    )), "}");
  }
}
function iA(e, t) {
  return Pn(new Nu(e, t));
}
function ZX(e) {
  return e instanceof Nu;
}
const QX = {
  testNode: (e) => e.type === "mdxTextExpression" || e.type === "mdxFlowExpression",
  visitNode({ lexicalParent: e, mdastNode: t }) {
    e.append(iA(t.value, t.type));
  },
  priority: -200
}, eZ = {
  testLexicalNode: ZX,
  visitLexicalNode({ actions: e, mdastParent: t, lexicalNode: n }) {
    const r = {
      type: n.getMdastType(),
      value: n.getValue()
    };
    e.appendToParent(t, r);
  }
}, tZ = (e) => {
  const t = mn(Yo);
  return /* @__PURE__ */ T.createElement(S7, { ...e, container: t == null ? void 0 : t.current });
}, nZ = T.forwardRef(
  (e, t) => /* @__PURE__ */ T.createElement(k7, { ...e, className: de.popoverContent, sideOffset: 5, side: "top", ref: t }, /* @__PURE__ */ T.createElement("span", { className: de.popoverArrow }, /* @__PURE__ */ T.createElement(T7, null)), e.children)
), sA = ({ title: e, properties: t, onChange: n }) => {
  const [r, i] = T.useState(!1), s = mn(ir), { register: o, handleSubmit: a, reset: l } = Hp({ defaultValues: t });
  return /* @__PURE__ */ T.createElement(
    E7,
    {
      open: r,
      onOpenChange: (c) => {
        i(c);
      }
    },
    /* @__PURE__ */ T.createElement(Zj, { className: de.iconButton }, /* @__PURE__ */ T.createElement("div", null, s("settings"))),
    /* @__PURE__ */ T.createElement(tZ, null, /* @__PURE__ */ T.createElement(nZ, null, /* @__PURE__ */ T.createElement(
      "form",
      {
        onSubmit: (c) => {
          a(n)(c), i(!1), c.preventDefault(), c.stopPropagation();
        }
      },
      /* @__PURE__ */ T.createElement("h3", { className: de.propertyPanelTitle }, e, " Attributes"),
      /* @__PURE__ */ T.createElement("table", { className: de.propertyEditorTable }, /* @__PURE__ */ T.createElement("thead", null, /* @__PURE__ */ T.createElement("tr", null, /* @__PURE__ */ T.createElement("th", { className: de.readOnlyColumnCell }, "Attribute"), /* @__PURE__ */ T.createElement("th", null, "Value"))), /* @__PURE__ */ T.createElement("tbody", null, Object.keys(t).map((c) => /* @__PURE__ */ T.createElement("tr", { key: c }, /* @__PURE__ */ T.createElement("th", { className: de.readOnlyColumnCell }, " ", c, " "), /* @__PURE__ */ T.createElement("td", null, /* @__PURE__ */ T.createElement("input", { ...o(c), className: de.propertyEditorInput }))))), /* @__PURE__ */ T.createElement("tfoot", null, /* @__PURE__ */ T.createElement("tr", null, /* @__PURE__ */ T.createElement("td", { colSpan: 2 }, /* @__PURE__ */ T.createElement("div", { className: de.buttonsFooter }, /* @__PURE__ */ T.createElement("button", { type: "submit", className: de.primaryButton }, "Save"), /* @__PURE__ */ T.createElement(
        "button",
        {
          type: "reset",
          className: de.secondaryButton,
          onClick: (c) => {
            c.preventDefault(), l(t), i(!1);
          }
        },
        "Cancel"
      ))))))
    )))
  );
}, rZ = (e) => e !== null && typeof e == "object" && "type" in e && "value" in e && typeof e.value == "string", iZ = (e) => typeof e == "string", sZ = (e) => e.type === "mdxJsxAttribute" && typeof e.name == "string", ho = ({ mdastNode: e, descriptor: t, PropertyEditor: n }) => {
  const r = kl(), i = T.useMemo(
    () => t.props.reduce((l, { name: c }) => {
      const u = e.attributes.find((f) => sZ(f) ? f.name === c : !1);
      if (u) {
        if (rZ(u.value))
          return l[c] = u.value.value, l;
        if (iZ(u.value))
          return l[c] = u.value, l;
      }
      return l[c] = "", l;
    }, {}),
    [e, t]
  ), s = T.useCallback(
    (l) => {
      const c = Object.entries(l).reduce((u, [f, d]) => {
        if (d === "")
          return u;
        const h = t.props.find((m) => m.name === f);
        return (h == null ? void 0 : h.type) === "expression" ? (u.push({
          type: "mdxJsxAttribute",
          name: f,
          value: { type: "mdxJsxAttributeValueExpression", value: d }
        }), u) : (u.push({
          type: "mdxJsxAttribute",
          name: f,
          value: d
        }), u);
      }, []);
      r({ attributes: c });
    },
    [e, r, t]
  ), o = n ?? sA, a = t.props.length == 0 && t.hasChildren && t.kind === "flow";
  return /* @__PURE__ */ T.createElement("div", { className: t.kind === "text" ? de.inlineEditor : de.blockEditor }, a ? /* @__PURE__ */ T.createElement("span", { className: de.genericComponentName }, e.name ?? "Fragment") : null, t.props.length > 0 ? /* @__PURE__ */ T.createElement(o, { properties: i, title: e.name ?? "", onChange: s }) : null, t.hasChildren ? /* @__PURE__ */ T.createElement(
    xx,
    {
      block: t.kind === "flow",
      getContent: (l) => l.children,
      getUpdatedMdastNode: (l, c) => ({ ...l, children: c })
    }
  ) : /* @__PURE__ */ T.createElement("span", { className: de.genericComponentName }, e.name));
};
function oZ(e) {
  return e.type === "mdxJsxFlowElement" || e.type === "mdxJsxTextElement";
}
const aZ = (e) => e !== null && typeof e == "object" && "type" in e && "value" in e && typeof e.value == "string", lZ = (e) => Object.entries(e).map(
  ([t, n]) => ({
    type: "mdxJsxAttribute",
    name: t,
    value: aZ(n) ? { type: "mdxJsxAttributeValueExpression", value: n.value } : n
  })
), Iu = Bt((e) => {
  e.link(
    e.pipe(
      Iu,
      Ds(({ kind: t, name: n, children: r, props: i }) => () => {
        const s = lZ(i);
        return Uc(t === "flow" ? {
          type: "mdxJsxFlowElement",
          name: n,
          children: r ?? [],
          attributes: s
        } : {
          type: "mdxJsxTextElement",
          name: n,
          children: r ?? [],
          attributes: s
        });
      })
    ),
    Ep
  );
}), W4 = {
  name: null,
  kind: "flow",
  props: [],
  hasChildren: !0,
  Editor: ho
}, J4 = (e) => e ? e.allowFragment ?? !0 ? [W4, ...e.jsxComponentDescriptors] : e.jsxComponentDescriptors : [W4], cZ = Jn({
  init: (e, t) => {
    e.pubIn({
      // import
      [ny]: !0,
      [Ya]: xT(),
      [Ga]: rA(),
      [Er]: [GX, qX, QX],
      // export
      [Yr]: [Au, Nu],
      [Xr]: [KX, eZ],
      [pu]: cx(),
      [qa]: J4(t)
    });
  },
  update(e, t) {
    e.pub(qa, J4(t));
  }
});
var uZ = Object.defineProperty, fZ = (e, t, n) => t in e ? uZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, vs = (e, t, n) => (fZ(e, typeof t != "symbol" ? t + "" : t, n), n);
class Tl extends bi {
  constructor(t, n, r, i) {
    super(i), vs(this, "__code"), vs(this, "__meta"), vs(this, "__language"), vs(this, "__focusEmitter", wx()), vs(this, "setCode", (s) => {
      s !== this.__code && (this.getWritable().__code = s);
    }), vs(this, "setMeta", (s) => {
      s !== this.__meta && (this.getWritable().__meta = s);
    }), vs(this, "setLanguage", (s) => {
      s !== this.__language && (this.getWritable().__language = s);
    }), vs(this, "select", () => {
      this.__focusEmitter.publish();
    }), this.__code = t, this.__meta = r, this.__language = n;
  }
  static getType() {
    return "codeblock";
  }
  static clone(t) {
    return new Tl(t.__code, t.__language, t.__meta, t.__key);
  }
  static importJSON(t) {
    const { code: n, meta: r, language: i } = t;
    return Lu({
      code: n,
      language: i,
      meta: r
    });
  }
  static importDOM() {
    return {
      pre: () => ({
        conversion: gZ,
        priority: 3
      })
    };
  }
  exportJSON() {
    return {
      code: this.getCode(),
      language: this.getLanguage(),
      meta: this.getMeta(),
      type: "codeblock",
      version: 1
    };
  }
  // View
  createDOM(t) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getCode() {
    return this.__code;
  }
  getMeta() {
    return this.__meta;
  }
  getLanguage() {
    return this.__language;
  }
  decorate(t) {
    return /* @__PURE__ */ T.createElement(
      pZ,
      {
        parentEditor: t,
        code: this.getCode(),
        meta: this.getMeta(),
        language: this.getLanguage(),
        codeBlockNode: this,
        nodeKey: this.getKey(),
        focusEmitter: this.__focusEmitter
      }
    );
  }
  isInline() {
    return !1;
  }
}
const dZ = T.createContext(null), hZ = ({ parentEditor: e, lexicalNode: t, children: n }) => {
  const r = T.useMemo(() => ({
    lexicalNode: t,
    parentEditor: e,
    setCode: (i) => {
      e.update(() => {
        t.setCode(i), setTimeout(() => {
          e.dispatchCommand(du, void 0);
        }, 0);
      });
    },
    setLanguage: (i) => {
      e.update(() => {
        t.setLanguage(i);
      });
    },
    setMeta: (i) => {
      e.update(() => {
        t.setMeta(i);
      });
    }
  }), [t, e]);
  return /* @__PURE__ */ T.createElement(dZ.Provider, { value: r }, n);
}, pZ = (e) => {
  const t = mn(hu), n = mn(_x);
  let r = t.sort((l, c) => c.priority - l.priority).find((l) => l.match(e.language || "", e.meta || ""));
  if (r || (r = t.find((l) => l.match(n || "", e.meta || ""))), !r)
    throw new Error(`No CodeBlockEditor registered for language=${e.language} meta=${e.meta}`);
  const i = r.Editor, { codeBlockNode: s, parentEditor: o, ...a } = e;
  return /* @__PURE__ */ T.createElement(hZ, { parentEditor: e.parentEditor, lexicalNode: e.codeBlockNode }, /* @__PURE__ */ T.createElement(i, { ...a }));
};
function Lu(e) {
  const { code: t = "", language: n = "", meta: r = "" } = e;
  return new Tl(t, n, r);
}
function mZ(e) {
  return e instanceof Tl;
}
function gZ(e) {
  const t = e, n = t.textContent ?? "", r = e.getAttribute("class") ?? "", i = e.getAttribute("data-language") ?? "", s = r.match(/language-(\w+)/), o = s ? s[1] : i, a = t.getAttribute("data-meta") ?? "";
  return {
    node: Lu({ code: n, language: o, meta: a })
  };
}
const vZ = {
  testLexicalNode: mZ,
  visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
    t.addAndStepInto("code", {
      value: e.getCode(),
      lang: e.getLanguage(),
      meta: e.getMeta()
    });
  }
}, yZ = {
  testNode: (e, { codeBlockEditorDescriptors: t }) => e.type === "code" ? t.find((r) => r.match(e.lang, e.meta)) !== void 0 : !1,
  visitNode({ mdastNode: e, actions: t }) {
    t.addAndStepInto(
      Lu({
        code: e.value,
        language: e.lang,
        meta: e.meta
      })
    );
  }
}, _x = Te(""), xZ = Bt((e) => {
  e.link(
    e.pipe(
      xZ,
      Tt(_x),
      Ds(
        ([t, n]) => () => Lu({ language: n, ...t })
      )
    ),
    Ep
  );
});
Fn(hu);
const wZ = Jn({
  update(e, t) {
    e.pub(_x, (t == null ? void 0 : t.defaultCodeBlockLanguage) ?? "");
  },
  init(e, t) {
    e.pubIn({
      [vl]: "codeblock",
      [hu]: (t == null ? void 0 : t.codeBlockEditorDescriptors) ?? [],
      [Er]: yZ,
      [Yr]: Tl,
      [Xr]: vZ
    });
  }
});
function K4(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function _Z(e) {
  const t = w.useRef({ value: e, previous: e });
  return w.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var oA = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), bZ = "VisuallyHidden", aA = w.forwardRef(
  (e, t) => /* @__PURE__ */ A(
    Ye.span,
    {
      ...e,
      ref: t,
      style: { ...oA, ...e.style }
    }
  )
);
aA.displayName = bZ;
var CZ = aA, EZ = [" ", "Enter", "ArrowUp", "ArrowDown"], SZ = [" ", "Enter"], jo = "Select", [Xp, Zp, kZ] = A7(jo), [Al, jme] = us(jo, [
  kZ,
  bl
]), Qp = bl(), [TZ, ro] = Al(jo), [AZ, NZ] = Al(jo), lA = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    value: o,
    defaultValue: a,
    onValueChange: l,
    dir: c,
    name: u,
    autoComplete: f,
    disabled: d,
    required: h,
    form: m
  } = e, p = Qp(t), [y, v] = w.useState(null), [g, x] = w.useState(null), [_, b] = w.useState(!1), C = Pp(c), [E, S] = ts({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: jo
  }), [k, M] = ts({
    prop: o,
    defaultProp: a,
    onChange: l,
    caller: jo
  }), O = w.useRef(null), R = y ? m || !!y.closest("form") : !0, [I, H] = w.useState(/* @__PURE__ */ new Set()), P = Array.from(I).map((W) => W.props.value).join(";");
  return /* @__PURE__ */ A(yy, { ...p, children: /* @__PURE__ */ Oe(
    TZ,
    {
      required: h,
      scope: t,
      trigger: y,
      onTriggerChange: v,
      valueNode: g,
      onValueNodeChange: x,
      valueNodeHasChildren: _,
      onValueNodeHasChildrenChange: b,
      contentId: qi(),
      value: k,
      onValueChange: M,
      open: E,
      onOpenChange: S,
      dir: C,
      triggerPointerDownPosRef: O,
      disabled: d,
      children: [
        /* @__PURE__ */ A(Xp.Provider, { scope: t, children: /* @__PURE__ */ A(
          AZ,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: w.useCallback((W) => {
              H((G) => new Set(G).add(W));
            }, []),
            onNativeOptionRemove: w.useCallback((W) => {
              H((G) => {
                const J = new Set(G);
                return J.delete(W), J;
              });
            }, []),
            children: n
          }
        ) }),
        R ? /* @__PURE__ */ Oe(
          AA,
          {
            "aria-hidden": !0,
            required: h,
            tabIndex: -1,
            name: u,
            autoComplete: f,
            value: k,
            onChange: (W) => M(W.target.value),
            disabled: d,
            form: m,
            children: [
              k === void 0 ? /* @__PURE__ */ A("option", { value: "" }) : null,
              Array.from(I)
            ]
          },
          P
        ) : null
      ]
    }
  ) });
};
lA.displayName = jo;
var cA = "SelectTrigger", uA = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = e, s = Qp(n), o = ro(cA, n), a = o.disabled || r, l = _t(t, o.onTriggerChange), c = Zp(n), u = w.useRef("touch"), [f, d, h] = IA((p) => {
      const y = c().filter((x) => !x.disabled), v = y.find((x) => x.value === o.value), g = LA(y, p, v);
      g !== void 0 && o.onValueChange(g.value);
    }), m = (p) => {
      a || (o.onOpenChange(!0), h()), p && (o.triggerPointerDownPosRef.current = {
        x: Math.round(p.pageX),
        y: Math.round(p.pageY)
      });
    };
    return /* @__PURE__ */ A(Ip, { asChild: !0, ...s, children: /* @__PURE__ */ A(
      Ye.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": o.contentId,
        "aria-expanded": o.open,
        "aria-required": o.required,
        "aria-autocomplete": "none",
        dir: o.dir,
        "data-state": o.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": NA(o.value) ? "" : void 0,
        ...i,
        ref: l,
        onClick: ze(i.onClick, (p) => {
          p.currentTarget.focus(), u.current !== "mouse" && m(p);
        }),
        onPointerDown: ze(i.onPointerDown, (p) => {
          u.current = p.pointerType;
          const y = p.target;
          y.hasPointerCapture(p.pointerId) && y.releasePointerCapture(p.pointerId), p.button === 0 && p.ctrlKey === !1 && p.pointerType === "mouse" && (m(p), p.preventDefault());
        }),
        onKeyDown: ze(i.onKeyDown, (p) => {
          const y = f.current !== "";
          !(p.ctrlKey || p.altKey || p.metaKey) && p.key.length === 1 && d(p.key), !(y && p.key === " ") && EZ.includes(p.key) && (m(), p.preventDefault());
        })
      }
    ) });
  }
);
uA.displayName = cA;
var fA = "SelectValue", dA = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, children: s, placeholder: o = "", ...a } = e, l = ro(fA, n), { onValueNodeHasChildrenChange: c } = l, u = s !== void 0, f = _t(t, l.onValueNodeChange);
    return gn(() => {
      c(u);
    }, [c, u]), /* @__PURE__ */ A(
      Ye.span,
      {
        ...a,
        ref: f,
        style: { pointerEvents: "none" },
        children: NA(l.value) ? /* @__PURE__ */ A(Ut, { children: o }) : s
      }
    );
  }
);
dA.displayName = fA;
var IZ = "SelectIcon", hA = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: r, ...i } = e;
    return /* @__PURE__ */ A(Ye.span, { "aria-hidden": !0, ...i, ref: t, children: r || "▼" });
  }
);
hA.displayName = IZ;
var LZ = "SelectPortal", pA = (e) => /* @__PURE__ */ A(yu, { asChild: !0, ...e });
pA.displayName = LZ;
var Wo = "SelectContent", mA = w.forwardRef(
  (e, t) => {
    const n = ro(Wo, e.__scopeSelect), [r, i] = w.useState();
    if (gn(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const s = r;
      return s ? Dh.createPortal(
        /* @__PURE__ */ A(gA, { scope: e.__scopeSelect, children: /* @__PURE__ */ A(Xp.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ A("div", { children: e.children }) }) }),
        s
      ) : null;
    }
    return /* @__PURE__ */ A(vA, { ...e, ref: t });
  }
);
mA.displayName = Wo;
var Lr = 10, [gA, io] = Al(Wo), MZ = "SelectContentImpl", OZ = /* @__PURE__ */ Za("SelectContent.RemoveScroll"), vA = w.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: s,
      onPointerDownOutside: o,
      //
      // PopperContent props
      side: a,
      sideOffset: l,
      align: c,
      alignOffset: u,
      arrowPadding: f,
      collisionBoundary: d,
      collisionPadding: h,
      sticky: m,
      hideWhenDetached: p,
      avoidCollisions: y,
      //
      ...v
    } = e, g = ro(Wo, n), [x, _] = w.useState(null), [b, C] = w.useState(null), E = _t(t, (q) => _(q)), [S, k] = w.useState(null), [M, O] = w.useState(
      null
    ), R = Zp(n), [I, H] = w.useState(!1), P = w.useRef(!1);
    w.useEffect(() => {
      if (x) return _y(x);
    }, [x]), ly();
    const W = w.useCallback(
      (q) => {
        const [Z, ...oe] = R().map((Y) => Y.ref.current), [le] = oe.slice(-1), ie = document.activeElement;
        for (const Y of q)
          if (Y === ie || (Y == null || Y.scrollIntoView({ block: "nearest" }), Y === Z && b && (b.scrollTop = 0), Y === le && b && (b.scrollTop = b.scrollHeight), Y == null || Y.focus(), document.activeElement !== ie)) return;
      },
      [R, b]
    ), G = w.useCallback(
      () => W([S, x]),
      [W, S, x]
    );
    w.useEffect(() => {
      I && G();
    }, [I, G]);
    const { onOpenChange: J, triggerPointerDownPosRef: X } = g;
    w.useEffect(() => {
      if (x) {
        let q = { x: 0, y: 0 };
        const Z = (le) => {
          var ie, Y;
          q = {
            x: Math.abs(Math.round(le.pageX) - (((ie = X.current) == null ? void 0 : ie.x) ?? 0)),
            y: Math.abs(Math.round(le.pageY) - (((Y = X.current) == null ? void 0 : Y.y) ?? 0))
          };
        }, oe = (le) => {
          q.x <= 10 && q.y <= 10 ? le.preventDefault() : x.contains(le.target) || J(!1), document.removeEventListener("pointermove", Z), X.current = null;
        };
        return X.current !== null && (document.addEventListener("pointermove", Z), document.addEventListener("pointerup", oe, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", Z), document.removeEventListener("pointerup", oe, { capture: !0 });
        };
      }
    }, [x, J, X]), w.useEffect(() => {
      const q = () => J(!1);
      return window.addEventListener("blur", q), window.addEventListener("resize", q), () => {
        window.removeEventListener("blur", q), window.removeEventListener("resize", q);
      };
    }, [J]);
    const [N, U] = IA((q) => {
      const Z = R().filter((ie) => !ie.disabled), oe = Z.find((ie) => ie.ref.current === document.activeElement), le = LA(Z, q, oe);
      le && setTimeout(() => le.ref.current.focus());
    }), ee = w.useCallback(
      (q, Z, oe) => {
        const le = !P.current && !oe;
        (g.value !== void 0 && g.value === Z || le) && (k(q), le && (P.current = !0));
      },
      [g.value]
    ), F = w.useCallback(() => x == null ? void 0 : x.focus(), [x]), ue = w.useCallback(
      (q, Z, oe) => {
        const le = !P.current && !oe;
        (g.value !== void 0 && g.value === Z || le) && O(q);
      },
      [g.value]
    ), pe = r === "popper" ? K0 : yA, ce = pe === K0 ? {
      side: a,
      sideOffset: l,
      align: c,
      alignOffset: u,
      arrowPadding: f,
      collisionBoundary: d,
      collisionPadding: h,
      sticky: m,
      hideWhenDetached: p,
      avoidCollisions: y
    } : {};
    return /* @__PURE__ */ A(
      gA,
      {
        scope: n,
        content: x,
        viewport: b,
        onViewportChange: C,
        itemRefCallback: ee,
        selectedItem: S,
        onItemLeave: F,
        itemTextRefCallback: ue,
        focusSelectedItem: G,
        selectedItemText: M,
        position: r,
        isPositioned: I,
        searchRef: N,
        children: /* @__PURE__ */ A(Mp, { as: OZ, allowPinchZoom: !0, children: /* @__PURE__ */ A(
          kp,
          {
            asChild: !0,
            trapped: g.open,
            onMountAutoFocus: (q) => {
              q.preventDefault();
            },
            onUnmountAutoFocus: ze(i, (q) => {
              var Z;
              (Z = g.trigger) == null || Z.focus({ preventScroll: !0 }), q.preventDefault();
            }),
            children: /* @__PURE__ */ A(
              gu,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: s,
                onPointerDownOutside: o,
                onFocusOutside: (q) => q.preventDefault(),
                onDismiss: () => g.onOpenChange(!1),
                children: /* @__PURE__ */ A(
                  pe,
                  {
                    role: "listbox",
                    id: g.contentId,
                    "data-state": g.open ? "open" : "closed",
                    dir: g.dir,
                    onContextMenu: (q) => q.preventDefault(),
                    ...v,
                    ...ce,
                    onPlaced: () => H(!0),
                    ref: E,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...v.style
                    },
                    onKeyDown: ze(v.onKeyDown, (q) => {
                      const Z = q.ctrlKey || q.altKey || q.metaKey;
                      if (q.key === "Tab" && q.preventDefault(), !Z && q.key.length === 1 && U(q.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(q.key)) {
                        let le = R().filter((ie) => !ie.disabled).map((ie) => ie.ref.current);
                        if (["ArrowUp", "End"].includes(q.key) && (le = le.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(q.key)) {
                          const ie = q.target, Y = le.indexOf(ie);
                          le = le.slice(Y + 1);
                        }
                        setTimeout(() => W(le)), q.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
vA.displayName = MZ;
var PZ = "SelectItemAlignedPosition", yA = w.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: r, ...i } = e, s = ro(Wo, n), o = io(Wo, n), [a, l] = w.useState(null), [c, u] = w.useState(null), f = _t(t, (E) => u(E)), d = Zp(n), h = w.useRef(!1), m = w.useRef(!0), { viewport: p, selectedItem: y, selectedItemText: v, focusSelectedItem: g } = o, x = w.useCallback(() => {
    if (s.trigger && s.valueNode && a && c && p && y && v) {
      const E = s.trigger.getBoundingClientRect(), S = c.getBoundingClientRect(), k = s.valueNode.getBoundingClientRect(), M = v.getBoundingClientRect();
      if (s.dir !== "rtl") {
        const ie = M.left - S.left, Y = k.left - ie, Ce = E.left - Y, Fe = E.width + Ce, je = Math.max(Fe, S.width), Ze = window.innerWidth - Lr, mt = K4(Y, [
          Lr,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(Lr, Ze - je)
        ]);
        a.style.minWidth = Fe + "px", a.style.left = mt + "px";
      } else {
        const ie = S.right - M.right, Y = window.innerWidth - k.right - ie, Ce = window.innerWidth - E.right - Y, Fe = E.width + Ce, je = Math.max(Fe, S.width), Ze = window.innerWidth - Lr, mt = K4(Y, [
          Lr,
          Math.max(Lr, Ze - je)
        ]);
        a.style.minWidth = Fe + "px", a.style.right = mt + "px";
      }
      const O = d(), R = window.innerHeight - Lr * 2, I = p.scrollHeight, H = window.getComputedStyle(c), P = parseInt(H.borderTopWidth, 10), W = parseInt(H.paddingTop, 10), G = parseInt(H.borderBottomWidth, 10), J = parseInt(H.paddingBottom, 10), X = P + W + I + J + G, N = Math.min(y.offsetHeight * 5, X), U = window.getComputedStyle(p), ee = parseInt(U.paddingTop, 10), F = parseInt(U.paddingBottom, 10), ue = E.top + E.height / 2 - Lr, pe = R - ue, ce = y.offsetHeight / 2, q = y.offsetTop + ce, Z = P + W + q, oe = X - Z;
      if (Z <= ue) {
        const ie = O.length > 0 && y === O[O.length - 1].ref.current;
        a.style.bottom = "0px";
        const Y = c.clientHeight - p.offsetTop - p.offsetHeight, Ce = Math.max(
          pe,
          ce + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (ie ? F : 0) + Y + G
        ), Fe = Z + Ce;
        a.style.height = Fe + "px";
      } else {
        const ie = O.length > 0 && y === O[0].ref.current;
        a.style.top = "0px";
        const Ce = Math.max(
          ue,
          P + p.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (ie ? ee : 0) + ce
        ) + oe;
        a.style.height = Ce + "px", p.scrollTop = Z - ue + p.offsetTop;
      }
      a.style.margin = `${Lr}px 0`, a.style.minHeight = N + "px", a.style.maxHeight = R + "px", r == null || r(), requestAnimationFrame(() => h.current = !0);
    }
  }, [
    d,
    s.trigger,
    s.valueNode,
    a,
    c,
    p,
    y,
    v,
    s.dir,
    r
  ]);
  gn(() => x(), [x]);
  const [_, b] = w.useState();
  gn(() => {
    c && b(window.getComputedStyle(c).zIndex);
  }, [c]);
  const C = w.useCallback(
    (E) => {
      E && m.current === !0 && (x(), g == null || g(), m.current = !1);
    },
    [x, g]
  );
  return /* @__PURE__ */ A(
    FZ,
    {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: h,
      onScrollButtonChange: C,
      children: /* @__PURE__ */ A(
        "div",
        {
          ref: l,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: _
          },
          children: /* @__PURE__ */ A(
            Ye.div,
            {
              ...i,
              ref: f,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...i.style
              }
            }
          )
        }
      )
    }
  );
});
yA.displayName = PZ;
var DZ = "SelectPopperPosition", K0 = w.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: i = Lr,
    ...s
  } = e, o = Qp(n);
  return /* @__PURE__ */ A(
    xy,
    {
      ...o,
      ...s,
      ref: t,
      align: r,
      collisionPadding: i,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...s.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
K0.displayName = DZ;
var [FZ, bx] = Al(Wo, {}), q0 = "SelectViewport", xA = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: r, ...i } = e, s = io(q0, n), o = bx(q0, n), a = _t(t, s.onViewportChange), l = w.useRef(0);
    return /* @__PURE__ */ Oe(Ut, { children: [
      /* @__PURE__ */ A(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ A(Xp.Slot, { scope: n, children: /* @__PURE__ */ A(
        Ye.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...i,
          ref: a,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...i.style
          },
          onScroll: ze(i.onScroll, (c) => {
            const u = c.currentTarget, { contentWrapper: f, shouldExpandOnScrollRef: d } = o;
            if (d != null && d.current && f) {
              const h = Math.abs(l.current - u.scrollTop);
              if (h > 0) {
                const m = window.innerHeight - Lr * 2, p = parseFloat(f.style.minHeight), y = parseFloat(f.style.height), v = Math.max(p, y);
                if (v < m) {
                  const g = v + h, x = Math.min(m, g), _ = g - x;
                  f.style.height = x + "px", f.style.bottom === "0px" && (u.scrollTop = _ > 0 ? _ : 0, f.style.justifyContent = "flex-end");
                }
              }
            }
            l.current = u.scrollTop;
          })
        }
      ) })
    ] });
  }
);
xA.displayName = q0;
var wA = "SelectGroup", [RZ, $Z] = Al(wA), VZ = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = qi();
    return /* @__PURE__ */ A(RZ, { scope: n, id: i, children: /* @__PURE__ */ A(Ye.div, { role: "group", "aria-labelledby": i, ...r, ref: t }) });
  }
);
VZ.displayName = wA;
var _A = "SelectLabel", BZ = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = $Z(_A, n);
    return /* @__PURE__ */ A(Ye.div, { id: i.id, ...r, ref: t });
  }
);
BZ.displayName = _A;
var Sh = "SelectItem", [zZ, bA] = Al(Sh), CA = w.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: i = !1,
      textValue: s,
      ...o
    } = e, a = ro(Sh, n), l = io(Sh, n), c = a.value === r, [u, f] = w.useState(s ?? ""), [d, h] = w.useState(!1), m = _t(
      t,
      (g) => {
        var x;
        return (x = l.itemRefCallback) == null ? void 0 : x.call(l, g, r, i);
      }
    ), p = qi(), y = w.useRef("touch"), v = () => {
      i || (a.onValueChange(r), a.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ A(
      zZ,
      {
        scope: n,
        value: r,
        disabled: i,
        textId: p,
        isSelected: c,
        onItemTextChange: w.useCallback((g) => {
          f((x) => x || ((g == null ? void 0 : g.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ A(
          Xp.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: i,
            textValue: u,
            children: /* @__PURE__ */ A(
              Ye.div,
              {
                role: "option",
                "aria-labelledby": p,
                "data-highlighted": d ? "" : void 0,
                "aria-selected": c && d,
                "data-state": c ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...o,
                ref: m,
                onFocus: ze(o.onFocus, () => h(!0)),
                onBlur: ze(o.onBlur, () => h(!1)),
                onClick: ze(o.onClick, () => {
                  y.current !== "mouse" && v();
                }),
                onPointerUp: ze(o.onPointerUp, () => {
                  y.current === "mouse" && v();
                }),
                onPointerDown: ze(o.onPointerDown, (g) => {
                  y.current = g.pointerType;
                }),
                onPointerMove: ze(o.onPointerMove, (g) => {
                  var x;
                  y.current = g.pointerType, i ? (x = l.onItemLeave) == null || x.call(l) : y.current === "mouse" && g.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: ze(o.onPointerLeave, (g) => {
                  var x;
                  g.currentTarget === document.activeElement && ((x = l.onItemLeave) == null || x.call(l));
                }),
                onKeyDown: ze(o.onKeyDown, (g) => {
                  var _;
                  ((_ = l.searchRef) == null ? void 0 : _.current) !== "" && g.key === " " || (SZ.includes(g.key) && v(), g.key === " " && g.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
CA.displayName = Sh;
var Xl = "SelectItemText", EA = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, ...s } = e, o = ro(Xl, n), a = io(Xl, n), l = bA(Xl, n), c = NZ(Xl, n), [u, f] = w.useState(null), d = _t(
      t,
      (v) => f(v),
      l.onItemTextChange,
      (v) => {
        var g;
        return (g = a.itemTextRefCallback) == null ? void 0 : g.call(a, v, l.value, l.disabled);
      }
    ), h = u == null ? void 0 : u.textContent, m = w.useMemo(
      () => /* @__PURE__ */ A("option", { value: l.value, disabled: l.disabled, children: h }, l.value),
      [l.disabled, l.value, h]
    ), { onNativeOptionAdd: p, onNativeOptionRemove: y } = c;
    return gn(() => (p(m), () => y(m)), [p, y, m]), /* @__PURE__ */ Oe(Ut, { children: [
      /* @__PURE__ */ A(Ye.span, { id: l.textId, ...s, ref: d }),
      l.isSelected && o.valueNode && !o.valueNodeHasChildren ? Dh.createPortal(s.children, o.valueNode) : null
    ] });
  }
);
EA.displayName = Xl;
var SA = "SelectItemIndicator", HZ = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return bA(SA, n).isSelected ? /* @__PURE__ */ A(Ye.span, { "aria-hidden": !0, ...r, ref: t }) : null;
  }
);
HZ.displayName = SA;
var G0 = "SelectScrollUpButton", UZ = w.forwardRef((e, t) => {
  const n = io(G0, e.__scopeSelect), r = bx(G0, e.__scopeSelect), [i, s] = w.useState(!1), o = _t(t, r.onScrollButtonChange);
  return gn(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const c = l.scrollTop > 0;
        s(c);
      };
      const l = n.viewport;
      return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ A(
    kA,
    {
      ...e,
      ref: o,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: l } = n;
        a && l && (a.scrollTop = a.scrollTop - l.offsetHeight);
      }
    }
  ) : null;
});
UZ.displayName = G0;
var Y0 = "SelectScrollDownButton", jZ = w.forwardRef((e, t) => {
  const n = io(Y0, e.__scopeSelect), r = bx(Y0, e.__scopeSelect), [i, s] = w.useState(!1), o = _t(t, r.onScrollButtonChange);
  return gn(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const c = l.scrollHeight - l.clientHeight, u = Math.ceil(l.scrollTop) < c;
        s(u);
      };
      const l = n.viewport;
      return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ A(
    kA,
    {
      ...e,
      ref: o,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: l } = n;
        a && l && (a.scrollTop = a.scrollTop + l.offsetHeight);
      }
    }
  ) : null;
});
jZ.displayName = Y0;
var kA = w.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: r, ...i } = e, s = io("SelectScrollButton", n), o = w.useRef(null), a = Zp(n), l = w.useCallback(() => {
    o.current !== null && (window.clearInterval(o.current), o.current = null);
  }, []);
  return w.useEffect(() => () => l(), [l]), gn(() => {
    var u;
    const c = a().find((f) => f.ref.current === document.activeElement);
    (u = c == null ? void 0 : c.ref.current) == null || u.scrollIntoView({ block: "nearest" });
  }, [a]), /* @__PURE__ */ A(
    Ye.div,
    {
      "aria-hidden": !0,
      ...i,
      ref: t,
      style: { flexShrink: 0, ...i.style },
      onPointerDown: ze(i.onPointerDown, () => {
        o.current === null && (o.current = window.setInterval(r, 50));
      }),
      onPointerMove: ze(i.onPointerMove, () => {
        var c;
        (c = s.onItemLeave) == null || c.call(s), o.current === null && (o.current = window.setInterval(r, 50));
      }),
      onPointerLeave: ze(i.onPointerLeave, () => {
        l();
      })
    }
  );
}), WZ = "SelectSeparator", TA = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return /* @__PURE__ */ A(Ye.div, { "aria-hidden": !0, ...r, ref: t });
  }
);
TA.displayName = WZ;
var X0 = "SelectArrow", JZ = w.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Qp(n), s = ro(X0, n), o = io(X0, n);
    return s.open && o.position === "popper" ? /* @__PURE__ */ A(wy, { ...i, ...r, ref: t }) : null;
  }
);
JZ.displayName = X0;
var KZ = "SelectBubbleInput", AA = w.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, r) => {
    const i = w.useRef(null), s = _t(r, i), o = _Z(t);
    return w.useEffect(() => {
      const a = i.current;
      if (!a) return;
      const l = window.HTMLSelectElement.prototype, u = Object.getOwnPropertyDescriptor(
        l,
        "value"
      ).set;
      if (o !== t && u) {
        const f = new Event("change", { bubbles: !0 });
        u.call(a, t), a.dispatchEvent(f);
      }
    }, [o, t]), /* @__PURE__ */ A(
      Ye.select,
      {
        ...n,
        style: { ...oA, ...n.style },
        ref: s,
        defaultValue: t
      }
    );
  }
);
AA.displayName = KZ;
function NA(e) {
  return e === "" || e === void 0;
}
function IA(e) {
  const t = js(e), n = w.useRef(""), r = w.useRef(0), i = w.useCallback(
    (o) => {
      const a = n.current + o;
      t(a), function l(c) {
        n.current = c, window.clearTimeout(r.current), c !== "" && (r.current = window.setTimeout(() => l(""), 1e3));
      }(a);
    },
    [t]
  ), s = w.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return w.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, s];
}
function LA(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t, s = n ? e.indexOf(n) : -1;
  let o = qZ(e, Math.max(s, 0));
  i.length === 1 && (o = o.filter((c) => c !== n));
  const l = o.find(
    (c) => c.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function qZ(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var GZ = lA, YZ = uA, XZ = dA, ZZ = hA, QZ = pA, eQ = mA, tQ = xA, nQ = CA, rQ = EA, iQ = TA, [e1, Wme] = us("Tooltip", [
  bl
]), t1 = bl(), MA = "TooltipProvider", sQ = 700, Z0 = "tooltip.open", [oQ, Cx] = e1(MA), OA = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = sQ,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: s
  } = e, o = w.useRef(!0), a = w.useRef(!1), l = w.useRef(0);
  return w.useEffect(() => {
    const c = l.current;
    return () => window.clearTimeout(c);
  }, []), /* @__PURE__ */ A(
    oQ,
    {
      scope: t,
      isOpenDelayedRef: o,
      delayDuration: n,
      onOpen: w.useCallback(() => {
        window.clearTimeout(l.current), o.current = !1;
      }, []),
      onClose: w.useCallback(() => {
        window.clearTimeout(l.current), l.current = window.setTimeout(
          () => o.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: w.useCallback((c) => {
        a.current = c;
      }, []),
      disableHoverableContent: i,
      children: s
    }
  );
};
OA.displayName = MA;
var jc = "Tooltip", [aQ, Mu] = e1(jc), PA = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    disableHoverableContent: o,
    delayDuration: a
  } = e, l = Cx(jc, e.__scopeTooltip), c = t1(t), [u, f] = w.useState(null), d = qi(), h = w.useRef(0), m = o ?? l.disableHoverableContent, p = a ?? l.delayDuration, y = w.useRef(!1), [v, g] = ts({
    prop: r,
    defaultProp: i ?? !1,
    onChange: (E) => {
      E ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Z0))) : l.onClose(), s == null || s(E);
    },
    caller: jc
  }), x = w.useMemo(() => v ? y.current ? "delayed-open" : "instant-open" : "closed", [v]), _ = w.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, y.current = !1, g(!0);
  }, [g]), b = w.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, g(!1);
  }, [g]), C = w.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      y.current = !0, g(!0), h.current = 0;
    }, p);
  }, [p, g]);
  return w.useEffect(() => () => {
    h.current && (window.clearTimeout(h.current), h.current = 0);
  }, []), /* @__PURE__ */ A(yy, { ...c, children: /* @__PURE__ */ A(
    aQ,
    {
      scope: t,
      contentId: d,
      open: v,
      stateAttribute: x,
      trigger: u,
      onTriggerChange: f,
      onTriggerEnter: w.useCallback(() => {
        l.isOpenDelayedRef.current ? C() : _();
      }, [l.isOpenDelayedRef, C, _]),
      onTriggerLeave: w.useCallback(() => {
        m ? b() : (window.clearTimeout(h.current), h.current = 0);
      }, [b, m]),
      onOpen: _,
      onClose: b,
      disableHoverableContent: m,
      children: n
    }
  ) });
};
PA.displayName = jc;
var Q0 = "TooltipTrigger", DA = w.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = Mu(Q0, n), s = Cx(Q0, n), o = t1(n), a = w.useRef(null), l = _t(t, a, i.onTriggerChange), c = w.useRef(!1), u = w.useRef(!1), f = w.useCallback(() => c.current = !1, []);
    return w.useEffect(() => () => document.removeEventListener("pointerup", f), [f]), /* @__PURE__ */ A(Ip, { asChild: !0, ...o, children: /* @__PURE__ */ A(
      Ye.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: ze(e.onPointerMove, (d) => {
          d.pointerType !== "touch" && !u.current && !s.isPointerInTransitRef.current && (i.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: ze(e.onPointerLeave, () => {
          i.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: ze(e.onPointerDown, () => {
          i.open && i.onClose(), c.current = !0, document.addEventListener("pointerup", f, { once: !0 });
        }),
        onFocus: ze(e.onFocus, () => {
          c.current || i.onOpen();
        }),
        onBlur: ze(e.onBlur, i.onClose),
        onClick: ze(e.onClick, i.onClose)
      }
    ) });
  }
);
DA.displayName = Q0;
var Ex = "TooltipPortal", [lQ, cQ] = e1(Ex, {
  forceMount: void 0
}), FA = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, s = Mu(Ex, t);
  return /* @__PURE__ */ A(lQ, { scope: t, forceMount: n, children: /* @__PURE__ */ A(Qs, { present: n || s.open, children: /* @__PURE__ */ A(yu, { asChild: !0, container: i, children: r }) }) });
};
FA.displayName = Ex;
var il = "TooltipContent", RA = w.forwardRef(
  (e, t) => {
    const n = cQ(il, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...s } = e, o = Mu(il, e.__scopeTooltip);
    return /* @__PURE__ */ A(Qs, { present: r || o.open, children: o.disableHoverableContent ? /* @__PURE__ */ A($A, { side: i, ...s, ref: t }) : /* @__PURE__ */ A(uQ, { side: i, ...s, ref: t }) });
  }
), uQ = w.forwardRef((e, t) => {
  const n = Mu(il, e.__scopeTooltip), r = Cx(il, e.__scopeTooltip), i = w.useRef(null), s = _t(t, i), [o, a] = w.useState(null), { trigger: l, onClose: c } = n, u = i.current, { onPointerInTransitChange: f } = r, d = w.useCallback(() => {
    a(null), f(!1);
  }, [f]), h = w.useCallback(
    (m, p) => {
      const y = m.currentTarget, v = { x: m.clientX, y: m.clientY }, g = pQ(v, y.getBoundingClientRect()), x = mQ(v, g), _ = gQ(p.getBoundingClientRect()), b = yQ([...x, ..._]);
      a(b), f(!0);
    },
    [f]
  );
  return w.useEffect(() => () => d(), [d]), w.useEffect(() => {
    if (l && u) {
      const m = (y) => h(y, u), p = (y) => h(y, l);
      return l.addEventListener("pointerleave", m), u.addEventListener("pointerleave", p), () => {
        l.removeEventListener("pointerleave", m), u.removeEventListener("pointerleave", p);
      };
    }
  }, [l, u, h, d]), w.useEffect(() => {
    if (o) {
      const m = (p) => {
        const y = p.target, v = { x: p.clientX, y: p.clientY }, g = (l == null ? void 0 : l.contains(y)) || (u == null ? void 0 : u.contains(y)), x = !vQ(v, o);
        g ? d() : x && (d(), c());
      };
      return document.addEventListener("pointermove", m), () => document.removeEventListener("pointermove", m);
    }
  }, [l, u, o, c, d]), /* @__PURE__ */ A($A, { ...e, ref: s });
}), [fQ, dQ] = e1(jc, { isInside: !1 }), hQ = /* @__PURE__ */ cH("TooltipContent"), $A = w.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: s,
      onPointerDownOutside: o,
      ...a
    } = e, l = Mu(il, n), c = t1(n), { onClose: u } = l;
    return w.useEffect(() => (document.addEventListener(Z0, u), () => document.removeEventListener(Z0, u)), [u]), w.useEffect(() => {
      if (l.trigger) {
        const f = (d) => {
          const h = d.target;
          h != null && h.contains(l.trigger) && u();
        };
        return window.addEventListener("scroll", f, { capture: !0 }), () => window.removeEventListener("scroll", f, { capture: !0 });
      }
    }, [l.trigger, u]), /* @__PURE__ */ A(
      gu,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        onFocusOutside: (f) => f.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ Oe(
          xy,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ A(hQ, { children: r }),
              /* @__PURE__ */ A(fQ, { scope: n, isInside: !0, children: /* @__PURE__ */ A(CZ, { id: l.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
RA.displayName = il;
var VA = "TooltipArrow", BA = w.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = t1(n);
    return dQ(
      VA,
      n
    ).isInside ? null : /* @__PURE__ */ A(wy, { ...i, ...r, ref: t });
  }
);
BA.displayName = VA;
function pQ(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), s = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, s)) {
    case s:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function mQ(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function gQ(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function vQ(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let s = 0, o = t.length - 1; s < t.length; o = s++) {
    const a = t[s], l = t[o], c = a.x, u = a.y, f = l.x, d = l.y;
    u > r != d > r && n < (f - c) * (r - u) / (d - u) + c && (i = !i);
  }
  return i;
}
function yQ(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), xQ(t);
}
function xQ(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], o = t[t.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const s = n[n.length - 1], o = n[n.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var zA = OA, HA = PA, UA = DA, jA = FA, WA = RA, wQ = BA;
const Ou = T.forwardRef(({ title: e, children: t }, n) => {
  const r = mn(Yo);
  return /* @__PURE__ */ T.createElement(zA, { delayDuration: 100 }, /* @__PURE__ */ T.createElement(HA, null, /* @__PURE__ */ T.createElement(UA, { ref: n, asChild: !0 }, /* @__PURE__ */ T.createElement("span", { className: de.tooltipTrigger }, t)), /* @__PURE__ */ T.createElement(jA, { container: r == null ? void 0 : r.current }, /* @__PURE__ */ T.createElement(WA, { className: rt(de.tooltipContent), sideOffset: 10 }, e))));
}), _Q = T.forwardRef(
  ({ children: e, className: t, ...n }, r) => /* @__PURE__ */ T.createElement(nQ, { ...n, ref: r, className: rt(t, de.selectItem) }, /* @__PURE__ */ T.createElement(rQ, null, e))
), bQ = ({ title: e, placeholder: t, className: n }) => {
  const [r, i] = On(Cr, ir);
  return /* @__PURE__ */ T.createElement(Ou, { title: e }, /* @__PURE__ */ T.createElement(
    YZ,
    {
      "aria-label": t,
      className: rt(de.selectTrigger, n),
      "data-toolbar-item": !0,
      disabled: r
    },
    /* @__PURE__ */ T.createElement(XZ, { placeholder: t }),
    /* @__PURE__ */ T.createElement(ZZ, { className: de.selectDropdownArrow }, i("arrow_drop_down"))
  ));
}, CQ = ({
  children: e,
  className: t = de.selectContainer
}) => {
  const n = mn(Yo);
  return /* @__PURE__ */ T.createElement(QZ, { container: n == null ? void 0 : n.current }, /* @__PURE__ */ T.createElement(
    eQ,
    {
      className: rt(t, "mdxeditor-select-content"),
      onCloseAutoFocus: (r) => {
        r.preventDefault();
      },
      position: "popper"
    },
    /* @__PURE__ */ T.createElement(tQ, { "data-editor-dropdown": !0 }, e)
  ));
}, EQ = (e) => /* @__PURE__ */ T.createElement(GZ, { value: e.value || "", onValueChange: e.onChange, disabled: e.disabled }, /* @__PURE__ */ T.createElement(bQ, { title: e.triggerTitle, placeholder: e.placeholder }), /* @__PURE__ */ T.createElement(CQ, null, e.items.map((t, n) => t === "separator" ? /* @__PURE__ */ T.createElement(iQ, { key: n }) : /* @__PURE__ */ T.createElement(_Q, { key: n, value: t.value }, t.label)))), SQ = {}.hasOwnProperty, kQ = {}, q4 = /^[^\t\n\r "#'.<=>`}]+$/, TQ = /^[^\t\n\r "'<=>`}]+$/;
function AQ() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: IQ,
      directiveContainerAttributes: bm,
      directiveContainerLabel: OQ,
      directiveLeaf: LQ,
      directiveLeafAttributes: bm,
      directiveText: MQ,
      directiveTextAttributes: bm
    },
    exit: {
      directiveContainer: Am,
      directiveContainerAttributeClassValue: Em,
      directiveContainerAttributeIdValue: Cm,
      directiveContainerAttributeName: km,
      directiveContainerAttributeValue: Sm,
      directiveContainerAttributes: Tm,
      directiveContainerLabel: PQ,
      directiveContainerName: _m,
      directiveLeaf: Am,
      directiveLeafAttributeClassValue: Em,
      directiveLeafAttributeIdValue: Cm,
      directiveLeafAttributeName: km,
      directiveLeafAttributeValue: Sm,
      directiveLeafAttributes: Tm,
      directiveLeafName: _m,
      directiveText: Am,
      directiveTextAttributeClassValue: Em,
      directiveTextAttributeIdValue: Cm,
      directiveTextAttributeName: km,
      directiveTextAttributeValue: Sm,
      directiveTextAttributes: Tm,
      directiveTextName: _m
    }
  };
}
function NQ(e) {
  const t = kQ;
  if (t.quote !== '"' && t.quote !== "'" && t.quote !== null && t.quote !== void 0)
    throw new Error(
      "Invalid quote `" + t.quote + "`, expected `'` or `\"`"
    );
  return n.peek = DQ, {
    handlers: {
      containerDirective: n,
      leafDirective: n,
      textDirective: n
    },
    unsafe: [
      {
        character: "\r",
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
      },
      {
        character: `
`,
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
      },
      {
        before: "[^:]",
        character: ":",
        after: "[A-Za-z]",
        inConstruct: ["phrasing"]
      },
      { atBreak: !0, character: ":", after: ":" }
    ]
  };
  function n(s, o, a, l) {
    const c = a.createTracker(l), u = FQ(s), f = a.enter(s.type);
    let d = c.move(u + (s.name || "")), h;
    if (s.type === "containerDirective") {
      const m = (s.children || [])[0];
      h = G4(m) ? m : void 0;
    } else
      h = s;
    if (h && h.children && h.children.length > 0) {
      const m = a.enter("label"), p = `${s.type}Label`, y = a.enter(p);
      d += c.move("["), d += c.move(
        a.containerPhrasing(h, {
          ...c.current(),
          before: d,
          after: "]"
        })
      ), d += c.move("]"), y(), m();
    }
    if (d += c.move(r(s, a)), s.type === "containerDirective") {
      const m = (s.children || [])[0];
      let p = s;
      G4(m) && (p = Object.assign({}, s, { children: s.children.slice(1) })), p && p.children && p.children.length > 0 && (d += c.move(`
`), d += c.move(a.containerFlow(p, c.current()))), d += c.move(`
` + u);
    }
    return f(), d;
  }
  function r(s, o) {
    const a = s.attributes || {}, l = [];
    let c, u, f, d;
    for (d in a)
      if (SQ.call(a, d) && a[d] !== void 0 && a[d] !== null) {
        const h = String(a[d]);
        if (d === "id")
          f = t.preferShortcut !== !1 && q4.test(h) ? "#" + h : i("id", h, s, o);
        else if (d === "class") {
          const m = h.split(/[\t\n\r ]+/g), p = [], y = [];
          let v = -1;
          for (; ++v < m.length; )
            (t.preferShortcut !== !1 && q4.test(m[v]) ? y : p).push(m[v]);
          c = p.length > 0 ? i("class", p.join(" "), s, o) : "", u = y.length > 0 ? "." + y.join(".") : "";
        } else
          l.push(i(d, h, s, o));
      }
    return c && l.unshift(c), u && l.unshift(u), f && l.unshift(f), l.length > 0 ? "{" + l.join(" ") + "}" : "";
  }
  function i(s, o, a, l) {
    if (t.collapseEmptyAttributes !== !1 && !o) return s;
    if (t.preferUnquoted && TQ.test(o))
      return s + "=" + o;
    const c = t.quote || l.options.quote || '"', u = c === '"' ? "'" : '"', f = t.quoteSmart && $d(o, c) > $d(o, u) ? u : c, d = a.type === "textDirective" ? [f] : [f, `
`, "\r"];
    return s + "=" + f + Q9(o, { subset: d }) + f;
  }
}
function IQ(e) {
  Sx.call(this, "containerDirective", e);
}
function LQ(e) {
  Sx.call(this, "leafDirective", e);
}
function MQ(e) {
  Sx.call(this, "textDirective", e);
}
function Sx(e, t) {
  this.enter({ type: e, name: "", attributes: {}, children: [] }, t);
}
function _m(e) {
  const t = this.stack[this.stack.length - 1];
  t.type === "containerDirective" || t.type === "leafDirective" || t.type, t.name = this.sliceSerialize(e);
}
function OQ(e) {
  this.enter(
    { type: "paragraph", data: { directiveLabel: !0 }, children: [] },
    e
  );
}
function PQ(e) {
  this.exit(e);
}
function bm() {
  this.data.directiveAttributes = [], this.buffer();
}
function Cm(e) {
  this.data.directiveAttributes.push([
    "id",
    xp(this.sliceSerialize(e), { attribute: !0 })
  ]);
}
function Em(e) {
  this.data.directiveAttributes.push([
    "class",
    xp(this.sliceSerialize(e), { attribute: !0 })
  ]);
}
function Sm(e) {
  const t = this.data.directiveAttributes;
  t[t.length - 1][1] = xp(this.sliceSerialize(e), {
    attribute: !0
  });
}
function km(e) {
  this.data.directiveAttributes.push([this.sliceSerialize(e), ""]);
}
function Tm() {
  const e = this.data.directiveAttributes, t = {};
  let n = -1;
  for (; ++n < e.length; ) {
    const i = e[n];
    i[0] === "class" && t.class ? t.class += " " + i[1] : t[i[0]] = i[1];
  }
  this.data.directiveAttributes = void 0, this.resume();
  const r = this.stack[this.stack.length - 1];
  r.type === "containerDirective" || r.type === "leafDirective" || r.type, r.attributes = t;
}
function Am(e) {
  this.exit(e);
}
function DQ() {
  return ":";
}
function G4(e) {
  return !!(e && e.type === "paragraph" && e.data && e.data.directiveLabel);
}
function FQ(e) {
  let t = 0;
  return e.type === "containerDirective" ? (d6(e, function(n, r) {
    if (n.type === "containerDirective") {
      let i = r.length, s = 0;
      for (; i--; )
        r[i].type === "containerDirective" && s++;
      s > t && (t = s);
    }
  }), t += 3) : e.type === "leafDirective" ? t = 2 : t = 1, ":".repeat(t);
}
function kx(e, t, n, r, i, s, o, a, l, c, u, f, d, h, m) {
  let p, y;
  return v;
  function v(P) {
    return e.enter(r), e.enter(i), e.consume(P), e.exit(i), g;
  }
  function g(P) {
    return P === 35 ? (p = o, x(P)) : P === 46 ? (p = a, x(P)) : P === 58 || P === 95 || er(P) ? (e.enter(s), e.enter(l), e.consume(P), C) : m && He(P) ? Ge(e, g, "whitespace")(P) : !m && ut(P) ? Wi(e, g)(P) : H(P);
  }
  function x(P) {
    const W = (
      /** @type {TokenType} */
      p + "Marker"
    );
    return e.enter(s), e.enter(p), e.enter(W), e.consume(P), e.exit(W), _;
  }
  function _(P) {
    if (P === null || P === 34 || P === 35 || P === 39 || P === 46 || P === 60 || P === 61 || P === 62 || P === 96 || P === 125 || ut(P))
      return n(P);
    const W = (
      /** @type {TokenType} */
      p + "Value"
    );
    return e.enter(W), e.consume(P), b;
  }
  function b(P) {
    if (P === null || P === 34 || P === 39 || P === 60 || P === 61 || P === 62 || P === 96)
      return n(P);
    if (P === 35 || P === 46 || P === 125 || ut(P)) {
      const W = (
        /** @type {TokenType} */
        p + "Value"
      );
      return e.exit(W), e.exit(p), e.exit(s), g(P);
    }
    return e.consume(P), b;
  }
  function C(P) {
    return P === 45 || P === 46 || P === 58 || P === 95 || Tn(P) ? (e.consume(P), C) : (e.exit(l), m && He(P) ? Ge(e, E, "whitespace")(P) : !m && ut(P) ? Wi(e, E)(P) : E(P));
  }
  function E(P) {
    return P === 61 ? (e.enter(c), e.consume(P), e.exit(c), S) : (e.exit(s), g(P));
  }
  function S(P) {
    return P === null || P === 60 || P === 61 || P === 62 || P === 96 || P === 125 || m && be(P) ? n(P) : P === 34 || P === 39 ? (e.enter(u), e.enter(d), e.consume(P), e.exit(d), y = P, M) : m && He(P) ? Ge(e, S, "whitespace")(P) : !m && ut(P) ? Wi(e, S)(P) : (e.enter(f), e.enter(h), e.consume(P), y = void 0, k);
  }
  function k(P) {
    return P === null || P === 34 || P === 39 || P === 60 || P === 61 || P === 62 || P === 96 ? n(P) : P === 125 || ut(P) ? (e.exit(h), e.exit(f), e.exit(s), g(P)) : (e.consume(P), k);
  }
  function M(P) {
    return P === y ? (e.enter(d), e.consume(P), e.exit(d), e.exit(u), e.exit(s), I) : (e.enter(f), O(P));
  }
  function O(P) {
    return P === y ? (e.exit(f), M(P)) : P === null ? n(P) : be(P) ? m ? n(P) : Wi(e, O)(P) : (e.enter(h), e.consume(P), R);
  }
  function R(P) {
    return P === y || P === null || be(P) ? (e.exit(h), O(P)) : (e.consume(P), R);
  }
  function I(P) {
    return P === 125 || ut(P) ? g(P) : H(P);
  }
  function H(P) {
    return P === 125 ? (e.enter(i), e.consume(P), e.exit(i), e.exit(r), t) : n(P);
  }
}
function Tx(e, t, n, r, i, s, o) {
  let a = 0, l = 0, c;
  return u;
  function u(y) {
    return e.enter(r), e.enter(i), e.consume(y), e.exit(i), f;
  }
  function f(y) {
    return y === 93 ? (e.enter(i), e.consume(y), e.exit(i), e.exit(r), t) : (e.enter(s), d(y));
  }
  function d(y) {
    if (y === 93 && !l)
      return p(y);
    const v = e.enter("chunkText", {
      contentType: "text",
      previous: c
    });
    return c && (c.next = v), c = v, h(y);
  }
  function h(y) {
    return y === null || a > 999 || y === 91 && ++l > 32 ? n(y) : y === 93 && !l-- ? (e.exit("chunkText"), p(y)) : be(y) ? o ? n(y) : (e.consume(y), e.exit("chunkText"), d) : (e.consume(y), y === 92 ? m : h);
  }
  function m(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), a++, h) : h(y);
  }
  function p(y) {
    return e.exit(s), e.enter(i), e.consume(y), e.exit(i), e.exit(r), t;
  }
}
function Ax(e, t, n, r) {
  const i = this;
  return s;
  function s(a) {
    return er(a) ? (e.enter(r), e.consume(a), o) : n(a);
  }
  function o(a) {
    return a === 45 || a === 95 || Tn(a) ? (e.consume(a), o) : (e.exit(r), i.previous === 45 || i.previous === 95 ? n(a) : t(a));
  }
}
const RQ = {
  tokenize: BQ,
  concrete: !0
}, $Q = {
  tokenize: zQ,
  partial: !0
}, VQ = {
  tokenize: HQ,
  partial: !0
}, hf = {
  tokenize: UQ,
  partial: !0
};
function BQ(e, t, n) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0, a;
  return l;
  function l(k) {
    return e.enter("directiveContainer"), e.enter("directiveContainerFence"), e.enter("directiveContainerSequence"), c(k);
  }
  function c(k) {
    return k === 58 ? (e.consume(k), o++, c) : o < 3 ? n(k) : (e.exit("directiveContainerSequence"), Ax.call(r, e, u, n, "directiveContainerName")(k));
  }
  function u(k) {
    return k === 91 ? e.attempt($Q, f, f)(k) : f(k);
  }
  function f(k) {
    return k === 123 ? e.attempt(VQ, d, d)(k) : d(k);
  }
  function d(k) {
    return Ge(e, h, "whitespace")(k);
  }
  function h(k) {
    return e.exit("directiveContainerFence"), k === null ? E(k) : be(k) ? r.interrupt ? t(k) : e.attempt(hf, m, E)(k) : n(k);
  }
  function m(k) {
    return k === null ? E(k) : be(k) ? e.check(hf, x, E)(k) : (e.enter("directiveContainerContent"), p(k));
  }
  function p(k) {
    return e.attempt({
      tokenize: S,
      partial: !0
    }, C, s ? Ge(e, y, "linePrefix", s + 1) : y)(k);
  }
  function y(k) {
    return k === null ? C(k) : be(k) ? e.check(hf, g, C)(k) : g(k);
  }
  function v(k) {
    if (k === null) {
      const M = e.exit("chunkDocument");
      return r.parser.lazy[M.start.line] = !1, C(k);
    }
    return be(k) ? e.check(hf, _, b)(k) : (e.consume(k), v);
  }
  function g(k) {
    const M = e.enter("chunkDocument", {
      contentType: "document",
      previous: a
    });
    return a && (a.next = M), a = M, v(k);
  }
  function x(k) {
    return e.enter("directiveContainerContent"), p(k);
  }
  function _(k) {
    e.consume(k);
    const M = e.exit("chunkDocument");
    return r.parser.lazy[M.start.line] = !1, p;
  }
  function b(k) {
    const M = e.exit("chunkDocument");
    return r.parser.lazy[M.start.line] = !1, C(k);
  }
  function C(k) {
    return e.exit("directiveContainerContent"), E(k);
  }
  function E(k) {
    return e.exit("directiveContainer"), t(k);
  }
  function S(k, M, O) {
    let R = 0;
    return Ge(k, I, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function I(W) {
      return k.enter("directiveContainerFence"), k.enter("directiveContainerSequence"), H(W);
    }
    function H(W) {
      return W === 58 ? (k.consume(W), R++, H) : R < o ? O(W) : (k.exit("directiveContainerSequence"), Ge(k, P, "whitespace")(W));
    }
    function P(W) {
      return W === null || be(W) ? (k.exit("directiveContainerFence"), M(W)) : O(W);
    }
  }
}
function zQ(e, t, n) {
  return Tx(e, t, n, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function HQ(e, t, n) {
  return kx(e, t, n, "directiveContainerAttributes", "directiveContainerAttributesMarker", "directiveContainerAttribute", "directiveContainerAttributeId", "directiveContainerAttributeClass", "directiveContainerAttributeName", "directiveContainerAttributeInitializerMarker", "directiveContainerAttributeValueLiteral", "directiveContainerAttributeValue", "directiveContainerAttributeValueMarker", "directiveContainerAttributeValueData", !0);
}
function UQ(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), s;
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
const jQ = {
  tokenize: KQ
}, WQ = {
  tokenize: qQ,
  partial: !0
}, JQ = {
  tokenize: GQ,
  partial: !0
};
function KQ(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("directiveLeaf"), e.enter("directiveLeafSequence"), e.consume(u), s;
  }
  function s(u) {
    return u === 58 ? (e.consume(u), e.exit("directiveLeafSequence"), Ax.call(r, e, o, n, "directiveLeafName")) : n(u);
  }
  function o(u) {
    return u === 91 ? e.attempt(WQ, a, a)(u) : a(u);
  }
  function a(u) {
    return u === 123 ? e.attempt(JQ, l, l)(u) : l(u);
  }
  function l(u) {
    return Ge(e, c, "whitespace")(u);
  }
  function c(u) {
    return u === null || be(u) ? (e.exit("directiveLeaf"), t(u)) : n(u);
  }
}
function qQ(e, t, n) {
  return Tx(e, t, n, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function GQ(e, t, n) {
  return kx(e, t, n, "directiveLeafAttributes", "directiveLeafAttributesMarker", "directiveLeafAttribute", "directiveLeafAttributeId", "directiveLeafAttributeClass", "directiveLeafAttributeName", "directiveLeafAttributeInitializerMarker", "directiveLeafAttributeValueLiteral", "directiveLeafAttributeValue", "directiveLeafAttributeValueMarker", "directiveLeafAttributeValueData", !0);
}
const YQ = {
  tokenize: eee,
  previous: QQ
}, XQ = {
  tokenize: tee,
  partial: !0
}, ZQ = {
  tokenize: nee,
  partial: !0
};
function QQ(e) {
  return e !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function eee(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return e.enter("directiveText"), e.enter("directiveTextMarker"), e.consume(l), e.exit("directiveTextMarker"), Ax.call(r, e, s, n, "directiveTextName");
  }
  function s(l) {
    return l === 58 ? n(l) : l === 91 ? e.attempt(XQ, o, o)(l) : o(l);
  }
  function o(l) {
    return l === 123 ? e.attempt(ZQ, a, a)(l) : a(l);
  }
  function a(l) {
    return e.exit("directiveText"), t(l);
  }
}
function tee(e, t, n) {
  return Tx(e, t, n, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function nee(e, t, n) {
  return kx(e, t, n, "directiveTextAttributes", "directiveTextAttributesMarker", "directiveTextAttribute", "directiveTextAttributeId", "directiveTextAttributeClass", "directiveTextAttributeName", "directiveTextAttributeInitializerMarker", "directiveTextAttributeValueLiteral", "directiveTextAttributeValue", "directiveTextAttributeValueMarker", "directiveTextAttributeValueData");
}
function ree() {
  return {
    text: {
      58: YQ
    },
    flow: {
      58: [RQ, jQ]
    }
  };
}
var iee = Object.defineProperty, see = (e, t, n) => t in e ? iee(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Nm = (e, t, n) => (see(e, typeof t != "symbol" ? t + "" : t, n), n);
class Pu extends bi {
  /**
   * Constructs a new {@link DirectiveNode} with the specified MDAST directive node as the object to edit.
   */
  constructor(t, n) {
    super(n), Nm(this, "__mdastNode"), Nm(this, "__focusEmitter", wx()), Nm(this, "select", () => {
      this.__focusEmitter.publish();
    }), this.__mdastNode = t;
  }
  /** @internal */
  static getType() {
    return "directive";
  }
  /** @internal */
  static clone(t) {
    return new Pu(structuredClone(t.__mdastNode), t.__key);
  }
  /** @internal */
  static importJSON(t) {
    return Nx(t.mdastNode);
  }
  /**
   * Returns the MDAST node that is being edited.
   */
  getMdastNode() {
    return this.__mdastNode;
  }
  /** @internal */
  exportJSON() {
    return {
      mdastNode: structuredClone(this.__mdastNode),
      type: "directive",
      version: 1
    };
  }
  /** @internal */
  createDOM() {
    return document.createElement(this.__mdastNode.type === "textDirective" ? "span" : "div");
  }
  /** @internal */
  updateDOM() {
    return !1;
  }
  /**
   * Sets a new MDAST node to edit.
   */
  setMdastNode(t) {
    this.getWritable().__mdastNode = t;
  }
  /** @internal */
  decorate(t, n) {
    return /* @__PURE__ */ T.createElement(
      oee,
      {
        lexicalNode: this,
        mdastNode: this.getMdastNode(),
        parentEditor: t,
        config: n,
        focusEmitter: this.__focusEmitter
      }
    );
  }
  /** @internal */
  isInline() {
    return this.__mdastNode.type === "textDirective";
  }
  /** @internal */
  isKeyboardSelectable() {
    return !0;
  }
}
const oee = (e) => {
  const { mdastNode: t } = e, [n] = On(Mc), r = n.find((s) => s.testNode(t));
  if (!r)
    throw new Error(`No descriptor found for directive ${t.name}`);
  const i = r.Editor;
  return /* @__PURE__ */ T.createElement(vx.Provider, { value: e }, /* @__PURE__ */ T.createElement(i, { descriptor: r, mdastNode: t, lexicalNode: e.lexicalNode, parentEditor: e.parentEditor }));
};
function Nx(e, t) {
  return new Pu(e, t);
}
function aee(e) {
  return e instanceof Pu;
}
const lee = {
  testLexicalNode: aee,
  visitLexicalNode({ actions: e, mdastParent: t, lexicalNode: n }) {
    e.appendToParent(t, n.getMdastNode());
  }
}, cee = ["leafDirective", "containerDirective", "textDirective"];
function uee(e) {
  return cee.includes(e.type);
}
const fee = (e) => ({
  testNode: (t, { directiveDescriptors: n }) => {
    if (uee(t)) {
      const r = n.find((i) => i.testNode(t));
      return e && !r && t.type === "textDirective" ? !0 : r !== void 0;
    }
    return !1;
  },
  visitNode({ lexicalParent: t, mdastNode: n, descriptors: r }) {
    !e || r.directiveDescriptors.some((s) => s.testNode(n)) ? t.append(Nx(n)) : t.append(yt(`:${n.name}`));
  }
}), dee = Bt((e) => {
  e.link(
    e.pipe(
      dee,
      Ds((t) => () => Nx({ children: [], ...t }))
    ),
    Ep
  );
}), hee = Jn({
  update: (e, t) => {
    e.pub(Mc, (t == null ? void 0 : t.directiveDescriptors) ?? []);
  },
  init: (e, t) => {
    e.pubIn({
      [Mc]: (t == null ? void 0 : t.directiveDescriptors) ?? [],
      // import
      [Ya]: AQ(),
      [Ga]: ree(),
      [Er]: fee(t == null ? void 0 : t.escapeUnknownTextDirectives),
      // export
      [Yr]: Pu,
      [Xr]: lee,
      [pu]: NQ()
    });
  }
}), pee = ({ mdastNode: e, descriptor: t }) => {
  const n = kl(), r = T.useMemo(() => t.attributes.reduce((s, o) => {
    var a;
    return s[o] = ((a = e.attributes) == null ? void 0 : a[o]) ?? "", s;
  }, {}), [e, t]), i = T.useCallback(
    (s) => {
      n({ attributes: Object.fromEntries(Object.entries(s).filter(([, o]) => o !== "")) });
    },
    [n]
  );
  return /* @__PURE__ */ T.createElement("div", { className: e.type === "textDirective" ? de.inlineEditor : de.blockEditor }, t.attributes.length == 0 && t.hasChildren && e.type !== "textDirective" ? /* @__PURE__ */ T.createElement("span", { className: de.genericComponentName }, e.name) : null, t.attributes.length > 0 ? /* @__PURE__ */ T.createElement(sA, { properties: r, title: e.name || "", onChange: i }) : null, t.hasChildren ? /* @__PURE__ */ T.createElement(
    xx,
    {
      block: e.type === "containerDirective",
      getContent: (s) => s.children,
      getUpdatedMdastNode: (s, o) => ({ ...s, children: o })
    }
  ) : /* @__PURE__ */ T.createElement("span", { className: de.genericComponentName }, e.name));
};
function mee(e) {
  try {
    const t = e.anchor, n = e.focus, r = e.anchor.getNode(), i = e.focus.getNode();
    return r === i ? r : e.isBackward() ? qw(n) ? r : i : qw(t) ? r : i;
  } catch {
    return null;
  }
}
function JA(e) {
  const t = ge(), n = window.getSelection(), r = document.activeElement, i = e.getRootElement();
  if (t !== null && n !== null && i !== null && i.contains(n.anchorNode) && e.isEditable()) {
    const s = n.getRangeAt(0);
    let o;
    if (n.isCollapsed) {
      let a = n.anchorNode;
      (a == null ? void 0 : a.nodeType) == 3 && (a = a.parentNode), o = a.getBoundingClientRect(), o.width = 0;
    } else if (n.anchorNode === i) {
      let a = i;
      for (; a.firstElementChild != null; )
        a = a.firstElementChild;
      o = a.getBoundingClientRect();
    } else
      o = s.getBoundingClientRect();
    return {
      top: Math.round(o.top),
      left: Math.round(o.left),
      width: Math.round(o.width),
      height: Math.round(o.height)
    };
  } else if (!r || r.className !== "link-input")
    return null;
  return null;
}
function gee({ url: e, title: t, onSubmit: n, onCancel: r, linkAutocompleteSuggestions: i }) {
  const {
    register: s,
    handleSubmit: o,
    control: a,
    setValue: l,
    reset: c
  } = Hp({
    values: {
      url: e,
      title: t
    }
  }), u = Kn();
  return /* @__PURE__ */ T.createElement(
    "form",
    {
      onSubmit: (f) => {
        o(n)(f), f.stopPropagation(), f.preventDefault();
      },
      onReset: (f) => {
        f.stopPropagation(), r();
      },
      className: rt(de.multiFieldForm, de.linkDialogEditForm)
    },
    /* @__PURE__ */ T.createElement("div", { className: de.formField }, /* @__PURE__ */ T.createElement("label", { htmlFor: "link-url" }, u("createLink.url", "URL")), /* @__PURE__ */ T.createElement(
      Ck,
      {
        register: s,
        initialInputValue: e,
        inputName: "url",
        suggestions: i,
        setValue: l,
        control: a,
        placeholder: u("createLink.urlPlaceholder", "Select or paste an URL"),
        autofocus: !0
      }
    )),
    /* @__PURE__ */ T.createElement("div", { className: de.formField }, /* @__PURE__ */ T.createElement("label", { htmlFor: "link-title" }, u("createLink.title", "Title")), /* @__PURE__ */ T.createElement("input", { id: "link-title", className: de.textInput, size: 40, ...s("title") })),
    /* @__PURE__ */ T.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } }, /* @__PURE__ */ T.createElement(
      "button",
      {
        type: "submit",
        title: u("createLink.saveTooltip", "Set URL"),
        "aria-label": u("createLink.saveTooltip", "Set URL"),
        className: rt(de.primaryButton)
      },
      u("dialogControls.save", "Save")
    ), /* @__PURE__ */ T.createElement(
      "button",
      {
        type: "reset",
        title: u("createLink.cancelTooltip", "Cancel change"),
        "aria-label": u("createLink.cancelTooltip", "Cancel change"),
        className: rt(de.secondaryButton)
      },
      u("dialogControls.cancel", "Cancel")
    ))
  );
}
const vee = () => {
  const [e, t, n, r, i, s] = On(
    Yo,
    Ft,
    ir,
    _n,
    ZA,
    QA
  ), o = It(KA), a = It(qA), l = It(GA), c = It(YA), u = It(XA);
  T.useEffect(() => {
    const y = () => {
      t == null || t.getEditorState().read(() => {
        o(!0);
      });
    };
    return window.addEventListener("resize", y), window.addEventListener("scroll", y), () => {
      window.removeEventListener("resize", y), window.removeEventListener("scroll", y);
    };
  }, [t, o]);
  const [f, d] = T.useState(!1), h = Kn();
  if (r.type === "inactive")
    return null;
  const m = r.rectangle, p = r.type === "preview" && r.url.startsWith("http");
  return /* @__PURE__ */ T.createElement(E7, { open: !0 }, /* @__PURE__ */ T.createElement(
    Xj,
    {
      "data-visible": r.type === "edit",
      className: de.linkDialogAnchor,
      style: {
        top: `${m.top}px`,
        left: `${m.left}px`,
        width: `${m.width}px`,
        height: `${m.height}px`
      }
    }
  ), /* @__PURE__ */ T.createElement(S7, { container: e == null ? void 0 : e.current }, /* @__PURE__ */ T.createElement(
    k7,
    {
      className: rt(de.linkDialogPopoverContent),
      sideOffset: 5,
      onOpenAutoFocus: (y) => {
        y.preventDefault();
      },
      key: r.linkNodeKey
    },
    r.type === "edit" && /* @__PURE__ */ T.createElement(
      gee,
      {
        url: r.url,
        title: r.title,
        onSubmit: a,
        onCancel: l.bind(null),
        linkAutocompleteSuggestions: i
      }
    ),
    r.type === "preview" && /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(
      "a",
      {
        className: de.linkDialogPreviewAnchor,
        href: r.url,
        ...p ? { target: "_blank", rel: "noreferrer" } : {},
        onClick: (y) => {
          s !== null && (y.preventDefault(), s(r.url));
        },
        title: p ? h("linkPreview.open", "Open {{url}} in new window", { url: r.url }) : r.url
      },
      /* @__PURE__ */ T.createElement("span", null, r.url),
      p && n("open_in_new")
    ), /* @__PURE__ */ T.createElement(
      Im,
      {
        onClick: () => {
          c();
        },
        title: h("linkPreview.edit", "Edit link URL"),
        "aria-label": h("linkPreview.edit", "Edit link URL")
      },
      n("edit")
    ), /* @__PURE__ */ T.createElement(zA, null, /* @__PURE__ */ T.createElement(HA, { open: f }, /* @__PURE__ */ T.createElement(UA, { asChild: !0 }, /* @__PURE__ */ T.createElement(
      Im,
      {
        title: h("linkPreview.copyToClipboard", "Copy to clipboard"),
        "aria-label": h("linkPreview.copyToClipboard", "Copy to clipboard"),
        onClick: () => {
          window.navigator.clipboard.writeText(r.url).then(() => {
            d(!0), setTimeout(() => {
              d(!1);
            }, 1e3);
          });
        }
      },
      n(f ? "check" : "content_copy")
    )), /* @__PURE__ */ T.createElement(jA, { container: e == null ? void 0 : e.current }, /* @__PURE__ */ T.createElement(WA, { className: rt(de.tooltipContent), sideOffset: 5 }, h("linkPreview.copied", "Copied!"), /* @__PURE__ */ T.createElement(wQ, null))))), /* @__PURE__ */ T.createElement(
      Im,
      {
        title: h("linkPreview.remove", "Remove link"),
        "aria-label": h("linkPreview.remove", "Remove link"),
        onClick: () => {
          u();
        }
      },
      n("link_off")
    )),
    /* @__PURE__ */ T.createElement(T7, { className: de.popoverArrow })
  )));
}, Im = T.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ T.createElement("button", { className: rt(de.actionButton, e), ref: n, ...t }));
function e2(e) {
  if (!e)
    return null;
  const t = mee(e);
  if (t === null)
    return null;
  const n = t.getParent();
  return ur(n) ? n : ur(t) ? t : null;
}
const KA = Bt(), _n = Te({ type: "inactive" }, (e) => {
  e.pub(Oc, (t) => t.registerCommand(
    eu,
    () => e.getValue(_n).type === "preview" ? (e.pub(_n, { type: "inactive" }), !0) : !1,
    xt
  )), e.sub(e.pipe(Kd), (t) => {
    t !== "rich-text" && e.pub(_n, { type: "inactive" });
  }), e.pub(Oc, (t) => t.registerCommand(
    VE,
    (n) => {
      if (n.key === "k" && (Gd ? n.metaKey : n.ctrlKey) && !e.getValue(Cr)) {
        const r = ge();
        return fe(r) ? (e.pub(Ix), n.stopPropagation(), n.preventDefault(), !0) : !1;
      }
      return !1;
    },
    Ld
  )), e.link(
    e.pipe(
      YA,
      Tt(_n),
      Ds(([, t]) => {
        if (t.type === "preview")
          return {
            type: "edit",
            initialUrl: t.url,
            url: t.url,
            title: t.title,
            linkNodeKey: t.linkNodeKey,
            rectangle: t.rectangle
          };
        throw new Error("Cannot switch to edit mode when not in preview mode");
      })
    ),
    _n
  ), e.sub(e.pipe(qA, Tt(Ft, _n, Ka)), ([t, n, r, i]) => {
    var s, o;
    const a = ((s = t.url) == null ? void 0 : s.trim()) ?? "", l = ((o = t.title) == null ? void 0 : o.trim()) ?? "";
    if (a !== "") {
      if (i != null && i.isCollapsed()) {
        const c = l || a;
        n == null || n.update(
          () => {
            const u = e2(i);
            if (u)
              u.setURL(a), u.setTitle(l);
            else {
              const f = Ks(a, { title: l });
              f.append(yt(c)), dl([f]), f.select();
            }
          },
          { discrete: !0 }
        );
      } else
        n == null || n.dispatchCommand(tl, { url: a, title: l });
      e.pub(_n, {
        type: "preview",
        linkNodeKey: r.linkNodeKey,
        rectangle: r.rectangle,
        title: l,
        url: a
      });
    } else
      r.type === "edit" && r.initialUrl !== "" && (n == null || n.dispatchCommand(tl, null)), e.pub(_n, {
        type: "inactive"
      });
  }), e.link(
    e.pipe(
      GA,
      Tt(_n, Ft),
      Ds(([, t, n]) => {
        if (t.type === "edit")
          return n == null || n.focus(), t.initialUrl === "" ? {
            type: "inactive"
          } : {
            type: "preview",
            url: t.initialUrl,
            linkNodeKey: t.linkNodeKey,
            rectangle: t.rectangle
          };
        throw new Error("Cannot cancel edit when not in edit mode");
      })
    ),
    _n
  ), e.link(
    e.pipe(
      e.combine(Ka, KA),
      Tt(Ft, _n, Cr),
      Ds(([[t], n, r, i]) => {
        if (fe(t) && n && !i) {
          const s = e2(t);
          if (s) {
            const o = JA(n);
            return o ? {
              type: "preview",
              url: s.getURL(),
              linkNodeKey: s.getKey(),
              title: s.getTitle(),
              rectangle: o
            } : { type: "inactive" };
          } else
            return { type: "inactive" };
        } else
          return { type: "inactive" };
      })
    ),
    _n
  );
}), qA = Bt(), GA = _i();
_i();
const YA = _i(), XA = _i((e) => {
  e.sub(e.pipe(XA, Tt(Ft)), ([, t]) => {
    t == null || t.dispatchCommand(tl, null);
  });
}), Ix = _i((e) => {
  e.sub(
    e.pipe(
      Ix,
      Tt(Ka, Ft),
      Xc(([, t]) => fe(t))
    ),
    ([, t, n]) => {
      n == null || n.focus(() => {
        setTimeout(() => {
          n.getEditorState().read(() => {
            const r = e2(t), i = JA(n);
            r ? e.pub(_n, {
              type: "edit",
              initialUrl: r.getURL(),
              initialTitle: r.getTitle() ?? "",
              url: r.getURL(),
              title: r.getTitle() ?? "",
              linkNodeKey: r.getKey(),
              rectangle: i
            }) : e.pub(_n, {
              type: "edit",
              initialUrl: "",
              initialTitle: "",
              title: "",
              url: "",
              linkNodeKey: "",
              rectangle: i
            });
          });
        });
      });
    }
  );
}), ZA = Te([]), QA = Te(null), eN = Te(null, (e) => {
  e.pub(Oc, (t) => {
    function n(r) {
      const [i, s] = e.getValues([Cr, eN]);
      !i || s === null || t.update(() => {
        const o = vi(r.target);
        if (o !== null) {
          const a = $r(o, (l) => l instanceof Zo);
          a !== null && s(r, a, a.getURL());
        }
      });
    }
    return t.registerRootListener((r, i) => {
      r && r.addEventListener("click", n), i && i.removeEventListener("click", n);
    });
  });
}), yee = Jn({
  init(e, t) {
    e.pub(Xo, (t == null ? void 0 : t.LinkDialog) ?? vee), e.pub(QA, (t == null ? void 0 : t.onClickLinkCallback) ?? null), e.pub(eN, (t == null ? void 0 : t.onReadOnlyClickLinkCallback) ?? null);
  },
  update(e, t = {}) {
    e.pub(ZA, t.linkAutocompleteSuggestions ?? []);
  }
});
function Lx(e, t) {
  return T.forwardRef((n, r) => {
    const i = rt(t.className, n.className);
    return /* @__PURE__ */ T.createElement(e, { ...t, ...n, className: i, ref: r });
  });
}
function xee(e) {
  return ({ title: t, children: n, ...r }) => /* @__PURE__ */ T.createElement(e, { ...r }, /* @__PURE__ */ T.createElement(Ou, { title: t }, n));
}
const wee = ({ readOnly: e, children: t, className: n }) => /* @__PURE__ */ T.createElement(
  TW,
  {
    className: rt("mdxeditor-toolbar", de.toolbarRoot, { [de.readOnlyToolbarRoot]: e }, n),
    ...e ? { tabIndex: -1 } : {}
  },
  t
), Du = Lx(Z7, { className: de.toolbarButton, "data-toolbar-item": !0 }), _ee = xee(Du), tN = Lx(AW, {
  className: de.toolbarToggleItem,
  "data-toolbar-item": !0
});
Lx(Ay, {
  type: "single",
  className: de.toolbarToggleSingleGroup
});
const nN = T.forwardRef(({ on: e, title: t, children: n, disabled: r, ...i }, s) => /* @__PURE__ */ T.createElement(
  Ay,
  {
    type: "single",
    className: de.toolbarToggleSingleGroup,
    ...i,
    value: e ? "on" : "off",
    ref: s
  },
  /* @__PURE__ */ T.createElement(tN, { "aria-label": t, value: "on", disabled: r }, /* @__PURE__ */ T.createElement(Ou, { title: t }, n))
)), rN = ({ items: e }) => /* @__PURE__ */ T.createElement("div", { className: de.toolbarGroupOfGroups }, e.map((t, n) => /* @__PURE__ */ T.createElement(
  nN,
  {
    key: n,
    title: t.title,
    on: t.active,
    onValueChange: (r) => {
      t.onChange(r === "on");
    },
    disabled: t.disabled
  },
  t.contents
))), bee = ({
  value: e,
  onChange: t,
  className: n,
  ggClassName: r,
  items: i
}) => {
  const s = Kn();
  return /* @__PURE__ */ T.createElement("div", { className: rt(de.toolbarGroupOfGroups, r) }, /* @__PURE__ */ T.createElement(
    Ay,
    {
      "aria-label": s("toolbar.toggleGroup", "toggle group"),
      type: "single",
      className: rt(de.toolbarToggleSingleGroup, n),
      onValueChange: t,
      value: e || "",
      onFocus: (o) => {
        o.preventDefault();
      }
    },
    i.map((o, a) => /* @__PURE__ */ T.createElement(tN, { key: a, "aria-label": o.title, value: o.value }, /* @__PURE__ */ T.createElement(Ou, { title: o.title }, o.contents)))
  ));
}, Lm = Te(() => null), Mm = Te(""), Y4 = () => "This is an empty toolbar. Pass `{toolbarContents: () => { return <>toolbar components</> }}` to the toolbarPlugin to customize it.", Cee = Jn({
  init(e, t) {
    const n = (t == null ? void 0 : t.toolbarPosition) === "bottom" ? AV : TV;
    e.pubIn({
      [Lm]: (t == null ? void 0 : t.toolbarContents) ?? Y4,
      [Mm]: (t == null ? void 0 : t.toolbarClassName) ?? "",
      [n]: () => {
        const [r, i, s] = On(Lm, Cr, Mm);
        return /* @__PURE__ */ T.createElement(wee, { className: s, readOnly: i }, r());
      }
    });
  },
  update(e, t) {
    e.pub(Lm, (t == null ? void 0 : t.toolbarContents) ?? Y4), e.pub(Mm, (t == null ? void 0 : t.toolbarClassName) ?? "");
  }
});
var Eee = { exports: {} };
(function(e) {
  var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var n = function(r) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, o = {}, a = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: r.Prism && r.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function g(x) {
          return x instanceof l ? new l(x.type, g(x.content), x.alias) : Array.isArray(x) ? x.map(g) : x.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(g) {
          return Object.prototype.toString.call(g).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(g) {
          return g.__id || Object.defineProperty(g, "__id", { value: ++s }), g.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function g(x, _) {
          _ = _ || {};
          var b, C;
          switch (a.util.type(x)) {
            case "Object":
              if (C = a.util.objId(x), _[C])
                return _[C];
              b = /** @type {Record<string, any>} */
              {}, _[C] = b;
              for (var E in x)
                x.hasOwnProperty(E) && (b[E] = g(x[E], _));
              return (
                /** @type {any} */
                b
              );
            case "Array":
              return C = a.util.objId(x), _[C] ? _[C] : (b = [], _[C] = b, /** @type {Array} */
              /** @type {any} */
              x.forEach(function(S, k) {
                b[k] = g(S, _);
              }), /** @type {any} */
              b);
            default:
              return x;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(g) {
          for (; g; ) {
            var x = i.exec(g.className);
            if (x)
              return x[1].toLowerCase();
            g = g.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(g, x) {
          g.className = g.className.replace(RegExp(i, "gi"), ""), g.classList.add("language-" + x);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if (document.currentScript && document.currentScript.tagName === "SCRIPT")
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (b) {
            var g = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(b.stack) || [])[1];
            if (g) {
              var x = document.getElementsByTagName("script");
              for (var _ in x)
                if (x[_].src == g)
                  return x[_];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(g, x, _) {
          for (var b = "no-" + x; g; ) {
            var C = g.classList;
            if (C.contains(x))
              return !0;
            if (C.contains(b))
              return !1;
            g = g.parentElement;
          }
          return !!_;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: o,
        plaintext: o,
        text: o,
        txt: o,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(g, x) {
          var _ = a.util.clone(a.languages[g]);
          for (var b in x)
            _[b] = x[b];
          return _;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(g, x, _, b) {
          b = b || /** @type {any} */
          a.languages;
          var C = b[g], E = {};
          for (var S in C)
            if (C.hasOwnProperty(S)) {
              if (S == x)
                for (var k in _)
                  _.hasOwnProperty(k) && (E[k] = _[k]);
              _.hasOwnProperty(S) || (E[S] = C[S]);
            }
          var M = b[g];
          return b[g] = E, a.languages.DFS(a.languages, function(O, R) {
            R === M && O != g && (this[O] = E);
          }), E;
        },
        // Traverse a language definition with Depth First Search
        DFS: function g(x, _, b, C) {
          C = C || {};
          var E = a.util.objId;
          for (var S in x)
            if (x.hasOwnProperty(S)) {
              _.call(x, S, x[S], b || S);
              var k = x[S], M = a.util.type(k);
              M === "Object" && !C[E(k)] ? (C[E(k)] = !0, g(k, _, null, C)) : M === "Array" && !C[E(k)] && (C[E(k)] = !0, g(k, _, S, C));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(g, x) {
        a.highlightAllUnder(document, g, x);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(g, x, _) {
        var b = {
          callback: _,
          container: g,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        a.hooks.run("before-highlightall", b), b.elements = Array.prototype.slice.apply(b.container.querySelectorAll(b.selector)), a.hooks.run("before-all-elements-highlight", b);
        for (var C = 0, E; E = b.elements[C++]; )
          a.highlightElement(E, x === !0, b.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(g, x, _) {
        var b = a.util.getLanguage(g), C = a.languages[b];
        a.util.setLanguage(g, b);
        var E = g.parentElement;
        E && E.nodeName.toLowerCase() === "pre" && a.util.setLanguage(E, b);
        var S = g.textContent, k = {
          element: g,
          language: b,
          grammar: C,
          code: S
        };
        function M(R) {
          k.highlightedCode = R, a.hooks.run("before-insert", k), k.element.innerHTML = k.highlightedCode, a.hooks.run("after-highlight", k), a.hooks.run("complete", k), _ && _.call(k.element);
        }
        if (a.hooks.run("before-sanity-check", k), E = k.element.parentElement, E && E.nodeName.toLowerCase() === "pre" && !E.hasAttribute("tabindex") && E.setAttribute("tabindex", "0"), !k.code) {
          a.hooks.run("complete", k), _ && _.call(k.element);
          return;
        }
        if (a.hooks.run("before-highlight", k), !k.grammar) {
          M(a.util.encode(k.code));
          return;
        }
        if (x && r.Worker) {
          var O = new Worker(a.filename);
          O.onmessage = function(R) {
            M(R.data);
          }, O.postMessage(JSON.stringify({
            language: k.language,
            code: k.code,
            immediateClose: !0
          }));
        } else
          M(a.highlight(k.code, k.grammar, k.language));
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(g, x, _) {
        var b = {
          code: g,
          grammar: x,
          language: _
        };
        if (a.hooks.run("before-tokenize", b), !b.grammar)
          throw new Error('The language "' + b.language + '" has no grammar.');
        return b.tokens = a.tokenize(b.code, b.grammar), a.hooks.run("after-tokenize", b), l.stringify(a.util.encode(b.tokens), b.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(g, x) {
        var _ = x.rest;
        if (_) {
          for (var b in _)
            x[b] = _[b];
          delete x.rest;
        }
        var C = new f();
        return d(C, C.head, g), u(g, C, x, C.head, 0), m(C);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(g, x) {
          var _ = a.hooks.all;
          _[g] = _[g] || [], _[g].push(x);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(g, x) {
          var _ = a.hooks.all[g];
          if (!(!_ || !_.length))
            for (var b = 0, C; C = _[b++]; )
              C(x);
        }
      },
      Token: l
    };
    r.Prism = a;
    function l(g, x, _, b) {
      this.type = g, this.content = x, this.alias = _, this.length = (b || "").length | 0;
    }
    l.stringify = function g(x, _) {
      if (typeof x == "string")
        return x;
      if (Array.isArray(x)) {
        var b = "";
        return x.forEach(function(M) {
          b += g(M, _);
        }), b;
      }
      var C = {
        type: x.type,
        content: g(x.content, _),
        tag: "span",
        classes: ["token", x.type],
        attributes: {},
        language: _
      }, E = x.alias;
      E && (Array.isArray(E) ? Array.prototype.push.apply(C.classes, E) : C.classes.push(E)), a.hooks.run("wrap", C);
      var S = "";
      for (var k in C.attributes)
        S += " " + k + '="' + (C.attributes[k] || "").replace(/"/g, "&quot;") + '"';
      return "<" + C.tag + ' class="' + C.classes.join(" ") + '"' + S + ">" + C.content + "</" + C.tag + ">";
    };
    function c(g, x, _, b) {
      g.lastIndex = x;
      var C = g.exec(_);
      if (C && b && C[1]) {
        var E = C[1].length;
        C.index += E, C[0] = C[0].slice(E);
      }
      return C;
    }
    function u(g, x, _, b, C, E) {
      for (var S in _)
        if (!(!_.hasOwnProperty(S) || !_[S])) {
          var k = _[S];
          k = Array.isArray(k) ? k : [k];
          for (var M = 0; M < k.length; ++M) {
            if (E && E.cause == S + "," + M)
              return;
            var O = k[M], R = O.inside, I = !!O.lookbehind, H = !!O.greedy, P = O.alias;
            if (H && !O.pattern.global) {
              var W = O.pattern.toString().match(/[imsuy]*$/)[0];
              O.pattern = RegExp(O.pattern.source, W + "g");
            }
            for (var G = O.pattern || O, J = b.next, X = C; J !== x.tail && !(E && X >= E.reach); X += J.value.length, J = J.next) {
              var N = J.value;
              if (x.length > g.length)
                return;
              if (!(N instanceof l)) {
                var U = 1, ee;
                if (H) {
                  if (ee = c(G, X, g, I), !ee || ee.index >= g.length)
                    break;
                  var ce = ee.index, F = ee.index + ee[0].length, ue = X;
                  for (ue += J.value.length; ce >= ue; )
                    J = J.next, ue += J.value.length;
                  if (ue -= J.value.length, X = ue, J.value instanceof l)
                    continue;
                  for (var pe = J; pe !== x.tail && (ue < F || typeof pe.value == "string"); pe = pe.next)
                    U++, ue += pe.value.length;
                  U--, N = g.slice(X, ue), ee.index -= X;
                } else if (ee = c(G, 0, N, I), !ee)
                  continue;
                var ce = ee.index, q = ee[0], Z = N.slice(0, ce), oe = N.slice(ce + q.length), le = X + N.length;
                E && le > E.reach && (E.reach = le);
                var ie = J.prev;
                Z && (ie = d(x, ie, Z), X += Z.length), h(x, ie, U);
                var Y = new l(S, R ? a.tokenize(q, R) : q, P, q);
                if (J = d(x, ie, Y), oe && d(x, J, oe), U > 1) {
                  var Ce = {
                    cause: S + "," + M,
                    reach: le
                  };
                  u(g, x, _, J.prev, X, Ce), E && Ce.reach > E.reach && (E.reach = Ce.reach);
                }
              }
            }
          }
        }
    }
    function f() {
      var g = { value: null, prev: null, next: null }, x = { value: null, prev: g, next: null };
      g.next = x, this.head = g, this.tail = x, this.length = 0;
    }
    function d(g, x, _) {
      var b = x.next, C = { value: _, prev: x, next: b };
      return x.next = C, b.prev = C, g.length++, C;
    }
    function h(g, x, _) {
      for (var b = x.next, C = 0; C < _ && b !== g.tail; C++)
        b = b.next;
      x.next = b, b.prev = x, g.length -= C;
    }
    function m(g) {
      for (var x = [], _ = g.head.next; _ !== g.tail; )
        x.push(_.value), _ = _.next;
      return x;
    }
    if (!r.document)
      return r.addEventListener && (a.disableWorkerMessageHandler || r.addEventListener("message", function(g) {
        var x = JSON.parse(g.data), _ = x.language, b = x.code, C = x.immediateClose;
        r.postMessage(a.highlight(b, a.languages[_], _)), C && r.close();
      }, !1)), a;
    var p = a.util.currentScript();
    p && (a.filename = p.src, p.hasAttribute("data-manual") && (a.manual = !0));
    function y() {
      a.manual || a.highlightAll();
    }
    if (!a.manual) {
      var v = document.readyState;
      v === "loading" || v === "interactive" && p && p.defer ? document.addEventListener("DOMContentLoaded", y) : window.requestAnimationFrame ? window.requestAnimationFrame(y) : window.setTimeout(y, 16);
    }
    return a;
  }(t);
  e.exports && (e.exports = n), typeof Xa < "u" && (Xa.Prism = n), n.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, n.languages.markup.tag.inside["attr-value"].inside.entity = n.languages.markup.entity, n.languages.markup.doctype.inside["internal-subset"].inside = n.languages.markup, n.hooks.add("wrap", function(r) {
    r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(n.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(i, s) {
      var o = {};
      o["language-" + s] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: n.languages[s]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var a = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      a["language-" + s] = {
        pattern: /[\s\S]+/,
        inside: n.languages[s]
      };
      var l = {};
      l[i] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return i;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: a
      }, n.languages.insertBefore("markup", "cdata", l);
    }
  }), Object.defineProperty(n.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(r, i) {
      n.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [i, "language-" + i],
                inside: n.languages[i]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), n.languages.html = n.languages.markup, n.languages.mathml = n.languages.markup, n.languages.svg = n.languages.markup, n.languages.xml = n.languages.extend("markup", {}), n.languages.ssml = n.languages.xml, n.languages.atom = n.languages.xml, n.languages.rss = n.languages.xml, function(r) {
    var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    r.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + i.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: i,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, r.languages.css.atrule.inside.rest = r.languages.css;
    var s = r.languages.markup;
    s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css"));
  }(n), n.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, n.languages.javascript = n.languages.extend("clike", {
    "class-name": [
      n.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), n.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, n.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: n.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: n.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: n.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: n.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: n.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), n.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: n.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), n.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), n.languages.markup && (n.languages.markup.tag.addInlined("script", "javascript"), n.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), n.languages.js = n.languages.javascript, function() {
    if (typeof n > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var r = "Loading…", i = function(p, y) {
      return "✖ Error " + p + " while fetching file: " + y;
    }, s = "✖ Error: File does not exist or is empty", o = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, a = "data-src-status", l = "loading", c = "loaded", u = "failed", f = "pre[data-src]:not([" + a + '="' + c + '"]):not([' + a + '="' + l + '"])';
    function d(p, y, v) {
      var g = new XMLHttpRequest();
      g.open("GET", p, !0), g.onreadystatechange = function() {
        g.readyState == 4 && (g.status < 400 && g.responseText ? y(g.responseText) : g.status >= 400 ? v(i(g.status, g.statusText)) : v(s));
      }, g.send(null);
    }
    function h(p) {
      var y = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(p || "");
      if (y) {
        var v = Number(y[1]), g = y[2], x = y[3];
        return g ? x ? [v, Number(x)] : [v, void 0] : [v, v];
      }
    }
    n.hooks.add("before-highlightall", function(p) {
      p.selector += ", " + f;
    }), n.hooks.add("before-sanity-check", function(p) {
      var y = (
        /** @type {HTMLPreElement} */
        p.element
      );
      if (y.matches(f)) {
        p.code = "", y.setAttribute(a, l);
        var v = y.appendChild(document.createElement("CODE"));
        v.textContent = r;
        var g = y.getAttribute("data-src"), x = p.language;
        if (x === "none") {
          var _ = (/\.(\w+)$/.exec(g) || [, "none"])[1];
          x = o[_] || _;
        }
        n.util.setLanguage(v, x), n.util.setLanguage(y, x);
        var b = n.plugins.autoloader;
        b && b.loadLanguages(x), d(
          g,
          function(C) {
            y.setAttribute(a, c);
            var E = h(y.getAttribute("data-range"));
            if (E) {
              var S = C.split(/\r\n?|\n/g), k = E[0], M = E[1] == null ? S.length : E[1];
              k < 0 && (k += S.length), k = Math.max(0, Math.min(k - 1, S.length)), M < 0 && (M += S.length), M = Math.max(0, Math.min(M, S.length)), C = S.slice(k, M).join(`
`), y.hasAttribute("data-start") || y.setAttribute("data-start", String(k + 1));
            }
            v.textContent = C, n.highlightElement(v);
          },
          function(C) {
            y.setAttribute(a, u), v.textContent = C;
          }
        );
      }
    }), n.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function(y) {
        for (var v = (y || document).querySelectorAll(f), g = 0, x; x = v[g++]; )
          n.highlightElement(x);
      }
    };
    var m = !1;
    n.fileHighlight = function() {
      m || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), m = !0), n.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(Eee);
Prism.languages.clike = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: !0,
      greedy: !0
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: !0,
      greedy: !0
    }
  ],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: !0
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: {
      punctuation: /[.\\]/
    }
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: !0
    }
  ],
  keyword: [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: !0
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: !0
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  number: {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: !0
  },
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: !0,
    greedy: !0,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: !0,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  parameter: [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: !0,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: !0,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: !0,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: !0,
      inside: Prism.languages.javascript
    }
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  hashbang: {
    pattern: /^#!.*/,
    greedy: !0,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: !0,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: !0,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      string: /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: !0,
    greedy: !0,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: !0,
    alias: "property"
  }
});
Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
  /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
  "javascript"
));
Prism.languages.js = Prism.languages.javascript;
Prism.languages.markup = {
  comment: {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: !0
  },
  prolog: {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: !0
  },
  doctype: {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      punctuation: /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /[^\s<>'"]+/
    }
  },
  cdata: {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: !0
  },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          punctuation: /^<\/?/,
          namespace: /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: !0
            }
          ]
        }
      },
      punctuation: /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          namespace: /^[^\s>\/:]+:/
        }
      }
    }
  },
  entity: [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity;
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(e) {
  e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function(t, n) {
    var r = {};
    r["language-" + n] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: !0,
      inside: Prism.languages[n]
    }, r.cdata = /^<!\[CDATA\[|\]\]>$/i;
    var i = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: r
      }
    };
    i["language-" + n] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[n]
    };
    var s = {};
    s[t] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return t;
      }), "i"),
      lookbehind: !0,
      greedy: !0,
      inside: i
    }, Prism.languages.insertBefore("markup", "cdata", s);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(e, t) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: !0,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            value: {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: !0,
              alias: [t, "language-" + t],
              inside: Prism.languages[t]
            },
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(e) {
  var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n(u) {
    return u = u.replace(/<inner>/g, function() {
      return t;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + u + ")");
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return r;
  }), s = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  e.languages.markdown = e.languages.extend("markup", {}), e.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        punctuation: /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: e.languages.yaml
        }
      }
    },
    blockquote: {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    table: {
      pattern: RegExp("^" + i + s + "(?:" + i + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + i + s + ")(?:" + i + ")*$"),
          lookbehind: !0,
          inside: {
            "table-data": {
              pattern: RegExp(r),
              inside: e.languages.markdown
            },
            punctuation: /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + i + ")" + s + "$"),
          lookbehind: !0,
          inside: {
            punctuation: /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + i + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(r),
              alias: "important",
              inside: e.languages.markdown
            },
            punctuation: /\|/
          }
        }
      }
    },
    code: [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: !0,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: !0,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: !0
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: !0
          },
          punctuation: /```/
        }
      }
    ],
    title: [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: !0,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    hr: {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: !0,
      alias: "punctuation"
    },
    list: {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: !0,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        variable: {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: !0
        },
        string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        punctuation: /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    bold: {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        punctuation: /\*\*|__/
      }
    },
    italic: {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        punctuation: /[*_]/
      }
    },
    strike: {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        punctuation: /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: !0,
      greedy: !0,
      alias: ["code", "keyword"]
    },
    url: {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        operator: /^!/,
        content: {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        variable: {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: !0
        },
        url: {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: !0
        },
        string: {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: !0
        }
      }
    }
  }), ["url", "bold", "italic", "strike"].forEach(function(u) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(f) {
      u !== f && (e.languages.markdown[u].inside.content.inside[f] = e.languages.markdown[f]);
    });
  }), e.hooks.add("after-tokenize", function(u) {
    if (u.language !== "markdown" && u.language !== "md")
      return;
    function f(d) {
      if (!(!d || typeof d == "string"))
        for (var h = 0, m = d.length; h < m; h++) {
          var p = d[h];
          if (p.type !== "code") {
            f(p.content);
            continue;
          }
          var y = p.content[1], v = p.content[3];
          if (y && v && y.type === "code-language" && v.type === "code-block" && typeof y.content == "string") {
            var g = y.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
            g = (/[a-z][\w-]*/i.exec(g) || [""])[0].toLowerCase();
            var x = "language-" + g;
            v.alias ? typeof v.alias == "string" ? v.alias = [v.alias, x] : v.alias.push(x) : v.alias = [x];
          }
        }
    }
    f(u.tokens);
  }), e.hooks.add("wrap", function(u) {
    if (u.type === "code-block") {
      for (var f = "", d = 0, h = u.classes.length; d < h; d++) {
        var m = u.classes[d], p = /language-(.+)/.exec(m);
        if (p) {
          f = p[1];
          break;
        }
      }
      var y = e.languages[f];
      if (y)
        u.content = e.highlight(c(u.content), y, f);
      else if (f && f !== "none" && e.plugins.autoloader) {
        var v = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        u.attributes.id = v, e.plugins.autoloader.loadLanguages(f, function() {
          var g = document.getElementById(v);
          g && (g.innerHTML = e.highlight(g.textContent, e.languages[f], f));
        });
      }
    }
  });
  var o = RegExp(e.languages.markup.tag.pattern.source, "gi"), a = {
    amp: "&",
    lt: "<",
    gt: ">",
    quot: '"'
  }, l = String.fromCodePoint || String.fromCharCode;
  function c(u) {
    var f = u.replace(o, "");
    return f = f.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(d, h) {
      if (h = h.toLowerCase(), h[0] === "#") {
        var m;
        return h[1] === "x" ? m = parseInt(h.slice(2), 16) : m = Number(h.slice(1)), l(m);
      } else {
        var p = a[h];
        return p || d;
      }
    }), f;
  }
  e.languages.md = e.languages.markdown;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  comment: {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: !0
  },
  string: {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: !0
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: !0
  },
  keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  char: {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: !0
  }
});
Prism.languages.insertBefore("c", "string", {
  macro: {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
    inside: {
      string: [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: !0
        },
        Prism.languages.c.string
      ],
      char: Prism.languages.c.char,
      comment: Prism.languages.c.comment,
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: !0
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: !0,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      directive: {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: !0,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=[\r\n])/,
      expression: {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c.boolean;
(function(e) {
  var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  e.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        rule: /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: !0,
          alias: "selector"
        },
        keyword: {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: !0
        }
        // See rest below
      }
    },
    url: {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: !0,
      inside: {
        function: /^url/i,
        punctuation: /^\(|\)$/,
        string: {
          pattern: RegExp("^" + t.source + "$"),
          alias: "url"
        }
      }
    },
    selector: {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"),
      lookbehind: !0
    },
    string: {
      pattern: t,
      greedy: !0
    },
    property: {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: !0
    },
    important: /!important\b/i,
    function: {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: !0
    },
    punctuation: /[(){};:,]/
  }, e.languages.css.atrule.inside.rest = e.languages.css;
  var n = e.languages.markup;
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  string: {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: !0
  },
  keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
Prism.languages.sql = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: !0
  },
  variable: [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: !0
    },
    /@[\w.$]+/
  ],
  string: {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: !0,
    lookbehind: !0
  },
  identifier: {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: !0,
    lookbehind: !0,
    inside: {
      punctuation: /^`|`$/
    }
  },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/
};
(function(e) {
  var t = e.languages.powershell = {
    comment: [
      {
        pattern: /(^|[^`])<#[\s\S]*?#>/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^`])#.*/,
        lookbehind: !0
      }
    ],
    string: [
      {
        pattern: /"(?:`[\s\S]|[^`"])*"/,
        greedy: !0,
        inside: null
        // see below
      },
      {
        pattern: /'(?:[^']|'')*'/,
        greedy: !0
      }
    ],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    boolean: /\$(?:false|true)\b/i,
    variable: /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    function: [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    operator: {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: !0
    },
    punctuation: /[|{}[\];(),.]/
  };
  t.string[0].inside = {
    function: {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: !0,
      inside: t
    },
    boolean: t.boolean,
    variable: t.variable
  };
})(Prism);
Prism.languages.python = {
  comment: {
    pattern: /(^|[^\\])#.*/,
    lookbehind: !0,
    greedy: !0
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: !0,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: !0
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      string: /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: !0,
    alias: "string"
  },
  string: {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: !0
  },
  function: {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: !0
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: !0
  },
  decorator: {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: !0,
    alias: ["annotation", "punctuation"],
    inside: {
      punctuation: /\./
    }
  },
  keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function(e) {
  for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
    t = t.replace(/<self>/g, function() {
      return t;
    });
  t = t.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e.languages.rust = {
    comment: [
      {
        pattern: RegExp(/(^|[^\\])/.source + t),
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: !0
    },
    char: {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: !0
    },
    attribute: {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: !0,
      alias: "attr-name",
      inside: {
        string: null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: !0,
      alias: "punctuation"
    },
    variable: /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: !0,
      alias: "class-name"
    },
    "module-declaration": [
      {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
        lookbehind: !0,
        alias: "namespace"
      },
      {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
        lookbehind: !0,
        alias: "namespace",
        inside: {
          punctuation: /::/
        }
      }
    ],
    keyword: [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    macro: {
      pattern: /\b\w+!/,
      alias: "property"
    },
    constant: /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    namespace: {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        punctuation: /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    boolean: /\b(?:false|true)\b/,
    punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
})(Prism);
Prism.languages.swift = {
  comment: {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: !0,
    greedy: !0
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: !0,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: !0,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        string: /[\s\S]+/
      }
    }
  ],
  directive: {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: /\b(?:false|true)\b/,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/
    }
  },
  literal: {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  attribute: {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  label: {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: !0,
    alias: "important"
  },
  keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: /\b(?:false|true)\b/,
  nil: {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  omit: {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  punctuation: /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(e) {
  e.inside.interpolation.inside = Prism.languages.swift;
});
(function(e) {
  e.languages.typescript = e.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null
      // see below
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  }), e.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  ), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
  var t = e.languages.extend("typescript", {});
  delete t["class-name"], e.languages.typescript["class-name"].inside = t, e.languages.insertBefore("typescript", "function", {
    decorator: {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        at: {
          pattern: /^@/,
          alias: "operator"
        },
        function: /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: !0,
      inside: {
        function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        generic: {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: t
        }
      }
    }
  }), e.languages.ts = e.languages.typescript;
})(Prism);
(function(e) {
  var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, r = {
    pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: !0,
    inside: {
      namespace: {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /\./
    }
  };
  e.languages.java = e.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: !0,
      greedy: !0
    },
    "class-name": [
      r,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: !0,
        inside: r.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + n + /[A-Z]\w*\b/.source),
        lookbehind: !0,
        inside: r.inside
      }
    ],
    keyword: t,
    function: [
      e.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: !0
      }
    ],
    number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    operator: {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: !0
    },
    constant: /\b[A-Z][A-Z_\d]+\b/
  }), e.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: !0,
      alias: "string"
    },
    char: {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: !0
    }
  }), e.languages.insertBefore("java", "class-name", {
    annotation: {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: !0,
      alias: "punctuation"
    },
    generics: {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": r,
        keyword: t,
        punctuation: /[<>(),.:]/,
        operator: /[?&|]/
      }
    },
    import: [
      {
        pattern: RegExp(/(\bimport\s+)/.source + n + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: !0,
        inside: {
          namespace: r.inside.namespace,
          punctuation: /\./,
          operator: /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + n + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: !0,
        alias: "static",
        inside: {
          namespace: r.inside.namespace,
          static: /\b\w+$/,
          punctuation: /\./,
          operator: /\*/,
          "class-name": /\w+/
        }
      }
    ],
    namespace: {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return t.source;
        })
      ),
      lookbehind: !0,
      inside: {
        punctuation: /\./
      }
    }
  });
})(Prism);
(function(e) {
  var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return t.source;
  });
  e.languages.cpp = e.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return t.source;
        })),
        lookbehind: !0
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    keyword: t,
    number: {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: !0
    },
    operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    boolean: /\b(?:false|true)\b/
  }), e.languages.insertBefore("cpp", "string", {
    module: {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return n;
        }) + ")"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        string: /^[<"][\s\S]+/,
        operator: /:/,
        punctuation: /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: !0
    }
  }), e.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        function: /^\w+/,
        generic: {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: e.languages.cpp
        }
      }
    }
  }), e.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  }), e.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: !0,
      greedy: !0,
      inside: e.languages.extend("cpp", {})
    }
  }), e.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, e.languages.cpp["base-clause"]);
})(Prism);
(function(e) {
  e.languages.diff = { coord: [/^(?:\*{3}|-{3}|\+{3}).*$/m, /^@@.*@@$/m, /^\d.*$/m] };
  var t = { "deleted-sign": "-", "deleted-arrow": "<", "inserted-sign": "+", "inserted-arrow": ">", unchanged: " ", diff: "!" };
  Object.keys(t).forEach(function(n) {
    var r = t[n], i = [];
    /^\w+$/.test(n) || i.push(/\w+/.exec(n)[0]), n === "diff" && i.push("bold"), e.languages.diff[n] = { pattern: RegExp("^(?:[" + r + `].*(?:\r
?|
|(?![\\s\\S])))+`, "m"), alias: i, inside: { line: { pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/, lookbehind: !0 }, prefix: { pattern: /[\s\S]/, alias: /\w+/.exec(n)[0] } } };
  }), Object.defineProperty(e.languages.diff, "PREFIXES", { value: t });
})(Prism);
const Om = globalThis.Prism || window.Prism, X4 = (e) => {
  const t = /^diff-([\w-]+)/i;
  try {
    if (!e) return !1;
    const n = t.exec(e);
    return n ? Om.languages.hasOwnProperty("diff") && Om.languages.hasOwnProperty(n[1]) : Om.languages.hasOwnProperty(e);
  } catch {
    return !1;
  }
};
function iN(e, t) {
  for (const n of e.childNodes) {
    if (At(n) && n.tagName === t) return !0;
    iN(n, t);
  }
  return !1;
}
const Zl = "data-language", pf = "data-highlight-language";
let Mx = class sN extends Wn {
  static getType() {
    return "code";
  }
  static clone(t) {
    return new sN(t.__language, t.__key);
  }
  constructor(t, n) {
    super(n), this.__language = t || void 0, this.__isSyntaxHighlightSupported = X4(t);
  }
  createDOM(t) {
    const n = document.createElement("code");
    Ur(n, t.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Zl, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(pf, r)), n;
  }
  updateDOM(t, n, r) {
    const i = this.__language, s = t.__language;
    return i ? i !== s && (n.setAttribute(Zl, i), this.__isSyntaxHighlightSupported && n.setAttribute(pf, i)) : s && (n.removeAttribute(Zl), t.__isSyntaxHighlightSupported && n.removeAttribute(pf)), !1;
  }
  exportDOM(t) {
    const n = document.createElement("pre");
    Ur(n, t._config.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Zl, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(pf, r)), { element: n };
  }
  static importDOM() {
    return { code: (t) => t.textContent != null && (/\r?\n/.test(t.textContent) || iN(t, "BR")) ? { conversion: Z4, priority: 1 } : null, div: () => ({ conversion: See, priority: 1 }), pre: () => ({ conversion: Z4, priority: 0 }), table: (t) => Pm(t) ? { conversion: kee, priority: 3 } : null, td: (t) => {
      const n = t, r = n.closest("table");
      return n.classList.contains("js-file-line") || r && Pm(r) ? { conversion: Q4, priority: 3 } : null;
    }, tr: (t) => {
      const n = t.closest("table");
      return n && Pm(n) ? { conversion: Q4, priority: 3 } : null;
    } };
  }
  static importJSON(t) {
    return Ji().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setLanguage(t.language);
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage() };
  }
  insertNewAfter(t, n = !0) {
    const r = this.getChildren(), i = r.length;
    if (i >= 2 && r[i - 1].getTextContent() === `
` && r[i - 2].getTextContent() === `
` && t.isCollapsed() && t.anchor.key === this.__key && t.anchor.offset === i) {
      r[i - 1].remove(), r[i - 2].remove();
      const l = st();
      return this.insertAfter(l, n), l;
    }
    const { anchor: s, focus: o } = t, a = (s.isBefore(o) ? s : o).getNode();
    if (ye(a)) {
      let l = Aee(a);
      const c = [];
      for (; ; ) if (op(l)) c.push(ul()), l = l.getNextSibling();
      else {
        if (!cN(l)) break;
        {
          let y = 0;
          const v = l.getTextContent(), g = l.getTextContentSize();
          for (; y < g && v[y] === " "; ) y++;
          if (y !== 0 && c.push(lN(" ".repeat(y))), y !== g) break;
          l = l.getNextSibling();
        }
      }
      const u = a.splitText(s.offset)[0], f = s.offset === 0 ? 0 : 1, d = u.getIndexWithinParent() + f, h = a.getParentOrThrow(), m = [Br(), ...c];
      h.splice(d, 0, m);
      const p = c[c.length - 1];
      p ? p.select() : s.offset === 0 ? u.selectPrevious() : u.getNextSibling().selectNext(0, 0);
    }
    if (Ox(a)) {
      const { offset: l } = t.anchor;
      a.splice(l, 0, [Br()]), a.select(l + 1, l + 1);
    }
    return null;
  }
  canIndent() {
    return !1;
  }
  collapseAtStart() {
    const t = st();
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  setLanguage(t) {
    const n = this.getWritable();
    return n.__language = t || void 0, n.__isSyntaxHighlightSupported = X4(t), n;
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
};
function Ji(e) {
  return Pn(new Mx(e));
}
function Ox(e) {
  return e instanceof Mx;
}
function Z4(e) {
  return { node: Ji(e.getAttribute(Zl)) };
}
function See(e) {
  const t = e, n = e3(t);
  return n || function(r) {
    let i = r.parentElement;
    for (; i !== null; ) {
      if (e3(i)) return !0;
      i = i.parentElement;
    }
    return !1;
  }(t) ? { node: n ? Ji() : null } : { node: null };
}
function kee() {
  return { node: Ji() };
}
function Q4() {
  return { node: null };
}
function e3(e) {
  return e.style.fontFamily.match("monospace") !== null;
}
function Pm(e) {
  return e.classList.contains("js-file-line-container");
}
let oN = class aN extends Ys {
  constructor(t = "", n, r) {
    super(t, r), this.__highlightType = n;
  }
  static getType() {
    return "code-highlight";
  }
  static clone(t) {
    return new aN(t.__text, t.__highlightType || void 0, t.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  setHighlightType(t) {
    const n = this.getWritable();
    return n.__highlightType = t || void 0, n;
  }
  canHaveFormat() {
    return !1;
  }
  createDOM(t) {
    const n = super.createDOM(t), r = Dm(t.theme, this.__highlightType);
    return Ur(n, r), n;
  }
  updateDOM(t, n, r) {
    const i = super.updateDOM(t, n, r), s = Dm(r.theme, t.__highlightType), o = Dm(r.theme, this.__highlightType);
    return s !== o && (s && gp(n, s), o && Ur(n, o)), i;
  }
  static importJSON(t) {
    return lN().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setHighlightType(t.highlightType);
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType() };
  }
  setFormat(t) {
    return this;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return Ji();
  }
};
function Dm(e, t) {
  return t && e && e.codeHighlight && e.codeHighlight[t];
}
function lN(e = "", t) {
  return Pn(new oN(e, t));
}
function cN(e) {
  return e instanceof oN;
}
function Tee(e, t) {
  let n = e;
  for (let r = Kt(e, t); r && (cN(r.origin) || op(r.origin)); r = dP(r)) n = r.origin;
  return n;
}
function Aee(e) {
  return Tee(e, "previous");
}
function t2(e, t) {
  const n = {};
  for (const r of e) {
    const i = t(r);
    i && (n[i] ? n[i].push(r) : n[i] = [r]);
  }
  return n;
}
function Nee(e) {
  const t = t2(e, (n) => n.type);
  return { element: t.element || [], multilineElement: t["multiline-element"] || [], textFormat: t["text-format"] || [], textMatch: t["text-match"] || [] };
}
const t3 = /[!-/:-@[-`{-~\s]/;
function Iee(e) {
  return ye(e) && !e.hasFormat("code");
}
function Lee(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function n3(e, t, n) {
  const r = n.length;
  for (let i = t; i >= r; i--) {
    const s = i - r;
    if (uN(e, s, n, 0, r) && e[s + r] !== " ") return s;
  }
  return -1;
}
function uN(e, t, n, r, i) {
  for (let s = 0; s < i; s++) if (e[t + s] !== n[r + s]) return !1;
  return !0;
}
function Mee(e, t = EN) {
  const n = Nee(t), r = t2(n.textFormat, ({ tag: o }) => o[o.length - 1]), i = t2(n.textMatch, ({ trigger: o }) => o);
  for (const o of t) {
    const a = o.type;
    if (a === "element" || a === "text-match" || a === "multiline-element") {
      const l = o.dependencies;
      for (const c of l) e.hasNode(c) || Lee(173, c.getType());
    }
  }
  const s = (o, a, l) => {
    (function(c, u, f, d) {
      const h = c.getParent();
      if (!Jt(h) || c.getFirstChild() !== u) return !1;
      const m = u.getTextContent();
      if (m[f - 1] !== " ") return !1;
      for (const { regExp: p, replace: y } of d) {
        const v = m.match(p);
        if (v && v[0].length === (v[0].endsWith(" ") ? f : f - 1)) {
          const g = u.getNextSiblings(), [x, _] = u.splitText(f);
          if (y(c, _ ? [_, ...g] : g, v, !1) !== !1) return x.remove(), !0;
        }
      }
      return !1;
    })(o, a, l, n.element) || function(c, u, f, d) {
      const h = c.getParent();
      if (!Jt(h) || c.getFirstChild() !== u) return !1;
      const m = u.getTextContent();
      if (m[f - 1] !== " ") return !1;
      for (const { regExpStart: p, replace: y, regExpEnd: v } of d) {
        if (v && !("optional" in v) || v && "optional" in v && !v.optional) continue;
        const g = m.match(p);
        if (g && g[0].length === (g[0].endsWith(" ") ? f : f - 1)) {
          const x = u.getNextSiblings(), [_, b] = u.splitText(f);
          if (y(c, b ? [b, ...x] : x, g, null, null, !1) !== !1) return _.remove(), !0;
        }
      }
      return !1;
    }(o, a, l, n.multilineElement) || function(c, u, f) {
      let d = c.getTextContent();
      const h = f[d[u - 1]];
      if (h == null) return !1;
      u < d.length && (d = d.slice(0, u));
      for (const m of h) {
        if (!m.replace || !m.regExp) continue;
        const p = d.match(m.regExp);
        if (p === null) continue;
        const y = p.index || 0, v = y + p[0].length;
        let g;
        return y === 0 ? [g] = c.splitText(v) : [, g] = c.splitText(y, v), g.selectNext(0, 0), m.replace(g, p), !0;
      }
      return !1;
    }(a, l, i) || function(c, u, f) {
      const d = c.getTextContent(), h = u - 1, m = d[h], p = f[m];
      if (!p) return !1;
      for (const y of p) {
        const { tag: v } = y, g = v.length, x = h - g + 1;
        if (g > 1 && !uN(d, x, v, 0, g) || d[x - 1] === " ") continue;
        const _ = d[h + 1];
        if (y.intraword === !1 && _ && !t3.test(_)) continue;
        const b = c;
        let C = b, E = n3(d, x, v), S = C;
        for (; E < 0 && (S = S.getPreviousSibling()) && !Rr(S); ) if (ye(S)) {
          if (S.hasFormat("code")) continue;
          const G = S.getTextContent();
          C = S, E = n3(G, G.length, v);
        }
        if (E < 0 || C === b && E + g === x) continue;
        const k = C.getTextContent();
        if (E > 0 && k[E - 1] === m) continue;
        const M = k[E - 1];
        if (y.intraword === !1 && M && !t3.test(M)) continue;
        const O = b.getTextContent(), R = O.slice(0, x) + O.slice(h + 1);
        b.setTextContent(R);
        const I = C === b ? R : k;
        C.setTextContent(I.slice(0, E) + I.slice(E + g));
        const H = ge(), P = fl();
        Ot(P);
        const W = h - g * (C === b ? 2 : 1) + 1;
        P.anchor.set(C.__key, E, "text"), P.focus.set(b.__key, W, "text");
        for (const G of y.format) P.hasFormat(G) || P.formatText(G);
        P.anchor.set(P.focus.key, P.focus.offset, P.focus.type);
        for (const G of y.format) P.hasFormat(G) && P.toggleFormat(G);
        return fe(H) && (P.format = H.format), !0;
      }
    }(a, l, r);
  };
  return e.registerUpdateListener(({ tags: o, dirtyLeaves: a, editorState: l, prevEditorState: c }) => {
    if (o.has(f9) || o.has(Id) || e.isComposing()) return;
    const u = l.read(ge), f = c.read(ge);
    if (!fe(f) || !fe(u) || !u.isCollapsed() || u.is(f)) return;
    const d = u.anchor.key, h = u.anchor.offset, m = l._nodeMap.get(d);
    !ye(m) || !a.has(d) || h !== 1 && h > f.anchor.offset + 1 || e.update(() => {
      if (!Iee(m)) return;
      const p = m.getParent();
      p === null || Ox(p) || s(p, m, u.anchor.offset);
    });
  });
}
const Oee = /^(\s*)(\d{1,})\.\s/, Pee = /^(\s*)[-*+]\s/, Dee = /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i, Fee = /^(#{1,6})\s/, Ree = /^>\s/, $ee = /^[ \t]*```([\w-]+)?/, Vee = /[ \t]*```$/, fN = (e) => (t, n, r, i) => {
  const s = e(r);
  s.append(...n), t.replace(s), i || s.select(0, 0);
}, Px = (e) => (t, n, r, i) => {
  const s = t.getPreviousSibling(), o = t.getNextSibling(), a = Ln(e === "check" ? r[3] === "x" : void 0);
  if (De(o) && o.getListType() === e) {
    const c = o.getFirstChild();
    c !== null ? c.insertBefore(a) : o.append(a), t.remove();
  } else if (De(s) && s.getListType() === e) s.append(a), t.remove();
  else {
    const c = In(e, e === "number" ? Number(r[2]) : void 0);
    c.append(a), t.replace(c);
  }
  a.append(...n), i || a.select(0, 0);
  const l = function(c) {
    const u = c.match(/\t/g), f = c.match(/ /g);
    let d = 0;
    return u && (d += u.length), f && (d += Math.floor(f.length / 4)), d;
  }(r[1]);
  l && a.setIndent(l);
}, n1 = (e, t, n) => {
  const r = [], i = e.getChildren();
  let s = 0;
  for (const o of i) if (Je(o)) {
    if (o.getChildrenSize() === 1) {
      const u = o.getFirstChild();
      if (De(u)) {
        r.push(n1(u, t, n + 1));
        continue;
      }
    }
    const a = " ".repeat(4 * n), l = e.getListType(), c = l === "number" ? `${e.getStart() + s}. ` : l === "check" ? `- [${o.getChecked() ? "x" : " "}] ` : "- ";
    r.push(a + c + t(o)), s++;
  }
  return r.join(`
`);
}, Bee = { dependencies: [lu], export: (e, t) => {
  if (!vp(e)) return null;
  const n = Number(e.getTag().slice(1));
  return "#".repeat(n) + " " + t(e);
}, regExp: Fee, replace: fN((e) => {
  const t = "h" + e[1].length;
  return li(t);
}), type: "element" }, dN = { dependencies: [ml], export: (e, t) => {
  if (!Jg(e)) return null;
  const n = t(e).split(`
`), r = [];
  for (const i of n) r.push("> " + i);
  return r.join(`
`);
}, regExp: Ree, replace: (e, t, n, r) => {
  if (r) {
    const s = e.getPreviousSibling();
    if (Jg(s)) return s.splice(s.getChildrenSize(), 0, [Br(), ...t]), void e.remove();
  }
  const i = au();
  i.append(...t), e.replace(i), r || i.select(0, 0);
}, type: "element" }, hN = { dependencies: [Mx], export: (e) => {
  if (!Ox(e)) return null;
  const t = e.getTextContent();
  return "```" + (e.getLanguage() || "") + (t ? `
` + t : "") + "\n```";
}, regExpEnd: { optional: !0, regExp: Vee }, regExpStart: $ee, replace: (e, t, n, r, i, s) => {
  let o, a;
  if (!t && i) {
    if (i.length === 1) r ? (o = Ji(), a = n[1] + i[0]) : (o = Ji(n[1]), a = i[0].startsWith(" ") ? i[0].slice(1) : i[0]);
    else {
      if (o = Ji(n[1]), i[0].trim().length === 0) for (; i.length > 0 && !i[0].length; ) i.shift();
      else i[0] = i[0].startsWith(" ") ? i[0].slice(1) : i[0];
      for (; i.length > 0 && !i[i.length - 1].length; ) i.pop();
      a = i.join(`
`);
    }
    const l = yt(a);
    o.append(l), e.append(o);
  } else t && fN((l) => Ji(l ? l[1] : void 0))(e, t, n, s);
}, type: "multiline-element" }, pN = { dependencies: [cs, ls], export: (e, t) => De(e) ? n1(e, t, 0) : null, regExp: Pee, replace: Px("bullet"), type: "element" }, zee = { dependencies: [cs, ls], export: (e, t) => De(e) ? n1(e, t, 0) : null, regExp: Dee, replace: Px("check"), type: "element" }, mN = { dependencies: [cs, ls], export: (e, t) => De(e) ? n1(e, t, 0) : null, regExp: Oee, replace: Px("number"), type: "element" }, gN = { format: ["code"], tag: "`", type: "text-format" }, Hee = { format: ["highlight"], tag: "==", type: "text-format" }, vN = { format: ["bold", "italic"], tag: "***", type: "text-format" }, yN = { format: ["bold", "italic"], intraword: !1, tag: "___", type: "text-format" }, xN = { format: ["bold"], tag: "**", type: "text-format" }, wN = { format: ["bold"], intraword: !1, tag: "__", type: "text-format" }, Uee = { format: ["strikethrough"], tag: "~~", type: "text-format" }, _N = { format: ["italic"], tag: "*", type: "text-format" }, bN = { format: ["italic"], intraword: !1, tag: "_", type: "text-format" }, CN = { dependencies: [Zo], export: (e, t, n) => {
  if (!ur(e) || oi(e)) return null;
  const r = e.getTitle(), i = t(e);
  return r ? `[${i}](${e.getURL()} "${r}")` : `[${i}](${e.getURL()})`;
}, importRegExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/, regExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/, replace: (e, t) => {
  const [, n, r, i] = t, s = Ks(r, { title: i }), o = yt(n);
  return o.setFormat(e.getFormat()), s.append(o), e.replace(s), o;
}, trigger: ")", type: "text-match" }, jee = [Bee, dN, pN, mN], Wee = [hN], Jee = [gN, vN, yN, xN, wN, Hee, _N, bN, Uee], Kee = [CN], EN = [...jee, ...Wee, ...Jee, ...Kee], qee = [{ dependencies: [mu], export: (e) => oy(e) ? "***" : null, regExp: /^(---|\*\*\*|___)\s?$/, replace: (e, t, n, r) => {
  const i = xl();
  r || e.getNextSibling() != null ? e.replace(i) : e.insertBefore(i), i.selectNext();
}, type: "element" }, ...EN];
function r3({ transformers: e = qee }) {
  const [t] = vn();
  return Le(() => Mee(t, e), [t, e]), null;
}
const Gee = Jn({
  init(e) {
    const t = e.getValue(sy), n = t.includes("headings") ? e.getValue(Sp) : [], r = Zee(t, n);
    e.pubIn({
      [Xo]: () => /* @__PURE__ */ T.createElement(r3, { transformers: r }),
      [aS]: () => /* @__PURE__ */ T.createElement(r3, { transformers: r })
    });
  }
}), Yee = (e) => (t, n, r) => {
  const i = e(r);
  i.append(...n), t.replace(i), i.select(0, 0);
}, Xee = {
  dependencies: [mu],
  export: (e) => oy(e) ? "***" : null,
  regExp: /^(---|\*\*\*|___)\s?$/,
  replace: (e, t, n, r) => {
    const i = xl();
    r || e.getNextSibling() != null ? e.replace(i) : e.insertBefore(i), i.selectNext();
  },
  type: "element"
};
function Zee(e, t) {
  const n = [
    vN,
    yN,
    xN,
    wN,
    gN,
    _N,
    bN
    // HIGHLIGHT,
    // STRIKETHROUGH
  ];
  if (e.includes("headings")) {
    const r = Math.min(...t), i = Math.max(...t), s = new RegExp(`^(#{${r},${i}})\\s`), o = {
      dependencies: [lu],
      export: (a, l) => {
        if (!vp(a))
          return null;
        const c = Number(a.getTag().slice(1));
        return "#".repeat(c) + " " + l(a);
      },
      regExp: s,
      replace: Yee((a) => {
        const l = `h${a[1].length}`;
        return li(l);
      }),
      type: "element"
    };
    n.push(o);
  }
  if (e.includes("thematicBreak") && n.push(Xee), e.includes("quote") && n.push(dN), e.includes("link") && n.push(CN), e.includes("lists") && n.push(mN, pN, zee), e.includes("codeblock")) {
    const r = {
      ...hN,
      dependencies: [Tl],
      replace: (i, s, o) => {
        const a = Lu({ code: "", language: o[1] ?? "", meta: "" });
        i.selectPrevious(), i.replace(a), setTimeout(() => {
          a.select();
        }, 80);
      }
    };
    n.push(r);
  }
  return n;
}
const Qee = () => {
  const e = It(Jd), t = mn(lS), n = mn(sy), r = n.includes("quote"), i = n.includes("headings"), s = Kn();
  if (!r && !i)
    return null;
  const o = [
    { label: s("toolbar.blockTypes.paragraph", "Paragraph"), value: "paragraph" }
  ];
  if (r && o.push({ label: s("toolbar.blockTypes.quote", "Quote"), value: "quote" }), i) {
    const a = mn(Sp);
    o.push(
      ...a.map(
        (l) => ({ label: s("toolbar.blockTypes.heading", "Heading {{level}}", { level: l }), value: `h${l}` })
      )
    );
  }
  return /* @__PURE__ */ T.createElement(
    EQ,
    {
      value: t,
      onChange: (a) => {
        switch (a) {
          case "quote":
            e(() => au());
            break;
          case "paragraph":
            e(() => st());
            break;
          case "":
            break;
          default:
            if (a.startsWith("h"))
              e(() => li(a));
            else
              throw new Error(`Unknown block type: ${a}`);
        }
      },
      triggerTitle: s("toolbar.blockTypeSelect.selectBlockTypeTooltip", "Select block type"),
      placeholder: s("toolbar.blockTypeSelect.placeholder", "Block type"),
      items: o
    }
  );
}, Fm = ({ format: e, addTitle: t, removeTitle: n, icon: r, formatName: i }) => {
  const [s, o] = On(Xv, ir), a = It(Zv), l = (s & e) !== 0;
  return /* @__PURE__ */ T.createElement(
    nN,
    {
      title: l ? n : t,
      on: l,
      onValueChange: () => {
        a(i);
      }
    },
    o(r)
  );
}, ete = ({ options: e }) => {
  const t = Kn(), n = typeof e > "u";
  return /* @__PURE__ */ T.createElement("div", { className: de.toolbarGroupOfGroups }, n || e.includes("Bold") ? /* @__PURE__ */ T.createElement(
    Fm,
    {
      format: lc,
      addTitle: t("toolbar.bold", "Bold"),
      removeTitle: t("toolbar.removeBold", "Remove bold"),
      icon: "format_bold",
      formatName: "bold"
    }
  ) : null, n || e.includes("Italic") ? /* @__PURE__ */ T.createElement(
    Fm,
    {
      format: cc,
      addTitle: t("toolbar.italic", "Italic"),
      removeTitle: t("toolbar.removeItalic", "Remove italic"),
      icon: "format_italic",
      formatName: "italic"
    }
  ) : null, n || e.includes("Underline") ? /* @__PURE__ */ T.createElement(
    Fm,
    {
      format: uc,
      addTitle: t("toolbar.underline", "Underline"),
      removeTitle: t("toolbar.removeUnderline", "Remove underline"),
      icon: "format_underlined",
      formatName: "underline"
    }
  ) : null);
}, tte = () => {
  const [e, t] = On(Xv, ir), n = It(Zv), r = Kn(), i = (e & _p) !== 0, s = i ? r("toolbar.removeInlineCode", "Remove code format") : r("toolbar.inlineCode", "Inline code format");
  return /* @__PURE__ */ T.createElement(
    rN,
    {
      items: [{ title: s, contents: t("code"), active: i, onChange: n.bind(null, "code") }]
    }
  );
}, nte = () => {
  const e = It(Ix), t = mn(ir), n = Kn();
  return /* @__PURE__ */ T.createElement(
    _ee,
    {
      "aria-label": n("toolbar.link", "Create link"),
      title: n("toolbar.link", "Create link"),
      onClick: (r) => {
        e();
      }
    },
    t("link")
  );
}, rte = T.forwardRef((e, t) => {
  const n = It(Ek), [r, i] = On(Cr, ir), s = Kn();
  return /* @__PURE__ */ T.createElement(
    Z7,
    {
      className: de.toolbarButton,
      ref: t,
      disabled: r,
      onClick: () => {
        n();
      }
    },
    /* @__PURE__ */ T.createElement(Ou, { title: s("toolbar.image", "Insert image") }, i("add_photo"))
  );
}), ite = {
  bullet: "format_list_bulleted",
  number: "format_list_numbered",
  check: "format_list_checked"
}, ste = ({ options: e = ["bullet", "number", "check"] }) => {
  const [t, n] = On(p0, ir), r = It(LS), i = Kn(), s = {
    bullet: i("toolbar.bulletedList", "Bulleted list"),
    number: i("toolbar.numberedList", "Numbered list"),
    check: i("toolbar.checkList", "Check list")
  }, o = e.map((a) => ({
    value: a,
    title: s[a],
    contents: n(ite[a])
  }));
  return /* @__PURE__ */ T.createElement(bee, { value: t || "", items: o, onChange: r });
}, ote = () => {
  const [e, t] = On(ir, Ft), [n, r] = T.useState(!1), [i, s] = T.useState(!1), o = Kn();
  return T.useEffect(() => {
    if (t)
      return Dn(
        t.registerCommand(
          Gl,
          (a) => (r(a), !1),
          zr
        ),
        t.registerCommand(
          ql,
          (a) => (s(a), !1),
          zr
        )
      );
  }, [t]), /* @__PURE__ */ T.createElement(
    rN,
    {
      items: [
        {
          title: o("toolbar.undo", "Undo {{shortcut}}", { shortcut: Gd ? "⌘Z" : "Ctrl+Z" }),
          disabled: !n,
          contents: e("undo"),
          active: !1,
          onChange: () => t == null ? void 0 : t.dispatchCommand(tp, void 0)
        },
        {
          title: o("toolbar.redo", "Redo {{shortcut}}", { shortcut: Gd ? "⌘Y" : "Ctrl+Y" }),
          disabled: !i,
          contents: e("redo"),
          active: !1,
          onChange: () => t == null ? void 0 : t.dispatchCommand(np, void 0)
        }
      ]
    }
  );
}, Rm = "phrasing", $m = ["autolink", "link", "image", "label"];
function ate() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Rm,
        notInConstruct: $m
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Rm,
        notInConstruct: $m
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Rm,
        notInConstruct: $m
      }
    ]
  };
}
SN.peek = lte;
function lte() {
  return "[";
}
function SN(e, t, n, r) {
  const i = n.createTracker(r);
  let s = i.move("[^");
  const o = n.enter("footnoteReference"), a = n.enter("reference");
  return s += i.move(
    n.safe(n.associationId(e), { after: "]", before: s })
  ), a(), o(), s += i.move("]"), s;
}
function cte(e) {
  return {
    handlers: { footnoteDefinition: t, footnoteReference: SN },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function t(n, r, i, s) {
    const o = i.createTracker(s);
    let a = o.move("[^");
    const l = i.enter("footnoteDefinition"), c = i.enter("label");
    return a += o.move(
      i.safe(i.associationId(n), { before: a, after: "]" })
    ), c(), a += o.move("]:"), n.children && n.children.length > 0 && (o.shift(4), a += o.move(
      " " + i.indentLines(
        i.containerFlow(n, o.current()),
        ute
      )
    )), l(), a;
  }
}
function ute(e, t, n) {
  return t === 0 ? e : fte(e, t, n);
}
function fte(e, t, n) {
  return (n ? "" : "    ") + e;
}
function dte(e) {
  return {
    extensions: [
      ate(),
      cte(),
      Y9(),
      nH(),
      IS()
    ]
  };
}
const hte = (e) => {
  const t = [], n = (r, i, s) => {
    if (r.type === "text" && r.value && r.value.includes("import") && r.value.includes("from") && i && Array.isArray(i.children) && typeof s == "number") {
      i.children.splice(s, 1), t.push({
        type: "paragraph",
        children: [r]
      });
      return;
    }
    if (r.children && Array.isArray(r.children)) {
      const o = [...r.children];
      for (let a = 0; a < o.length; a++)
        n(o[a], r, a);
    }
  };
  return n(e, null, null), e.type === "root" && Array.isArray(e.children) && (e.children = [...t, ...e.children]), e;
}, kN = (e) => {
  const t = e.attributes.reduce((r, i) => (r[i.name] = i.value, r), {});
  return {
    type: "mdxJsxFlowElement",
    name: "Figure",
    attributes: [],
    children: [
      { ...e },
      {
        type: "mdxJsxFlowElement",
        name: "Caption",
        attributes: [
          { name: "attrAuthor", value: t.attrAuthor },
          { name: "attrUrl", value: t.attrUrl }
        ],
        children: [{ type: "text", value: t.caption }]
      }
    ]
  };
}, pte = (e) => {
  const t = [];
  for (const n of e.children)
    if (n.children.some(
      (r) => r.name === "Chart" || r.name === "Map"
    ))
      for (const r of n.children)
        (r.name === "Chart" || r.name === "Map") && t.push(kN(r));
    else
      t.push({
        type: "mdxJsxFlowElement",
        name: "Prose",
        attributes: [],
        children: [...n.children]
      });
  return t;
}, mte = (e) => {
  const t = [], n = (i) => ({
    type: "mdxJsxFlowElement",
    name: "Prose",
    children: [...i]
  }), r = (i) => {
    const s = [];
    let o = [];
    for (const a of i)
      if (a.type === "mdxJsxTextElement" || a.type === "mdxJsxFlowElement") {
        if (a.name === "Break")
          o.length > 0 && (s.push([n(o)]), o = []);
        else if (a.name === "Block" || a.name === "Chart" || a.name === "Map" || a.name === "TwoColumn") {
          if (s.push([n(o)]), a.name === "Chart" || a.name === "Map")
            s.push([kN(a)]);
          else if (a.name === "TwoColumn") {
            const l = pte(a);
            s.push(l);
          }
          o = [];
        }
      } else
        o.push(a);
    return o.length > 0 && s.push([...o]), s;
  };
  if (e.type === "root" && Array.isArray(e.children)) {
    const i = r(e.children);
    for (const s of i)
      s.some((o) => o.name === "Prose") ? t.push({
        type: "mdxJsxFlowElement",
        name: "Block",
        children: [...s]
      }) : t.push({
        type: "mdxJsxFlowElement",
        name: "Block",
        children: [
          {
            type: "mdxJsxFlowElement",
            name: "Prose",
            children: [...s]
          }
        ]
      });
  }
  return t;
}, gte = (e) => {
  if (!e || e.type !== "root" || !Array.isArray(e.children))
    return e;
  const t = [];
  for (const n of e.children)
    n.type === "paragraph" && n.children.length === 1 && n.children[0].type === "mdxJsxFlowElement" ? t.push(n.children[0]) : t.push(n);
  return { ...e, children: t };
}, vte = (e) => {
  const t = gte(e), n = mte(t);
  hte(t);
  const r = { ...t, children: n };
  return ((s) => qv(s, {
    extensions: [cx(), dte(), Hv()]
  }))(r);
};
function yte(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var TN = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var a = arguments[o];
        a && (s = i(s, r(a)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return n.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var o = "";
      for (var a in s)
        t.call(s, a) && s[a] && (o = i(o, a));
      return o;
    }
    function i(s, o) {
      return o ? s ? s + " " + o : s + o : s;
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(TN);
var xte = TN.exports;
const $t = /* @__PURE__ */ yte(xte), Dx = ({
  type: e,
  children: t,
  secondary: n,
  base: r,
  accentStyle: i,
  outline: s,
  inverse: o,
  size: a,
  unstyled: l,
  onClick: c,
  className: u,
  ...f
}) => {
  const d = $t(
    "usa-button",
    {
      "usa-button--secondary": n,
      "usa-button--base": r,
      "usa-button--accent-cool": i === "cool",
      "usa-button--accent-warm": i === "warm",
      "usa-button--outline": s,
      "usa-button--inverse": o,
      "usa-button--big": a === "big",
      "usa-button--unstyled": l
    },
    u
  );
  return /* @__PURE__ */ A(
    "button",
    {
      type: e,
      className: d,
      onClick: c,
      "data-testid": "button",
      ...f,
      children: t
    }
  );
}, wte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20.5 6c-2.61.7-5.67 1-8.5 1s-5.89-.3-8.5-1L3 8c1.86.5 4 .83 6 1v13h2v-6h2v6h2V9c2-.17 4.14-.5 6-1l-.5-2zM12 6c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z" })), _te = B(wte), bte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 17, cy: 4.54, r: 2 }), /* @__PURE__ */ w.createElement("path", { d: "M14 17h-2c0 1.65-1.35 3-3 3s-3-1.35-3-3 1.35-3 3-3v-2c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5zm3-3.5h-1.86l1.67-3.67C17.42 8.5 16.44 7 14.96 7h-5.2c-.81 0-1.54.47-1.87 1.2L7.22 10l1.92.53L9.79 9H12l-1.83 4.1c-.6 1.33.39 2.9 1.85 2.9H17v5h2v-5.5c0-1.1-.9-2-2-2z" })), Cte = B(bte), Ete = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M4 10h3v7H4zm6.5 0h3v7h-3zM2 19h20v3H2zm15-9h3v7h-3zm-5-9L2 6v2h20V6z" })), Ste = B(Ete), kte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm7 13H5v-.23c0-.62.28-1.2.76-1.58C7.47 15.82 9.64 15 12 15s4.53.82 6.24 2.19c.48.38.76.97.76 1.58V19z" })), Tte = B(kte), Ate = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88a9.947 9.947 0 0 1 12.28 0C16.43 19.18 14.03 20 12 20z" })), Nte = B(Ate), Ite = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" })), Lte = B(Ite), Mte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z" })), Ote = B(Mte), Pte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" })), Dte = B(Pte), Fte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m22 5.72-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39 6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9a9 9 0 0 0 0-18zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z" })), Rte = B(Fte), $te = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10h5v-2h-5c-4.34 0-8-3.66-8-8s3.66-8 8-8 8 3.66 8 8v1.43c0 .79-.71 1.57-1.5 1.57s-1.5-.78-1.5-1.57V12c0-2.76-2.24-5-5-5s-5 2.24-5 5 2.24 5 5 5c1.38 0 2.64-.56 3.54-1.47.65.89 1.77 1.47 2.96 1.47 1.97 0 3.5-1.6 3.5-3.57V12c0-5.52-4.48-10-10-10zm0 13c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z" })), Vte = B($te), Bte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z" })), zte = B(Bte), Hte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" })), Ute = B(Hte), jte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z" })), Wte = B(jte), Jte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m7 10 5 5 5-5z" })), Kte = B(Jte), qte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m7 14 5-5 5 5z" })), Gte = B(qte), Yte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z" })), Xte = B(Yte), Zte = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z" })), Qte = B(Zte), ene = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m14 12-2 2-2-2 2-2 2 2zm-2-6 2.12 2.12 2.5-2.5L12 1 7.38 5.62l2.5 2.5L12 6zm-6 6 2.12-2.12-2.5-2.5L1 12l4.62 4.62 2.5-2.5L6 12zm12 0-2.12 2.12 2.5 2.5L23 12l-4.62-4.62-2.5 2.5L18 12zm-6 6-2.12-2.12-2.5 2.5L12 23l4.62-4.62-2.5-2.5L12 18z" })), tne = B(ene), nne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z" })), rne = B(nne), ine = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z" })), sne = B(ine), one = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z" })), ane = B(one), lne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8A5.87 5.87 0 0 1 6 12c0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z" })), cne = B(lne), une = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 8v12c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V8c0-1.86 1.28-3.41 3-3.86V2h3v2h4V2h3v2.14c1.72.45 3 2 3 3.86zM6 12v2h10v2h2v-4H6z" })), fne = B(une), dne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 7, cy: 7, r: 2 }), /* @__PURE__ */ w.createElement("path", { d: "M20 13V4.83C20 3.27 18.73 2 17.17 2c-.75 0-1.47.3-2 .83l-1.25 1.25c-.16-.05-.33-.08-.51-.08-.4 0-.77.12-1.08.32l2.76 2.76c.2-.31.32-.68.32-1.08 0-.18-.03-.34-.07-.51l1.25-1.25a.828.828 0 0 1 1.41.59V13h-6.85c-.3-.21-.57-.45-.82-.72l-1.4-1.55c-.19-.21-.43-.38-.69-.5A2.251 2.251 0 0 0 5 12.25V13H2v6c0 1.1.9 2 2 2 0 .55.45 1 1 1h14c.55 0 1-.45 1-1 1.1 0 2-.9 2-2v-6h-2z" })), hne = B(dne), pne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 10.13a33.86 33.86 0 0 1-10 0 1.92 1.92 0 0 1-1.51-1.46 10.42 10.42 0 0 1 0-4.84 1.92 1.92 0 0 1 1.57-1.46 33.86 33.86 0 0 1 10 0 1.9 1.9 0 0 1 1.56 1.46 10.16 10.16 0 0 1 0 4.84A1.9 1.9 0 0 1 17 10.13Zm4 12.12H7a5.25 5.25 0 0 1 0-10.5h10a3.25 3.25 0 0 1 0 6.5H7a1.25 1.25 0 0 1 0-2.5h10a.75.75 0 0 0 0-1.5H7a2.75 2.75 0 0 0 0 5.5h14a1.25 1.25 0 0 1 0 2.5Z" })), mne = B(pne), gne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z" })), vne = B(gne), yne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 8h-2.81a5.985 5.985 0 0 0-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z" })), xne = B(yne), wne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z" })), _ne = B(wne), bne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 3h-1V1h-2v2H7V1H5v2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 18H4V8h16v13z" })), Cne = B(bne), Ene = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18 11v2h4v-2h-4zm-2 6.61c.96.71 2.21 1.65 3.2 2.39.4-.53.8-1.07 1.2-1.6-.99-.74-2.24-1.68-3.2-2.4-.4.54-.8 1.08-1.2 1.61zM20.4 5.6c-.4-.53-.8-1.07-1.2-1.6-.99.74-2.24 1.68-3.2 2.4.4.53.8 1.07 1.2 1.6.96-.72 2.21-1.65 3.2-2.4zM4 9c-1.1 0-2 .9-2 2v2c0 1.1.9 2 2 2h1v4h2v-4h1l5 3V6L8 9H4zm11.5 3c0-1.33-.58-2.53-1.5-3.35v6.69c.92-.81 1.5-2.01 1.5-3.34z" })), Sne = B(Ene), kne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { fillRule: "evenodd", d: "m12 5 8 13h2v2H2v-2h2l8-13zm.05 8-2.69 5h5.38l-2.69-5zM5.5 3l-.018.024A2.5 2.5 0 0 0 7.498 7 2.5 2.5 0 1 1 5.5 3z" })), Tne = B(kne), Ane = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z" })), Nne = B(Ane), Ine = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z" })), Lne = B(Ine), Mne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" })), One = B(Mne), Pne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" })), Dne = B(Pne), Fne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" })), Rne = B(Fne), $ne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16.59 7.58 10 14.17l-3.59-3.58L5 12l5 5 8-8zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" })), Vne = B($ne), Bne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21.6 18.2 13 11.75v-.91a3.496 3.496 0 0 0-.18-6.75A3.51 3.51 0 0 0 8.5 7.5h2c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5c0 .84-.69 1.52-1.53 1.5-.54-.01-.97.45-.97.99v1.76L2.4 18.2c-.77.58-.36 1.8.6 1.8h18c.96 0 1.37-1.22.6-1.8zM6 18l6-4.5 6 4.5H6z" })), zne = B(Bne), Hne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m16.99 5 .63 1.37 1.37.63-1.37.63L16.99 9l-.63-1.37L14.99 7l1.37-.63.63-1.37M11 6.13V4h2c.57 0 1.1.17 1.55.45l1.43-1.43A4.899 4.899 0 0 0 13 2H7.5v2H9v2.14A5.007 5.007 0 0 0 5.26 9.5h3.98L15 11.65v-.62a5 5 0 0 0-4-4.9zM1 22h4V11H1v11zm19-5h-7l-2.09-.73.33-.94L13 16h2.82c.65 0 1.18-.53 1.18-1.18 0-.49-.31-.93-.77-1.11L8.97 11H7v9.02L14 22l8-3c-.01-1.1-.89-2-2-2zm0-3c1.1 0 2-.9 2-2s-2-4-2-4-2 2.9-2 4 .9 2 2 2z" })), Une = B(Hne), jne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.7 2.37 15 2.3V4a3 3 0 0 1-6 0V2.3l-.7.07a7 7 0 0 0-6.3 7V20h3V10h1.5v12h11V10H19v10h3V9.33a7 7 0 0 0-6.3-6.96Z" })), Wne = B(jne), Jne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })), Kne = B(Jne), qne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 4H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 7H9.5v-.5h-2v3h2V13H11v1c0 .55-.45 1-1 1H7c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1zm7 0h-1.5v-.5h-2v3h2V13H18v1c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1z" })), Gne = B(qne), Yne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z" })), Xne = B(Yne), Zne = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z" })), Qne = B(Zne), ere = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z" })), tre = B(ere), nre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 14H9a9 9 0 0 1 9-9v2c-3.87 0-7 3.13-7 7zm7-3V9c-2.76 0-5 2.24-5 5h2c0-1.66 1.34-3 3-3zM7 4c0-1.11-.89-2-2-2s-2 .89-2 2 .89 2 2 2 2-.89 2-2zm4.45.5h-2A2.99 2.99 0 0 1 6.5 7h-3C2.67 7 2 7.67 2 8.5V11h6V8.74a4.97 4.97 0 0 0 3.45-4.24zM19 17c1.11 0 2-.89 2-2s-.89-2-2-2-2 .89-2 2 .89 2 2 2zm1.5 1h-3a2.99 2.99 0 0 1-2.95-2.5h-2A4.97 4.97 0 0 0 16 19.74V22h6v-2.5c0-.83-.67-1.5-1.5-1.5z" })), rre = B(nre), ire = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m13.783 15.172 2.121-2.121 5.996 5.996-2.121 2.121zM17.5 10c1.93 0 3.5-1.57 3.5-3.5 0-.58-.16-1.12-.41-1.6l-2.7 2.7-1.49-1.49 2.7-2.7c-.48-.25-1.02-.41-1.6-.41C15.57 3 14 4.57 14 6.5c0 .41.08.8.21 1.16l-1.85 1.85-1.78-1.78.71-.71-1.41-1.41L12 3.49a3 3 0 0 0-4.24 0L4.22 7.03l1.41 1.41H2.81l-.71.71 3.54 3.54.71-.71V9.15l1.41 1.41.71-.71 1.78 1.78-7.41 7.41 2.12 2.12L16.34 9.79c.36.13.75.21 1.16.21z" })), sre = B(ire), ore = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 10.5, cy: 4.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M19.59 16h-1.27l-.64.71h-1.27L15.14 21h1.27l.64-.71h1.9l.64.71h1.27l-1.27-5zm-5.21-3.28L14 14.19l-3.8-1.26-.1-.16.52-3.13c.93 1.37 2.15 2.11 4.6 2.11v-1.5c-2.44 0-3.09-.77-3.9-2.39a2.65 2.65 0 0 0-3-1.59L3.75 7.41v3.38l-1.51-.5-.48 1.42 4.35 1.45L5 20.86l2 .28 1-7.34.38.13L10 16.3V21h2v-5.3l-.49-.7 2 .67-.37 1.27 1.91.57 1.24-4.19Zm-9.13-1.43v-2.7l1.57-.4-.49 3.46Z" })), are = B(ore), lre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm-2 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8H8v-.57c0-.81.48-1.53 1.22-1.85a6.95 6.95 0 0 1 5.56 0A2.01 2.01 0 0 1 16 17.43V18z" })), cre = B(lre), ure = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" })), fre = B(ure), dre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21.25 10.5c-.41 0-.75.34-.75.75h-1.54a6.978 6.978 0 0 0-1.52-3.65l1.09-1.09.01.01c.29.29.77.29 1.06 0s.29-.77 0-1.06L18.54 4.4a.754.754 0 0 0-1.06 0c-.29.29-.29.76-.01 1.05l-1.09 1.09a7.015 7.015 0 0 0-3.64-1.51V3.5h.01c.41 0 .75-.34.75-.75S13.16 2 12.75 2h-1.5c-.41 0-.75.34-.75.75s.33.74.74.75v1.55c-1.37.14-2.62.69-3.64 1.51L6.51 5.47l.01-.01c.29-.29.29-.77 0-1.06a.754.754 0 0 0-1.06 0L4.4 5.46c-.29.29-.29.77 0 1.06.29.29.76.29 1.05.01l1.09 1.09a6.89 6.89 0 0 0-1.5 3.63H3.5c0-.41-.34-.75-.75-.75s-.75.34-.75.75v1.5c0 .41.34.75.75.75s.75-.34.75-.75h1.54c.15 1.37.69 2.61 1.5 3.63l-1.09 1.09a.742.742 0 0 0-1.05.01c-.29.29-.29.77 0 1.06l1.06 1.06c.29.29.77.29 1.06 0 .29-.29.29-.77 0-1.06l-.01-.01 1.09-1.09c1.02.82 2.26 1.36 3.63 1.51v1.55c-.41.01-.74.34-.74.75s.34.75.75.75h1.5c.41 0 .75-.34.75-.75s-.34-.75-.75-.75h-.01v-1.54c1.37-.14 2.62-.69 3.64-1.51l1.09 1.09c-.29.29-.28.76.01 1.05.29.29.77.29 1.06 0l1.06-1.06c.29-.29.29-.77 0-1.06a.754.754 0 0 0-1.06 0l-.01.01-1.09-1.09a7.025 7.025 0 0 0 1.52-3.65h1.54c0 .41.34.75.75.75s.75-.34.75-.75v-1.5c.01-.4-.33-.74-.74-.74zM13.75 8c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM12 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1.75-5c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM8.5 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm1.75 3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3.5 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm.75-4c0-.55.45-1 1-1s1 .45 1 1-.45 1-1 1-1-.45-1-1z" })), hre = B(dre), pre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z" })), mre = B(pre), gre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M22 9 12 2 2 9h9v13h2V9z" }), /* @__PURE__ */ w.createElement("path", { d: "m4.14 12-1.96.37.82 4.37V22h2l.02-4H7v4h2v-6H4.9zm14.96 4H15v6h2v-4h1.98l.02 4h2v-5.26l.82-4.37-1.96-.37z" })), vre = B(gre), yre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" })), xre = B(yre), wre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15 13V5c0-1.66-1.34-3-3-3S9 3.34 9 5v8c-1.21.91-2 2.37-2 4 0 2.76 2.24 5 5 5s5-2.24 5-5c0-1.63-.79-3.09-2-4zm-4-8c0-.55.45-1 1-1s1 .45 1 1h-1v1h1v2h-1v1h1v2h-2V5z" })), _re = B(wre), bre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m21.41 10.59-7.99-8c-.78-.78-2.05-.78-2.83 0l-8.01 8c-.78.78-.78 2.05 0 2.83l8.01 8c.78.78 2.05.78 2.83 0l7.99-8c.79-.79.79-2.05 0-2.83zM13.5 14.5V12H10v3H8v-4c0-.55.45-1 1-1h4.5V7.5L17 11l-3.5 3.5z" })), Cre = B(bre), Ere = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM5 12c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 8.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5zm5.8-10 2.4-2.4.8.8c1.3 1.3 3 2.1 5.1 2.1V9c-1.5 0-2.7-.6-3.6-1.5l-1.9-1.9c-.5-.4-1-.6-1.6-.6s-1.1.2-1.4.6L7.8 8.4c-.4.4-.6.9-.6 1.4 0 .6.2 1.1.6 1.4L11 14v5h2v-6.2l-2.2-2.3zM19 12c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 8.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5z" })), Sre = B(Ere), kre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M4 16c0 .88.39 1.67 1 2.22V20c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h8v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.78c.61-.55 1-1.34 1-2.22V6c0-3.5-3.58-4-8-4s-8 .5-8 4v10zm3.5 1c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm9 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6H6V6h12v5z" })), Tre = B(kre), Are = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z" })), Nre = B(Are), Ire = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M13.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM9.8 8.9 7 23h2.1l1.8-8 2.1 2v6h2v-7.5l-2.1-2 .6-3C14.8 12 16.8 13 19 13v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1L6 8.3V13h2V9.6l1.8-.7" })), Lre = B(Ire), Mre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31A7.902 7.902 0 0 1 12 20zm6.31-3.1L7.1 5.69A7.902 7.902 0 0 1 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z" })), Ore = B(Mre), Pre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m13 10.17-2.5-2.5V2.25a1.25 1.25 0 0 1 2.5 0v7.92zm7 2.58v-7.5a1.25 1.25 0 0 0-2.5 0V11h-1V3.25a1.25 1.25 0 0 0-2.5 0v7.92l6 6v-4.42zM9.5 4.25C9.5 3.56 8.94 3 8.25 3c-.67 0-1.2.53-1.24 1.18L9.5 6.67V4.25zm3.5 5.92-2.5-2.5V2.25a1.25 1.25 0 0 1 2.5 0v7.92zm7 2.58v-7.5a1.25 1.25 0 0 0-2.5 0V11h-1V3.25a1.25 1.25 0 0 0-2.5 0v7.92l6 6v-4.42zM9.5 4.25C9.5 3.56 8.94 3 8.25 3c-.67 0-1.2.53-1.24 1.18L9.5 6.67V4.25zm11.69 16.94L2.81 2.81 1.39 4.22l5.63 5.63L7 9.83v4.3c-1.11-.64-2.58-1.47-2.6-1.48-.17-.09-.34-.14-.54-.14-.26 0-.5.09-.7.26-.04.01-1.16 1.11-1.16 1.11l6.8 7.18c.57.6 1.35.94 2.18.94H17c.62 0 1.18-.19 1.65-.52l-.02-.02 1.15 1.15 1.41-1.42z" })), Dre = B(Pre), Fre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 9H4v2h16V9zM4 15h16v-2H4v2z" })), Rre = B(Fre), $re = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }), /* @__PURE__ */ w.createElement("path", { d: "M6.05 8.05a7.001 7.001 0 0 0-.02 9.88c1.47-3.4 4.09-6.24 7.36-7.93A15.952 15.952 0 0 0 8 19.32c2.6 1.23 5.8.78 7.95-1.37C19.43 14.47 20 4 20 4S9.53 4.57 6.05 8.05z" })), Vre = B($re), Bre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" })), zre = B(Bre), Hre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 14c0-.55-.45-1-1-1h-2v2h2c.55 0 1-.45 1-1zm-1 3h-2v2h2c.55 0 1-.45 1-1s-.45-1-1-1zm-8-3h-2v4h2c0 1.1.9 2 2 2h3v-8h-3c-1.1 0-2 .9-2 2z" }), /* @__PURE__ */ w.createElement("path", { d: "M5 13c0-1.1.9-2 2-2h1.5c1.93 0 3.5-1.57 3.5-3.5S10.43 4 8.5 4H5c-.55 0-1 .45-1 1s.45 1 1 1h3.5c.83 0 1.5.67 1.5 1.5S9.33 9 8.5 9H7c-2.21 0-4 1.79-4 4s1.79 4 4 4h2v-2H7c-1.1 0-2-.9-2-2z" })), Ure = B(Hre), jre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94A5.01 5.01 0 0 0 11 15.9V19H7v2h10v-2h-4v-3.1a5.01 5.01 0 0 0 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z" })), Wre = B(jre), Jre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z" })), Kre = B(Jre), qre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" })), Gre = B(qre), Yre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z" })), Xre = B(Yre), Zre = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" })), Qre = B(Zre), eie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z" })), tie = B(eie), nie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }), /* @__PURE__ */ w.createElement("path", { d: "M22 12c0-5.52-4.48-10-10-10S2 6.48 2 12c0 4.84 3.44 8.87 8 9.8V15H8v-3h2V9.5C10 7.57 11.57 6 13.5 6H16v3h-2c-.55 0-1 .45-1 1v2h3v3h-3v6.95c5.05-.5 9-4.76 9-9.95z" })), rie = B(nie), iie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m4 18 8.5-6L4 6v12zm9-12v12l8.5-6L13 6z" })), sie = B(iie), oie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 18V6l-8.5 6 8.5 6zm.5-6 8.5 6V6l-8.5 6z" })), aie = B(oie), lie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m12 21.35-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" })), cie = B(lie), uie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z" })), fie = B(uie), die = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 9h-1V4H8v16h14v-8c0-1.66-1.34-3-3-3zm-9-3h6v3h-6V6zm4 11h-4v-5h4v5zm2 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3 3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM4.5 8A2.5 2.5 0 0 0 2 10.5v8a2.5 2.5 0 0 0 5 0v-8A2.5 2.5 0 0 0 4.5 8z" })), hie = B(die), pie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" })), mie = B(pie), gie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V7l-5-5zM6 20V4h8v4h4v12H6zm10-10v5c0 2.21-1.79 4-4 4s-4-1.79-4-4V8.5a2.5 2.5 0 0 1 2.76-2.49c1.3.13 2.24 1.32 2.24 2.63V15h-2V8.5c0-.28-.22-.5-.5-.5s-.5.22-.5.5V15c0 1.1.9 2 2 2s2-.9 2-2v-5h2z" })), vie = B(gie), yie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z" })), xie = B(yie), wie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39A.998.998 0 0 0 18.95 4H5.04c-.83 0-1.3.95-.79 1.61z" })), _ie = B(wie), bie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z" })), Cie = B(bie), Eie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17.81 4.47c-.08 0-.16-.02-.23-.06C15.66 3.42 14 3 12.01 3c-1.98 0-3.86.47-5.57 1.41-.24.13-.54.04-.68-.2a.506.506 0 0 1 .2-.68C7.82 2.52 9.86 2 12.01 2c2.13 0 3.99.47 6.03 1.52.25.13.34.43.21.67a.49.49 0 0 1-.44.28zM3.5 9.72a.499.499 0 0 1-.41-.79c.99-1.4 2.25-2.5 3.75-3.27C9.98 4.04 14 4.03 17.15 5.65c1.5.77 2.76 1.86 3.75 3.25a.5.5 0 0 1-.12.7c-.23.16-.54.11-.7-.12a9.388 9.388 0 0 0-3.39-2.94c-2.87-1.47-6.54-1.47-9.4.01-1.36.7-2.5 1.7-3.4 2.96-.08.14-.23.21-.39.21zm6.25 12.07a.47.47 0 0 1-.35-.15c-.87-.87-1.34-1.43-2.01-2.64-.69-1.23-1.05-2.73-1.05-4.34 0-2.97 2.54-5.39 5.66-5.39s5.66 2.42 5.66 5.39c0 .28-.22.5-.5.5s-.5-.22-.5-.5c0-2.42-2.09-4.39-4.66-4.39-2.57 0-4.66 1.97-4.66 4.39 0 1.44.32 2.77.93 3.85.64 1.15 1.08 1.64 1.85 2.42.19.2.19.51 0 .71-.11.1-.24.15-.37.15zm7.17-1.85c-1.19 0-2.24-.3-3.1-.89-1.49-1.01-2.38-2.65-2.38-4.39 0-.28.22-.5.5-.5s.5.22.5.5c0 1.41.72 2.74 1.94 3.56.71.48 1.54.71 2.54.71.24 0 .64-.03 1.04-.1.27-.05.53.13.58.41.05.27-.13.53-.41.58-.57.11-1.07.12-1.21.12zM14.91 22c-.04 0-.09-.01-.13-.02-1.59-.44-2.63-1.03-3.72-2.1a7.297 7.297 0 0 1-2.17-5.22c0-1.62 1.38-2.94 3.08-2.94 1.7 0 3.08 1.32 3.08 2.94 0 1.07.93 1.94 2.08 1.94s2.08-.87 2.08-1.94c0-3.77-3.25-6.83-7.25-6.83-2.84 0-5.44 1.58-6.61 4.03-.39.81-.59 1.76-.59 2.8 0 .78.07 2.01.67 3.61.1.26-.03.55-.29.64-.26.1-.55-.04-.64-.29a11.14 11.14 0 0 1-.73-3.96c0-1.2.23-2.29.68-3.24 1.33-2.79 4.28-4.6 7.51-4.6 4.55 0 8.25 3.51 8.25 7.83 0 1.62-1.38 2.94-3.08 2.94s-3.08-1.32-3.08-2.94c0-1.07-.93-1.94-2.08-1.94s-2.08.87-2.08 1.94c0 1.71.66 3.31 1.87 4.51.95.94 1.86 1.46 3.27 1.85.27.07.42.35.35.61-.05.23-.26.38-.47.38z" })), Sie = B(Eie), kie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18.41 16.59 13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z" })), Tie = B(kie), Aie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M14.4 6 14 4H5v17h2v-7h5.6l.4 2h7V6z" })), Nie = B(Aie), Iie = (e) => /* @__PURE__ */ w.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M6.459 17a4.444 4.444 0 0 1-4.116-2.768 4.541 4.541 0 0 1 .954-4.909 4.405 4.405 0 0 1 4.845-.982 4.5 4.5 0 0 1 2.747 4.159 4.514 4.514 0 0 1-1.292 3.181A4.403 4.403 0 0 1 6.459 17Zm11.111 0a4.444 4.444 0 0 1-4.116-2.768 4.541 4.541 0 0 1 .954-4.909 4.405 4.405 0 0 1 4.845-.982A4.5 4.5 0 0 1 22 12.5a4.514 4.514 0 0 1-1.292 3.181A4.403 4.403 0 0 1 17.57 17Z" })), Lie = B(Iie), Mie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z" })), Oie = B(Mie), Pie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 18.16a6 6 0 0 0-2.95.8 4.08 4.08 0 0 1-2.05.6 3.81 3.81 0 0 1-2-.56 5.84 5.84 0 0 0-5.9 0 4.05 4.05 0 0 1-2 .6v2a6 6 0 0 0 3-.8 4.05 4.05 0 0 1 1.9-.69 3.87 3.87 0 0 1 2.05.6 5.84 5.84 0 0 0 5.9 0 4.08 4.08 0 0 1 2.05-.6 3.81 3.81 0 0 1 2.05.6 5.9 5.9 0 0 0 2.95.8v-2a3.81 3.81 0 0 1-2-.51 6 6 0 0 0-3-.84Zm3-3.65a6.8 6.8 0 0 0-2-.71V10h3l-9-7-9 7h3v3.8a6.8 6.8 0 0 0-1.95.71 4.15 4.15 0 0 1-2 .6v1.95a6.07 6.07 0 0 0 3-.8 3.8 3.8 0 0 1 4.1 0 5.87 5.87 0 0 0 2.95.8 6 6 0 0 0 2.95-.8 3.8 3.8 0 0 1 4.1 0 5.9 5.9 0 0 0 2.95.8v-1.95a3.81 3.81 0 0 1-2.1-.6Zm-9.95 0V11h4v3.54a4.19 4.19 0 0 1-2 .57 3.8 3.8 0 0 1-2.05-.57Z" })), Die = B(Pie), Fie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z" })), Rie = B(Fie), $ie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z" })), Vie = B($ie), Bie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z" })), zie = B(Bie), Hie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z" })), Uie = B(Hie), jie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z" })), Wie = B(jie), Jie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2a10 10 0 0 0-3.16 19.49c.5.09.68-.22.68-.48v-1.7C6.73 19.91 6.14 18 6.14 18A2.69 2.69 0 0 0 5 16.5c-.91-.62.07-.61.07-.61a2.13 2.13 0 0 1 1.53 1 2.14 2.14 0 0 0 2.91.83 2.16 2.16 0 0 1 .63-1.34c-2.14-.21-4.52-1.07-4.52-4.9a3.89 3.89 0 0 1 1-2.69 3.57 3.57 0 0 1 .1-2.64s.84-.27 2.75 1a9.63 9.63 0 0 1 5 0c1.91-1.29 2.75-1 2.75-1a3.57 3.57 0 0 1 .1 2.64 3.89 3.89 0 0 1 1 2.69c0 3.84-2.34 4.68-4.57 4.93a2.39 2.39 0 0 1 .68 1.85v2.75c0 .33.18.58.69.48A10 10 0 0 0 12 2Z", fillRule: "evenodd" })), Kie = B(Jie), qie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { fillRule: "evenodd", d: "M3 3v8h8V3H3zm6 6H5V5h4v4zm-6 4v8h8v-8H3zm6 6H5v-4h4v4zm4-16v8h8V3h-8zm6 6h-4V5h4v4zm-6 4v8h8v-8h-8zm6 6h-4v-4h4v4z" })), Gie = B(qie), Yie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M22 9V7h-2v2h-2v2h2v2h2v-2h2V9zM8 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 1c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4zm4.51-8.95C13.43 5.11 14 6.49 14 8s-.57 2.89-1.49 3.95C14.47 11.7 16 10.04 16 8s-1.53-3.7-3.49-3.95zm4.02 9.78C17.42 14.66 18 15.7 18 17v3h2v-3c0-1.45-1.59-2.51-3.47-3.17z" })), Xie = B(Yie), Zie = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 12.75c1.63 0 3.07.39 4.24.9 1.08.48 1.76 1.56 1.76 2.73V18H6v-1.61c0-1.18.68-2.26 1.76-2.73 1.17-.52 2.61-.91 4.24-.91zM4 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm1.13 1.1c-.37-.06-.74-.1-1.13-.1-.99 0-1.93.21-2.78.58A2.01 2.01 0 0 0 0 16.43V18h4.5v-1.61c0-.83.23-1.61.63-2.29zM20 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm4 3.43c0-.81-.48-1.53-1.22-1.85A6.95 6.95 0 0 0 20 14c-.39 0-.76.04-1.13.1.4.68.63 1.46.63 2.29V18H24v-1.57zM12 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z" })), Qie = B(Zie), ese = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 20c-.29 0-.56-.06-.76-.15-.71-.37-1.21-.88-1.71-2.38-.51-1.56-1.47-2.29-2.39-3-.79-.61-1.61-1.24-2.32-2.53C9.29 10.98 9 9.93 9 9c0-2.8 2.2-5 5-5s5 2.2 5 5h2c0-3.93-3.07-7-7-7S7 5.07 7 9c0 1.26.38 2.65 1.07 3.9.91 1.65 1.98 2.48 2.85 3.15.81.62 1.39 1.07 1.71 2.05.6 1.82 1.37 2.84 2.73 3.55A3.999 3.999 0 0 0 21 18h-2c0 1.1-.9 2-2 2zM7.64 2.64 6.22 1.22C4.23 3.21 3 5.96 3 9s1.23 5.79 3.22 7.78l1.41-1.41C6.01 13.74 5 11.49 5 9s1.01-4.74 2.64-6.36zM11.5 9a2.5 2.5 0 0 0 5 0 2.5 2.5 0 0 0-5 0z" })), tse = B(ese), nse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z" })), rse = B(nse), ise = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z" })), sse = B(ise), ose = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M14.59 8 12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" })), ase = B(ose), lse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z" })), cse = B(lse), use = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" })), fse = B(use), dse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2Zm-3 14h-2v-4h-4v4H8V7h2v4h4V7h2Z" })), hse = B(dse), pse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M7 13c1.66 0 3-1.34 3-3S8.66 7 7 7s-3 1.34-3 3 1.34 3 3 3zm12-6h-8v7H3V5H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4z" })), mse = B(pse), gse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6zm10 14.5V20H8v-3.5l4-4 4 4zm-4-5-4-4V4h8v3.5l-4 4z" })), vse = B(gse), yse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 12a7 7 0 0 0-6.34-7 27.32 27.32 0 0 1 2.21-2.09.44.44 0 0 0-.29-.78 10.62 10.62 0 0 0-9.17 7.5 4.26 4.26 0 0 0-.15.47v.06A7.18 7.18 0 0 0 5 12a7 7 0 0 0 6.35 7 27.71 27.71 0 0 1-2.21 2.1.44.44 0 0 0 .29.78 10.65 10.65 0 0 0 9.23-7.69v-.14c0-.05.05-.13.07-.2A6.76 6.76 0 0 0 19 12Zm-7 3.5a3.5 3.5 0 1 1 3.5-3.5 3.5 3.5 0 0 1-3.5 3.5Z" })), xse = B(yse), wse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 14.14C11 13.38 9.33 13 8.5 13S6 13.38 6 14.14V15h5Z" }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 10.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M20 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2Zm-7 13H4V7h9Zm7 0h-5v-2h5Zm0-4h-5v-2h5Zm0-4h-5V7h5Z" })), _se = B(wse), bse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" })), Cse = B(bse), Ese = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" })), Sse = B(Ese), kse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M0 0h24v24H0V0z", fill: "none" }), /* @__PURE__ */ w.createElement("path", { d: "M11 7h2v2h-2V7zm0 4h2v6h-2v-6zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" })), Tse = B(kse), Ase = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 8c-1.45 0-2.26 1.44-1.93 2.51l-3.55 3.56c-.3-.09-.74-.09-1.04 0l-2.55-2.55C12.27 10.45 11.46 9 10 9c-1.45 0-2.27 1.44-1.93 2.52l-4.56 4.55C2.44 15.74 1 16.55 1 18c0 1.1.9 2 2 2 1.45 0 2.26-1.44 1.93-2.51l4.55-4.56c.3.09.74.09 1.04 0l2.55 2.55C12.73 16.55 13.54 18 15 18c1.45 0 2.27-1.44 1.93-2.52l3.56-3.55c1.07.33 2.51-.48 2.51-1.93 0-1.1-.9-2-2-2z" }), /* @__PURE__ */ w.createElement("path", { d: "m15 9 .94-2.07L18 6l-2.06-.93L15 3l-.92 2.07L12 6l2.08.93zM3.5 11 4 9l2-.5L4 8l-.5-2L3 8l-2 .5L3 9z" })), Nse = B(Ase), Ise = (e) => /* @__PURE__ */ w.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M8.273 3.063c-.958.045-1.612.198-2.184.423a4.41 4.41 0 0 0-1.592 1.04 4.409 4.409 0 0 0-1.035 1.596c-.222.572-.372 1.227-.414 2.185-.042.958-.052 1.266-.047 3.71.005 2.444.016 2.75.062 3.71.046.958.198 1.612.423 2.184a4.41 4.41 0 0 0 1.04 1.592 4.4 4.4 0 0 0 1.597 1.035c.572.221 1.227.372 2.185.414.958.042 1.266.052 3.71.047 2.443-.005 2.75-.016 3.71-.061.96-.046 1.611-.199 2.183-.423a4.411 4.411 0 0 0 1.592-1.04 4.41 4.41 0 0 0 1.035-1.597c.222-.572.372-1.227.414-2.184.042-.96.052-1.268.047-3.711-.005-2.444-.016-2.75-.061-3.71-.046-.96-.198-1.612-.423-2.184a4.418 4.418 0 0 0-1.04-1.592 4.4 4.4 0 0 0-1.597-1.035c-.572-.221-1.227-.372-2.185-.414-.958-.041-1.266-.052-3.71-.047-2.444.005-2.75.015-3.71.062m.105 16.27c-.878-.038-1.354-.184-1.672-.306a2.802 2.802 0 0 1-1.036-.671 2.772 2.772 0 0 1-.675-1.034c-.124-.317-.272-.793-.313-1.67-.045-.95-.054-1.234-.06-3.637-.004-2.403.005-2.687.046-3.636.038-.877.184-1.354.306-1.671.162-.421.357-.72.672-1.036a2.778 2.778 0 0 1 1.033-.675c.317-.124.793-.272 1.67-.313.95-.045 1.234-.054 3.637-.06 2.402-.005 2.687.004 3.637.046.876.038 1.354.183 1.67.306.421.162.72.357 1.037.671.316.315.511.613.675 1.034.124.317.271.792.313 1.67.045.95.055 1.234.06 3.636.004 2.402-.004 2.688-.046 3.636-.038.878-.184 1.354-.306 1.672a2.79 2.79 0 0 1-.672 1.036 2.78 2.78 0 0 1-1.033.675c-.317.124-.794.271-1.67.313-.95.045-1.234.054-3.637.06-2.403.005-2.687-.005-3.636-.046M15.715 7.19a1.08 1.08 0 1 0 2.16-.004 1.08 1.08 0 0 0-2.16.004m-8.336 4.819a4.62 4.62 0 1 0 9.242-.018 4.62 4.62 0 0 0-9.242.018M9 12.006a3 3 0 1 1 6-.012 3 3 0 0 1-6 .012" })), Lse = B(Ise), Mse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z" })), Ose = B(Mse), Pse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z" })), Dse = B(Pse), Fse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95a15.65 15.65 0 0 0-1.38-3.56A8.03 8.03 0 0 1 18.92 8zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56A7.987 7.987 0 0 1 5.08 16zm2.95-8H5.08a7.987 7.987 0 0 1 4.33-3.56A15.65 15.65 0 0 0 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95a8.03 8.03 0 0 1-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z" })), Rse = B(Fse), $se = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M5.59 7.41 10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z" })), Vse = B($se), Bse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 19H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z" })), zse = B(Bse), Hse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9 21c0 .5.4 1 1 1h4c.6 0 1-.5 1-1v-1H9v1zm3-19C8.1 2 5 5.1 5 9c0 2.4 1.2 4.5 3 5.7V17c0 .5.4 1 1 1h6c.6 0 1-.5 1-1v-2.3c1.8-1.3 3-3.4 3-5.7 0-3.9-3.1-7-7-7z" })), Use = B(Hse), jse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }), /* @__PURE__ */ w.createElement("path", { d: "M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2 11.7V16h-4v-2.3C8.48 12.63 7 11.53 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 2.49-1.51 3.65-3 4.7z" })), Wse = B(jse), Jse = (e) => /* @__PURE__ */ w.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.667 3A1.322 1.322 0 0 1 21 4.298V19.7a1.323 1.323 0 0 1-1.333 1.3H4.328A1.32 1.32 0 0 1 3 19.701V4.3A1.32 1.32 0 0 1 4.328 3h15.339Zm-4.898 6.1a2.834 2.834 0 0 0-2.55 1.403h-.036V9.316H9.6V18h2.692v-4.296c0-1.133.214-2.23 1.616-2.23 1.382 0 1.4 1.296 1.4 2.303V18H18v-4.764c0-2.338-.503-4.136-3.231-4.136Zm-6.86.216H5.213V18h2.694V9.316ZM6.561 5A1.57 1.57 0 0 0 5 6.565a1.57 1.57 0 0 0 1.562 1.564l.142-.006a1.572 1.572 0 0 0 1.42-1.558l-.006-.142A1.572 1.572 0 0 0 6.562 5Z" })), Kse = B(Jse), qse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z" })), Gse = B(qse), Yse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11A4.991 4.991 0 0 0 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z" })), Xse = B(Yse), Zse = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z" })), Qse = B(Zse), eoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2a2 2 0 0 0 2-2V5c0-1.11-.89-2-2-2zm0 5h-2V5h2v3zM4 19h16v2H4z" })), toe = B(eoe), noe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m12 12.9-2.13 2.09c-.56.56-.87 1.29-.87 2.07C9 18.68 10.35 20 12 20s3-1.32 3-2.94c0-.78-.31-1.52-.87-2.07L12 12.9z" }), /* @__PURE__ */ w.createElement("path", { d: "m16 6-.44.55C14.38 8.02 12 7.19 12 5.3V2S4 6 4 13c0 2.92 1.56 5.47 3.89 6.86-.56-.79-.89-1.76-.89-2.8 0-1.32.52-2.56 1.47-3.5L12 10.1l3.53 3.47c.95.93 1.47 2.17 1.47 3.5 0 1.02-.31 1.96-.85 2.75 1.89-1.15 3.29-3.06 3.71-5.3.66-3.55-1.07-6.9-3.86-8.52z" })), roe = B(noe), ioe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m19.77 7.23.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33a2.5 2.5 0 0 0 2.5 2.5c.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5a2.5 2.5 0 0 0 5 0V9c0-.69-.28-1.32-.73-1.77zM12 10H6V5h6v5zm6 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z" })), soe = B(ioe), ooe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49A1.003 1.003 0 0 0 20 4H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z" })), aoe = B(ooe), loe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4v4z" })), coe = B(loe), uoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9.17 16.83a4.008 4.008 0 0 0 5.66 0 4.008 4.008 0 0 0 0-5.66l-5.66 5.66zM18 2.01 6 2c-1.11 0-2 .89-2 2v16c0 1.11.89 2 2 2h12c1.11 0 2-.89 2-2V4c0-1.11-.89-1.99-2-1.99zM10 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM7 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm5 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z" })), foe = B(uoe), doe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z" })), hoe = B(doe), poe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z" })), moe = B(poe), goe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M13 3H6v18h4v-6h3c3.31 0 6-2.69 6-6s-2.69-6-6-6zm.2 8H10V7h3.2c1.1 0 2 .9 2 2s-.9 2-2 2z" })), voe = B(goe), yoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 5h-2.64l1.14-3.14L17.15 1l-1.46 4H3v2l2 6-2 6v2h18v-2l-2-6 2-6V5zm-5 9h-3v3h-2v-3H8v-2h3V9h2v3h3v2z" })), xoe = B(yoe), woe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm2.5 11.59.9 3.88-3.4-2.05-3.4 2.05.9-3.87-3-2.59 3.96-.34L12 6.02l1.54 3.64 3.96.34-3 2.59z" })), _oe = B(woe), boe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18.92 6.01C18.72 5.42 18.16 5 17.5 5H15V3H9v2H6.5c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z" })), Coe = B(boe), Eoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15 11V5l-3-3-3 3v2H3v14h18V11h-6zm-8 8H5v-2h2v2zm0-4H5v-2h2v2zm0-4H5V9h2v2zm6 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V9h2v2zm0-4h-2V5h2v2zm6 12h-2v-2h2v2zm0-4h-2v-2h2v2z" })), Soe = B(Eoe), koe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5a2.5 2.5 0 0 1 0-5 2.5 2.5 0 0 1 0 5z" })), Toe = B(koe), Aoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z" })), Noe = B(Aoe), Ioe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z" })), Loe = B(Ioe), Moe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }), /* @__PURE__ */ w.createElement("path", { d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H8.9V6zM18 20H6V10h12v10z" })), Ooe = B(Moe), Poe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 7 9.6 8.4l2.6 2.6H2v2h10.2l-2.6 2.6L11 17l5-5-5-5zm9 12h-8v2h8c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-8v2h8v14z" })), Doe = B(Poe), Foe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m17 7-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z" })), Roe = B(Foe), $oe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46A7.93 7.93 0 0 0 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74A7.93 7.93 0 0 0 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z" })), Voe = B($oe), Boe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z" })), zoe = B(Boe), Hoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V8l8 5 8-5v10zm-8-7L4 6h16l-8 5z" })), Uoe = B(Hoe), joe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m20.5 3-.16.03L15 5.1 9 3 3.36 4.9c-.21.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.21-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5zM15 19l-6-2.11V5l6 2.11V19z" })), Woe = B(joe), Joe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.5 6c-1.31 0-2.37 1.01-2.48 2.3-1.88-.5-2.84-1.8-5.02-1.8-2.19 0-3.14 1.3-5.02 1.8C6.87 7.02 5.81 6 4.5 6A2.5 2.5 0 0 0 2 8.5V9c0 6 3.6 7.81 6.52 7.98C9.53 17.62 10.72 18 12 18s2.47-.38 3.48-1.02C18.4 16.81 22 15 22 9v-.5A2.5 2.5 0 0 0 19.5 6zm-16 3v-.5c0-.55.45-1 1-1s1 .45 1 1v3c0 1.28.38 2.47 1.01 3.48C4.99 14.27 3.5 12.65 3.5 9zm17 0c0 3.65-1.49 5.27-3.01 5.98.64-1.01 1.01-2.2 1.01-3.48v-3c0-.55.45-1 1-1s1 .45 1 1V9zm-9.81 1.48c-.44.26-.96.56-1.69.76V10.2c.48-.17.84-.38 1.18-.58C10.72 9.3 11.23 9 12 9s1.27.3 1.8.62c.34.2.71.42 1.2.59v1.04c-.75-.21-1.26-.51-1.71-.78-.46-.27-.8-.47-1.29-.47s-.84.2-1.31.48z" })), Koe = B(Joe), qoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 6h-4V4c0-1.1-.9-2-2-2h-4c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM10 4h4v2h-4V4zm6 11h-3v3h-2v-3H8v-2h3v-3h2v3h3v2z" })), Goe = B(qoe), Yoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" })), Xoe = B(Yoe), Zoe = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 10.43V2H7v8.43c0 .35.18.68.49.86l4.18 2.51-.99 2.34-3.41.29 2.59 2.24L9.07 22 12 20.23 14.93 22l-.78-3.33 2.59-2.24-3.41-.29-.99-2.34 4.18-2.51c.3-.18.48-.5.48-.86zm-4 1.8-1 .6-1-.6V3h2v9.23z" })), Qoe = B(Zoe), eae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })), tae = B(eae), nae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })), rae = B(nae), iae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3A8.994 8.994 0 0 0 13 3.06V1h-2v2.06A8.994 8.994 0 0 0 3.06 11H1v2h2.06A8.994 8.994 0 0 0 11 20.94V23h2v-2.06A8.994 8.994 0 0 0 20.94 13H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z" })), sae = B(iae), oae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z" })), aae = B(oae), lae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" })), cae = B(lae), uae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11.41 7.41 10 6l-6 6 6 6 1.41-1.41L6.83 12zm8 0L18 6l-6 6 6 6 1.41-1.41L14.83 12z" })), fae = B(uae), dae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m14 6-1.41 1.41L17.17 12l-4.58 4.59L14 18l6-6zM6 6 4.59 7.41 9.17 12l-4.58 4.59L6 18l6-6z" })), hae = B(dae), pae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 3 3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z" })), mae = B(pae), gae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 22c1.1 0 2-.9 2-2h-4a2 2 0 0 0 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z" })), vae = B(gae), yae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M7.58 4.08 6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2a8.445 8.445 0 0 1 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43a8.495 8.495 0 0 1 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z" })), xae = B(yae), wae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z" })), _ae = B(wae), bae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 18.69 7.84 6.14 5.27 3.49 4 4.76l2.8 2.8v.01c-.52.99-.8 2.16-.8 3.42v5l-2 2v1h13.73l2 2L21 19.72l-1-1.03zM12 22c1.11 0 2-.89 2-2h-4c0 1.11.89 2 2 2zm6-7.32V11c0-3.08-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-.15.03-.29.08-.42.12-.1.03-.2.07-.3.11h-.01c-.01 0-.01 0-.02.01-.23.09-.46.2-.68.31 0 0-.01 0-.01.01L18 14.68z" })), Cae = B(bae), Eae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 12h2L12 2 5.05 12H7l-3.9 6h6.92v4h3.96v-4H21z" })), Sae = B(Eae), kae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z" })), Tae = B(kae), Aae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" })), Nae = B(Aae), Iae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 4.5, cy: 9.5, r: 2.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 9, cy: 5.5, r: 2.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 15, cy: 5.5, r: 2.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 19.5, cy: 9.5, r: 2.5 }), /* @__PURE__ */ w.createElement("path", { d: "M17.34 14.86c-.87-1.02-1.6-1.89-2.48-2.91-.46-.54-1.05-1.08-1.75-1.32-.11-.04-.22-.07-.33-.09-.25-.04-.52-.04-.78-.04s-.53 0-.79.05c-.11.02-.22.05-.33.09-.7.24-1.28.78-1.75 1.32-.87 1.02-1.6 1.89-2.48 2.91-1.31 1.31-2.92 2.76-2.62 4.79.29 1.02 1.02 2.03 2.33 2.32.73.15 3.06-.44 5.54-.44h.18c2.48 0 4.81.58 5.54.44 1.31-.29 2.04-1.31 2.33-2.32.31-2.04-1.3-3.49-2.61-4.8z" })), Lae = B(Iae), Mae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z" })), Oae = B(Mae), Pae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 12, cy: 12, r: 3.2 }), /* @__PURE__ */ w.createElement("path", { d: "M9 2 7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z" })), Dae = B(Pae), Fae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z" })), Rae = B(Fae), $ae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 12, cy: 19, r: 2 }), /* @__PURE__ */ w.createElement("path", { d: "M10 3h4v12h-4z" })), Vae = B($ae), Bae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" })), zae = B(Bae), Hae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { fillRule: "evenodd", d: "M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1 1 1-1v-7H19v-2c-1.66 0-3-1.34-3-3z" })), Uae = B(Hae), jae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" })), Wae = B(jae), Jae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17.51 7A5.62 5.62 0 0 0 7 5.51a4.5 4.5 0 0 0 .49 9h9.75A3.74 3.74 0 0 0 17.51 7ZM4.076 20.774 6.08 15.77l1.857.743-2.003 5.004zm4.998-.002 2.003-5.004 1.856.743-2.002 5.004zm4.998.008 2.002-5.004 1.857.743-2.002 5.004z" })), Kae = B(Jae), qae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16 4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm4.78 3.58A6.95 6.95 0 0 0 18 7c-.67 0-1.31.1-1.92.28.58.55.92 1.32.92 2.15V10h5v-.57c0-.81-.48-1.53-1.22-1.85zM6 6c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm1.92 1.28C7.31 7.1 6.67 7 6 7c-.99 0-1.93.21-2.78.58A2.01 2.01 0 0 0 2 9.43V10h5v-.57c0-.83.34-1.6.92-2.15zM10 4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm6 6H8v-.57c0-.81.48-1.53 1.22-1.85a6.95 6.95 0 0 1 5.56 0A2.01 2.01 0 0 1 16 9.43V10zm-1 6c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm6 6h-8v-.57c0-.81.48-1.53 1.22-1.85a6.95 6.95 0 0 1 5.56 0A2.01 2.01 0 0 1 21 21.43V22zM5 16c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm6 6H3v-.57c0-.81.48-1.53 1.22-1.85a6.95 6.95 0 0 1 5.56 0A2.01 2.01 0 0 1 11 21.43V22zm1.75-9v-2h-1.5v2H9l3 3 3-3h-2.25z" })), Gae = B(qae), Yae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z" })), Xae = B(Yae), Zae = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 13H5v-2h14v2z" })), Qae = B(Zae), ele = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z" })), tle = B(ele), nle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7zm5-3v8h2.5v8H21V2c-2.76 0-5 2.24-5 4z" })), rle = B(nle), ile = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 6.18, cy: 17.82, r: 2.18 }), /* @__PURE__ */ w.createElement("path", { d: "M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z" })), sle = B(ile), ole = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11 5h2v14h-2V5zm-6 7c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm2.78 1.58a6.95 6.95 0 0 0-5.56 0A2.01 2.01 0 0 0 1 15.43V16h8v-.57c0-.81-.48-1.53-1.22-1.85zM19 12c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm2.78 1.58a6.95 6.95 0 0 0-5.56 0A2.01 2.01 0 0 0 15 15.43V16h8v-.57c0-.81-.48-1.53-1.22-1.85z" })), ale = B(ole), lle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.5 6.5C15.5 5.66 17 4 17 4s1.5 1.66 1.5 2.5c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5zm4 8.5a2.5 2.5 0 0 0 2.5-2.5c0-1.67-2.5-4.5-2.5-4.5S17 10.83 17 12.5a2.5 2.5 0 0 0 2.5 2.5zM13 14h-2v-2H9v2H7v2h2v2h2v-2h2v-2zm3-2v10H4V12c0-2.97 2.16-5.43 5-5.91V4H7V2h6c1.13 0 2.15.39 2.99 1.01l-1.43 1.43C14.1 4.17 13.57 4 13 4h-2v2.09c2.84.48 5 2.94 5 5.91z" })), cle = B(lle), ule = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67 2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z" })), fle = B(ule), dle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("g", { "data-name": "Severe Weather" }, /* @__PURE__ */ w.createElement("path", { d: "M4.05 17.73 12 4l8 13.85A5 5 0 0 0 19.2 8a7.49 7.49 0 0 0-14-2 6 6 0 0 0-1.15 11.73Z" }), /* @__PURE__ */ w.createElement("path", { d: "M12 7 3.34 22h17.32Zm0 13.4a1 1 0 1 1 1-1 1 1 0 0 1-1 1ZM11 17v-4.6h2V17Z" }))), hle = B(dle), ple = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }), /* @__PURE__ */ w.createElement("path", { d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z" })), mle = B(ple), gle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3 1 9l11 6 9-4.91V17h2V9L12 3z" })), vle = B(gle), yle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.8 18.4 14 10.67V6.5l1.35-1.69c.26-.33.03-.81-.39-.81H9.04c-.42 0-.65.48-.39.81L10 6.5v4.17L4.2 18.4c-.49.66-.02 1.6.8 1.6h14c.82 0 1.29-.94.8-1.6z" })), xle = B(yle), wle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" })), _le = B(wle), ble = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z" })), Cle = B(ble), Ele = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z" })), Sle = B(Ele), kle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 15.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-3.5c.73 0 1.39.19 1.97.53.12-.14.86-.98 1.01-1.14A5.39 5.39 0 0 0 12 15c-1.11 0-2.13.33-2.99.88.97 1.09.01.02 1.01 1.14.59-.33 1.25-.52 1.98-.52z" })), Tle = B(kle), Ale = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9 15.5h6v1H9v-1z" }), /* @__PURE__ */ w.createElement("circle", { cx: 15.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" })), Nle = B(Ale), Ile = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 15.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-4c-.73 0-1.38-.18-1.96-.52-.12.14-.86.98-1.01 1.15a5.49 5.49 0 0 0 5.95-.01c-.97-1.09-.01-.02-1.01-1.15-.59.35-1.24.53-1.97.53z" })), Lle = B(Ile), Mle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 15.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 15.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-2.5c2.33 0 4.32-1.45 5.12-3.5h-1.67c-.69 1.19-1.97 2-3.45 2s-2.75-.81-3.45-2H6.88c.8 2.05 2.79 3.5 5.12 3.5z" })), Ole = B(Mle), Ple = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("circle", { cx: 15.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("circle", { cx: 8.5, cy: 9.5, r: 1.5 }), /* @__PURE__ */ w.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-6c-2.33 0-4.32 1.45-5.12 3.5h1.67c.69-1.19 1.97-2 3.45-2s2.75.81 3.45 2h1.67c-.8-2.05-2.79-3.5-5.12-3.5z" })), Dle = B(Ple), Fle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z" })), Rle = B(Fle), $le = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" })), Vle = B($le), Ble = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z" })), zle = B(Ble), Hle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m17.21 9-4.38-6.56a.993.993 0 0 0-.83-.42c-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z" })), Ule = B(Hle), jle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m20.76 14.07-.66-1.34-2.88 1.42L13.5 12l3.72-2.15 2.88 1.42.66-1.34-1.97-.98 2.25-1.3-.75-1.3-2.25 1.3.14-2.2-1.5-.1-.21 3.2-3.72 2.15V6.4l2.67-1.78-.84-1.24-1.83 1.22V2h-1.5v2.6L9.42 3.38l-.84 1.24 2.67 1.78v4.3L7.53 8.55l-.21-3.2-1.5.1.14 2.2-2.25-1.3-.75 1.3 2.25 1.3-1.97.98.66 1.34 2.88-1.42L10.5 12l-3.72 2.15-2.88-1.42-.66 1.34 1.97.98-2.25 1.3.75 1.3 2.25-1.3-.14 2.2 1.5.1.21-3.2 3.72-2.15v4.3l-2.67 1.78.84 1.24 1.83-1.22V22h1.5v-2.6l1.83 1.22.84-1.24-2.67-1.78v-4.3l3.72 2.15.21 3.2 1.5-.1-.14-2.2 2.25 1.3.75-1.3-2.25-1.3 1.97-.98z" })), Wle = B(jle), Jle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m9.12 5-7.18 6.79c-.6.56-.94 1.35-.94 2.18V20c0 1.66 1.34 3 3 3h13.75a1.25 1.25 0 0 0 0-2.5H12v-1h7.75a1.25 1.25 0 0 0 0-2.5H12v-1h8.75a1.25 1.25 0 0 0 0-2.5H12v-1h6.75a1.25 1.25 0 0 0 0-2.5H8.86c.64-1.11 1.48-2.58 1.49-2.61a1.065 1.065 0 0 0-.12-1.23C10.22 6.12 9.12 5 9.12 5zM14 6.25c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75m0-1.5c-1.24 0-2.25 1.01-2.25 2.25S12.76 9.25 14 9.25 16.25 8.24 16.25 7 15.24 4.75 14 4.75zm5.75.75c.28 0 .5.22.5.5s-.22.5-.5.5-.5-.22-.5-.5.22-.5.5-.5m0-1.5c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM16.5 1c-.83 0-1.5.67-1.5 1.5S15.67 4 16.5 4 18 3.33 18 2.5 17.33 1 16.5 1z" })), Kle = B(Jle), qle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M4 5c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm4.78 3.58a6.95 6.95 0 0 0-5.56 0A2.01 2.01 0 0 0 2 10.43V11h8v-.57c0-.81-.48-1.53-1.22-1.85zM18 7c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm2.78 1.58a6.95 6.95 0 0 0-5.56 0A2.01 2.01 0 0 0 14 10.43V11h8v-.57c0-.81-.48-1.53-1.22-1.85zM22 17l-4-4v3H6v-3l-4 4 4 4v-3h12v3l4-4z" })), Gle = B(qle), Yle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.17 15 13 17.17V6.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 11 6.83v10.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15z" })), Xle = B(Yle), Zle = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z" })), Qle = B(Zle), ece = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" })), tce = B(ece), nce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m22 9.24-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z" })), rce = B(nce), ice = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m22 9.24-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z" })), sce = B(ice), oce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z" })), ace = B(oce), lce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm7.46 7.12-2.78 1.15a4.982 4.982 0 0 0-2.95-2.94l1.15-2.78c2.1.8 3.77 2.47 4.58 4.57zM12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zM9.13 4.54l1.17 2.78a5 5 0 0 0-2.98 2.97L4.54 9.13a7.984 7.984 0 0 1 4.59-4.59zM4.54 14.87l2.78-1.15a4.968 4.968 0 0 0 2.97 2.96l-1.17 2.78a7.996 7.996 0 0 1-4.58-4.59zm10.34 4.59-1.15-2.78a4.978 4.978 0 0 0 2.95-2.97l2.78 1.17a8.007 8.007 0 0 1-4.58 4.58z" })), cce = B(lce), uce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 12.22C21 6.73 16.74 3 12 3c-4.69 0-9 3.65-9 9.28-.6.34-1 .98-1 1.72v2c0 1.1.9 2 2 2h1v-6.1c0-3.87 3.13-7 7-7s7 3.13 7 7V19h-8v2h8c1.1 0 2-.9 2-2v-1.22c.59-.31 1-.92 1-1.64v-2.3c0-.7-.41-1.31-1-1.62z" }), /* @__PURE__ */ w.createElement("circle", { cx: 9, cy: 13, r: 1 }), /* @__PURE__ */ w.createElement("circle", { cx: 15, cy: 13, r: 1 }), /* @__PURE__ */ w.createElement("path", { d: "M18 11.03A6.04 6.04 0 0 0 12.05 6c-3.03 0-6.29 2.51-6.03 6.45a8.075 8.075 0 0 0 4.86-5.89c1.31 2.63 4 4.44 7.12 4.47z" })), fce = B(uce), dce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z" })), hce = B(dce), pce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M22 4h-2c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h2V4zM2.17 11.12c-.11.25-.17.52-.17.8V13c0 1.1.9 2 2 2h5.5l-.92 4.65c-.05.22-.02.46.08.66.23.45.52.86.88 1.22L10 22l6.41-6.41c.38-.38.59-.89.59-1.42V6.34C17 5.05 15.95 4 14.66 4h-8.1c-.71 0-1.36.37-1.72.97l-2.67 6.15z" })), mce = B(pce), gce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M2 20h2c.55 0 1-.45 1-1v-9c0-.55-.45-1-1-1H2v11zm19.83-7.12c.11-.25.17-.52.17-.8V11c0-1.1-.9-2-2-2h-5.5l.92-4.65c.05-.22.02-.46-.08-.66a4.8 4.8 0 0 0-.88-1.22L14 2 7.59 8.41C7.21 8.79 7 9.3 7 9.83v7.84A2.34 2.34 0 0 0 9.34 20h8.11c.7 0 1.36-.37 1.72-.97l2.66-6.15z" })), vce = B(gce), yce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M9 1h6v2H9zm10.03 6.39 1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42A8.962 8.962 0 0 0 12 4a9 9 0 0 0-9 9c0 4.97 4.02 9 9 9a8.994 8.994 0 0 0 7.03-14.61zM13 14h-2V8h2v6z" })), xce = B(yce), wce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h10c2.76 0 5-2.24 5-5s-2.24-5-5-5zM7 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z" })), _ce = B(wce), bce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M17 7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h10c2.76 0 5-2.24 5-5s-2.24-5-5-5zm0 8c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z" })), Cce = B(bce), Ece = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6 10H6v-2h8v2zm4-4H6v-2h12v2z" })), Sce = B(Ece), kce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "1em", viewBox: "0 0 24 24", width: "1em", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M13 16v-2h2.77c.08-.32.16-.65.23-1 1.19-5.95 4-6 4-10H4a10.35 10.35 0 0 0 .48 3H8v2H5.26c.32.69.68 1.36 1 2H10v2H7.51A13.86 13.86 0 0 1 9 15a6.24 6.24 0 0 1-1 6l1 1c2.82-1.54 4.85-3.09 6.1-6Z" })), Tce = B(kce), Ace = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7 1.62-4.33L19.12 17h-3.24z" })), Nce = B(Ace), Ice = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m16 18 2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z" })), Lce = B(Ice), Mce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m16 6 2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" })), Oce = B(Mce), Pce = (e) => /* @__PURE__ */ w.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.912 7.925v.527A11.562 11.562 0 0 1 8.265 20.098 11.443 11.443 0 0 1 2 18.265c.328.017.657.017.985 0a8.132 8.132 0 0 0 5.093-1.698 4.092 4.092 0 0 1-3.786-2.852c.255.062.518.091.781.085.36-.002.72-.047 1.07-.136a4.109 4.109 0 0 1-3.21-4.024c.566.32 1.202.494 1.851.51a4.126 4.126 0 0 1-1.34-5.518 11.613 11.613 0 0 0 8.488 4.295 4.397 4.397 0 0 1-.119-.934 4.092 4.092 0 0 1 4.092-4.092 4.04 4.04 0 0 1 3.005 1.29 7.929 7.929 0 0 0 2.53-1c-.3.953-.94 1.763-1.8 2.274A7.725 7.725 0 0 0 22 5.803a8.489 8.489 0 0 1-2.088 2.122Z", fillRule: "evenodd" })), Dce = B(Pce), Fce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" })), Rce = B(Fce), $ce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M7.41 18.59 8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z" })), Vce = B($ce), Bce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 5.83 15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z" })), zce = B(Bce), Hce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3v7.12zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8h1.5z" })), Uce = B(Hce), jce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 15.01l1.41 1.41L11 14.84V19h2v-4.16l1.59 1.59L16 15.01 12.01 11z" })), Wce = B(jce), Jce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69L23 12zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48-7.33 7.35z" })), Kce = B(Jce), qce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z" })), Gce = B(qce), Yce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" })), Xce = B(Yce), Zce = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46A11.804 11.804 0 0 0 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z" })), Qce = B(Zce), eue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M16.5 12A4.5 4.5 0 0 0 14 7.97v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51A8.796 8.796 0 0 0 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06a8.99 8.99 0 0 0 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4 9.91 6.09 12 8.18V4z" })), tue = B(eue), nue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" })), rue = B(nue), iue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M18.5 8A2.5 2.5 0 0 0 21 5.5C21 3.83 18.5 1 18.5 1S16 3.83 16 5.5A2.5 2.5 0 0 0 18.5 8zm-5 1c.83 0 1.5-.67 1.5-1.5 0-.84-1.5-2.5-1.5-2.5S12 6.66 12 7.5c0 .83.67 1.5 1.5 1.5zM9.12 5l-7.18 6.79c-.6.56-.94 1.35-.94 2.18V20c0 1.66 1.34 3 3 3h13.75a1.25 1.25 0 0 0 0-2.5H12v-1h7.75a1.25 1.25 0 0 0 0-2.5H12v-1h8.75a1.25 1.25 0 0 0 0-2.5H12v-1h6.75a1.25 1.25 0 0 0 0-2.5H8.86c.64-1.11 1.48-2.58 1.49-2.61a1.065 1.065 0 0 0-.12-1.23C10.22 6.12 9.12 5 9.12 5z" })), sue = B(iue), oue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m1 9 2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8 3 3 3-3a4.237 4.237 0 0 0-6 0zm-4-4 2 2a7.074 7.074 0 0 1 10 0l2-2C15.14 9.14 8.87 9.14 5 13z" })), aue = B(oue), lue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z" })), cue = B(lue), uue = (e) => /* @__PURE__ */ w.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M13.522 10.775 19.48 4h-1.412l-5.172 5.883L8.765 4H4l6.247 8.895L4 20h1.412l5.461-6.212L15.236 20H20l-6.478-9.225Zm-1.933 2.199-.633-.886L5.92 5.04h2.168l4.064 5.688.633.886 5.283 7.394H15.9l-4.311-6.034Z" })), fue = B(uue), due = (e) => /* @__PURE__ */ w.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M19.816 5.389a2.469 2.469 0 0 1 1.766 1.746c.291 1.598.43 3.22.417 4.843a25.867 25.867 0 0 1-.417 4.794 2.468 2.468 0 0 1-1.766 1.795c-2.593.318-5.204.46-7.816.429a58.411 58.411 0 0 1-7.816-.429 2.469 2.469 0 0 1-1.766-1.746 25.879 25.879 0 0 1-.417-4.843 25.85 25.85 0 0 1 .417-4.793 2.468 2.468 0 0 1 1.766-1.796c2.594-.3 5.205-.427 7.816-.379a58.413 58.413 0 0 1 7.816.379ZM9.95 9.046v5.864l5.233-2.932L9.95 9.046Z" })), hue = B(due), pue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }), /* @__PURE__ */ w.createElement("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })), mue = B(pue), gue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "m15 3 2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3h-6zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3v6zm6 12-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6h6zm12-6-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6v-6z" })), vue = B(gue), yue = (e) => /* @__PURE__ */ w.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ w.createElement("path", { d: "M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z" })), xue = B(yue), V = (e) => {
  const t = (n) => {
    const {
      size: r,
      className: i,
      focusable: s = !1,
      role: o = "img",
      ...a
    } = n, l = {
      className: $t(
        "usa-icon",
        {
          [`usa-icon--size-${r}`]: r !== void 0
        },
        i
      ),
      focusable: s,
      role: o,
      ...a
    };
    return o === "img" && !a["aria-hidden"] && !a["aria-label"] && !a["aria-labelledby"] && console.warn(
      "Icon with img role is missing an accessible label. https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Img_role#associated_wai-aria_roles_states_and_properties"
    ), /* @__PURE__ */ A(e, { ...l });
  };
  return t.displayName = e.displayName, t;
}, $ = class {
};
$.AccessibilityNew = V(_te), $.AccessibleForward = V(Cte), $.AccountBalance = V(Ste), $.AccountBox = V(Tte), $.AccountCircle = V(Nte), $.Add = V(Lte), $.AddCircle = V(Ote), $.AddCircleOutline = V(Dte), $.Alarm = V(Rte), $.AlternateEmail = V(Vte), $.Announcement = V(zte), $.ArrowBack = V(Ute), $.ArrowDownward = V(Wte), $.ArrowDropDown = V(Kte), $.ArrowDropUp = V(Gte), $.ArrowForward = V(Xte), $.ArrowUpward = V(Qte), $.Api = V(tne), $.Assessment = V(rne), $.AttachFile = V(sne), $.AttachMoney = V(ane), $.Autorenew = V(cne), $.Backpack = V(fne), $.Bathtub = V(hne), $.Bedding = V(mne), $.Bookmark = V(vne), $.BugReport = V(xne), $.Build = V(_ne), $.CalendarToday = V(Cne), $.Campaign = V(Sne), $.Camping = V(Tne), $.Cancel = V(Nne), $.Chat = V(Lne), $.Check = V(One), $.CheckBoxOutlineBlank = V(Dne), $.CheckCircle = V(Rne), $.CheckCircleOutline = V(Vne), $.Checkroom = V(zne), $.CleanHands = V(Une), $.Clothes = V(Wne), $.Close = V(Kne), $.ClosedCaption = V(Gne), $.Cloud = V(Xne), $.Code = V(Qne), $.Comment = V(tre), $.ConnectWithoutContact = V(rre), $.Construction = V(sre), $.ConstructionWorker = V(are), $.ContactPage = V(cre), $.ContentCopy = V(fre), $.Coronavirus = V(hre), $.CreditCard = V(mre), $.Deck = V(vre), $.Delete = V(xre), $.DeviceThermostat = V(_re), $.Directions = V(Cre), $.DirectionsBike = V(Sre), $.DirectionsBus = V(Tre), $.DirectionsCar = V(Nre), $.DirectionsWalk = V(Lre), $.DoNotDisturb = V(Ore), $.DoNotTouch = V(Dre), $.DragHandle = V(Rre), $.Eco = V(Vre), $.Edit = V(zre), $.ElectricalServices = V(Ure), $.EmojiEvents = V(Wre), $.Error = V(Kre), $.ErrorOutline = V(Gre), $.Event = V(Xre), $.ExpandLess = V(Qre), $.ExpandMore = V(tie), $.Facebook = V(rie), $.FastForward = V(sie), $.FastRewind = V(aie), $.Favorite = V(cie), $.FavoriteBorder = V(fie), $.Fax = V(hie), $.FileDownload = V(mie), $.FilePresent = V(vie), $.FileUpload = V(xie), $.FilterAlt = V(_ie), $.FilterList = V(Cie), $.Fingerprint = V(Sie), $.FirstPage = V(Tie), $.Flag = V(Nie), $.Flickr = V(Lie), $.Flight = V(Oie), $.Flooding = V(Die), $.Folder = V(Rie), $.FolderOpen = V(Vie), $.FormatQuote = V(zie), $.FormatSize = V(Uie), $.Forum = V(Wie), $.Github = V(Kie), $.GridView = V(Gie), $.GroupAdd = V(Xie), $.Groups = V(Qie), $.Hearing = V(tse), $.Help = V(rse), $.HelpOutline = V(sse), $.HighlightOff = V(ase), $.History = V(cse), $.Home = V(fse), $.Hospital = V(hse), $.Hotel = V(mse), $.HourglassEmpty = V(vse), $.Hurricane = V(xse), $.Identification = V(_se), $.Image = V(Cse), $.Info = V(Sse), $.InfoOutline = V(Tse), $.Insights = V(Nse), $.Instagram = V(Lse), $.Keyboard = V(Ose), $.Label = V(Dse), $.Language = V(Rse), $.LastPage = V(Vse), $.Launch = V(zse), $.Lightbulb = V(Use), $.LightbulbOutline = V(Wse), $.LinkedIn = V(Kse), $.Link = V(Gse), $.LinkOff = V(Xse), $.List = V(Qse), $.LocalCafe = V(toe), $.LocalFireDepartment = V(roe), $.LocalGasStation = V(soe), $.LocalGroceryStore = V(aoe), $.LocalHospital = V(coe), $.LocalLaundryService = V(foe), $.LocalLibrary = V(hoe), $.LocalOffer = V(moe), $.LocalParking = V(voe), $.LocalPharmacy = V(xoe), $.LocalPolice = V(_oe), $.LocalTaxi = V(Coe), $.LocationCity = V(Soe), $.LocationOn = V(Toe), $.Lock = V(Noe), $.LockOpen = V(Loe), $.LockOutline = V(Ooe), $.Login = V(Doe), $.Logout = V(Roe), $.Loop = V(Voe), $.Mail = V(zoe), $.MailOutline = V(Uoe), $.Map = V(Woe), $.Masks = V(Koe), $.MedicalServices = V(Goe), $.Menu = V(Xoe), $.MilitaryTech = V(Qoe), $.MoreHoriz = V(tae), $.MoreVert = V(rae), $.MyLocation = V(sae), $.NavigateBefore = V(aae), $.NavigateNext = V(cae), $.NavigateFarBefore = V(fae), $.NavigateFarNext = V(hae), $.NearMe = V(mae), $.Notifications = V(vae), $.NotificationsActive = V(xae), $.NotificationsNone = V(_ae), $.NotificationsOff = V(Cae), $.Park = V(Sae), $.People = V(Tae), $.Person = V(Nae), $.Pets = V(Lae), $.Phone = V(Oae), $.PhotoCamera = V(Dae), $.Print = V(Rae), $.PriorityHigh = V(Vae), $.Public = V(zae), $.PushPin = V(Uae), $.RadioButtonUnchecked = V(Wae), $.Rain = V(Kae), $.ReduceCapacity = V(Gae), $.RemoveCircle = V(Xae), $.Remove = V(Qae), $.Report = V(tle), $.Restaurant = V(rle), $.RssFeed = V(sle), $.SafetyDivider = V(ale), $.Sanitizer = V(cle), $.SaveAlt = V(fle), $.SevereWeather = V(hle), $.Schedule = V(mle), $.School = V(vle), $.Science = V(xle), $.Search = V(_le), $.Security = V(Cle), $.Send = V(Sle), $.SentimentDissatisfied = V(Tle), $.SentimentNeutral = V(Nle), $.SentimentSatisfied = V(Lle), $.SentimentSatisfiedAlt = V(Ole), $.SentimentVeryDissatisfied = V(Dle), $.Settings = V(Rle), $.Share = V(Vle), $.Shield = V(zle), $.ShoppingBasket = V(Ule), $.Snow = V(Wle), $.Soap = V(Kle), $.SocialDistance = V(Gle), $.SortArrow = V(Xle), $.Spellcheck = V(Qle), $.Star = V(tce), $.StarHalf = V(rce), $.StarOutline = V(sce), $.Store = V(ace), $.Support = V(cce), $.SupportAgent = V(fce), $.TextFields = V(hce), $.ThumbDownAlt = V(mce), $.ThumbUpAlt = V(vce), $.Timer = V(xce), $.ToggleOff = V(_ce), $.ToggleOn = V(Cce), $.Topic = V(Sce), $.Tornado = V(Tce), $.Translate = V(Nce), $.TrendingDown = V(Lce), $.TrendingUp = V(Oce), $.Twitter = V(Dce), $.Undo = V(Rce), $.UnfoldLess = V(Vce), $.UnfoldMore = V(zce), $.Update = V(Uce), $.UploadFile = V(Wce), $.Verified = V(Kce), $.VerifiedUser = V(Gce), $.Visibility = V(Xce), $.VisibilityOff = V(Qce), $.VolumeOff = V(tue), $.Warning = V(rue), $.Wash = V(sue), $.Wifi = V(aue), $.Work = V(cue), $.X = V(fue), $.Youtube = V(hue), $.ZoomIn = V(mue), $.ZoomOutMap = V(vue), $.ZoomOut = V(xue);
let Fx = $;
const AN = wi(
  (e, t) => {
    const {
      id: n,
      name: r,
      type: i,
      className: s,
      validationStatus: o,
      inputSize: a,
      inputRef: l,
      ...c
    } = e, u = $t(
      "usa-input",
      {
        "usa-input--error": o === "error",
        "usa-input--success": o === "success",
        "usa-input--small": a === "small",
        "usa-input--medium": a === "medium"
      },
      s
    );
    return /* @__PURE__ */ A(
      "input",
      {
        "data-testid": "textInput",
        className: u,
        id: n,
        name: r,
        type: i,
        ref: l || t,
        ...c
      }
    );
  }
);
AN.displayName = "TextInput";
const wue = ({
  id: e,
  name: t,
  className: n,
  error: r,
  success: i,
  children: s,
  inputRef: o,
  ...a
}) => {
  const l = $t(
    "usa-textarea",
    {
      "usa-input--error": r,
      "usa-input--success": i
    },
    n
  );
  return /* @__PURE__ */ A(
    "textarea",
    {
      "data-testid": "textarea",
      className: l,
      id: e,
      name: t,
      ref: o,
      ...a,
      children: s
    }
  );
}, _ue = ({
  id: e,
  name: t,
  className: n,
  label: r,
  inputRef: i,
  tile: s,
  labelDescription: o,
  ...a
}) => {
  const l = $t("usa-checkbox", n), c = $t("usa-checkbox__input", {
    "usa-checkbox__input--tile": s
  });
  return /* @__PURE__ */ Oe("div", { "data-testid": "checkbox", className: l, children: [
    /* @__PURE__ */ A(
      "input",
      {
        className: c,
        id: e,
        type: "checkbox",
        name: t,
        ref: i,
        ...a
      }
    ),
    /* @__PURE__ */ Oe("label", { className: "usa-checkbox__label", htmlFor: e, children: [
      r,
      o && /* @__PURE__ */ A("span", { className: "usa-checkbox__label-description", children: o })
    ] })
  ] });
}, bue = (e, t = "", n = {}) => {
  const r = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  let i = e.replace(/{{(.*?)}}/g, (s, o) => {
    const a = o.trim(), l = n[a];
    if (a !== "query" && l) {
      const c = new RegExp(l, "i"), u = t.match(c);
      return u ? r(u[1]) : "";
    }
    return r(t);
  });
  return i = "^(?:" + i + ")$", new RegExp(i, "i");
};
var ht = /* @__PURE__ */ ((e) => (e[e.SELECT_OPTION = 0] = "SELECT_OPTION", e[e.CLEAR = 1] = "CLEAR", e[e.OPEN_LIST = 2] = "OPEN_LIST", e[e.CLOSE_LIST = 3] = "CLOSE_LIST", e[e.FOCUS_OPTION = 4] = "FOCUS_OPTION", e[e.UPDATE_FILTER = 5] = "UPDATE_FILTER", e[e.BLUR = 6] = "BLUR", e[e.CLEAR_SELECTION = 7] = "CLEAR_SELECTION", e[e.FOCUS_INPUT = 8] = "FOCUS_INPUT", e))(ht || {});
const Cue = (e, t, n, r) => {
  const i = (s) => {
    const o = bue(
      r.filter,
      s,
      r.extras
    ), a = t.filter(
      (l) => o.test(l.label.toLowerCase())
    );
    return n ? {
      closestMatch: a.length > 0 ? a[0] : t[0],
      optionsToDisplay: t
    } : {
      closestMatch: a[0],
      optionsToDisplay: a
    };
  };
  return rC((s, o) => {
    switch (o.type) {
      case 0:
        return {
          ...s,
          isOpen: !1,
          selectedOption: o.option,
          focusMode: Di.Input,
          inputValue: o.option.label,
          filteredOptions: t,
          focusedOption: o.option,
          statusText: ""
        };
      case 5: {
        const { closestMatch: a, optionsToDisplay: l } = i(
          o.value
        ), c = {
          ...s,
          isOpen: !0,
          filteredOptions: l,
          inputValue: o.value,
          statusText: `${l.length} result${l.length > 1 ? "s" : ""} available.`
        };
        return l.length < 1 && (c.statusText = "No results."), n || !s.selectedOption ? c.focusedOption = a : s.selectedOption && (c.filteredOptions.includes(s.selectedOption) ? c.focusedOption = s.selectedOption : c.focusedOption = a), c;
      }
      case 2: {
        const a = s.filteredOptions.length ? `${s.filteredOptions.length} result${s.filteredOptions.length > 1 ? "s" : ""} available.` : "No results.";
        return {
          ...s,
          isOpen: !0,
          focusMode: Di.Input,
          focusedOption: s.selectedOption || s.focusedOption || t[0],
          statusText: a
        };
      }
      case 3: {
        const a = {
          ...s,
          isOpen: !1,
          focusMode: Di.Input,
          focusedOption: void 0,
          statusText: ""
        };
        return s.filteredOptions.length === 0 && (a.filteredOptions = t, a.inputValue = ""), s.selectedOption && (a.inputValue = s.selectedOption.label), a;
      }
      case 4: {
        const a = s.filteredOptions.length ? `${s.filteredOptions.length} result${s.filteredOptions.length > 1 ? "s" : ""} available.` : "No results.";
        return {
          ...s,
          isOpen: !0,
          focusedOption: o.option,
          focusMode: Di.Item,
          statusText: a
        };
      }
      case 1:
        return {
          ...s,
          inputValue: "",
          isOpen: !1,
          focusMode: Di.Input,
          selectedOption: void 0,
          filteredOptions: t,
          focusedOption: t[0],
          statusText: ""
        };
      case 6: {
        const a = {
          ...s,
          isOpen: !1,
          focusMode: Di.None,
          filteredOptions: t,
          statusText: ""
        };
        return s.selectedOption ? (a.inputValue = s.selectedOption.label, a.focusedOption = s.selectedOption) : (a.inputValue = "", a.focusedOption = t[0]), a;
      }
      case 7:
        return {
          ...s,
          inputValue: "",
          isOpen: !1,
          focusMode: Di.None,
          selectedOption: void 0,
          filteredOptions: t,
          focusedOption: void 0,
          statusText: ""
        };
      case 8:
        return {
          ...s,
          focusMode: Di.Input
        };
      default:
        throw new Error();
    }
  }, e);
}, Eue = ".*{{query}}.*";
var Di = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Input = 1] = "Input", e[e.Item = 2] = "Item", e))(Di || {});
const Sue = ({
  focused: e,
  ...t
}) => {
  const n = $e(null);
  return Le(() => {
    e && n.current && n.current.focus();
  }), /* @__PURE__ */ A(
    "input",
    {
      type: "text",
      ...t,
      className: "usa-combo-box__input",
      "data-testid": "combo-box-input",
      autoCapitalize: "off",
      autoComplete: "off",
      ref: n
    }
  );
}, kue = ({
  id: e,
  name: t,
  className: n,
  options: r,
  defaultValue: i,
  disabled: s,
  onChange: o,
  assistiveHint: a,
  noResults: l,
  selectProps: c,
  inputProps: u,
  ulProps: f,
  customFilter: d,
  disableFiltering: h = !1
}, m) => {
  var p;
  const y = !!s;
  let v;
  i && (v = r.find((U) => U.value === i));
  const g = d || { filter: Eue }, x = {
    isOpen: !1,
    selectedOption: v || void 0,
    focusedOption: void 0,
    focusMode: 0,
    filteredOptions: r,
    inputValue: v ? v.label : "",
    statusText: ""
  }, [_, b] = Cue(
    x,
    r,
    h,
    g
  ), C = $e(null), E = $e(null), S = $e(null);
  Le(() => {
    _.filteredOptions = r;
  }, [r]), Le(() => {
    var U;
    o && o(((U = _.selectedOption) == null ? void 0 : U.value) || void 0);
  }, [_.selectedOption]), Le(() => {
    _.focusMode === 2 && _.focusedOption && S.current && S.current.focus();
  }, [_.focusMode, _.focusedOption]), Le(() => {
    if (_.isOpen && _.focusedOption && S.current && E.current && _.focusMode === 1) {
      const U = S.current.offsetTop + S.current.offsetHeight, ee = E.current.scrollTop + E.current.offsetHeight;
      U > ee && (E.current.scrollTop = U - E.current.offsetHeight), S.current.offsetTop < E.current.scrollTop && (E.current.scrollTop = S.current.offsetTop);
    }
  }, [_.isOpen, _.focusedOption]), Le(() => {
    var U;
    _.focusMode !== 0 && ((U = C.current) != null && U.contains(window.document.activeElement) || b({
      type: ht.BLUR
    }));
  }, [_.focusMode]), _2(
    m,
    () => ({
      focus: () => b({ type: ht.FOCUS_INPUT }),
      clearSelection: () => b({ type: ht.CLEAR_SELECTION })
    }),
    []
  );
  const k = (U) => {
    if (U.key === "Escape")
      b({ type: ht.CLOSE_LIST });
    else if (U.key === "ArrowDown" || U.key == "Down")
      U.preventDefault(), b({
        type: ht.FOCUS_OPTION,
        option: _.selectedOption || _.focusedOption || _.filteredOptions[0]
      });
    else if (U.key === "Tab") {
      if (_.isOpen && !_.selectedOption) {
        const ee = h ? _.focusedOption : _.selectedOption || _.focusedOption;
        ee ? (U.preventDefault(), b({
          type: ht.FOCUS_OPTION,
          option: ee
        })) : b({
          type: ht.BLUR
        });
      }
      !_.isOpen && _.selectedOption && b({
        type: ht.BLUR
      });
    } else if (U.key === "Enter" && _.isOpen) {
      U.preventDefault();
      const ee = _.filteredOptions.find(
        (F) => F.label.toLowerCase() === _.inputValue.toLowerCase()
      );
      ee ? b({
        type: ht.SELECT_OPTION,
        option: ee
      }) : _.selectedOption ? b({
        type: ht.CLOSE_LIST
      }) : b({ type: ht.CLEAR });
    }
  }, M = (U) => {
    var ee;
    const { relatedTarget: F } = U;
    (!F || F instanceof Node && !((ee = C.current) != null && ee.contains(F))) && _.focusMode !== 0 && b({ type: ht.BLUR });
  }, O = (U) => {
    U.key === "Tab" && _.isOpen && _.selectedOption && (U.preventDefault(), b({
      type: ht.FOCUS_OPTION,
      option: _.selectedOption
    }));
  }, R = (U, ee, F) => {
    const ue = ee.focusedOption ? ee.filteredOptions.indexOf(ee.focusedOption) : -1, pe = ee.filteredOptions[0], ce = ee.filteredOptions[ee.filteredOptions.length - 1];
    if (ue === -1)
      U({ type: ht.FOCUS_OPTION, option: pe });
    else {
      const q = ue + F;
      if (q < 0)
        U({ type: ht.CLOSE_LIST });
      else if (q >= ee.filteredOptions.length)
        U({ type: ht.FOCUS_OPTION, option: ce });
      else {
        const Z = ee.filteredOptions[q];
        U({ type: ht.FOCUS_OPTION, option: Z });
      }
    }
  }, I = (U) => {
    var ee;
    const { relatedTarget: F } = U;
    (!F || F instanceof Node && !((ee = C.current) != null && ee.contains(F))) && b({ type: ht.BLUR });
  }, H = (U) => {
    U.key === "Escape" ? b({ type: ht.CLOSE_LIST }) : U.key === "Tab" || U.key === "Enter" ? (U.preventDefault(), _.focusedOption && b({
      type: ht.SELECT_OPTION,
      option: _.focusedOption
    })) : U.key === "ArrowDown" || U.key === "Down" ? (U.preventDefault(), R(
      b,
      _,
      1
      /* Next */
    )) : (U.key === "ArrowUp" || U.key === "Up") && (U.preventDefault(), R(
      b,
      _,
      -1
      /* Previous */
    ));
  }, P = _.selectedOption && _.selectedOption.label === _.inputValue, W = $t("usa-combo-box", n, {
    "usa-combo-box--pristine": P
  }), G = `${e}--list`, J = `${e}--assistiveHint`, X = _.focusedOption ? _.filteredOptions.findIndex((U) => U === _.focusedOption) : -1, N = X > -1 && `${G}--option-${X}`;
  return /* @__PURE__ */ Oe(
    "div",
    {
      "data-testid": "combo-box",
      "data-enhanced": "true",
      className: W,
      ref: C,
      children: [
        /* @__PURE__ */ A(
          "select",
          {
            ...c,
            className: "usa-select usa-sr-only usa-combo-box__select",
            name: t,
            "aria-hidden": !0,
            tabIndex: -1,
            defaultValue: (p = _.selectedOption) == null ? void 0 : p.value,
            "data-testid": "combo-box-select",
            children: r.map((U) => /* @__PURE__ */ A("option", { value: U.value, children: U.label }, U.value))
          }
        ),
        /* @__PURE__ */ A(
          Sue,
          {
            ...u,
            role: "combobox",
            onChange: (U) => {
              u != null && u.onChange && (u == null || u.onChange(U)), b({ type: ht.UPDATE_FILTER, value: U.target.value });
            },
            onClick: () => b({ type: ht.OPEN_LIST }),
            onBlur: M,
            onKeyDown: k,
            value: _.inputValue,
            focused: _.focusMode === 1,
            "aria-owns": G,
            "aria-controls": G,
            "aria-autocomplete": "list",
            "aria-describedby": J,
            "aria-expanded": _.isOpen,
            "aria-activedescendant": _.isOpen && N || "",
            id: e,
            disabled: y
          }
        ),
        /* @__PURE__ */ A("span", { className: "usa-combo-box__clear-input__wrapper", tabIndex: -1, children: /* @__PURE__ */ A(
          "button",
          {
            type: "button",
            className: "usa-combo-box__clear-input",
            "aria-label": "Clear the select contents",
            onClick: () => b({ type: ht.CLEAR }),
            "data-testid": "combo-box-clear-button",
            onKeyDown: O,
            hidden: !P || y,
            disabled: y,
            children: " "
          }
        ) }),
        /* @__PURE__ */ A("span", { className: "usa-combo-box__input-button-separator", children: " " }),
        /* @__PURE__ */ A("span", { className: "usa-combo-box__toggle-list__wrapper", tabIndex: -1, children: /* @__PURE__ */ A(
          "button",
          {
            "data-testid": "combo-box-toggle",
            type: "button",
            className: "usa-combo-box__toggle-list",
            tabIndex: -1,
            "aria-label": "Toggle the dropdown list",
            onClick: () => b({
              type: _.isOpen ? ht.CLOSE_LIST : ht.OPEN_LIST
            }),
            disabled: y,
            children: " "
          }
        ) }),
        /* @__PURE__ */ Oe(
          "ul",
          {
            ...f,
            "data-testid": "combo-box-option-list",
            tabIndex: -1,
            id: G,
            className: "usa-combo-box__list",
            role: "listbox",
            ref: E,
            hidden: !_.isOpen,
            children: [
              _.filteredOptions.map((U, ee) => {
                const F = U === _.focusedOption, ue = U === _.selectedOption, pe = $t("usa-combo-box__list-option", {
                  "usa-combo-box__list-option--focused": F,
                  "usa-combo-box__list-option--selected": ue
                });
                return /* @__PURE__ */ A(
                  "li",
                  {
                    ref: F ? S : null,
                    value: U.value,
                    className: pe,
                    tabIndex: F ? 0 : -1,
                    role: "option",
                    "aria-selected": ue,
                    "aria-setsize": _.filteredOptions.length,
                    "aria-posinset": ee + 1,
                    id: G + `--option-${ee}`,
                    onKeyDown: H,
                    onBlur: I,
                    "data-testid": `combo-box-option-${U.value}`,
                    "data-value": U.value,
                    onMouseEnter: () => b({ type: ht.FOCUS_OPTION, option: U }),
                    onClick: () => {
                      b({ type: ht.SELECT_OPTION, option: U });
                    },
                    children: U.label
                  },
                  U.value
                );
              }),
              _.filteredOptions.length === 0 ? /* @__PURE__ */ A("li", { className: "usa-combo-box__list-option--no-results", children: l || "No results found" }) : null
            ]
          }
        ),
        /* @__PURE__ */ A("div", { className: "usa-combo-box__status usa-sr-only", role: "status", children: _.statusText }),
        /* @__PURE__ */ A(
          "span",
          {
            id: J,
            className: "usa-sr-only",
            "data-testid": "combo-box-assistive-hint",
            children: a || `When autocomplete results are available use up and down arrows to review
           and enter to select. Touch device users, explore by touch or with swipe
           gestures.`
          }
        )
      ]
    }
  );
};
wi(kue);
const Tue = () => /* @__PURE__ */ A("abbr", { title: "required", className: "usa-hint usa-hint--required", children: "*" }), Ul = ({
  children: e,
  htmlFor: t,
  className: n,
  error: r,
  hint: i,
  srOnly: s,
  requiredMarker: o,
  ...a
}) => {
  const l = $t(
    {
      "usa-label": !s,
      "usa-sr-only": s,
      "usa-label--error": r
    },
    n
  );
  return /* @__PURE__ */ Oe(
    "label",
    {
      ...a,
      "data-testid": "label",
      className: l,
      htmlFor: t,
      children: [
        e,
        i && /* @__PURE__ */ A("span", { className: "usa-hint", children: i }),
        o && /* @__PURE__ */ Oe(Ut, { children: [
          " ",
          /* @__PURE__ */ A(Tue, {})
        ] })
      ]
    }
  );
}, i3 = "Please enter a valid date", Aue = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], Nue = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
], Iue = ["S", "M", "T", "W", "Th", "F", "S"], Qr = 12, Lue = "0000-01-01", pc = "MM/DD/YYYY", NN = "YYYY-MM-DD", r1 = {
  months: Aue,
  daysOfWeek: Nue,
  daysOfWeekShort: Iue,
  statuses: [
    "You can navigate by day using left and right arrows",
    "Weeks by using up and down arrows",
    "Months by using page up and page down keys",
    "Years by using shift plus page up and shift plus page down",
    "Home and end keys navigate to the beginning and end of a week"
  ],
  selectedDate: "Selected date",
  selectAMonth: "Select a month.",
  toggleCalendar: "Toggle calendar",
  backOneYear: "Navigate back one year",
  backOneMonth: "Navigate back one month",
  forwardOneYear: "Navigate forward one year",
  forwardOneMonth: "Navigate forward one month",
  selectMonth: "Select month",
  selectYear: "Select year"
}, Rx = (e, t) => (t !== e.getMonth() && e.setDate(0), e), kh = (e, t, n) => {
  const r = /* @__PURE__ */ new Date(0);
  return r.setFullYear(e, t, n), r;
}, Th = () => {
  const e = /* @__PURE__ */ new Date(), t = e.getDate(), n = e.getMonth(), r = e.getFullYear();
  return kh(r, n, t);
}, $x = (e) => {
  const t = /* @__PURE__ */ new Date(0);
  return t.setFullYear(e.getFullYear(), e.getMonth(), 1), t;
}, IN = (e) => {
  const t = /* @__PURE__ */ new Date(0);
  return t.setFullYear(e.getFullYear(), e.getMonth() + 1, 0), t;
}, Os = (e, t) => {
  const n = new Date(e.getTime());
  return n.setDate(n.getDate() + t), n;
}, n2 = (e, t) => Os(e, -t), LN = (e, t) => Os(e, t * 7), Mue = (e, t) => LN(e, -1), s3 = (e) => {
  const t = e.getDay();
  return n2(e, t);
}, Oue = (e) => {
  const t = e.getDay();
  return Os(e, 6 - t);
}, mc = (e, t) => {
  const n = new Date(e.getTime()), r = (n.getMonth() + 12 + t) % 12;
  return n.setMonth(n.getMonth() + t), Rx(n, r), n;
}, Vm = (e, t) => mc(e, -1), r2 = (e, t) => mc(e, t * 12), o3 = (e, t) => r2(e, -1), Fa = (e, t) => {
  const n = new Date(e.getTime());
  return n.setMonth(t), Rx(n, t), n;
}, Cs = (e, t) => {
  const n = new Date(e.getTime()), r = n.getMonth();
  return n.setFullYear(t), Rx(n, r), n;
}, Pue = (e, t) => {
  let n = e;
  return t < e && (n = t), new Date(n.getTime());
}, Due = (e, t) => {
  let n = e;
  return t > e && (n = t), new Date(n.getTime());
}, MN = (e, t) => e && t && e.getFullYear() === t.getFullYear(), mo = (e, t) => MN(e, t) && e.getMonth() === t.getMonth(), Fi = (e, t) => mo(e, t) && e.getDate() === t.getDate(), Xn = (e, t, n) => {
  let r = e;
  return e < t ? r = t : n && e > n && (r = n), new Date(r.getTime());
}, i2 = (e, t, n) => e >= t && (!n || e <= n), Fue = (e, t, n) => IN(e) < t || !!n && $x(e) > n, Bm = (e, t, n) => IN(Fa(e, 11)) < t || !!n && $x(Fa(e, 0)) > n, Li = (e, t = NN, n = !1) => {
  let r, i, s, o, a;
  if (e) {
    let l, c, u;
    if (t === pc ? [l, c, u] = e.split("/") : [u, l, c] = e.split("-"), u && (a = parseInt(u, 10), !Number.isNaN(a) && (o = a, n && (o = Math.max(0, o), u.length < 3)))) {
      const f = Th().getFullYear();
      o = f - f % 10 ** u.length + a;
    }
    if (l && (a = parseInt(l, 10), Number.isNaN(a) || (i = a, n && (i = Math.max(1, i), i = Math.min(12, i)))), i && c && o != null && (a = parseInt(c, 10), !Number.isNaN(a) && (s = a, n))) {
      const f = kh(o, i, 0).getDate();
      s = Math.max(1, s), s = Math.min(f, s);
    }
    i && s && o != null && (r = kh(o, i - 1, s));
  }
  return r;
}, qf = (e, t = NN) => {
  const n = (o, a) => `0000${o}`.slice(-a), r = e.getMonth() + 1, i = e.getDate(), s = e.getFullYear();
  return t === pc ? [n(r, 2), n(i, 2), n(s, 4)].join("/") : [n(s, 4), n(r, 2), n(i, 2)].join("-");
}, a3 = (e, t, n) => {
  let r = !1;
  if (e) {
    r = !0;
    const i = e.split("/"), [s, o, a] = i.map((l) => {
      let c;
      const u = parseInt(l, 10);
      return Number.isNaN(u) || (c = u), c;
    });
    if (s && o && a != null) {
      const l = kh(a, s - 1, o);
      l.getMonth() === s - 1 && l.getDate() === o && l.getFullYear() === a && i[2].length === 4 && i2(l, t, n) && (r = !1);
    }
  }
  return r;
}, Vx = (e, t) => {
  const n = [];
  let r = 0;
  for (; r < e.length; ) {
    const i = [];
    for (; r < e.length && i.length < t; )
      i.push(e[parseInt(`${r}`)]), r += 1;
    n.push(i);
  }
  return /* @__PURE__ */ A(Ut, { children: n.map((i, s) => /* @__PURE__ */ A("tr", { children: i.map((o, a) => /* @__PURE__ */ A("td", { children: o }, `row_${s}_cell_${a}`)) }, `row_${s}`)) });
}, Bx = (e, t) => {
  if (e.key === "Tab") {
    const n = t.filter((d) => d && !d.disabled), r = document == null ? void 0 : document.activeElement, i = 0, s = n.length - 1, o = n[parseInt(`${i}`)], a = n[parseInt(`${s}`)], l = r instanceof HTMLButtonElement ? n.indexOf(r) : -1, c = l === s, u = l === i, f = l === -1;
    e.shiftKey ? (u || f) && (e.preventDefault(), a == null || a.focus()) : (c || f) && (e.preventDefault(), o == null || o.focus());
  }
}, zx = () => typeof navigator < "u" && (navigator.userAgent.match(/(iPod|iPhone|iPad)/g) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !window.MSStream, Rue = ({
  date: e,
  onClick: t,
  onKeyDown: n,
  onMouseMove: r,
  isDisabled: i = !1,
  isSelected: s = !1,
  isFocused: o = !1,
  isPrevMonth: a = !1,
  isFocusedMonth: l = !1,
  isNextMonth: c = !1,
  isToday: u = !1,
  isRangeDate: f = !1,
  isRangeStart: d = !1,
  isRangeEnd: h = !1,
  isWithinRange: m = !1,
  i18n: p = r1
}, y) => {
  const v = e.getDate(), g = e.getMonth(), x = e.getFullYear(), _ = e.getDay(), b = qf(e), C = o ? 0 : -1, E = $t("usa-date-picker__calendar__date", {
    "usa-date-picker__calendar__date--previous-month": a,
    "usa-date-picker__calendar__date--current-month": l,
    "usa-date-picker__calendar__date--next-month": c,
    "usa-date-picker__calendar__date--selected": s,
    "usa-date-picker__calendar__date--today": u,
    "usa-date-picker__calendar__date--focused": o,
    "usa-date-picker__calendar__date--range-date": f,
    "usa-date-picker__calendar__date--range-date-start": d,
    "usa-date-picker__calendar__date--range-date-end": h,
    "usa-date-picker__calendar__date--within-range": m
  }), S = p.months[parseInt(`${g}`)], k = p.daysOfWeek[parseInt(`${_}`)], M = () => {
    t(b);
  }, O = (I) => {
    n(I);
  }, R = () => {
    i || zx() || r(e);
  };
  return (
    // Ignoring error: "The attribute aria-selected is not supported by the role button. This role is implicit on the element button."
    // Ignoring because this attribute is present in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L1017)
    // eslint-disable-next-line jsx-a11y/role-supports-aria-props
    /* @__PURE__ */ A(
      "button",
      {
        type: "button",
        "data-testid": "select-date",
        ref: y,
        onClick: M,
        tabIndex: C,
        className: E,
        "data-day": v,
        "data-month": g + 1,
        "data-year": x,
        "data-value": b,
        "aria-label": `${v} ${S} ${x} ${k}`,
        "aria-selected": !!s,
        disabled: i,
        onKeyDown: O,
        onMouseMove: l ? R : void 0,
        children: v
      }
    )
  );
}, $ue = wi(Rue), Vue = ({
  date: e,
  minDate: t,
  maxDate: n,
  handleSelectMonth: r,
  i18n: i = r1
}) => {
  const s = e.getMonth(), [o, a] = Re(s), l = $e(null), c = $e(null);
  Le(() => {
    const h = l.current && l.current.querySelector(
      `[data-value="${o}"]`
    );
    h && h.focus();
  }, [o]);
  const u = (h) => {
    Bx(h, [c == null ? void 0 : c.current]);
  }, f = (h) => {
    var m;
    let p;
    const y = h.target, v = parseInt(((m = y.dataset) == null ? void 0 : m.value) || "", 10), g = Fa(e, v);
    switch (h.key) {
      case "ArrowUp":
      case "Up":
        p = v - 3;
        break;
      case "ArrowDown":
      case "Down":
        p = v + 3;
        break;
      case "ArrowLeft":
      case "Left":
        p = v - 1;
        break;
      case "ArrowRight":
      case "Right":
        p = v + 1;
        break;
      case "Home":
        p = v - v % 3;
        break;
      case "End":
        p = v + 2 - v % 3;
        break;
      case "PageDown":
        p = 11;
        break;
      case "PageUp":
        p = 0;
        break;
      default:
        return;
    }
    if (p !== void 0) {
      p = Math.max(0, Math.min(11, p));
      const x = Fa(e, p), _ = Xn(x, t, n);
      mo(g, _) || a(_.getMonth());
    }
    h.preventDefault();
  }, d = i.months.map((h, m) => {
    const p = Fa(e, m), y = Fue(
      p,
      t,
      n
    ), v = m === s, g = m === o, x = g ? 0 : -1, _ = $t("usa-date-picker__calendar__month", {
      "usa-date-picker__calendar__month--selected": v,
      "usa-date-picker__calendar__month--focused": g
    });
    return (
      // Ignoring error: "The attribute aria-selected is not supported by the role button. This role is implicit on the element button."
      // Ignoring because this attribute is present in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L1340)
      // eslint-disable-next-line jsx-a11y/role-supports-aria-props
      /* @__PURE__ */ A(
        "button",
        {
          type: "button",
          ref: g ? c : null,
          tabIndex: x,
          className: _,
          "data-value": m,
          "data-label": h,
          "aria-selected": v,
          disabled: y,
          onClick: () => {
            r(m);
          },
          onKeyDown: f,
          onMouseMove: () => {
            y || zx() || m !== o && a(m);
          },
          children: h
        },
        `selectMonth_${h}`
      )
    );
  });
  return (
    // Ignoring error: "Static HTML elements with event handlers require a role."
    // Ignoring because this element does not have a role in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L1345)
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ A(
      "div",
      {
        tabIndex: -1,
        "data-testid": "calendar-month-picker",
        className: "usa-date-picker__calendar__month-picker",
        ref: l,
        onKeyDown: u,
        children: /* @__PURE__ */ A("table", { className: "usa-date-picker__calendar__table", role: "presentation", children: /* @__PURE__ */ A("tbody", { children: Vx(d, 3) }) })
      }
    )
  );
}, Bue = ({
  date: e,
  minDate: t,
  maxDate: n,
  handleSelectYear: r,
  setStatuses: i
}) => {
  const s = $e(null), o = $e(null), a = $e(null), l = $e(null), c = e.getFullYear(), [u, f] = Re(c), [d, h] = Re([null, null]);
  let m = u;
  m -= m % Qr, m = Math.max(0, m);
  const p = Bm(
    Cs(e, m - 1),
    t,
    n
  ), y = Bm(
    Cs(e, m + Qr),
    t,
    n
  );
  Le(() => {
    const E = `Showing years ${m} to ${m + Qr - 1}. Select a year.`;
    i([E]);
    const [S, k] = d;
    if (S && k)
      S.disabled ? k.focus() : S.focus(), h([null, null]);
    else {
      const M = l.current && l.current.querySelector(
        ".usa-date-picker__calendar__year--focused"
      );
      M && M.focus();
    }
  }, [u]), Le(() => {
    const E = l.current && l.current.querySelector(
      `[data-value="${u}"]`
    );
    E && E.focus();
  }, []);
  const v = (E) => {
    Bx(E, [
      s == null ? void 0 : s.current,
      a == null ? void 0 : a.current,
      o == null ? void 0 : o.current
    ]);
  }, g = (E) => {
    var S;
    let k;
    const M = E.target, O = parseInt(((S = M.dataset) == null ? void 0 : S.value) || "", 10), R = Cs(e, O);
    switch (E.key) {
      case "ArrowUp":
      case "Up":
        k = O - 3;
        break;
      case "ArrowDown":
      case "Down":
        k = O + 3;
        break;
      case "ArrowLeft":
      case "Left":
        k = O - 1;
        break;
      case "ArrowRight":
      case "Right":
        k = O + 1;
        break;
      case "Home":
        k = O - O % 3;
        break;
      case "End":
        k = O + 2 - O % 3;
        break;
      case "PageDown":
        k = O + Qr;
        break;
      case "PageUp":
        k = O - Qr;
        break;
      default:
        return;
    }
    if (k !== void 0) {
      k = Math.max(0, k);
      const I = Cs(e, k), H = Xn(I, t, n);
      MN(R, H) || f(H.getFullYear());
    }
    E.preventDefault();
  }, x = [];
  let _ = m;
  for (; x.length < Qr; ) {
    const E = _, S = Bm(
      Cs(e, E),
      t,
      n
    ), k = E === c, M = E === u, O = M ? 0 : -1, R = $t("usa-date-picker__calendar__year", {
      "usa-date-picker__calendar__year--selected": k,
      "usa-date-picker__calendar__year--focused": M
    }), I = () => {
      r(E);
    }, H = () => {
      S || zx() || E !== u && f(E);
    };
    x.push(
      // Ignoring error: "The attribute aria-selected is not supported by the role button. This role is implicit on the element button."
      // Ignoring because this attribute is present in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L1447)
      // eslint-disable-next-line jsx-a11y/role-supports-aria-props
      /* @__PURE__ */ A(
        "button",
        {
          type: "button",
          tabIndex: O,
          ref: M ? a : null,
          className: R,
          "data-value": E,
          "aria-selected": k,
          disabled: S,
          onClick: I,
          onKeyDown: g,
          onMouseMove: H,
          children: E
        }
      )
    ), _ += 1;
  }
  const b = () => {
    let E = u - Qr;
    E = Math.max(0, E);
    let S = Cs(e, E);
    S = Xn(S, t, n), h([s.current, l.current]), f(S.getFullYear());
  }, C = () => {
    let E = u + Qr;
    E = Math.max(0, E);
    let S = Cs(e, E);
    S = Xn(S, t, n), h([o.current, l.current]), f(S.getFullYear());
  };
  return (
    // Ignoring error: "Static HTML elements with event handlers require a role."
    // Ignoring because this element does not have a role in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L1457)
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ A(
      "div",
      {
        tabIndex: -1,
        className: "usa-date-picker__calendar__year-picker",
        "data-testid": "calendar-year-picker",
        ref: l,
        onKeyDown: v,
        children: /* @__PURE__ */ A("table", { className: "usa-date-picker__calendar__table", role: "presentation", children: /* @__PURE__ */ A("tbody", { children: /* @__PURE__ */ Oe("tr", { children: [
          /* @__PURE__ */ A("td", { children: /* @__PURE__ */ A(
            "button",
            {
              type: "button",
              "data-testid": "previous-year-chunk",
              className: "usa-date-picker__calendar__previous-year-chunk",
              "aria-label": `Navigate back ${Qr} years`,
              disabled: p,
              onClick: b,
              ref: s
            }
          ) }),
          /* @__PURE__ */ A("td", { colSpan: 3, children: /* @__PURE__ */ A(
            "table",
            {
              className: "usa-date-picker__calendar__table",
              role: "presentation",
              children: /* @__PURE__ */ A("tbody", { children: Vx(x, 3) })
            }
          ) }),
          /* @__PURE__ */ A("td", { children: /* @__PURE__ */ A(
            "button",
            {
              type: "button",
              "data-testid": "next-year-chunk",
              className: "usa-date-picker__calendar__next-year-chunk",
              "aria-label": `Navigate forward ${Qr} years`,
              disabled: y,
              onClick: C,
              ref: o
            }
          ) })
        ] }) }) })
      }
    )
  );
}, ys = {
  DATE_PICKER: "DATE_PICKER",
  MONTH_PICKER: "MONTH_PICKER",
  YEAR_PICKER: "YEAR_PICKER"
}, zue = ({
  date: e,
  selectedDate: t,
  handleSelectDate: n,
  minDate: r,
  maxDate: i,
  rangeDate: s,
  setStatuses: o,
  focusMode: a,
  i18n: l = r1
}) => {
  const c = $e(null), u = $e(null), f = $e(null), d = $e(null), h = $e(null), m = $e(null), p = $e(null), y = $e(null), [v, g] = Re(e || Th()), [x, _] = Re(ys.DATE_PICKER), [b, C] = Re([null, null]);
  let E = !0;
  const S = (se) => {
    let ne = Fa(v, se);
    ne = Xn(ne, r, i), g(ne), _(ys.DATE_PICKER);
  }, k = (se) => {
    let ne = Cs(v, se);
    ne = Xn(ne, r, i), g(ne), _(ys.DATE_PICKER);
  }, M = Os(v, 0), O = v.getMonth(), R = v.getFullYear(), I = l.months[parseInt(`${O}`)], H = l.daysOfWeekShort, P = l.daysOfWeek, W = l.backOneYear, G = l.backOneMonth, J = `${I}. ${l.selectMonth}`, X = `${R}. ${l.selectYear}`, N = l.forwardOneMonth, U = l.forwardOneYear;
  if (Le(() => {
    E = !1;
  }, []), Le(() => {
    e && x === ys.DATE_PICKER && g(e);
  }, [e]), Le(() => {
    if (a !== ON.Input) {
      const [se, ne] = b;
      if (se && ne)
        se.disabled ? ne.focus() : se.focus(), C([null, null]);
      else {
        const he = y.current && y.current.querySelector(
          ".usa-date-picker__calendar__date--focused"
        );
        he && he.focus();
      }
    }
    if (E) {
      const se = [`${I} ${R}`];
      if (t && Fi(M, t)) {
        const ne = l.selectedDate;
        se.unshift(ne);
      }
      o(se);
    }
  }, [v]), x === ys.MONTH_PICKER)
    return /* @__PURE__ */ A(
      Vue,
      {
        date: v,
        minDate: r,
        maxDate: i,
        handleSelectMonth: S,
        i18n: l
      }
    );
  if (x === ys.YEAR_PICKER)
    return /* @__PURE__ */ A(
      Bue,
      {
        date: v,
        minDate: r,
        maxDate: i,
        handleSelectYear: k,
        setStatuses: o
      }
    );
  const ee = Vm(v), F = mc(v, 1), ue = $x(v), pe = mo(v, r), ce = i && mo(v, i), q = t || v, Z = s && Pue(q, s), oe = s && Due(q, s), le = Z && Os(Z, 1), ie = oe && n2(oe, 1), Y = (se) => {
    Bx(se, [
      c == null ? void 0 : c.current,
      u == null ? void 0 : u.current,
      h == null ? void 0 : h.current,
      m == null ? void 0 : m.current,
      f == null ? void 0 : f.current,
      d == null ? void 0 : d.current,
      p == null ? void 0 : p.current
    ]);
  }, Ce = (se) => {
    let ne;
    switch (se.key) {
      case "ArrowUp":
      case "Up":
        ne = Mue(v);
        break;
      case "ArrowDown":
      case "Down":
        ne = LN(v, 1);
        break;
      case "ArrowLeft":
      case "Left":
        ne = n2(v, 1);
        break;
      case "ArrowRight":
      case "Right":
        ne = Os(v, 1);
        break;
      case "Home":
        ne = s3(v);
        break;
      case "End":
        ne = Oue(v);
        break;
      case "PageDown":
        se.shiftKey ? ne = r2(v, 1) : ne = mc(v, 1);
        break;
      case "PageUp":
        se.shiftKey ? ne = o3(v) : ne = Vm(v);
        break;
      default:
        return;
    }
    if (ne !== void 0) {
      const he = Xn(
        ne,
        r,
        i
      );
      Fi(v, he) || g(ne);
    }
    se.preventDefault();
  }, Fe = (se) => {
    se !== v && g(se);
  }, je = () => {
    let se = o3(v);
    se = Xn(se, r, i), g(se), C([c.current, y.current]);
  }, Ze = () => {
    let se = Vm(v);
    se = Xn(se, r, i), g(se), C([u.current, y.current]);
  }, mt = () => {
    let se = mc(v, 1);
    se = Xn(se, r, i), g(se), C([f.current, y.current]);
  }, xn = () => {
    let se = r2(v, 1);
    se = Xn(se, r, i), g(se), C([d.current, y.current]);
  }, bt = () => {
    _(ys.MONTH_PICKER);
    const se = l.selectAMonth;
    o([se]);
  }, z = () => {
    _(ys.YEAR_PICKER);
  }, K = [];
  let Q = s3(ue);
  for (; K.length < 28 || Q.getMonth() === O || K.length % 7 !== 0; ) {
    const se = Fi(Q, M);
    K.push(
      /* @__PURE__ */ A(
        $ue,
        {
          date: Q,
          onClick: n,
          onKeyDown: Ce,
          onMouseMove: Fe,
          ref: se ? p : null,
          isDisabled: !i2(Q, r, i),
          isSelected: t && Fi(Q, t),
          isFocused: se,
          isPrevMonth: mo(Q, ee),
          isFocusedMonth: mo(Q, M),
          isNextMonth: mo(Q, F),
          isToday: Fi(Q, Th()),
          isRangeDate: s && Fi(Q, s),
          isRangeStart: Z && Fi(Q, Z),
          isRangeEnd: oe && Fi(Q, oe),
          isWithinRange: le && ie && i2(
            Q,
            le,
            ie
          ),
          i18n: l
        }
      )
    ), Q = Os(Q, 1);
  }
  return (
    // Ignoring error: "Static HTML elements with event handlers require a role."
    // Ignoring because this element does not have a role in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L1042)
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ Oe(
      "div",
      {
        tabIndex: -1,
        className: "usa-date-picker__calendar__date-picker",
        "data-testid": "calendar-date-picker",
        ref: y,
        onKeyDown: Y,
        children: [
          /* @__PURE__ */ Oe("div", { className: "usa-date-picker__calendar__row", children: [
            /* @__PURE__ */ A("div", { className: "usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items", children: /* @__PURE__ */ A(
              "button",
              {
                type: "button",
                "data-testid": "previous-year",
                onClick: je,
                ref: c,
                className: "usa-date-picker__calendar__previous-year",
                "aria-label": W,
                disabled: pe
              }
            ) }),
            /* @__PURE__ */ A("div", { className: "usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items", children: /* @__PURE__ */ A(
              "button",
              {
                type: "button",
                "data-testid": "previous-month",
                onClick: Ze,
                ref: u,
                className: "usa-date-picker__calendar__previous-month",
                "aria-label": G,
                disabled: pe
              }
            ) }),
            /* @__PURE__ */ Oe("div", { className: "usa-date-picker__calendar__cell usa-date-picker__calendar__month-label", children: [
              /* @__PURE__ */ A(
                "button",
                {
                  type: "button",
                  "data-testid": "select-month",
                  onClick: bt,
                  ref: h,
                  className: "usa-date-picker__calendar__month-selection",
                  "aria-label": J,
                  children: I
                }
              ),
              /* @__PURE__ */ A(
                "button",
                {
                  type: "button",
                  "data-testid": "select-year",
                  onClick: z,
                  ref: m,
                  className: "usa-date-picker__calendar__year-selection",
                  "aria-label": X,
                  children: R
                }
              )
            ] }),
            /* @__PURE__ */ A("div", { className: "usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items", children: /* @__PURE__ */ A(
              "button",
              {
                type: "button",
                "data-testid": "next-month",
                onClick: mt,
                ref: f,
                className: "usa-date-picker__calendar__next-month",
                "aria-label": N,
                disabled: ce
              }
            ) }),
            /* @__PURE__ */ A("div", { className: "usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items", children: /* @__PURE__ */ A(
              "button",
              {
                type: "button",
                "data-testid": "next-year",
                onClick: xn,
                ref: d,
                className: "usa-date-picker__calendar__next-year",
                "aria-label": U,
                disabled: ce
              }
            ) })
          ] }),
          /* @__PURE__ */ Oe("table", { className: "usa-date-picker__calendar__table", children: [
            /* @__PURE__ */ A("thead", { children: /* @__PURE__ */ A("tr", { children: H.map((se, ne) => /* @__PURE__ */ A(
              "th",
              {
                className: "usa-date-picker__calendar__day-of-week",
                scope: "col",
                "aria-label": P[parseInt(`${ne}`)],
                children: se
              },
              `day-of-week-${se}-${ne}`
            )) }) }),
            /* @__PURE__ */ A("tbody", { children: Vx(K, 7) })
          ] })
        ]
      }
    )
  );
};
var ON = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Input = 1] = "Input", e))(ON || {});
const Hue = ({
  id: e,
  name: t,
  className: n,
  validationStatus: r,
  defaultValue: i,
  disabled: s,
  required: o,
  minDate: a = Lue,
  maxDate: l,
  rangeDate: c,
  onChange: u,
  onBlur: f,
  i18n: d = r1,
  ...h
}) => {
  const m = $e(null), p = $e(null), y = r === "error", v = r === "success", [g, x] = Re(""), [_, b] = Re(""), [C, E] = Re(!1), [S, k] = Re(void 0), [M, O] = Re(0), [R, I] = Re([]), [H, P] = Re(
    0
    /* None */
  ), [W, G] = Re(
    void 0
  ), J = Li(a), X = l ? Li(l) : void 0, N = c ? Li(c) : void 0, U = () => {
    var Y, Ce, Fe, je;
    const Ze = a3(_, J, X);
    Ze && !((Y = p == null ? void 0 : p.current) != null && Y.validationMessage) && ((Ce = p == null ? void 0 : p.current) == null || Ce.setCustomValidity(i3)), !Ze && ((Fe = p == null ? void 0 : p.current) == null ? void 0 : Fe.validationMessage) === i3 && ((je = p == null ? void 0 : p.current) == null || je.setCustomValidity(""));
  }, ee = (Y, Ce = !0) => {
    var Fe;
    const je = Li(Y), Ze = je && qf(je, pc);
    je && x(Y), Ze && b(Ze), u && u(Ze), Ce && (E(!1), I([]), (Fe = p == null ? void 0 : p.current) == null || Fe.focus());
  }, F = (Y) => {
    const Ce = Y.target.value;
    b(Ce), u && u(Ce);
    const Fe = Li(Ce, pc, !0);
    let je = "";
    if (Fe && !a3(Ce, J, X) && (je = qf(Fe)), g !== je && x(je), Fe && C) {
      const Ze = Xn(
        Fe,
        J,
        X
      );
      k(Ze);
    }
  };
  Le(() => {
    i && ee(i, !1);
  }, []), Le(() => {
    if (C) {
      const Y = m.current && m.current.querySelector(
        ".usa-date-picker__calendar__date--focused"
      );
      Y && Y.focus();
    }
  }, [C]), Le(() => {
    U();
  }, [_, a, l]);
  const ue = () => {
    var Y;
    if (C)
      I([]);
    else {
      const Ce = Li(
        _,
        pc,
        !0
      ), Fe = Xn(
        Ce || i && Li(i) || Th(),
        J,
        X
      );
      k(Fe), O((Y = m == null ? void 0 : m.current) == null ? void 0 : Y.offsetHeight);
      const je = d.statuses, Ze = Li(g);
      if (Ze && Fi(Ze, Os(Fe, 0))) {
        const mt = d.selectedDate;
        je.unshift(mt);
      }
      I(je);
    }
    E(!C);
  }, pe = (Y) => {
    var Ce;
    (Ce = m.current) != null && Ce.contains(Y == null ? void 0 : Y.relatedTarget) || (C && (E(!1), I([])), f && f(Y));
  }, ce = (Y) => {
    var Ce;
    Y.key === "Escape" && (C && (E(!1), I([]), (Ce = p == null ? void 0 : p.current) == null || Ce.focus()), Y.preventDefault());
  }, q = (Y) => {
    G(Y.keyCode);
  }, Z = (Y) => {
    Y.keyCode !== W && Y.preventDefault();
  }, oe = $t(
    "usa-date-picker",
    "usa-date-picker--initialized",
    {
      "usa-date-picker--active": C
    },
    n
  ), le = $t(
    "usa-input",
    "usa-date-picker__external-input",
    {
      "usa-input--error": y,
      "usa-input--success": v
    }
  ), ie = d.toggleCalendar;
  return (
    // Ignoring error: "Static HTML elements with event handlers require a role."
    // Ignoring because this element does not have a role in the USWDS implementation (https://github.com/uswds/uswds/blob/develop/src/js/components/date-picker.js#L828)
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ Oe(
      "div",
      {
        "data-testid": "date-picker",
        className: oe,
        ref: m,
        onBlur: pe,
        onKeyDown: ce,
        children: [
          /* @__PURE__ */ A(
            "input",
            {
              ...h,
              name: t,
              "data-testid": "date-picker-internal-input",
              className: "usa-input usa-sr-only usa-date-picker__internal-input",
              type: "text",
              "aria-hidden": !0,
              tabIndex: -1,
              required: !1,
              disabled: !1,
              value: g,
              readOnly: !0
            }
          ),
          /* @__PURE__ */ Oe("div", { className: "usa-date-picker__wrapper", tabIndex: -1, children: [
            /* @__PURE__ */ A(
              "input",
              {
                ...h,
                id: e,
                "data-testid": "date-picker-external-input",
                className: le,
                type: "text",
                disabled: s,
                required: o,
                value: _,
                ref: p,
                onInput: F,
                onFocus: () => {
                  P(
                    1
                    /* Input */
                  );
                },
                onBlur: (Y) => {
                  P(
                    0
                    /* None */
                  ), f && f(Y);
                }
              }
            ),
            /* @__PURE__ */ A(
              "button",
              {
                "data-testid": "date-picker-button",
                type: "button",
                className: "usa-date-picker__button",
                "aria-haspopup": !0,
                "aria-label": ie,
                disabled: s,
                onClick: ue
              }
            ),
            /* @__PURE__ */ A(
              "div",
              {
                "data-testid": "date-picker-calendar",
                className: "usa-date-picker__calendar",
                role: "application",
                hidden: !C,
                "data-value": S && qf(S),
                style: { top: `${M}px` },
                onKeyDown: q,
                onKeyUp: Z,
                children: C && /* @__PURE__ */ A(
                  zue,
                  {
                    date: S,
                    handleSelectDate: ee,
                    minDate: J,
                    maxDate: X,
                    rangeDate: N,
                    selectedDate: Li(g),
                    setStatuses: I,
                    focusMode: H,
                    i18n: d
                  }
                )
              }
            ),
            /* @__PURE__ */ A(
              "div",
              {
                "data-testid": "date-picker-status",
                className: "usa-sr-only usa-date-picker__status",
                role: "status",
                "aria-live": "polite",
                children: R.join(". ")
              }
            )
          ] })
        ]
      }
    )
  );
}, l3 = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", Uue = ({
  imageId: e,
  file: t
}) => {
  const n = $e(new FileReader()), [r, i] = Re(!0), [s, o] = Re(l3), [a, l] = Re(!1);
  Le(() => (n.current.onloadend = () => {
    i(!1), o(n.current.result);
  }, n.current.readAsDataURL(t), () => {
    n.current.onloadend = null;
  }), []);
  const { name: c } = t, u = () => {
    o(l3), l(!0);
  }, f = c.indexOf(".pdf") > 0, d = c.indexOf(".doc") > 0 || c.indexOf(".pages") > 0, h = c.indexOf(".mov") > 0 || c.indexOf(".mp4") > 0, m = c.indexOf(".xls") > 0 || c.indexOf(".numbers") > 0, p = $t("usa-file-input__preview-image", {
    "is-loading": r,
    "usa-file-input__preview-image--pdf": a && f,
    "usa-file-input__preview-image--word": a && d,
    "usa-file-input__preview-image--video": a && h,
    "usa-file-input__preview-image--excel": a && m,
    "usa-file-input__preview-image--generic": a && !f && !d && !h && !m
  });
  return /* @__PURE__ */ Oe(
    "div",
    {
      "data-testid": "file-input-preview",
      className: "usa-file-input__preview",
      "aria-hidden": "true",
      children: [
        /* @__PURE__ */ A(
          "img",
          {
            id: e,
            "data-testid": "file-input-preview-image",
            src: s,
            alt: "",
            className: p,
            onError: u
          }
        ),
        c
      ]
    }
  );
}, jue = (e) => e.replace(/[^a-z0-9]/g, function(t) {
  const n = t.charCodeAt(0);
  return n === 32 ? "-" : n >= 65 && n <= 90 ? `img_${t.toLowerCase()}` : `__${n.toString(16).slice(-4)}`;
}), Wue = ({
  name: e,
  id: t,
  dragText: n,
  chooseText: r,
  errorText: i,
  disabled: s,
  multiple: o,
  className: a,
  accept: l,
  onChange: c,
  onDrop: u,
  ...f
}, d) => {
  const h = $e(null), [m, p] = Re(!1), [y, v] = Re(!1), [g, x] = Re([]), [_, b] = Re(!1);
  Le(() => {
    if (typeof navigator > "u") return;
    const X = /rv:11.0/i.test(navigator == null ? void 0 : navigator.userAgent) || /Edge\/\d./i.test(navigator == null ? void 0 : navigator.userAgent);
    b(X);
  }, [typeof navigator]), _2(
    d,
    () => ({
      input: h.current,
      clearFiles: () => x([]),
      files: g
    }),
    [g]
  );
  const C = $t(
    "usa-file-input",
    {
      "usa-file-input--disabled": s
    },
    a
  ), E = $t("usa-file-input__target", {
    "usa-file-input--drag": m,
    "has-invalid-file": y
  }), S = o ? "Drag files here or " : "Drag file here or ", k = "choose from folder", M = "This is not a valid file type.", O = [];
  if (g)
    for (let X = 0; X < (g == null ? void 0 : g.length); X++) {
      const N = jue(g[parseInt(`${X}`)].name), U = `filePreview_${N}`;
      O.push(
        /* @__PURE__ */ A(
          Uue,
          {
            imageId: N,
            file: g[parseInt(`${X}`)]
          },
          U
        )
      );
    }
  const R = $t("usa-file-input__instructions", {
    "display-none": O.length > 0
  }), I = O.length > 1 ? `${O.length} files selected` : "Selected file", H = (X) => {
    if (v(!1), l) {
      const N = l.split(",");
      let U = !0;
      for (let ee = 0; ee < X.dataTransfer.files.length; ee += 1) {
        const F = X.dataTransfer.files[parseInt(`${ee}`)];
        if (U)
          for (let ue = 0; ue < N.length; ue += 1) {
            const pe = N[parseInt(`${ue}`)];
            if (U = F.name.indexOf(pe) > 0 || F.type.includes(pe.replace(/\*/g, "")), U) break;
          }
        else break;
      }
      U || (x([]), v(!0), X.preventDefault(), X.stopPropagation());
    }
  }, P = () => p(!0), W = () => p(!1), G = (X) => {
    H(X), p(!1), u && u(X);
  }, J = (X) => {
    var N, U, ee, F;
    v(!1);
    const ue = [];
    if ((U = (N = X.target) == null ? void 0 : N.files) != null && U.length) {
      const pe = ((F = (ee = X.target) == null ? void 0 : ee.files) == null ? void 0 : F.length) || 0;
      for (let ce = 0; ce < pe; ce++) {
        const q = X.target.files.item(ce);
        q && ue.push(q);
      }
    }
    x(ue), c && c(X);
  };
  return /* @__PURE__ */ A(
    "div",
    {
      "data-testid": "file-input",
      className: C,
      "aria-disabled": s,
      children: /* @__PURE__ */ Oe(
        "div",
        {
          "data-testid": "file-input-droptarget",
          className: E,
          onDragOver: P,
          onDragLeave: W,
          onDrop: G,
          children: [
            O.length > 0 && /* @__PURE__ */ Oe(
              "div",
              {
                "data-testid": "file-input-preview-heading",
                className: "usa-file-input__preview-heading",
                children: [
                  I,
                  " ",
                  /* @__PURE__ */ Oe("span", { className: "usa-file-input__choose", children: [
                    "Change file",
                    O.length > 1 && "s"
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ Oe(
              "div",
              {
                "data-testid": "file-input-instructions",
                className: R,
                "aria-hidden": "true",
                children: [
                  !_ && /* @__PURE__ */ A("span", { className: "usa-file-input__drag-text", children: n || S }),
                  /* @__PURE__ */ A("span", { className: "usa-file-input__choose", children: r || k })
                ]
              }
            ),
            O,
            /* @__PURE__ */ A("div", { "data-testid": "file-input-box", className: "usa-file-input__box" }),
            y && /* @__PURE__ */ A(
              "div",
              {
                "data-testid": "file-input-error",
                className: "usa-file-input__accepted-files-message",
                children: i || M
              }
            ),
            /* @__PURE__ */ A(
              "input",
              {
                ...f,
                ref: h,
                type: "file",
                "data-testid": "file-input-input",
                name: e,
                id: t,
                className: "usa-file-input__input",
                disabled: s,
                onChange: J,
                multiple: o,
                accept: l
              }
            )
          ]
        }
      )
    }
  );
};
wi(Wue);
const c3 = ({
  id: e,
  name: t,
  className: n,
  inputRef: r,
  children: i,
  validationStatus: s,
  ...o
}) => {
  const a = $t(
    "usa-select",
    {
      "usa-input--error": s === "error",
      "usa-input--success": s === "success"
    },
    n
  );
  return /* @__PURE__ */ A(
    "select",
    {
      "data-testid": "Select",
      className: a,
      id: e,
      name: t,
      ref: r,
      ...o,
      children: i
    }
  );
}, Jue = (e) => {
  const [t, n] = Re(e || !1), r = (i) => {
    const s = i.target;
    return i && s && s.closest(".usa-modal") ? s.hasAttribute("[data-close-modal]") || !!s.closest("[data-close-modal]") : !0;
  };
  return { isOpen: t, toggleModal: (i, s) => i && !r(i) ? (i.stopPropagation(), !1) : (n(s === !0 ? !0 : s === !1 ? !1 : (o) => !o), !0) };
}, Kue = () => {
  var e;
  if (typeof document < "u") {
    const t = document.createElement("div");
    t.setAttribute(
      "style",
      "visibility: hidden; overflow: scroll; ms-overflow-style: scrollbar"
    ), document.body.appendChild(t);
    const n = document.createElement("div");
    t.appendChild(n);
    const r = `${t.offsetWidth - n.offsetWidth}px`;
    return (e = t.parentNode) == null || e.removeChild(t), r;
  }
  return "";
}, que = ({
  handleClose: e,
  ...t
}) => /* @__PURE__ */ A(
  Dx,
  {
    "aria-label": "Close this window",
    ...t,
    className: "usa-modal__close",
    onClick: e,
    "data-close-modal": !0,
    type: "button",
    children: /* @__PURE__ */ A(Fx.Close, { "aria-hidden": "true" })
  }
), Gue = ({
  modalId: e,
  className: t,
  children: n,
  handleClose: r,
  isLarge: i = !1,
  forceAction: s = !1,
  ...o
}, a) => {
  const l = $t(
    "usa-modal",
    {
      "usa-modal--lg": i
    },
    t
  );
  return /* @__PURE__ */ A(
    "div",
    {
      ...o,
      "data-testid": "modalWindow",
      className: l,
      ref: a,
      "data-force-action": s,
      children: /* @__PURE__ */ Oe("div", { className: "usa-modal__content", children: [
        /* @__PURE__ */ A("div", { className: "usa-modal__main", children: n }),
        !s && /* @__PURE__ */ A(que, { "aria-controls": e, handleClose: r })
      ] })
    }
  );
}, Yue = wi(Gue), Xue = ({ id: e, children: t, isVisible: n, forceAction: r, className: i, handleClose: s, ...o }, a) => {
  const l = $t(
    "usa-modal-wrapper",
    {
      "is-visible": n,
      "is-hidden": !n
    },
    i
  );
  return /* @__PURE__ */ A("div", { ...o, ref: a, id: e, className: l, role: "dialog", children: /* @__PURE__ */ A(
    "div",
    {
      "data-testid": "modalOverlay",
      className: "usa-modal-overlay",
      onClick: r ? void 0 : s,
      "aria-controls": e,
      children: t
    }
  ) });
}, Zue = wi(Xue), Que = ({
  id: e,
  children: t,
  isLarge: n = !1,
  forceAction: r = !1,
  modalRoot: i = ".usa-modal-wrapper",
  renderToPortal: s = !0,
  isInitiallyOpen: o,
  ...a
}, l) => {
  const { isOpen: c, toggleModal: u } = Jue(o), [f, d] = Re(!1), h = $e(), m = $e(), p = $e(null), y = `body > *:not(${i || ".usa-modal-wrapper"}):not([aria-hidden])`, v = "[data-modal-hidden]", g = (S) => {
    u(S, !1);
  };
  _2(
    l,
    () => ({
      modalId: e,
      modalIsOpen: c,
      toggleModal: u
    }),
    [e, c]
  );
  const x = () => {
    const { body: S } = document;
    S.style.paddingRight = m.current || "", S.classList.add("usa-js-modal--active"), document.querySelectorAll(y).forEach((k) => {
      k.setAttribute("aria-hidden", "true"), k.setAttribute("data-modal-hidden", "");
    }), r && S.classList.add("usa-js-no-click");
  }, _ = () => {
    const { body: S } = document;
    S.style.paddingRight = h.current || "", S.classList.remove("usa-js-modal--active"), S.classList.remove("usa-js-no-click"), document.querySelectorAll(v).forEach((k) => {
      k.removeAttribute("aria-hidden"), k.removeAttribute("data-modal-hidden");
    });
  };
  Le(() => {
    const S = Kue(), k = window.getComputedStyle(document.body).getPropertyValue("padding-right") || "0px", M = `${parseInt(k.replace(/px/, ""), 10) + parseInt(S.replace(/px/, ""), 10)}px`;
    return h.current = k, m.current = M, d(!0), () => {
      _();
    };
  }, []), Le(() => {
    f && (c === !0 ? x() : c === !1 && _());
  }, [c]);
  const b = a["aria-labelledby"], C = a["aria-describedby"];
  b || console.error(`${e} is missing aria-labelledby attribute`), C || console.error(`${e} is missing aria-describedby attribute`), delete a["aria-labelledby"], delete a["aria-describedby"];
  const E = /* @__PURE__ */ A(RI, { active: c, focusTrapOptions: {
    initialFocus: () => {
      var S;
      return ((S = p.current) == null ? void 0 : S.querySelector("[data-focus]")) || p.current || !1;
    },
    escapeDeactivates: () => r ? !1 : (g(), !0)
  }, children: /* @__PURE__ */ A(
    Zue,
    {
      role: "dialog",
      id: e,
      "aria-labelledby": b,
      "aria-describedby": C,
      "data-force-action": r,
      isVisible: c,
      handleClose: g,
      forceAction: r,
      children: /* @__PURE__ */ A(
        Yue,
        {
          modalId: e,
          ...a,
          ref: p,
          isLarge: n,
          forceAction: r,
          tabIndex: -1,
          handleClose: g,
          children: t
        }
      )
    }
  ) });
  if (s) {
    const S = document.getElementById("modal-root") || document.body;
    return iC.createPortal(E, S);
  } else
    return E;
};
wi(Que);
function efe() {
  return /* @__PURE__ */ Oe(
    "svg",
    {
      width: "24",
      height: "18",
      viewBox: "0 0 24 18",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ A("path", { d: "M0 0H13V18H0V0Z", fill: "black" }),
        /* @__PURE__ */ A("path", { d: "M27.7391 14V17.5H16V14H27.7391Z", fill: "black" }),
        /* @__PURE__ */ A("path", { d: "M27.7391 0V3.5H16V0H27.7391Z", fill: "black" }),
        /* @__PURE__ */ A("path", { d: "M27.7391 7.5V11H16V7.5H27.7391Z", fill: "black" })
      ]
    }
  );
}
const PN = (e) => {
  const t = {};
  return e == null || e.map((n) => {
    const r = n.metadata.id;
    t[r] = {
      data: n.metadata
    };
  }), t;
}, tfe = al({});
function nfe(e) {
  return e.map((t) => (t.metadata && t.metadata.layers && t.metadata.layers.forEach((n) => {
    n.mapLabel && typeof n.mapLabel == "string" && console.warn(
      "mapLabel as string functions are not automatically evaluated for security reasons"
    ), n.compare && n.compare.mapLabel && typeof n.compare.mapLabel == "string" && console.warn(
      "compare.mapLabel as string functions are not automatically evaluated for security reasons"
    );
  }), t));
}
function Hx({
  initialDatasets: e = void 0,
  children: t
}) {
  const [n, r] = Re(
    nfe(e)
  ), i = {
    datasets: n,
    setDatasets: r
  };
  return /* @__PURE__ */ A(tfe.Provider, { value: i, children: /* @__PURE__ */ A($I, { children: t }) });
}
function Ux({ children: e }) {
  return /* @__PURE__ */ A(
    VI,
    {
      config: {
        envMapboxToken: process.env.NEXT_PUBLIC_MAPBOX_TOKEN ?? "",
        envApiStacEndpoint: process.env.NEXT_PUBLIC_API_STAC_ENDPOINT ?? "",
        envApiRasterEndpoint: process.env.NEXT_PUBLIC_API_RASTER_ENDPOINT ?? ""
      },
      children: e
    }
  );
}
const rfe = {
  zIndices: {
    hide: -1,
    docked: 10,
    sticky: 900,
    dropdown: 1550,
    overlay: 1300,
    modal: 1400,
    popover: 1500,
    skipLink: 1600,
    toast: 1700,
    tooltip: 1800
  },
  color: {
    base: "#2c3e50",
    primary: "#d83933",
    link: "#6f3331",
    danger: "#FC3D21",
    infographicA: "#fcab10",
    infographicB: "#f4442e",
    infographicC: "#b62b6e",
    infographicD: "#2ca58d",
    infographicE: "#2276ac"
  },
  type: {
    base: {
      leadSize: "1.25rem",
      extrabold: "800",
      line: "inherit",
      // Increments to the type.base.size for each media breakpoint.
      sizeIncrement: {
        small: "0rem",
        medium: "0rem",
        large: "0.25rem",
        xlarge: "0.25rem"
      }
    },
    heading: {
      settings: '"wdth" 100, "wght" 700'
    }
  },
  layout: {
    min: "384px",
    max: "1440px",
    glspMultiplier: {
      xsmall: 1,
      small: 1,
      medium: 1.5,
      large: 2,
      xlarge: 2
    }
  }
};
function jx({
  children: e
}) {
  return /* @__PURE__ */ A(BI, { theme: YI(rfe), children: e });
}
function DN(e) {
  const t = e.allAvailableDatasets || [], n = PN(t);
  return /* @__PURE__ */ A(jx, { children: /* @__PURE__ */ A(Ux, { children: /* @__PURE__ */ A(Hx, { initialDatasets: t, children: /* @__PURE__ */ A("div", { className: "relative w-full h-[250px]", children: /* @__PURE__ */ A(zI, { ...e, datasets: n }) }) }) }) });
}
const Wx = {
  dataPath: "/charts/story/hurricane-maria-ida-chart1.csv",
  dateFormat: "%m/%Y",
  idKey: "Zip",
  xKey: "Month",
  yKey: "Number of Tarps",
  yAxisLabel: "Y TESSTSTST",
  xAxisLabel: "x axis test",
  highlightStart: "08/2021",
  highlightEnd: "09/2021",
  highlightLabel: "Fire Ignition",
  availableDomain: "[6/2021, 9/2022]",
  altTitle: "test title",
  altDesc: "test description",
  colorScheme: "Blues"
}, ife = (e) => {
  const t = (n) => typeof e[n] == "string" ? e[n].replace(/[\\[\](){}]/g, "").split(",").map((s) => s.trim()) : Wx[n];
  try {
    return /* @__PURE__ */ A(
      DN,
      {
        ...e,
        colors: t("colors"),
        availableDomain: t("availableDomain")
      }
    );
  } catch (n) {
    return console.error("Error rendering chart:", n), /* @__PURE__ */ A("div", { className: "h-[400px] flex items-center justify-center bg-red-50 border border-red-300 rounded", children: /* @__PURE__ */ A("div", { className: "text-red-500", children: "Error rendering chart component" }) });
  }
}, go = {
  center: "[-94.5, 41.25]",
  zoom: "8.3",
  datasetId: "vulcan-ffco2-yeargrid-v4",
  layerId: "vulcan-total-co2",
  dateTime: "2020-12-31",
  compareDateTime: "2015-12-31",
  compareLabel: "2020 VS 2015",
  attrUrl: "",
  attrAuthor: "",
  caption: ""
}, sfe = (e) => {
  const t = It(Iu);
  return /* @__PURE__ */ Oe(
    Du,
    {
      onClick: () => {
        try {
          t({
            name: "Map",
            kind: "text",
            props: { ...go }
          });
        } catch (r) {
          console.error("Error inserting Map component:", r), alert("Could not insert Map component. See console for details.");
        }
      },
      title: "Insert Map",
      className: "text-sm display-flex flex-align-center padding-1",
      children: [
        /* @__PURE__ */ A(Fx.Map, { className: "margin-right-05 width-3 height-3" }),
        "Add Map"
      ]
    }
  );
}, ofe = (e) => {
  const t = It(Iu);
  return /* @__PURE__ */ Oe(
    Du,
    {
      onClick: () => {
        try {
          t({
            name: "Chart",
            kind: "text",
            props: { ...Wx }
          });
        } catch (r) {
          console.error("Error inserting Map component:", r), alert("Could not insert chart component. See console for details.");
        }
      },
      title: "Insert Map",
      className: "text-sm display-flex flex-align-center padding-1",
      children: [
        /* @__PURE__ */ A(Fx.Insights, { className: "margin-right-05 width-3 height-3" }),
        "line graph"
      ]
    }
  );
}, afe = (e) => {
  const t = It(Iu);
  return /* @__PURE__ */ A(
    Du,
    {
      onClick: () => {
        try {
          t({
            name: "Break",
            kind: "text",
            props: {}
          });
        } catch (r) {
          console.error("Error inserting Map component:", r), alert("Could not insert chart component. See console for details.");
        }
      },
      title: "Insert Map",
      className: "text-sm display-flex flex-align-center padding-1",
      children: "Insert Break"
    }
  );
}, lfe = () => {
  const e = It(Iu);
  return /* @__PURE__ */ Oe(
    Du,
    {
      onClick: () => {
        try {
          e({
            name: "TwoColumn",
            kind: "flow",
            props: {},
            // The children need to be valid MDAST nodes.
            // An empty paragraph is added to each column to make them editable from the start.
            children: [
              {
                type: "mdxJsxFlowElement",
                name: "LeftColumn",
                attributes: [],
                children: [{ type: "paragraph", children: [{ type: "text", value: "" }] }]
              },
              {
                type: "mdxJsxFlowElement",
                name: "RightColumn",
                attributes: [],
                children: [{ type: "paragraph", children: [{ type: "text", value: "" }] }]
              }
            ]
          });
        } catch (n) {
          console.error("Error inserting TwoColumn component:", n), alert("Could not insert TwoColumn component. See console for details.");
        }
      },
      className: "text-sm display-flex flex-align-center padding-1",
      children: [
        /* @__PURE__ */ A("div", { className: "margin-right-05 width-3 height-3 flex-align-center display-flex", children: /* @__PURE__ */ A(efe, {}) }),
        "Insert 2 Column"
      ]
    }
  );
}, cfe = ({ props: e }) => {
  const { mdastNode: t } = e, n = kl();
  Le(() => {
    var o, a;
    const i = (o = t.children) == null ? void 0 : o.some(
      (l) => l.name === "LeftColumn"
    ), s = (a = t.children) == null ? void 0 : a.some(
      (l) => l.name === "RightColumn"
    );
    if (!i || !s) {
      const l = [...t.children || []];
      i || l.push({
        type: "mdxJsxFlowElement",
        name: "LeftColumn",
        children: [{ type: "paragraph", children: [{ type: "text", value: "" }] }]
      }), s || l.push({
        type: "mdxJsxFlowElement",
        name: "RightColumn",
        children: [{ type: "paragraph", children: [{ type: "text", value: "" }] }]
      }), n({ ...t, children: l });
    }
  }, [t, n]);
  const r = (i) => /* @__PURE__ */ A(
    xx,
    {
      getContent: (s) => {
        var o;
        return ((o = s.children.find((a) => a.name === i)) == null ? void 0 : o.children) || [];
      },
      block: !0,
      getUpdatedMdastNode: (s, o) => {
        const a = s.children.map(
          (l) => l.name === i ? { ...l, children: o } : l
        );
        return { ...s, children: a };
      }
    }
  );
  return /* @__PURE__ */ A("div", { className: "grid-container maxw-full", children: /* @__PURE__ */ Oe("div", { className: "grid-row", children: [
    /* @__PURE__ */ A("div", { className: "grid-col border rounded-md p-2", children: r("LeftColumn") }),
    /* @__PURE__ */ A("div", { className: "grid-col border rounded-md p-2", children: r("RightColumn") })
  ] }) });
}, FN = al(null), ufe = ({
  children: e,
  value: t
}) => /* @__PURE__ */ A(FN.Provider, { value: t, children: e }), ffe = () => {
  const e = ll(FN);
  if (!e)
    throw new Error("useMapContext must be used within a MapContextProvider");
  return e;
}, dfe = (e) => {
  const t = {
    "%d": "(0[1-9]|[12][0-9]|3[01])",
    "%m": "(0[1-9]|1[0-2])",
    "%Y": "\\d{4}",
    "%y": "\\d{2}",
    "%H": "([01][0-9]|2[0-3])",
    "%M": "([0-5][0-9])",
    "%S": "([0-5][0-9])"
  }, n = (i) => i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  let r = "";
  for (let i = 0; i < e.length; i++)
    if (e[i] === "%" && i < e.length - 1) {
      const s = e[i] + e[i + 1];
      r += t[s] || n(s), i++;
    } else
      r += n(e[i]);
  return new RegExp(`^${r}$`);
}, Es = (e, t) => !dfe(e).test(t), hfe = (e, t, n, r, i, s, o) => {
  e === "highlightStart" || e === "highlightEnd" ? Es(t.draftDateFormat, i) === !1 ? (n({
    highlightStart: Es(
      t.draftDateFormat,
      t.draftHighlightStart
    ),
    highlightEnd: Es(
      t.draftDateFormat,
      t.draftHighlightEnd
    )
  }), r.highlightStart == !1 && r.highlightEnd == !1 && s({
    ...o,
    dateFormat: t.draftDateFormat,
    highlightStart: t.draftHighlightStart,
    highlightEnd: t.draftHighlightEnd
  })) : n({
    highlightStart: Es(
      t.draftDateFormat,
      t.draftHighlightStart
    ),
    highlightEnd: Es(
      t.draftDateFormat,
      t.draftHighlightEnd
    )
  }) : e === "dateFormat" ? n({
    highlightStart: Es(i, o.highlightStart),
    highlightEnd: Es(i, o.highlightEnd)
  }) : r.highlightStart == !1 && r.highlightEnd == !1 && s({
    ...o,
    dateFormat: t.draftDateFormat,
    highlightStart: t.draftHighlightStart,
    highlightEnd: t.draftHighlightEnd
  });
}, pfe = (e, t, n, r, i, s, o) => {
  Es(t.defaultDateFormat, i) === !1 || i === "" ? (r({ ...n, [e]: !1 }), s({ ...o, [e]: i })) : r({ ...n, [e]: !0 });
}, mfe = (e, t, n, r, i, s, o) => {
  const a = /^\[[+-]?(0|[1-9][0-9]*)(\.[0-9]+)?(?:,\s*[+-]?(0|[1-9][0-9]*)(\.[0-9]+)?)*\]$/, l = i.replace(/\s/g, "");
  if (a.test(l)) {
    const c = JSON.parse(l), u = (d) => d <= 180 && d >= -180, f = (d) => d <= 90 && d >= -90;
    u(c[0]) && f(c[1]) ? (r({ ...n, [e]: !1 }), s({ ...o, [e]: i })) : r({ ...n, [e]: !0 });
  } else
    r({ ...n, [e]: !0 });
}, mf = (e, t) => e && !t ? { validationStatus: "error" } : "", gfe = [
  "Blues",
  "Greens",
  "Greys",
  "Oranges",
  "Purples",
  "Reds",
  "Turbo",
  "Viridis",
  "Inferno",
  "Magma",
  "Plasma",
  "Cividis",
  "Warm",
  "Cool",
  "CubehelixDefault"
], vfe = (e) => {
  const {
    value: t,
    isRequired: n,
    type: r,
    fieldName: i,
    hint: s,
    onChange: o,
    componentProps: a,
    propName: l,
    placeHolder: c,
    validateAgainst: u,
    draftInputs: f,
    setDraftInputs: d,
    inputErrors: h,
    setInputErrors: m,
    options: p
  } = e;
  if (p && Array.isArray(p))
    return /* @__PURE__ */ Oe(Ut, { children: [
      /* @__PURE__ */ A(Ul, { htmlFor: l, className: "margin-top-2", children: i }),
      /* @__PURE__ */ A("span", { className: "usa-hint", children: s }),
      /* @__PURE__ */ Oe(
        c3,
        {
          id: l,
          name: l,
          value: t,
          onChange: (_) => o({ ...a, [l]: _.target.value }),
          ...mf(n, t),
          children: [
            /* @__PURE__ */ A("option", { value: "", children: "- Select option -" }),
            p.map((_) => {
              const b = typeof _ == "object" ? _.value : _, C = typeof _ == "object" ? _.label : _;
              return /* @__PURE__ */ A("option", { value: b, children: C }, b);
            })
          ]
        }
      )
    ] });
  const y = r !== void 0 && r.toLowerCase(), [v, g] = Re(t), x = $e(null);
  switch (Le(() => (l === "dateFormat" && v != f.draftDateFormat && d({ ...f, draftDateFormat: v }), l === "highlightStart" && v != f.draftHighlightStart && d({ ...f, draftHighlightStart: v }), l === "highlightEnd" && v != f.draftHighlightEnd && d({ ...f, draftHighlightEnd: v }), clearTimeout(x.current), x.current = setTimeout(() => {
    u && (l === "dateFormat" || l === "highlightStart" || l === "highlightEnd" ? hfe(
      l,
      f,
      m,
      h,
      v,
      o,
      a
    ) : u === "defaultDateFormat" ? pfe(
      l,
      f,
      h,
      m,
      v,
      o,
      a
    ) : u === "centerFormat" ? mfe(
      l,
      f,
      h,
      m,
      v,
      o,
      a
    ) : o({ ...a, [l]: v }));
  }, 400), () => clearTimeout(x.current)), [v, f]), y) {
    case "date":
      return (
        //CHORE: Need to clean up or delete
        /* @__PURE__ */ Oe(Ut, { children: [
          /* @__PURE__ */ A(Ul, { htmlFor: "input-type-text", className: "margin-top-2", children: i }),
          /* @__PURE__ */ A("span", { className: "usa-hint", children: s }),
          /* @__PURE__ */ A(
            Hue,
            {
              defaultValue: t,
              onChange: (_) => console.log("DatePicker", _),
              ...mf(n, t)
            }
          )
        ] })
      );
    case "checkbox":
      return /* @__PURE__ */ A(
        _ue,
        {
          id: i,
          name: "checkbox",
          label: i,
          onChange: (_) => o({ ...a, [l]: _.target.value })
        }
      );
    case "select":
      return /* @__PURE__ */ Oe(Ut, { children: [
        /* @__PURE__ */ A(Ul, { htmlFor: "input-type-text", className: "margin-top-2", children: i }),
        /* @__PURE__ */ A("span", { className: "usa-hint", children: s }),
        /* @__PURE__ */ A(
          c3,
          {
            id: i,
            name: i,
            onChange: (_) => o({ ...a, [l]: _.target.value }),
            children: gfe.map((_) => /* @__PURE__ */ A("option", { value: _, children: _ }, _))
          }
        )
      ] });
    case "area":
      return /* @__PURE__ */ Oe(Ut, { children: [
        /* @__PURE__ */ A(Ul, { htmlFor: "input-type-text", className: "margin-top-2", children: i }),
        /* @__PURE__ */ A("span", { className: "usa-hint", children: s }),
        /* @__PURE__ */ A(
          wue,
          {
            id: "input-type-text",
            name: "input-type-text",
            value: t,
            onChange: (_) => {
              o({ ...a, [l]: _.target.value });
            },
            className: "",
            ...mf(n, t)
          }
        )
      ] });
    default:
      return /* @__PURE__ */ Oe(Ut, { children: [
        /* @__PURE__ */ A(Ul, { htmlFor: "input-type-text", className: "margin-top-2", children: i }),
        /* @__PURE__ */ A("span", { className: "usa-hint", children: s }),
        /* @__PURE__ */ A(
          AN,
          {
            id: "input-type-text",
            name: "input-type-text",
            type: "text",
            value: u ? v : t,
            onChange: (_) => {
              u ? g(_.target.value) : o({ ...a, [l]: _.target.value });
            },
            placeholder: c,
            ...mf(n, t),
            validationStatus: u && (h[l] ? "error" : void 0)
          }
        )
      ] });
  }
}, Gf = (e) => {
  const { propName: t, customClass: n } = e;
  return /* @__PURE__ */ A("div", { className: n, children: vfe(e) }, t);
};
function RN(e) {
  const t = e.allAvailableDatasets || [];
  if (t.length === 0)
    return /* @__PURE__ */ A("div", { className: "relative w-full h-[250px] flex items-center justify-center bg-gray-100", children: /* @__PURE__ */ A("p", { className: "text-gray-600", children: "No datasets available" }) });
  const n = PN(t);
  return /* @__PURE__ */ A(jx, { children: /* @__PURE__ */ A(Ux, { children: /* @__PURE__ */ A(Hx, { initialDatasets: t, children: /* @__PURE__ */ A("div", { className: "relative w-full h-[250px]", children: /* @__PURE__ */ A(
    HI,
    {
      ...e,
      datasets: n,
      layerId: e.layerId || "default",
      datasetId: e.datasetId || "default",
      dateTime: e.dateTime || (/* @__PURE__ */ new Date()).toISOString(),
      center: e.center || [-94.5, 41.25],
      zoom: e.zoom || 8.3
    }
  ) }) }) }) });
}
const yfe = () => ({
  __type: "placeholder",
  __key: "placeholder",
  __parent: null,
  __prev: null,
  __next: null,
  setProps: () => console.warn("setProps called on a placeholder node")
}), xfe = (e) => {
  const t = ffe(), [n, r] = Re(!0), i = () => {
    const J = e.mdastNode.attributes.reduce(
      (X, N) => (X[N.name] = N.value, X),
      {}
    );
    return J.center && J.layerId && J.zoom && J.datasetId && J.dateTime ? { ...J } : { ...go };
  }, [s, o] = Re(i()), [a, l] = Re({
    defaultDateFormat: "%Y-%m-%d",
    dateTime: s.dateTime,
    compareDateTime: s.compareDateTime,
    center: s.center
  }), [c, u] = Re({
    dateTime: !1,
    compareDateTime: !1,
    center: !1
  }), {
    center: f,
    layerId: d,
    zoom: h,
    datasetId: m,
    dateTime: p,
    compareDateTime: y,
    compareLabel: v,
    attrAuthor: g,
    attrUrl: x,
    caption: _
  } = s, b = typeof f == "string" ? f.startsWith("[") ? JSON.parse(f) : [-94.5, 41.25] : f, C = typeof h == "string" ? parseFloat(h) || 8.3 : h, E = kl(), { mdastNode: S, allAvailableDatasets: k } = e, M = [
    {
      type: "mdxJsxAttribute",
      name: "center",
      value: f
    },
    {
      type: "mdxJsxAttribute",
      name: "zoom",
      value: h
    },
    {
      type: "mdxJsxAttribute",
      name: "datasetId",
      value: m
    },
    {
      type: "mdxJsxAttribute",
      name: "layerId",
      value: d
    },
    {
      type: "mdxJsxAttribute",
      name: "dateTime",
      value: p
    },
    {
      type: "mdxJsxAttribute",
      name: "compareDateTime",
      value: y
    },
    {
      type: "mdxJsxAttribute",
      name: "compareLabel",
      value: v
    },
    {
      type: "mdxJsxAttribute",
      name: "attrUrl",
      value: x
    },
    {
      type: "mdxJsxAttribute",
      name: "attrAuthor",
      value: g
    },
    {
      type: "mdxJsxAttribute",
      name: "caption",
      value: _
    }
  ], O = () => {
    try {
      t != null && t.parentEditor && (t != null && t.lexicalNode) && t.parentEditor.update(() => {
        try {
          const J = t.lexicalNode;
          J != null && J.setProps && J.setProps({
            center: f,
            zoom: h,
            datasetId: m,
            layerId: d,
            dateTime: p,
            compareDateTime: y,
            compareLabel: v
          });
        } catch (J) {
          console.error("Error updating lexical node props:", J);
        }
      });
    } catch (J) {
      console.error("Error in updateProps function:", J);
    }
  };
  Le(() => {
    setTimeout(() => {
      O(), E({ ...S, attributes: M });
    }, 0);
  }, [s]), Le(() => {
    W && W.metadata.layers.length > 0 && (W.metadata.layers.some(
      (X) => X.id === d
    ) || o((X) => ({
      ...X,
      layerId: W.metadata.layers[0].id
    })));
  }, [m]);
  const R = [
    { fieldName: "*Dataset ID", propName: "datasetId", isRequired: !0 },
    { fieldName: "*Layer ID", propName: "layerId", isRequired: !0 },
    {
      fieldName: "*Center",
      propName: "center",
      isRequired: !0,
      validateAgainst: "centerFormat"
    },
    { fieldName: "*Zoom", propName: "zoom", isRequired: !0 },
    {
      fieldName: "*Date Time",
      propName: "dateTime",
      isRequired: !0,
      validateAgainst: "defaultDateFormat"
    }
  ], I = [
    { fieldName: "Compare Label", propName: "compareLabel" },
    {
      fieldName: "Compare Date",
      propName: "compareDateTime",
      validateAgainst: "defaultDateFormat"
    }
  ], H = [
    { fieldName: "Author Attribution", propName: "attrAuthor" },
    { fieldName: "Attribution Url", propName: "attrUrl" },
    {
      fieldName: "Caption",
      propName: "caption",
      type: "area",
      customClass: "flex flex-fill"
    }
  ], P = k == null ? void 0 : k.map((J) => ({
    value: J.metadata.id,
    label: J.metadata.name
  })), W = k == null ? void 0 : k.find(
    (J) => J.metadata.id === m
  ), G = W == null ? void 0 : W.metadata.layers.map((J) => ({
    value: J.id,
    label: J.name
  }));
  return /* @__PURE__ */ A(Ut, { children: /* @__PURE__ */ A("div", { className: " border-05 border-primary rounded-lg overflow-hidden shadow-sm bg-white", children: /* @__PURE__ */ Oe("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ Oe("div", { className: "padding-2 grid-container w-full maxw-full margin-2 bg-gray-10 radius-lg", children: [
      n && /* @__PURE__ */ Oe("div", { children: [
        /* @__PURE__ */ A(
          "h3",
          {
            className: `font-medium ${n ? "text-blue-700" : "text-gray-500"} text-sm`,
            children: "Map Properties"
          }
        ),
        /* @__PURE__ */ A("div", { className: "grid-row flex-align-end grid-gap-2", children: R.map((J) => {
          const { propName: X } = J, N = {
            ...J,
            value: s[X],
            onChange: o,
            componentProps: s,
            draftInputs: a,
            inputErrors: c,
            setInputErrors: u,
            setDraftInputs: l
          };
          return X === "datasetId" ? N.options = P : X === "layerId" && (N.options = G), Gf(N);
        }) }),
        /* @__PURE__ */ A("h4", { children: "Map Comparison" }),
        /* @__PURE__ */ A("div", { className: "grid-row flex-align-end grid-gap-2", children: I.map((J) => {
          const { propName: X, fieldName: N } = J, U = J.type, ee = J.customClass;
          return Gf({
            ...J,
            fieldName: N,
            value: s[X],
            onChange: o,
            type: U,
            componentProps: s,
            propName: X,
            customClass: ee,
            draftInputs: a,
            setDraftInputs: l,
            inputErrors: c,
            setInputErrors: u
          });
        }) }),
        /* @__PURE__ */ A("div", { className: "grid-row flex-align-start grid-gap-2", children: H.map((J) => {
          const { propName: X, fieldName: N } = J, U = J.type, ee = J.customClass;
          return Gf({
            ...J,
            fieldName: N,
            value: s[X],
            onChange: o,
            type: U,
            componentProps: s,
            propName: X,
            customClass: ee
          });
        }) })
      ] }),
      /* @__PURE__ */ A("div", { className: `${n && "padding-top-2"}`, children: /* @__PURE__ */ A(
        Dx,
        {
          type: "button",
          className: "bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded-md shadow flex items-center text-xs",
          onClick: () => r(!n),
          children: n ? "Collapse Map Editor" : "Open Map Editor"
        }
      ) })
    ] }),
    /* @__PURE__ */ A("div", { className: "relative", children: /* @__PURE__ */ A(
      RN,
      {
        ...s,
        center: b,
        zoom: C,
        allAvailableDatasets: k
      },
      `${m}-${d}`
    ) }),
    /* @__PURE__ */ A("div", { children: /* @__PURE__ */ A("figcaption", { className: "text-gray-30 flex padding-top-2", children: /* @__PURE__ */ A("span", { className: "", children: /* @__PURE__ */ A("p", { className: "display-inline", children: s.caption }) }) }) })
  ] }) }) });
}, wfe = (e) => {
  try {
    const [t] = oC();
    return /* @__PURE__ */ A(Ut, { children: /* @__PURE__ */ A(
      ufe,
      {
        value: {
          parentEditor: t,
          lexicalNode: e.node || yfe()
        },
        children: /* @__PURE__ */ A(
          xfe,
          {
            ...e,
            allAvailableDatasets: e.allAvailableDatasets
          }
        )
      }
    ) });
  } catch (t) {
    return console.error("Error in MapEditorWrapper:", t), /* @__PURE__ */ A("div", { className: "p-4 bg-yellow-100 rounded border border-yellow-400", children: /* @__PURE__ */ A("p", { className: "text-yellow-800", children: "Map component could not be loaded properly." }) });
  }
}, $N = al(null), _fe = ({
  children: e,
  value: t
}) => /* @__PURE__ */ A($N.Provider, { value: t, children: e }), bfe = () => {
  const e = ll($N);
  if (!e)
    throw new Error(
      "useChartContext must be used within a ChartContextProvider"
    );
  return e;
}, Cfe = () => ({
  __type: "placeholder",
  __key: "placeholder",
  __parent: null,
  __prev: null,
  __next: null,
  setProps: () => console.warn("setProps called on a placeholder node")
}), Efe = [
  { fieldName: "Data Path", propName: "dataPath", isRequired: !0 },
  {
    fieldName: "Date Format",
    propName: "dateFormat",
    isRequired: !0,
    validateAgainst: "highlightEnd, highlightStart"
  },
  { fieldName: "IdKey", propName: "idKey", isRequired: !0 },
  { fieldName: "xKey", propName: "xKey", isRequired: !0 },
  { fieldName: "yKey", propName: "yKey", isRequired: !0 },
  { fieldName: "Alternative title", propName: "altTitle" },
  { fieldName: "Alternative Description", propName: "altDesc" },
  { fieldName: "Colors", propName: "colors", placeHolder: "#FFFFFF, #000000" },
  { fieldName: "Colors Scheme", propName: "colorScheme", type: "select" },
  { fieldName: "X Axis Label", propName: "xAxisLabel" },
  { fieldName: "Y Axis Label", propName: "yAxisLabel" },
  {
    fieldName: "Highlight Start",
    propName: "highlightStart",
    validateAgainst: "dateFormat"
  },
  {
    fieldName: "Highlight End",
    propName: "highlightEnd",
    validateAgainst: "dateFormat"
  },
  { fieldName: "Highlight Label", propName: "highlightLabel" },
  {
    fieldName: "Available Domain",
    propName: "availableDomain",
    placeHolder: "[6/2021, 9/2022]"
  },
  { fieldName: "Author Attribution", propName: "attrAuthor" },
  { fieldName: "Attribution Url", propName: "attrUrl" },
  {
    fieldName: "Caption",
    propName: "caption",
    type: "area",
    customClass: "flex flex-fill"
  }
], Sfe = (e) => {
  const { allAvailableDatasets: t, allAvailableCsvs: n } = e, r = kl(), { mdastNode: i } = e, s = bfe(), [o, a] = Re(!0), l = () => {
    const { dataPath: y, dateFormat: v, idKey: g, xKey: x, yKey: _ } = e;
    return y && v && g && x && _ ? { ...e } : { ...Wx };
  }, [c, u] = Re(l()), [f, d] = Re({
    draftDateFormat: c.dateFormat,
    draftHighlightEnd: c.highlightEnd,
    draftHighlightStart: c.highlightStart
  }), [h, m] = Re({
    highlightStart: !1,
    highlightEnd: !1
  }), p = () => {
    try {
      s != null && s.parentEditor && (s != null && s.lexicalNode) && s.parentEditor.update(() => {
        try {
          const y = s.lexicalNode;
          y != null && y.setProps && y.setProps({
            ...c
          });
        } catch (y) {
          console.error("Error updating lexical node props:", y);
        }
      });
    } catch (y) {
      console.error("Error in updateProps function:", y);
    }
  };
  return Le(() => {
    p();
    const y = Object.entries(c).map(([v, g]) => ({
      type: "mdxJsxAttribute",
      name: v,
      value: g
    }));
    r({ ...i, attributes: y });
  }, [c]), /* @__PURE__ */ A("div", { className: " border-05 border-primary rounded-lg overflow-hidden shadow-sm bg-white", children: /* @__PURE__ */ Oe("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ Oe("div", { className: "padding-2 grid-container w-full maxw-full margin-2 bg-gray-10 radius-lg", children: [
      o && /* @__PURE__ */ Oe("div", { children: [
        /* @__PURE__ */ A(
          "h3",
          {
            className: `font-medium ${o ? "text-blue-700" : "text-gray-500"} text-sm`,
            children: "Chart Properties"
          }
        ),
        /* @__PURE__ */ A("div", { className: "grid-row flex-align-start grid-gap-2", children: Efe.map((y) => {
          const { propName: v } = y;
          return Gf({
            ...y,
            value: c[v],
            onChange: u,
            componentProps: c,
            draftInputs: f,
            setDraftInputs: d,
            inputErrors: h,
            setInputErrors: m
          });
        }) })
      ] }),
      /* @__PURE__ */ A("div", { className: `${o && "padding-top-2"}`, children: /* @__PURE__ */ A(
        Dx,
        {
          type: "button",
          className: "bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded-md shadow flex items-center text-xs",
          onClick: () => a(!o),
          children: o ? "Collapse Chart Editor" : "Open Chart Editor"
        }
      ) })
    ] }),
    /* @__PURE__ */ Oe("div", { className: "relative", children: [
      /* @__PURE__ */ A("div", { children: /* @__PURE__ */ A(
        DN,
        {
          ...c,
          allAvailableDatasets: t
        }
      ) }),
      /* @__PURE__ */ A("div", { children: /* @__PURE__ */ A("figcaption", { className: "text-gray-30 flex", children: /* @__PURE__ */ A("span", { className: "", children: /* @__PURE__ */ A("p", { className: "display-inline", children: c.caption }) }) }) })
    ] })
  ] }) });
}, kfe = (e) => {
  try {
    const [t] = oC();
    return /* @__PURE__ */ A(
      _fe,
      {
        value: {
          parentEditor: t,
          lexicalNode: e.node || Cfe()
        },
        children: /* @__PURE__ */ A(Sfe, { ...e })
      }
    );
  } catch (t) {
    return console.error("Error in ChartEditorWrapper:", t), /* @__PURE__ */ A("div", { className: "p-4 bg-yellow-100 rounded border border-yellow-400", children: /* @__PURE__ */ A("p", { className: "text-yellow-800", children: "Chart component could not be loaded properly." }) });
  }
}, Ah = [
  {
    metadata: {
      id: "ct-ch4-monthgrid-v2023",
      name: "CarbonTracker-CH₄ Isotopic Methane Inverse Fluxes",
      description: "Global, monthly 1 degree resolution methane emission estimates from microbial, fossil and pyrogenic sources derived using inverse modeling, version 2023",
      taxonomy: [
        {
          name: "Topics",
          values: [
            { id: "Anthropogenic Emissions", name: "Anthropogenic Emissions" },
            {
              id: "Natural Emissions and Sinks",
              name: "Natural Emissions and Sinks"
            },
            { id: "Methane", name: "Methane" }
          ]
        },
        {
          name: "Source",
          values: [
            { id: "NASA", name: "NASA" },
            { id: "NOAA", name: "NOAA" }
          ]
        },
        {
          name: "Gas",
          values: [{ id: "CH₄", name: "CH₄" }]
        },
        {
          name: "Product Type",
          values: [
            { id: "Ground Measurements", name: "Ground Measurements" },
            { id: "Model Output", name: "Model Output" }
          ]
        }
      ],
      layers: [
        {
          id: "total-ch4",
          stacCol: "ct-ch4-monthgrid-v2023",
          name: "Total CH₄ Emission",
          type: "raster",
          description: "Total methane emission from microbial, fossil and pyrogenic sources.",
          zoomExtent: [0, 0],
          legend: {
            unit: { label: "g CH₄/m²/year" },
            type: "gradient",
            min: "0",
            max: "50",
            stops: [
              "#F7F4F9",
              "#E9E3F0",
              "#D9C3DF",
              "#CDA0CD",
              "#D57ABA",
              "#E34A9F",
              "#DF2179",
              "#C10E51",
              "#92003F",
              "#67001F"
            ]
          },
          compare: {
            datasetId: "ct-ch4-monthgrid-v2023",
            layerId: "total-ch4",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          }
        },
        {
          id: "microbial-ch4",
          stacCol: "ct-ch4-monthgrid-v2023",
          name: "Microbial CH₄ Emission",
          type: "raster",
          description: "Emission of methane from all microbial sources, such as wetlands, ruminants, agriculture and termites.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "g CH₄/m²/year" },
            type: "gradient",
            min: "0",
            max: "30",
            stops: [
              "#F7F4F9",
              "#E9E3F0",
              "#D9C3DF",
              "#CDA0CD",
              "#D57ABA",
              "#E34A9F",
              "#DF2179",
              "#C10E51",
              "#92003F",
              "#67001F"
            ]
          },
          compare: {
            datasetId: "ct-ch4-monthgrid-v2023",
            layerId: "microbial-ch4",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          }
        },
        {
          id: "fossil-ch4",
          stacCol: "ct-ch4-monthgrid-v2023",
          name: "Fossil CH₄ Emission",
          type: "raster",
          description: "Emission of methane from all fossil sources, such as oil and gas activities and coal mining.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "g CH₄/m²/year" },
            type: "gradient",
            min: "0",
            max: "50",
            stops: [
              "#F7F4F9",
              "#E9E3F0",
              "#D9C3DF",
              "#CDA0CD",
              "#D57ABA",
              "#E34A9F",
              "#DF2179",
              "#C10E51",
              "#92003F",
              "#67001F"
            ]
          },
          compare: {
            datasetId: "ct-ch4-monthgrid-v2023",
            layerId: "fossil-ch4",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          }
        },
        {
          id: "pyrogenic-ch4",
          stacCol: "ct-ch4-monthgrid-v2023",
          name: "Pyrogenic CH₄ Emission",
          type: "raster",
          description: "Emission of methane from all sources of biomass burning, such as wildfires and crop residue burning.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "g CH₄/m²/year" },
            type: "gradient",
            min: "0",
            max: "8",
            stops: [
              "#F7F4F9",
              "#E9E3F0",
              "#D9C3DF",
              "#CDA0CD",
              "#D57ABA",
              "#E34A9F",
              "#DF2179",
              "#C10E51",
              "#92003F",
              "#67001F"
            ]
          },
          compare: {
            datasetId: "ct-ch4-monthgrid-v2023",
            layerId: "pyrogenic-ch4",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          }
        }
      ]
    },
    slug: "ct-ch4-monthgrid-v2023",
    content: ""
    // If you want to include full markdown content, you can parse it in here
  },
  {
    metadata: {
      id: "eccodarwin-co2flux-monthgrid-v5",
      name: "Air-Sea CO₂ Flux, ECCO-Darwin Model v5",
      description: "Global, monthly average air-sea CO₂ flux at ~1/3° resolution from 2020 to 2022",
      taxonomy: [
        {
          name: "Topics",
          values: [
            {
              id: "Natural Emissions and Sinks",
              name: "Natural Emissions and Sinks"
            }
          ]
        },
        {
          name: "Source",
          values: [{ id: "NASA", name: "NASA" }]
        },
        {
          name: "Gas",
          values: [{ id: "CO₂", name: "CO₂" }]
        },
        {
          name: "Product Type",
          values: [{ id: "Model Output", name: "Model Output" }]
        }
      ],
      layers: [
        {
          id: "air-sea-co2",
          stacCol: "eccodarwin-co2flux-monthgrid-v5",
          name: "Air-Sea CO₂ Flux",
          type: "raster",
          description: "Monthly mean air-sea CO₂ Flux (negative into ocean)",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "mmol m²/s" },
            type: "gradient",
            min: "-0.0007",
            max: "0.0007",
            stops: [
              "#0000FF",
              "#3399FF",
              "#66CCFF",
              "#FFFFFF",
              "#FF66CC",
              "#FF3399",
              "#FF0000"
            ]
          },
          compare: {
            datasetId: "eccodarwin-co2flux-monthgrid-v5",
            layerId: "air-sea-co2",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          }
        }
      ]
    },
    slug: "eccodarwin-co2flux-monthgrid-v5",
    content: ""
    // optional: parsed MDX markdown content if needed
  },
  // {
  // metadata: {
  //   id: "vulcan-ffco2-elc-res-yeargrid-v4",
  //   name: "Vulcan Fossil Fuel CO₂ Emissions, Version 4",
  //   description: "Annual (2010 - 2021), 1 km resolution estimates of carbon dioxide emissions from fossil fuels and cement production over the contiguous United States, version 4.0",
  //   isHidden: true,
  //   taxonomy: [
  //     {
  //       name: "Topics",
  //       values: [
  //         { id: "Anthropogenic Emissions", name: "Anthropogenic Emissions" }
  //       ]
  //     },
  //     {
  //       name: "Source",
  //       values: [
  //         { id: "NAU", name: "NAU" },
  //         { id: "NASA", name: "NASA" },
  //         { id: "NOAA", name: "NOAA" },
  //         { id: "NSF", name: "NSF" }
  //       ]
  //     },
  //     {
  //       name: "Gas",
  //       values: [
  //         { id: "CO₂", name: "CO₂" }
  //       ]
  //     },
  //     {
  //       name: "Product Type",
  //       values: [
  //         { id: "Model Output", name: "Model Output" }
  //       ]
  //     }
  //   ],
  //   layers: [
  //     {
  //       id: "vulcan-elc-res-co2",
  //       stacCol: "vulcan-ffco2-elc-res-yeargrid-v4",
  //       name: "Scope 2 Residential Fossil Fuel CO₂ Emissions",
  //       type: "raster",
  //       description: "Estimated total annual CO₂ emissions from fossil fuel combustion (ffCO₂) across all sectors.",
  //       zoomExtent: [0, 20],
  //       legend: {
  //         unit: { label: "tonne CO₂/km²/year" },
  //         type: "gradient",
  //         min: "0",
  //         max: "500",
  //         stops: [
  //           '#5e4fa2',
  //           '#388eba',
  //           '#75c8a5',
  //           '#bfe5a0',
  //           '#f1f9a9',
  //           '#feeea2',
  //           '#fdbf6f',
  //           '#f67b4a',
  //           '#d8434e',
  //           '#9e0142'
  //         ]
  //       },
  //       compare: {
  //         datasetId: "vulcan-ffco2-yeargrid-v4",
  //         layerId: "vulcan-total-co2",
  //         mapLabel: ({ dateFns, datetime, compareDatetime }) =>
  //           dateFns && datetime && compareDatetime
  //             ? `${dateFns.format(datetime, 'LLL yyyy')} VS ${dateFns.format(compareDatetime, 'LLL yyyy')}`
  //             : ""
  //       },
  //       info: {
  //         source: "NASA",
  //         spatialExtent: "Contiguous United States",
  //         temporalResolution: "Annual",
  //         unit: "tonne CO₂/km²/year"
  //       }
  //     }
  //   ]
  // },
  // slug: "vulcan-ffco2-elc-res-yeargrid-v4",
  // content: ""
  // },
  {
    metadata: {
      id: "vulcan-ffco2-yeargrid-v4",
      name: "Vulcan Fossil Fuel CO₂ Emissions",
      description: "Annual (2010 - 2021), 1 km resolution estimates of carbon dioxide emissions from fossil fuel combustion over the contiguous United States, version 4.0",
      taxonomy: [
        {
          name: "Topics",
          values: [
            { id: "Anthropogenic Emissions", name: "Anthropogenic Emissions" },
            { id: "Urban", name: "Urban" }
          ]
        },
        {
          name: "Source",
          values: [
            { id: "NAU", name: "NAU" },
            { id: "NASA", name: "NASA" },
            { id: "NOAA", name: "NOAA" },
            { id: "NSF", name: "NSF" }
          ]
        },
        {
          name: "Gas",
          values: [{ id: "CO₂", name: "CO₂" }]
        },
        {
          name: "Product Type",
          values: [{ id: "Hybrid Product", name: "Hybrid Product" }]
        }
      ],
      layers: [
        {
          id: "vulcan-total-co2",
          stacCol: "vulcan-ffco2-yeargrid-v4",
          name: "Total Fossil Fuel CO₂ Emissions",
          type: "raster",
          description: "Estimated total annual CO₂ emissions from fossil fuel combustion (ffCO₂) across all sectors.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "tonne CO₂/km²/year" },
            type: "gradient",
            min: "0",
            max: "1400",
            stops: [
              "#5e4fa2",
              "#388eba",
              "#75c8a5",
              "#bfe5a0",
              "#f1f9a9",
              "#feeea2",
              "#fdbf6f",
              "#f67b4a",
              "#d8434e",
              "#9e0142"
            ]
          },
          compare: {
            datasetId: "vulcan-ffco2-yeargrid-v4",
            layerId: "vulcan-total-co2",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          },
          info: {
            source: "NASA",
            spatialExtent: "Contiguous United States",
            temporalResolution: "Annual",
            unit: "tonne CO₂/km²/year"
          }
        },
        {
          id: "vulcan-air-co2",
          stacCol: "vulcan-ffco2-yeargrid-v4",
          name: "Airport Fossil Fuel CO₂ Emissions",
          type: "raster",
          description: "Estimated total annual ffCO₂ emissions from taxi, take-off, and landing up to 3000 ft.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "tonne CO₂/km²/year" },
            type: "gradient",
            min: "0",
            max: "1400",
            stops: [
              "#5e4fa2",
              "#388eba",
              "#75c8a5",
              "#bfe5a0",
              "#f1f9a9",
              "#feeea2",
              "#fdbf6f",
              "#f67b4a",
              "#d8434e",
              "#9e0142"
            ]
          },
          compare: {
            datasetId: "vulcan-ffco2-yeargrid-v4",
            layerId: "vulcan-air-co2",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          },
          info: {
            source: "NASA",
            spatialExtent: "Contiguous United States",
            temporalResolution: "Annual",
            unit: "tonne CO₂/km²/year"
          }
        },
        {
          id: "vulcan-res-co2",
          stacCol: "vulcan-ffco2-yeargrid-v4",
          name: "Residential Fossil Fuel CO₂ Emissions",
          type: "raster",
          description: "Estimated total annual ffCO₂ emissions from Residential buildings.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "tonne CO₂/km²/year" },
            type: "gradient",
            min: "0",
            max: "1400",
            stops: [
              "#5e4fa2",
              "#388eba",
              "#75c8a5",
              "#bfe5a0",
              "#f1f9a9",
              "#feeea2",
              "#fdbf6f",
              "#f67b4a",
              "#d8434e",
              "#9e0142"
            ]
          },
          compare: {
            datasetId: "vulcan-ffco2-elc-res-yeargrid-v4",
            layerId: "vulcan-elc-res-co2",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          },
          info: {
            source: "NASA",
            spatialExtent: "Contiguous United States",
            temporalResolution: "Annual",
            unit: "tonne CO₂/km²/year"
          }
        }
        // Add other layers like vulcan-com-co2, vulcan-ind-co2, etc. if needed
      ]
    },
    slug: "vulcan-ffco2-yeargrid-v4",
    content: ""
  },
  {
    metadata: {
      id: "vulcan-ffco2-elc-res-yeargrid-v4",
      name: "Vulcan Fossil Fuel CO₂ Emissions, Version 4",
      description: "Annual (2010 - 2021), 1 km resolution estimates of carbon dioxide emissions from fossil fuels and cement production over the contiguous United States, version 4.0",
      isHidden: !0,
      taxonomy: [
        {
          name: "Topics",
          values: [
            { id: "Anthropogenic Emissions", name: "Anthropogenic Emissions" }
          ]
        },
        {
          name: "Source",
          values: [
            { id: "NAU", name: "NAU" },
            { id: "NASA", name: "NASA" },
            { id: "NOAA", name: "NOAA" },
            { id: "NSF", name: "NSF" }
          ]
        },
        {
          name: "Gas",
          values: [{ id: "CO₂", name: "CO₂" }]
        },
        {
          name: "Product Type",
          values: [{ id: "Model Output", name: "Model Output" }]
        }
      ],
      layers: [
        {
          id: "vulcan-elc-res-co2",
          stacCol: "vulcan-ffco2-elc-res-yeargrid-v4",
          name: "Scope 2 Residential Fossil Fuel CO₂ Emissions",
          type: "raster",
          description: "Estimated total annual CO₂ emissions from fossil fuel combustion (ffCO₂) across all sectors.",
          zoomExtent: [0, 20],
          legend: {
            unit: { label: "tonne CO₂/km²/year" },
            type: "gradient",
            min: "0",
            max: "500",
            stops: [
              "#5e4fa2",
              "#388eba",
              "#75c8a5",
              "#bfe5a0",
              "#f1f9a9",
              "#feeea2",
              "#fdbf6f",
              "#f67b4a",
              "#d8434e",
              "#9e0142"
            ]
          },
          compare: {
            datasetId: "vulcan-ffco2-yeargrid-v4",
            layerId: "vulcan-total-co2",
            mapLabel: ({ dateFns: e, datetime: t, compareDatetime: n }) => e && t && n ? `${e.format(t, "LLL yyyy")} VS ${e.format(
              n,
              "LLL yyyy"
            )}` : ""
          },
          info: {
            source: "NASA",
            spatialExtent: "Contiguous United States",
            temporalResolution: "Annual",
            unit: "tonne CO₂/km²/year"
          }
        }
      ]
    },
    slug: "vulcan-ffco2-elc-res-yeargrid-v4",
    content: ""
  }
], Tfe = [
  {
    name: "TwoColumn",
    kind: "flow",
    source: "./components",
    // Adjust the path
    hasChildren: !0,
    props: [{ name: "children", type: "expression" }],
    Editor: (e) => /* @__PURE__ */ A(cfe, { props: { ...e } })
  },
  {
    name: "Block",
    kind: "flow",
    source: "@teamimpact/veda-ui",
    // Adjust the path
    hasChildren: !0,
    props: [],
    Editor: ho
  },
  {
    name: "Figure",
    kind: "flow",
    source: "./components",
    // Adjust the path
    hasChildren: !0,
    props: [],
    Editor: ho
  },
  {
    name: "Break",
    kind: "flow",
    source: "./components",
    // Adjust the path
    hasChildren: !1,
    props: [],
    Editor: ho
  },
  {
    name: "Prose",
    kind: "flow",
    source: "@teamimpact/veda-ui",
    // Adjust the path
    hasChildren: !0,
    props: [{ name: "children", type: "expression" }],
    Editor: ho
  },
  {
    name: "LeftColumn",
    kind: "flow",
    source: "./components",
    hasChildren: !0,
    props: [{ name: "children", type: "expression" }],
    Editor: ho
  },
  {
    name: "RightColumn",
    kind: "flow",
    source: "./components",
    hasChildren: !0,
    props: [{ name: "children", type: "expression" }],
    Editor: ho
  },
  {
    name: "Map",
    kind: "text",
    source: "@teamimpact/veda-ui",
    props: [
      { name: "center", type: "string" },
      { name: "zoom", type: "string" },
      { name: "datasetId", type: "string" },
      { name: "layerId", type: "string" },
      { name: "dateTime", type: "string" },
      { name: "compareDateTime", type: "string" },
      { name: "compareLabel", type: "string" }
    ],
    hasChildren: !1,
    Editor: (e) => /* @__PURE__ */ A(Ut, { children: /* @__PURE__ */ A(
      wfe,
      {
        ...e,
        ...e.mdastNode.attributes.reduce((t, n) => (t[n.name] = n.value, t), {}),
        allAvailableDatasets: Ah
      }
    ) })
  },
  {
    name: "Chart",
    kind: "text",
    source: "@teamimpact/veda-ui",
    props: [
      { name: "dataPath", type: "string" },
      { name: "dateFormat", type: "string" },
      { name: "idKey", type: "string" },
      { name: "xKey", type: "string" },
      { name: "yKey", type: "string" },
      { name: "yAxisLabel", type: "string" },
      { name: "xAxisLabel", type: "string" },
      { name: "highlightStart", type: "string" },
      { name: "highlightEnd", type: "string" },
      { name: "highlightLabel", type: "string" },
      { name: "availableDomain", type: "string" },
      { name: "altTitle", type: "string" },
      { name: "colorScheme", type: "string" },
      { name: "colors", type: "string" },
      { name: "altDesc", type: "string" }
    ],
    hasChildren: !1,
    Editor: (e) => /* @__PURE__ */ A(Ut, { children: /* @__PURE__ */ A(
      kfe,
      {
        ...e,
        allAvailableDatasets: Ah
      }
    ) })
  }
], Afe = {
  name: "callout",
  testNode(e) {
    return e.name === "callout";
  },
  // set some attribute names to have the editor display a property editor popup.
  attributes: [],
  // used by the generic editor to determine whether or not to render a nested editor.
  hasChildren: !0,
  Editor: pee
};
function Nfe({ markdown: e, onChange: t, previewMDAST: n }) {
  const r = $e(null), [i, s] = Re(null), [o, a] = Re(!1);
  Le(() => {
    const c = () => {
      r.current ? a(!0) : setTimeout(c, 100);
    };
    c();
  }, []);
  const l = () => {
    try {
      const c = r.current && r.current.getMarkdown();
      if (c) {
        const u = Ud(c, {
          extensions: [zd()],
          mdastExtensions: [Vd()]
        });
        cu(u, "mdxJsxFlowElement", (f) => {
          var d;
          if (["RightColumn", "LeftColumn"].includes(f.name) && f.children.length > 0) {
            const h = (d = f.children[0]) == null ? void 0 : d.value;
            typeof h == "string" && (f.children = Ud(h, {
              extensions: [zd()],
              mdastExtensions: [Vd()]
            }).children);
          }
        }), s(u), n(vte(u));
      }
    } catch (c) {
      console.error("Error analyzing MDAST:", c), alert("Error analyzing MDAST: " + c.message);
    }
  };
  return /* @__PURE__ */ A("div", { className: "h-[600px] border rounded-lg overflow-hidden", children: /* @__PURE__ */ A(
    fz,
    {
      ref: r,
      markdown: e,
      onChange: (c) => (l(), t(c)),
      contentEditableClassName: "prose prose-lg max-w-none min-h-[500px] outline-none px-4 py-2",
      plugins: [
        // scrollytellingButtonPlugin(), // Temporarily disable custom plugin
        vz(),
        Yz(),
        RY(),
        Ez(),
        Gee(),
        wZ(),
        PY(),
        zK(),
        JW(),
        yee(),
        cZ({
          jsxComponentDescriptors: Tfe
        }),
        hee({
          directiveDescriptors: [Afe]
        }),
        Cee({
          toolbarContents: () => /* @__PURE__ */ Oe("div", { className: "grid-column", children: [
            /* @__PURE__ */ Oe("div", { className: "grid-row border-bottom-1px padding-y-1", children: [
              /* @__PURE__ */ A(ote, {}),
              /* @__PURE__ */ A(ete, {}),
              /* @__PURE__ */ A(ste, {}),
              /* @__PURE__ */ A(Qee, {}),
              /* @__PURE__ */ A(nte, {}),
              /* @__PURE__ */ A(tte, {}),
              /* @__PURE__ */ A(rte, {})
            ] }),
            /* @__PURE__ */ Oe("div", { className: "grid-row padding-y-1", children: [
              /* @__PURE__ */ A(sfe, {}),
              /* @__PURE__ */ A(ofe, {}),
              /* @__PURE__ */ A(lfe, {}),
              /* @__PURE__ */ A(afe, {})
            ] })
          ] })
        })
      ],
      className: "w-full h-full"
    }
  ) });
}
const s2 = {}, VN = T.createContext(s2);
function Ife(e) {
  const t = T.useContext(VN);
  return T.useMemo(
    function() {
      return typeof e == "function" ? e(t) : { ...t, ...e };
    },
    [t, e]
  );
}
function Lfe(e) {
  let t;
  return e.disableParentContext ? t = typeof e.components == "function" ? e.components(s2) : e.components || s2 : t = Ife(e.components), T.createElement(
    VN.Provider,
    { value: t },
    e.children
  );
}
const ri = { basename: Mfe, dirname: Ofe, extname: Pfe, join: Dfe, sep: "/" };
function Mfe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Fu(e);
  let n = 0, r = -1, i = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (s) {
          n = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let o = -1, a = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (s) {
        n = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (r = i) : (a = -1, r = o));
  return n === r ? r = o : r < 0 && (r = e.length), e.slice(n, r);
}
function Ofe(e) {
  if (Fu(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Pfe(e) {
  Fu(e);
  let t = e.length, n = -1, r = 0, i = -1, s = 0, o;
  for (; t--; ) {
    const a = e.codePointAt(t);
    if (a === 47) {
      if (o) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = t + 1), a === 46 ? i < 0 ? i = t : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function Dfe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Fu(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : Ffe(n);
}
function Ffe(e) {
  Fu(e);
  const t = e.codePointAt(0) === 47;
  let n = Rfe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function Rfe(e, t) {
  let n = "", r = 0, i = -1, s = 0, o = -1, a, l;
  for (; ++o <= e.length; ) {
    if (o < e.length)
      a = e.codePointAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === o - 1 || s === 1)) if (i !== o - 1 && s === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = o, s = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = o, s = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, o) : n = e.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else a === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function Fu(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const $fe = { cwd: Vfe };
function Vfe() {
  return "/";
}
function o2(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Bfe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!o2(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return zfe(e);
}
function zfe(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const zm = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class BN {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? o2(t) ? n = { path: t } : typeof t == "string" || Hfe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : $fe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < zm.length; ) {
      const s = zm[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let i;
    for (i in n)
      zm.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? ri.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Um(t, "basename"), Hm(t, "basename"), this.path = ri.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? ri.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    u3(this.basename, "dirname"), this.path = ri.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? ri.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Hm(t, "extname"), u3(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = ri.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    o2(t) && (t = Bfe(t)), Um(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? ri.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Um(t, "stem"), Hm(t, "stem"), this.path = ri.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new ot(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Hm(e, t) {
  if (e && e.includes(ri.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + ri.sep + "`"
    );
}
function Um(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function u3(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Hfe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Ufe = [
  "md",
  "markdown",
  "mdown",
  "mkdn",
  "mkd",
  "mdwn",
  "mkdown",
  "ron"
], jfe = Ufe.map(function(e) {
  return "." + e;
});
function Wfe(e, t) {
  const n = Jfe(e) ? e : new BN(e), { format: r, ...i } = t || {};
  return {
    file: n,
    options: {
      format: r === "md" || r === "mdx" ? r : n.extname && (i.mdExtensions || jfe).includes(n.extname) ? "md" : "mdx",
      ...i
    }
  };
}
function Jfe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
class Kfe {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (t) => this.replacement = t
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(t, n, r, i) {
    t && n && (r != null ? t[n][r] = i : t[n] = i);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(t, n, r) {
    t && n && (r != null ? t[n].splice(r, 1) : delete t[n]);
  }
}
class qfe extends Kfe {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(t, n) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (r) => this.replacement = r
    }, this.enter = t, this.leave = n;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(t, n, r, i) {
    if (t) {
      if (this.enter) {
        const o = this.should_skip, a = this.should_remove, l = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, n, r, i), this.replacement && (t = this.replacement, this.replace(n, r, i, t)), this.should_remove && this.remove(n, r, i);
        const c = this.should_skip, u = this.should_remove;
        if (this.should_skip = o, this.should_remove = a, this.replacement = l, c) return t;
        if (u) return null;
      }
      let s;
      for (s in t) {
        const o = t[s];
        if (o && typeof o == "object")
          if (Array.isArray(o)) {
            const a = (
              /** @type {Array<unknown>} */
              o
            );
            for (let l = 0; l < a.length; l += 1) {
              const c = a[l];
              f3(c) && (this.visit(c, t, s, l) || l--);
            }
          } else f3(o) && this.visit(o, t, s, null);
      }
      if (this.leave) {
        const o = this.replacement, a = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, n, r, i), this.replacement && (t = this.replacement, this.replace(n, r, i, t)), this.should_remove && this.remove(n, r, i);
        const l = this.should_remove;
        if (this.replacement = o, this.should_remove = a, l) return null;
      }
    }
    return t;
  }
}
function f3(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
function Ra(e, { enter: t, leave: n }) {
  return new qfe(t, n).visit(e, null);
}
const jm = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g;
function Gfe(e, t) {
  const n = t || {};
  let r = n.runtime === "automatic";
  const i = {}, s = {};
  Ra(e, {
    enter(o) {
      if (o.type === "Program") {
        const a = o.comments || [];
        let l = -1;
        for (; ++l < a.length; ) {
          jm.lastIndex = 0;
          let c = jm.exec(a[l].value);
          for (; c; )
            i[c[1]] = c[2], c = jm.exec(a[l].value);
        }
        if (i.jsxRuntime)
          if (i.jsxRuntime === "automatic") {
            if (r = !0, i.jsx)
              throw new Error("Unexpected `@jsx` pragma w/ automatic runtime");
            if (i.jsxFrag)
              throw new Error(
                "Unexpected `@jsxFrag` pragma w/ automatic runtime"
              );
          } else if (i.jsxRuntime === "classic") {
            if (r = !1, i.jsxImportSource)
              throw new Error(
                "Unexpected `@jsxImportSource` w/ classic runtime"
              );
          } else
            throw new Error(
              "Unexpected `jsxRuntime` `" + i.jsxRuntime + "`, expected `automatic` or `classic`"
            );
      }
    },
    // eslint-disable-next-line complexity
    leave(o) {
      if (o.type === "Program") {
        const p = [];
        if (s.fragment && p.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "Fragment" },
          local: { type: "Identifier", name: "_Fragment" }
        }), s.jsx && p.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsx" },
          local: { type: "Identifier", name: "_jsx" }
        }), s.jsxs && p.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxs" },
          local: { type: "Identifier", name: "_jsxs" }
        }), s.jsxDEV && p.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxDEV" },
          local: { type: "Identifier", name: "_jsxDEV" }
        }), p.length > 0) {
          let y = 0;
          for (; y < o.body.length; ) {
            const v = o.body[y];
            if ("directive" in v && v.directive)
              y++;
            else
              break;
          }
          o.body.splice(y, 0, {
            type: "ImportDeclaration",
            specifiers: p,
            source: {
              type: "Literal",
              value: (i.jsxImportSource || n.importSource || "react") + (n.development ? "/jsx-dev-runtime" : "/jsx-runtime")
            }
          });
        }
      }
      if (o.type !== "JSXElement" && o.type !== "JSXFragment")
        return;
      const a = [];
      let l = -1;
      for (; ++l < o.children.length; ) {
        const p = o.children[l];
        if (p.type === "JSXExpressionContainer")
          p.expression.type !== "JSXEmptyExpression" && a.push(p.expression);
        else if (p.type === "JSXText") {
          const y = p.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, `
`).replace(/\n+/g, `
`).replace(/\n+$/, "").replace(/^\n+/, "").replace(/\n/g, " ");
          if (y) {
            const v = { type: "Literal", value: y };
            gc(p, v), a.push(v);
          }
        } else
          p.type !== "JSXElement" && p.type !== "JSXFragment" && p.type, a.push(p);
      }
      let c;
      const u = [];
      let f = [], d;
      if (o.type === "JSXElement") {
        if (c = Nh(o.openingElement.name), c.type === "Identifier" && /^[a-z]/.test(c.name)) {
          const g = { type: "Literal", value: c.name };
          gc(c, g), c = g;
        }
        let p;
        const y = o.openingElement.attributes;
        let v = -1;
        for (; ++v < y.length; ) {
          const g = y[v];
          if (g.type === "JSXSpreadAttribute")
            g.argument.type === "ObjectExpression" ? u.push(...g.argument.properties) : u.push({ type: "SpreadElement", argument: g.argument }), p = !0;
          else {
            const x = Yfe(g);
            if (r && x.key.type === "Identifier" && x.key.name === "key") {
              if (p)
                throw new Error(
                  "Expected `key` to come before any spread expressions"
                );
              const _ = x.value;
              _.type !== "AssignmentPattern" && _.type !== "ArrayPattern" && _.type !== "ObjectPattern" && _.type, d = _;
            } else
              u.push(x);
          }
        }
      } else r ? (s.fragment = !0, c = { type: "Identifier", name: "_Fragment" }) : c = d3(
        i.jsxFrag || n.pragmaFrag || "React.Fragment"
      );
      r ? a.length > 0 && u.push({
        type: "Property",
        key: { type: "Identifier", name: "children" },
        value: a.length > 1 ? { type: "ArrayExpression", elements: a } : a[0],
        kind: "init",
        method: !1,
        shorthand: !1,
        computed: !1
      }) : f = a;
      let h;
      if (r) {
        f.push({ type: "ObjectExpression", properties: u }), d ? f.push(d) : n.development && f.push({ type: "Identifier", name: "undefined" });
        const p = a.length > 1;
        if (n.development) {
          s.jsxDEV = !0, h = {
            type: "Identifier",
            name: "_jsxDEV"
          }, f.push({ type: "Literal", value: p });
          const y = {
            type: "ObjectExpression",
            properties: [
              {
                type: "Property",
                method: !1,
                shorthand: !1,
                computed: !1,
                kind: "init",
                key: { type: "Identifier", name: "fileName" },
                value: {
                  type: "Literal",
                  value: n.filePath || "<source.js>"
                }
              }
            ]
          };
          o.loc && y.properties.push(
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "lineNumber" },
              value: { type: "Literal", value: o.loc.start.line }
            },
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "columnNumber" },
              value: { type: "Literal", value: o.loc.start.column + 1 }
            }
          ), f.push(y, { type: "ThisExpression" });
        } else p ? (s.jsxs = !0, h = { type: "Identifier", name: "_jsxs" }) : (s.jsx = !0, h = { type: "Identifier", name: "_jsx" });
      } else
        u.length > 0 ? f.unshift({ type: "ObjectExpression", properties: u }) : f.length > 0 && f.unshift({ type: "Literal", value: null }), h = d3(
          i.jsx || n.pragma || "React.createElement"
        );
      f.unshift(c);
      const m = {
        type: "CallExpression",
        callee: h,
        arguments: f,
        optional: !1
      };
      gc(o, m), this.replace(m);
    }
  });
}
function Yfe(e) {
  let t;
  if (e.value)
    if (e.value.type === "JSXExpressionContainer") {
      const r = e.value.expression;
      r.type, t = r;
    } else {
      const r = e.value;
      r.type !== "JSXElement" && r.type, t = r, delete t.raw;
    }
  else
    t = { type: "Literal", value: !0 };
  const n = {
    type: "Property",
    key: Nh(e.name),
    value: t,
    kind: "init",
    method: !1,
    shorthand: !1,
    computed: !1
  };
  return gc(e, n), n;
}
function Nh(e) {
  let t;
  if (e.type === "JSXMemberExpression") {
    const n = Nh(e.property);
    t = {
      type: "MemberExpression",
      object: Nh(e.object),
      property: n,
      computed: n.type === "Literal",
      optional: !1
    };
  } else e.type === "JSXNamespacedName" ? t = {
    type: "Literal",
    value: e.namespace.name + ":" + e.name.name
  } : t = hi(e.name) ? { type: "Identifier", name: e.name } : { type: "Literal", value: e.name };
  return gc(e, t), t;
}
function d3(e) {
  const t = e.split(".");
  let n = -1, r;
  for (; ++n < t.length; ) {
    const i = hi(t[n]) ? { type: "Identifier", name: t[n] } : { type: "Literal", value: t[n] };
    r = r ? {
      type: "MemberExpression",
      object: r,
      property: i,
      computed: !!(n && i.type === "Literal"),
      optional: !1
    } : i;
  }
  return r;
}
function gc(e, t) {
  const n = ["start", "end", "loc", "range", "comments"];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    i in e && (t[i] = e[i]);
  }
}
function Xfe(e) {
  return function(t, n) {
    Gfe(t, { filePath: n.history[0], ...e });
  };
}
const { stringify: Zfe } = JSON;
if (!String.prototype.repeat)
  throw new Error(
    "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
  );
if (!String.prototype.endsWith)
  throw new Error(
    "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
  );
const gf = {
  "||": 2,
  "??": 3,
  "&&": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
}, Or = 17, Qfe = {
  // Definitions
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  PrivateIdentifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  // Operations
  MemberExpression: 19,
  ChainExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  // Other definitions
  ArrowFunctionExpression: Or,
  ClassExpression: Or,
  FunctionExpression: Or,
  ObjectExpression: Or,
  // Other operations
  UpdateExpression: 16,
  UnaryExpression: 15,
  AwaitExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function fa(e, t) {
  const { generator: n } = e;
  if (e.write("("), t != null && t.length > 0) {
    n[t[0].type](t[0], e);
    const { length: r } = t;
    for (let i = 1; i < r; i++) {
      const s = t[i];
      e.write(", "), n[s.type](s, e);
    }
  }
  e.write(")");
}
function zN(e, t, n, r) {
  const i = e.expressionsPrecedence[t.type];
  if (i === Or)
    return !0;
  const s = e.expressionsPrecedence[n.type];
  return i !== s ? !r && i === 15 && s === 14 && n.operator === "**" || i < s : i !== 13 && i !== 14 ? !1 : t.operator === "**" && n.operator === "**" ? !r : i === 13 && s === 13 && (t.operator === "??" || n.operator === "??") ? !0 : r ? gf[t.operator] <= gf[n.operator] : gf[t.operator] < gf[n.operator];
}
function vf(e, t, n, r) {
  const { generator: i } = e;
  zN(e, t, n, r) ? (e.write("("), i[t.type](t, e), e.write(")")) : i[t.type](t, e);
}
function ede(e, t, n, r) {
  const i = t.split(`
`), s = i.length - 1;
  if (e.write(i[0].trim()), s > 0) {
    e.write(r);
    for (let o = 1; o < s; o++)
      e.write(n + i[o].trim() + r);
    e.write(n + i[s].trim());
  }
}
function wn(e, t, n, r) {
  const { length: i } = t;
  for (let s = 0; s < i; s++) {
    const o = t[s];
    e.write(n), o.type[0] === "L" ? e.write("// " + o.value.trim() + `
`, o) : (e.write("/*"), ede(e, o.value, n, r), e.write("*/" + r));
  }
}
function tde(e) {
  let t = e;
  for (; t != null; ) {
    const { type: n } = t;
    if (n[0] === "C" && n[1] === "a")
      return !0;
    if (n[0] === "M" && n[1] === "e" && n[2] === "m")
      t = t.object;
    else
      return !1;
  }
}
function Wm(e, t) {
  const { generator: n } = e, { declarations: r } = t;
  e.write(t.kind + " ");
  const { length: i } = r;
  if (i > 0) {
    n.VariableDeclarator(r[0], e);
    for (let s = 1; s < i; s++)
      e.write(", "), n.VariableDeclarator(r[s], e);
  }
}
let h3, p3, m3, g3, v3, y3;
const HN = {
  /*
  Default generator.
  */
  Program(e, t) {
    const n = t.indent.repeat(t.indentLevel), { lineEnd: r, writeComments: i } = t;
    i && e.comments != null && wn(t, e.comments, n, r);
    const s = e.body, { length: o } = s;
    for (let a = 0; a < o; a++) {
      const l = s[a];
      i && l.comments != null && wn(t, l.comments, n, r), t.write(n), this[l.type](l, t), t.write(r);
    }
    i && e.trailingComments != null && wn(t, e.trailingComments, n, r);
  },
  BlockStatement: y3 = function(e, t) {
    const n = t.indent.repeat(t.indentLevel++), { lineEnd: r, writeComments: i } = t, s = n + t.indent;
    t.write("{");
    const o = e.body;
    if (o != null && o.length > 0) {
      t.write(r), i && e.comments != null && wn(t, e.comments, s, r);
      const { length: a } = o;
      for (let l = 0; l < a; l++) {
        const c = o[l];
        i && c.comments != null && wn(t, c.comments, s, r), t.write(s), this[c.type](c, t), t.write(r);
      }
      t.write(n);
    } else
      i && e.comments != null && (t.write(r), wn(t, e.comments, s, r), t.write(n));
    i && e.trailingComments != null && wn(t, e.trailingComments, s, r), t.write("}"), t.indentLevel--;
  },
  ClassBody: y3,
  StaticBlock(e, t) {
    t.write("static "), this.BlockStatement(e, t);
  },
  EmptyStatement(e, t) {
    t.write(";");
  },
  ExpressionStatement(e, t) {
    const n = t.expressionsPrecedence[e.expression.type];
    n === Or || n === 3 && e.expression.left.type[0] === "O" ? (t.write("("), this[e.expression.type](e.expression, t), t.write(")")) : this[e.expression.type](e.expression, t), t.write(";");
  },
  IfStatement(e, t) {
    t.write("if ("), this[e.test.type](e.test, t), t.write(") "), this[e.consequent.type](e.consequent, t), e.alternate != null && (t.write(" else "), this[e.alternate.type](e.alternate, t));
  },
  LabeledStatement(e, t) {
    this[e.label.type](e.label, t), t.write(": "), this[e.body.type](e.body, t);
  },
  BreakStatement(e, t) {
    t.write("break"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";");
  },
  ContinueStatement(e, t) {
    t.write("continue"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";");
  },
  WithStatement(e, t) {
    t.write("with ("), this[e.object.type](e.object, t), t.write(") "), this[e.body.type](e.body, t);
  },
  SwitchStatement(e, t) {
    const n = t.indent.repeat(t.indentLevel++), { lineEnd: r, writeComments: i } = t;
    t.indentLevel++;
    const s = n + t.indent, o = s + t.indent;
    t.write("switch ("), this[e.discriminant.type](e.discriminant, t), t.write(") {" + r);
    const { cases: a } = e, { length: l } = a;
    for (let c = 0; c < l; c++) {
      const u = a[c];
      i && u.comments != null && wn(t, u.comments, s, r), u.test ? (t.write(s + "case "), this[u.test.type](u.test, t), t.write(":" + r)) : t.write(s + "default:" + r);
      const { consequent: f } = u, { length: d } = f;
      for (let h = 0; h < d; h++) {
        const m = f[h];
        i && m.comments != null && wn(t, m.comments, o, r), t.write(o), this[m.type](m, t), t.write(r);
      }
    }
    t.indentLevel -= 2, t.write(n + "}");
  },
  ReturnStatement(e, t) {
    t.write("return"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t)), t.write(";");
  },
  ThrowStatement(e, t) {
    t.write("throw "), this[e.argument.type](e.argument, t), t.write(";");
  },
  TryStatement(e, t) {
    if (t.write("try "), this[e.block.type](e.block, t), e.handler) {
      const { handler: n } = e;
      n.param == null ? t.write(" catch ") : (t.write(" catch ("), this[n.param.type](n.param, t), t.write(") ")), this[n.body.type](n.body, t);
    }
    e.finalizer && (t.write(" finally "), this[e.finalizer.type](e.finalizer, t));
  },
  WhileStatement(e, t) {
    t.write("while ("), this[e.test.type](e.test, t), t.write(") "), this[e.body.type](e.body, t);
  },
  DoWhileStatement(e, t) {
    t.write("do "), this[e.body.type](e.body, t), t.write(" while ("), this[e.test.type](e.test, t), t.write(");");
  },
  ForStatement(e, t) {
    if (t.write("for ("), e.init != null) {
      const { init: n } = e;
      n.type[0] === "V" ? Wm(t, n) : this[n.type](n, t);
    }
    t.write("; "), e.test && this[e.test.type](e.test, t), t.write("; "), e.update && this[e.update.type](e.update, t), t.write(") "), this[e.body.type](e.body, t);
  },
  ForInStatement: h3 = function(e, t) {
    t.write(`for ${e.await ? "await " : ""}(`);
    const { left: n } = e;
    n.type[0] === "V" ? Wm(t, n) : this[n.type](n, t), t.write(e.type[3] === "I" ? " in " : " of "), this[e.right.type](e.right, t), t.write(") "), this[e.body.type](e.body, t);
  },
  ForOfStatement: h3,
  DebuggerStatement(e, t) {
    t.write("debugger;", e);
  },
  FunctionDeclaration: p3 = function(e, t) {
    t.write(
      (e.async ? "async " : "") + (e.generator ? "function* " : "function ") + (e.id ? e.id.name : ""),
      e
    ), fa(t, e.params), t.write(" "), this[e.body.type](e.body, t);
  },
  FunctionExpression: p3,
  VariableDeclaration(e, t) {
    Wm(t, e), t.write(";");
  },
  VariableDeclarator(e, t) {
    this[e.id.type](e.id, t), e.init != null && (t.write(" = "), this[e.init.type](e.init, t));
  },
  ClassDeclaration(e, t) {
    if (t.write("class " + (e.id ? `${e.id.name} ` : ""), e), e.superClass) {
      t.write("extends ");
      const { superClass: n } = e, { type: r } = n, i = t.expressionsPrecedence[r];
      (r[0] !== "C" || r[1] !== "l" || r[5] !== "E") && (i === Or || i < t.expressionsPrecedence.ClassExpression) ? (t.write("("), this[e.superClass.type](n, t), t.write(")")) : this[n.type](n, t), t.write(" ");
    }
    this.ClassBody(e.body, t);
  },
  ImportDeclaration(e, t) {
    t.write("import ");
    const { specifiers: n, attributes: r } = e, { length: i } = n;
    let s = 0;
    if (i > 0) {
      for (; s < i; ) {
        s > 0 && t.write(", ");
        const o = n[s], a = o.type[6];
        if (a === "D")
          t.write(o.local.name, o), s++;
        else if (a === "N")
          t.write("* as " + o.local.name, o), s++;
        else
          break;
      }
      if (s < i) {
        for (t.write("{"); ; ) {
          const o = n[s], { name: a } = o.imported;
          if (t.write(a, o), a !== o.local.name && t.write(" as " + o.local.name), ++s < i)
            t.write(", ");
          else
            break;
        }
        t.write("}");
      }
      t.write(" from ");
    }
    if (this.Literal(e.source, t), r && r.length > 0) {
      t.write(" with { ");
      for (let o = 0; o < r.length; o++)
        this.ImportAttribute(r[o], t), o < r.length - 1 && t.write(", ");
      t.write(" }");
    }
    t.write(";");
  },
  ImportAttribute(e, t) {
    this.Identifier(e.key, t), t.write(": "), this.Literal(e.value, t);
  },
  ImportExpression(e, t) {
    t.write("import("), this[e.source.type](e.source, t), t.write(")");
  },
  ExportDefaultDeclaration(e, t) {
    t.write("export default "), this[e.declaration.type](e.declaration, t), t.expressionsPrecedence[e.declaration.type] != null && e.declaration.type[0] !== "F" && t.write(";");
  },
  ExportNamedDeclaration(e, t) {
    if (t.write("export "), e.declaration)
      this[e.declaration.type](e.declaration, t);
    else {
      t.write("{");
      const { specifiers: n } = e, { length: r } = n;
      if (r > 0)
        for (let i = 0; ; ) {
          const s = n[i], { name: o } = s.local;
          if (t.write(o, s), o !== s.exported.name && t.write(" as " + s.exported.name), ++i < r)
            t.write(", ");
          else
            break;
        }
      if (t.write("}"), e.source && (t.write(" from "), this.Literal(e.source, t)), e.attributes && e.attributes.length > 0) {
        t.write(" with { ");
        for (let i = 0; i < e.attributes.length; i++)
          this.ImportAttribute(e.attributes[i], t), i < e.attributes.length - 1 && t.write(", ");
        t.write(" }");
      }
      t.write(";");
    }
  },
  ExportAllDeclaration(e, t) {
    if (e.exported != null ? t.write("export * as " + e.exported.name + " from ") : t.write("export * from "), this.Literal(e.source, t), e.attributes && e.attributes.length > 0) {
      t.write(" with { ");
      for (let n = 0; n < e.attributes.length; n++)
        this.ImportAttribute(e.attributes[n], t), n < e.attributes.length - 1 && t.write(", ");
      t.write(" }");
    }
    t.write(";");
  },
  MethodDefinition(e, t) {
    e.static && t.write("static ");
    const n = e.kind[0];
    (n === "g" || n === "s") && t.write(e.kind + " "), e.value.async && t.write("async "), e.value.generator && t.write("*"), e.computed ? (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), fa(t, e.value.params), t.write(" "), this[e.value.body.type](e.value.body, t);
  },
  ClassExpression(e, t) {
    this.ClassDeclaration(e, t);
  },
  ArrowFunctionExpression(e, t) {
    t.write(e.async ? "async " : "", e);
    const { params: n } = e;
    n != null && (n.length === 1 && n[0].type[0] === "I" ? t.write(n[0].name, n[0]) : fa(t, e.params)), t.write(" => "), e.body.type[0] === "O" ? (t.write("("), this.ObjectExpression(e.body, t), t.write(")")) : this[e.body.type](e.body, t);
  },
  ThisExpression(e, t) {
    t.write("this", e);
  },
  Super(e, t) {
    t.write("super", e);
  },
  RestElement: m3 = function(e, t) {
    t.write("..."), this[e.argument.type](e.argument, t);
  },
  SpreadElement: m3,
  YieldExpression(e, t) {
    t.write(e.delegate ? "yield*" : "yield"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t));
  },
  AwaitExpression(e, t) {
    t.write("await ", e), vf(t, e.argument, e);
  },
  TemplateLiteral(e, t) {
    const { quasis: n, expressions: r } = e;
    t.write("`");
    const { length: i } = r;
    for (let o = 0; o < i; o++) {
      const a = r[o], l = n[o];
      t.write(l.value.raw, l), t.write("${"), this[a.type](a, t), t.write("}");
    }
    const s = n[n.length - 1];
    t.write(s.value.raw, s), t.write("`");
  },
  TemplateElement(e, t) {
    t.write(e.value.raw, e);
  },
  TaggedTemplateExpression(e, t) {
    vf(t, e.tag, e), this[e.quasi.type](e.quasi, t);
  },
  ArrayExpression: v3 = function(e, t) {
    if (t.write("["), e.elements.length > 0) {
      const { elements: n } = e, { length: r } = n;
      for (let i = 0; ; ) {
        const s = n[i];
        if (s != null && this[s.type](s, t), ++i < r)
          t.write(", ");
        else {
          s == null && t.write(", ");
          break;
        }
      }
    }
    t.write("]");
  },
  ArrayPattern: v3,
  ObjectExpression(e, t) {
    const n = t.indent.repeat(t.indentLevel++), { lineEnd: r, writeComments: i } = t, s = n + t.indent;
    if (t.write("{"), e.properties.length > 0) {
      t.write(r), i && e.comments != null && wn(t, e.comments, s, r);
      const o = "," + r, { properties: a } = e, { length: l } = a;
      for (let c = 0; ; ) {
        const u = a[c];
        if (i && u.comments != null && wn(t, u.comments, s, r), t.write(s), this[u.type](u, t), ++c < l)
          t.write(o);
        else
          break;
      }
      t.write(r), i && e.trailingComments != null && wn(t, e.trailingComments, s, r), t.write(n + "}");
    } else i ? e.comments != null ? (t.write(r), wn(t, e.comments, s, r), e.trailingComments != null && wn(t, e.trailingComments, s, r), t.write(n + "}")) : e.trailingComments != null ? (t.write(r), wn(t, e.trailingComments, s, r), t.write(n + "}")) : t.write("}") : t.write("}");
    t.indentLevel--;
  },
  Property(e, t) {
    e.method || e.kind[0] !== "i" ? this.MethodDefinition(e, t) : (e.shorthand || (e.computed ? (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), t.write(": ")), this[e.value.type](e.value, t));
  },
  PropertyDefinition(e, t) {
    if (e.static && t.write("static "), e.computed && t.write("["), this[e.key.type](e.key, t), e.computed && t.write("]"), e.value == null) {
      e.key.type[0] !== "F" && t.write(";");
      return;
    }
    t.write(" = "), this[e.value.type](e.value, t), t.write(";");
  },
  ObjectPattern(e, t) {
    if (t.write("{"), e.properties.length > 0) {
      const { properties: n } = e, { length: r } = n;
      for (let i = 0; this[n[i].type](n[i], t), ++i < r; )
        t.write(", ");
    }
    t.write("}");
  },
  SequenceExpression(e, t) {
    fa(t, e.expressions);
  },
  UnaryExpression(e, t) {
    if (e.prefix) {
      const {
        operator: n,
        argument: r,
        argument: { type: i }
      } = e;
      t.write(n);
      const s = zN(t, r, e);
      !s && (n.length > 1 || i[0] === "U" && (i[1] === "n" || i[1] === "p") && r.prefix && r.operator[0] === n && (n === "+" || n === "-")) && t.write(" "), s ? (t.write(n.length > 1 ? " (" : "("), this[i](r, t), t.write(")")) : this[i](r, t);
    } else
      this[e.argument.type](e.argument, t), t.write(e.operator);
  },
  UpdateExpression(e, t) {
    e.prefix ? (t.write(e.operator), this[e.argument.type](e.argument, t)) : (this[e.argument.type](e.argument, t), t.write(e.operator));
  },
  AssignmentExpression(e, t) {
    this[e.left.type](e.left, t), t.write(" " + e.operator + " "), this[e.right.type](e.right, t);
  },
  AssignmentPattern(e, t) {
    this[e.left.type](e.left, t), t.write(" = "), this[e.right.type](e.right, t);
  },
  BinaryExpression: g3 = function(e, t) {
    const n = e.operator === "in";
    n && t.write("("), vf(t, e.left, e, !1), t.write(" " + e.operator + " "), vf(t, e.right, e, !0), n && t.write(")");
  },
  LogicalExpression: g3,
  ConditionalExpression(e, t) {
    const { test: n } = e, r = t.expressionsPrecedence[n.type];
    r === Or || r <= t.expressionsPrecedence.ConditionalExpression ? (t.write("("), this[n.type](n, t), t.write(")")) : this[n.type](n, t), t.write(" ? "), this[e.consequent.type](e.consequent, t), t.write(" : "), this[e.alternate.type](e.alternate, t);
  },
  NewExpression(e, t) {
    t.write("new ");
    const n = t.expressionsPrecedence[e.callee.type];
    n === Or || n < t.expressionsPrecedence.CallExpression || tde(e.callee) ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.type](e.callee, t), fa(t, e.arguments);
  },
  CallExpression(e, t) {
    const n = t.expressionsPrecedence[e.callee.type];
    n === Or || n < t.expressionsPrecedence.CallExpression ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.type](e.callee, t), e.optional && t.write("?."), fa(t, e.arguments);
  },
  ChainExpression(e, t) {
    this[e.expression.type](e.expression, t);
  },
  MemberExpression(e, t) {
    const n = t.expressionsPrecedence[e.object.type];
    n === Or || n < t.expressionsPrecedence.MemberExpression ? (t.write("("), this[e.object.type](e.object, t), t.write(")")) : this[e.object.type](e.object, t), e.computed ? (e.optional && t.write("?."), t.write("["), this[e.property.type](e.property, t), t.write("]")) : (e.optional ? t.write("?.") : t.write("."), this[e.property.type](e.property, t));
  },
  MetaProperty(e, t) {
    t.write(e.meta.name + "." + e.property.name, e);
  },
  Identifier(e, t) {
    t.write(e.name, e);
  },
  PrivateIdentifier(e, t) {
    t.write(`#${e.name}`, e);
  },
  Literal(e, t) {
    e.raw != null ? t.write(e.raw, e) : e.regex != null ? this.RegExpLiteral(e, t) : e.bigint != null ? t.write(e.bigint + "n", e) : t.write(Zfe(e.value), e);
  },
  RegExpLiteral(e, t) {
    const { regex: n } = e;
    t.write(`/${n.pattern}/${n.flags}`, e);
  }
}, nde = {};
class rde {
  constructor(t) {
    const n = t ?? nde;
    this.output = "", n.output != null ? (this.output = n.output, this.write = this.writeToStream) : this.output = "", this.generator = n.generator != null ? n.generator : HN, this.expressionsPrecedence = n.expressionsPrecedence != null ? n.expressionsPrecedence : Qfe, this.indent = n.indent != null ? n.indent : "  ", this.lineEnd = n.lineEnd != null ? n.lineEnd : `
`, this.indentLevel = n.startingIndentLevel != null ? n.startingIndentLevel : 0, this.writeComments = n.comments ? n.comments : !1, n.sourceMap != null && (this.write = n.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = n.sourceMap, this.line = 1, this.column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = {
      original: null,
      // Uses the entire state to avoid generating ephemeral objects
      generated: this,
      name: void 0,
      source: n.sourceMap.file || n.sourceMap._file
    });
  }
  write(t) {
    this.output += t;
  }
  writeToStream(t) {
    this.output.write(t);
  }
  writeAndMap(t, n) {
    this.output += t, this.map(t, n);
  }
  writeToStreamAndMap(t, n) {
    this.output.write(t), this.map(t, n);
  }
  map(t, n) {
    if (n != null) {
      const { type: s } = n;
      if (s[0] === "L" && s[2] === "n") {
        this.column = 0, this.line++;
        return;
      }
      if (n.loc != null) {
        const { mapping: o } = this;
        o.original = n.loc.start, o.name = n.name, this.sourceMap.addMapping(o);
      }
      if (s[0] === "T" && s[8] === "E" || s[0] === "L" && s[1] === "i" && typeof n.value == "string") {
        const { length: o } = t;
        let { column: a, line: l } = this;
        for (let c = 0; c < o; c++)
          t[c] === `
` ? (a = 0, l++) : a++;
        this.column = a, this.line = l;
        return;
      }
    }
    const { length: r } = t, { lineEnd: i } = this;
    r > 0 && (this.lineEndSize > 0 && (i.length === 1 ? t[r - 1] === i : t.endsWith(i)) ? (this.line += this.lineEndSize, this.column = 0) : this.column += r);
  }
  toString() {
    return this.output;
  }
}
function ide(e, t) {
  const n = new rde(t);
  return n.generator[e.type](e, n), n.output;
}
const sde = {};
function ode(e, t) {
  const { SourceMapGenerator: n, filePath: r, handlers: i } = t || sde, s = n ? new n({ file: r || "<unknown>.js" }) : void 0, o = ide(
    e,
    // @ts-expect-error: `sourceMap` can be undefined, `astring` types are buggy.
    {
      comments: !0,
      generator: { ...HN, ...i },
      sourceMap: s || void 0
    }
  ), a = s ? s.toJSON() : void 0;
  return { value: o, map: a };
}
const ade = {
  JSXAttribute: lde,
  JSXClosingElement: cde,
  JSXClosingFragment: ude,
  JSXElement: fde,
  JSXEmptyExpression: dde,
  JSXExpressionContainer: hde,
  JSXFragment: pde,
  JSXIdentifier: mde,
  JSXMemberExpression: gde,
  JSXNamespacedName: vde,
  JSXOpeningElement: yde,
  JSXOpeningFragment: xde,
  JSXSpreadAttribute: wde,
  JSXText: _de
};
function lde(e, t) {
  this[e.name.type](e.name, t), e.value !== null && e.value !== void 0 && (t.write("="), e.value.type === "Literal" ? t.write(
    '"' + UN(String(e.value.value)).replace(/"/g, "&quot;") + '"',
    e
  ) : this[e.value.type](e.value, t));
}
function cde(e, t) {
  t.write("</"), this[e.name.type](e.name, t), t.write(">");
}
function ude(e, t) {
  t.write("</>", e);
}
function fde(e, t) {
  let n = -1;
  if (this[e.openingElement.type](e.openingElement, t), e.children)
    for (; ++n < e.children.length; ) {
      const r = e.children[n];
      if (r.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[r.type](r, t);
    }
  e.closingElement && this[e.closingElement.type](e.closingElement, t);
}
function dde() {
}
function hde(e, t) {
  t.write("{"), this[e.expression.type](e.expression, t), t.write("}");
}
function pde(e, t) {
  let n = -1;
  if (this[e.openingFragment.type](e.openingFragment, t), e.children)
    for (; ++n < e.children.length; ) {
      const r = e.children[n];
      if (r.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[r.type](r, t);
    }
  this[e.closingFragment.type](e.closingFragment, t);
}
function mde(e, t) {
  t.write(e.name, e);
}
function gde(e, t) {
  this[e.object.type](e.object, t), t.write("."), this[e.property.type](e.property, t);
}
function vde(e, t) {
  this[e.namespace.type](e.namespace, t), t.write(":"), this[e.name.type](e.name, t);
}
function yde(e, t) {
  let n = -1;
  if (t.write("<"), this[e.name.type](e.name, t), e.attributes)
    for (; ++n < e.attributes.length; )
      t.write(" "), this[e.attributes[n].type](e.attributes[n], t);
  t.write(e.selfClosing ? " />" : ">");
}
function xde(e, t) {
  t.write("<>", e);
}
function wde(e, t) {
  t.write("{"), this.SpreadElement(e, t), t.write("}");
}
function _de(e, t) {
  t.write(UN(e.value).replace(/[<>{}]/g, bde), e);
}
function UN(e) {
  return e.replace(/&(?=[#a-z])/gi, "&amp;");
}
function bde(e) {
  return e === "<" ? "&lt;" : e === ">" ? "&gt;" : e === "{" ? "&#123;" : "&#125;";
}
function Cde() {
  const e = this.data(), t = e.settings || (e.settings = {}), n = t.handlers || (t.handlers = {});
  (t.plugins || (t.plugins = [])).push(nA()), Object.assign(n, ade);
}
function Ede(e) {
  const t = this;
  this.compiler = n;
  function n(r, i) {
    const s = { ...t.data("settings"), ...e }, o = ode(r, {
      SourceMapGenerator: s.SourceMapGenerator,
      filePath: i.path || "unknown.js",
      handlers: s.handlers
    });
    return i.map = o.map, o.value;
  }
}
function Sde(e, t) {
  const n = { type: "Block", value: e.value };
  t.inherit(e, n), t.comments.push(n);
  const r = {
    type: "JSXEmptyExpression",
    // @ts-expect-error: `comments` is custom.
    comments: [Object.assign({}, n, { leading: !1, trailing: !0 })]
  };
  t.patch(e, r);
  const i = { type: "JSXExpressionContainer", expression: r };
  return t.patch(e, i), i;
}
function kde(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
class Ru {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Ru.prototype.normal = {};
Ru.prototype.property = {};
Ru.prototype.space = void 0;
function jN(e, t) {
  const n = {}, r = {};
  for (const i of e)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Ru(n, r, t);
}
function a2(e) {
  return e.toLowerCase();
}
class qn {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
qn.prototype.attribute = "";
qn.prototype.booleanish = !1;
qn.prototype.boolean = !1;
qn.prototype.commaOrSpaceSeparated = !1;
qn.prototype.commaSeparated = !1;
qn.prototype.defined = !1;
qn.prototype.mustUseProperty = !1;
qn.prototype.number = !1;
qn.prototype.overloadedBoolean = !1;
qn.prototype.property = "";
qn.prototype.spaceSeparated = !1;
qn.prototype.space = void 0;
let Tde = 0;
const We = na(), zt = na(), l2 = na(), xe = na(), vt = na(), $a = na(), Gn = na();
function na() {
  return 2 ** ++Tde;
}
const c2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: We,
  booleanish: zt,
  commaOrSpaceSeparated: Gn,
  commaSeparated: $a,
  number: xe,
  overloadedBoolean: l2,
  spaceSeparated: vt
}, Symbol.toStringTag, { value: "Module" })), Jm = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(c2)
);
class Jx extends qn {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, i) {
    let s = -1;
    if (super(t, n), x3(this, "space", i), typeof r == "number")
      for (; ++s < Jm.length; ) {
        const o = Jm[s];
        x3(this, Jm[s], (r & c2[o]) === c2[o]);
      }
  }
}
Jx.prototype.defined = !0;
function x3(e, t, n) {
  n && (e[t] = n);
}
function Nl(e) {
  const t = {}, n = {};
  for (const [r, i] of Object.entries(e.properties)) {
    const s = new Jx(
      r,
      e.transform(e.attributes || {}, r),
      i,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (s.mustUseProperty = !0), t[r] = s, n[a2(r)] = r, n[a2(s.attribute)] = r;
  }
  return new Ru(t, n, e.space);
}
const WN = Nl({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: zt,
    ariaAutoComplete: null,
    ariaBusy: zt,
    ariaChecked: zt,
    ariaColCount: xe,
    ariaColIndex: xe,
    ariaColSpan: xe,
    ariaControls: vt,
    ariaCurrent: null,
    ariaDescribedBy: vt,
    ariaDetails: null,
    ariaDisabled: zt,
    ariaDropEffect: vt,
    ariaErrorMessage: null,
    ariaExpanded: zt,
    ariaFlowTo: vt,
    ariaGrabbed: zt,
    ariaHasPopup: null,
    ariaHidden: zt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: vt,
    ariaLevel: xe,
    ariaLive: null,
    ariaModal: zt,
    ariaMultiLine: zt,
    ariaMultiSelectable: zt,
    ariaOrientation: null,
    ariaOwns: vt,
    ariaPlaceholder: null,
    ariaPosInSet: xe,
    ariaPressed: zt,
    ariaReadOnly: zt,
    ariaRelevant: null,
    ariaRequired: zt,
    ariaRoleDescription: vt,
    ariaRowCount: xe,
    ariaRowIndex: xe,
    ariaRowSpan: xe,
    ariaSelected: zt,
    ariaSetSize: xe,
    ariaSort: null,
    ariaValueMax: xe,
    ariaValueMin: xe,
    ariaValueNow: xe,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function JN(e, t) {
  return t in e ? e[t] : t;
}
function KN(e, t) {
  return JN(e, t.toLowerCase());
}
const Ade = Nl({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: $a,
    acceptCharset: vt,
    accessKey: vt,
    action: null,
    allow: null,
    allowFullScreen: We,
    allowPaymentRequest: We,
    allowUserMedia: We,
    alt: null,
    as: null,
    async: We,
    autoCapitalize: null,
    autoComplete: vt,
    autoFocus: We,
    autoPlay: We,
    blocking: vt,
    capture: null,
    charSet: null,
    checked: We,
    cite: null,
    className: vt,
    cols: xe,
    colSpan: null,
    content: null,
    contentEditable: zt,
    controls: We,
    controlsList: vt,
    coords: xe | $a,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: We,
    defer: We,
    dir: null,
    dirName: null,
    disabled: We,
    download: l2,
    draggable: zt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: We,
    formTarget: null,
    headers: vt,
    height: xe,
    hidden: l2,
    high: xe,
    href: null,
    hrefLang: null,
    htmlFor: vt,
    httpEquiv: vt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: We,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: We,
    itemId: null,
    itemProp: vt,
    itemRef: vt,
    itemScope: We,
    itemType: vt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: We,
    low: xe,
    manifest: null,
    max: null,
    maxLength: xe,
    media: null,
    method: null,
    min: null,
    minLength: xe,
    multiple: We,
    muted: We,
    name: null,
    nonce: null,
    noModule: We,
    noValidate: We,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: We,
    optimum: xe,
    pattern: null,
    ping: vt,
    placeholder: null,
    playsInline: We,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: We,
    referrerPolicy: null,
    rel: vt,
    required: We,
    reversed: We,
    rows: xe,
    rowSpan: xe,
    sandbox: vt,
    scope: null,
    scoped: We,
    seamless: We,
    selected: We,
    shadowRootClonable: We,
    shadowRootDelegatesFocus: We,
    shadowRootMode: null,
    shape: null,
    size: xe,
    sizes: null,
    slot: null,
    span: xe,
    spellCheck: zt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: xe,
    step: null,
    style: null,
    tabIndex: xe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: We,
    useMap: null,
    value: zt,
    width: xe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: vt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: xe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: xe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: We,
    // Lists. Use CSS to reduce space between items instead
    declare: We,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: xe,
    // `<img>` and `<object>`
    leftMargin: xe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: xe,
    // `<body>`
    marginWidth: xe,
    // `<body>`
    noResize: We,
    // `<frame>`
    noHref: We,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: We,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: We,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: xe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: zt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: xe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: xe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: We,
    disableRemotePlayback: We,
    prefix: null,
    property: null,
    results: xe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: KN
}), Nde = Nl({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Gn,
    accentHeight: xe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: xe,
    amplitude: xe,
    arabicForm: null,
    ascent: xe,
    attributeName: null,
    attributeType: null,
    azimuth: xe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: xe,
    by: null,
    calcMode: null,
    capHeight: xe,
    className: vt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: xe,
    diffuseConstant: xe,
    direction: null,
    display: null,
    dur: null,
    divisor: xe,
    dominantBaseline: null,
    download: We,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: xe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: xe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: xe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: $a,
    g2: $a,
    glyphName: $a,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: xe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: xe,
    horizOriginX: xe,
    horizOriginY: xe,
    id: null,
    ideographic: xe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: xe,
    k: xe,
    k1: xe,
    k2: xe,
    k3: xe,
    k4: xe,
    kernelMatrix: Gn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: xe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: xe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: xe,
    overlineThickness: xe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: xe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: vt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: xe,
    pointsAtY: xe,
    pointsAtZ: xe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Gn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Gn,
    rev: Gn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Gn,
    requiredFeatures: Gn,
    requiredFonts: Gn,
    requiredFormats: Gn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: xe,
    specularExponent: xe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: xe,
    strikethroughThickness: xe,
    string: null,
    stroke: null,
    strokeDashArray: Gn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: xe,
    strokeOpacity: xe,
    strokeWidth: null,
    style: null,
    surfaceScale: xe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Gn,
    tabIndex: xe,
    tableValues: null,
    target: null,
    targetX: xe,
    targetY: xe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Gn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: xe,
    underlineThickness: xe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: xe,
    values: null,
    vAlphabetic: xe,
    vMathematical: xe,
    vectorEffect: null,
    vHanging: xe,
    vIdeographic: xe,
    version: null,
    vertAdvY: xe,
    vertOriginX: xe,
    vertOriginY: xe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: xe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: JN
}), qN = Nl({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), GN = Nl({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: KN
}), YN = Nl({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), Ide = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Lde = /[A-Z]/g, w3 = /-[a-z]/g, Mde = /^data[-\w.:]+$/i;
function Ode(e, t) {
  const n = a2(t);
  let r = t, i = qn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Mde.test(t)) {
    if (t.charAt(4) === "-") {
      const s = t.slice(5).replace(w3, Dde);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = t.slice(4);
      if (!w3.test(s)) {
        let o = s.replace(Lde, Pde);
        o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o;
      }
    }
    i = Jx;
  }
  return new i(r, t);
}
function Pde(e) {
  return "-" + e.toLowerCase();
}
function Dde(e) {
  return e.charAt(1).toUpperCase();
}
const Fde = jN([WN, Ade, qN, GN, YN], "html"), Kx = jN([WN, Nde, qN, GN, YN], "svg");
function Rde(e) {
  return e.join(" ").trim();
}
var qx = {}, _3 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, $de = /\n/g, Vde = /^\s*/, Bde = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, zde = /^:\s*/, Hde = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Ude = /^[;\s]*/, jde = /^\s+|\s+$/g, Wde = `
`, b3 = "/", C3 = "*", vo = "", Jde = "comment", Kde = "declaration", qde = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function i(m) {
    var p = m.match($de);
    p && (n += p.length);
    var y = m.lastIndexOf(Wde);
    r = ~y ? m.length - y : r + m.length;
  }
  function s() {
    var m = { line: n, column: r };
    return function(p) {
      return p.position = new o(m), c(), p;
    };
  }
  function o(m) {
    this.start = m, this.end = { line: n, column: r }, this.source = t.source;
  }
  o.prototype.content = e;
  function a(m) {
    var p = new Error(
      t.source + ":" + n + ":" + r + ": " + m
    );
    if (p.reason = m, p.filename = t.source, p.line = n, p.column = r, p.source = e, !t.silent) throw p;
  }
  function l(m) {
    var p = m.exec(e);
    if (p) {
      var y = p[0];
      return i(y), e = e.slice(y.length), p;
    }
  }
  function c() {
    l(Vde);
  }
  function u(m) {
    var p;
    for (m = m || []; p = f(); )
      p !== !1 && m.push(p);
    return m;
  }
  function f() {
    var m = s();
    if (!(b3 != e.charAt(0) || C3 != e.charAt(1))) {
      for (var p = 2; vo != e.charAt(p) && (C3 != e.charAt(p) || b3 != e.charAt(p + 1)); )
        ++p;
      if (p += 2, vo === e.charAt(p - 1))
        return a("End of comment missing");
      var y = e.slice(2, p - 2);
      return r += 2, i(y), e = e.slice(p), r += 2, m({
        type: Jde,
        comment: y
      });
    }
  }
  function d() {
    var m = s(), p = l(Bde);
    if (p) {
      if (f(), !l(zde)) return a("property missing ':'");
      var y = l(Hde), v = m({
        type: Kde,
        property: E3(p[0].replace(_3, vo)),
        value: y ? E3(y[0].replace(_3, vo)) : vo
      });
      return l(Ude), v;
    }
  }
  function h() {
    var m = [];
    u(m);
    for (var p; p = d(); )
      p !== !1 && (m.push(p), u(m));
    return m;
  }
  return c(), h();
};
function E3(e) {
  return e ? e.replace(jde, vo) : vo;
}
var Gde = Xa && Xa.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(qx, "__esModule", { value: !0 });
qx.default = Xde;
var Yde = Gde(qde);
function Xde(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Yde.default)(e), i = typeof t == "function";
  return r.forEach(function(s) {
    if (s.type === "declaration") {
      var o = s.property, a = s.value;
      i ? t(o, a, s) : a && (n = n || {}, n[o] = a);
    }
  }), n;
}
var i1 = {};
Object.defineProperty(i1, "__esModule", { value: !0 });
i1.camelCase = void 0;
var Zde = /^--[a-zA-Z0-9_-]+$/, Qde = /-([a-z])/g, ehe = /^[^-]+$/, the = /^-(webkit|moz|ms|o|khtml)-/, nhe = /^-(ms)-/, rhe = function(e) {
  return !e || ehe.test(e) || Zde.test(e);
}, ihe = function(e, t) {
  return t.toUpperCase();
}, S3 = function(e, t) {
  return "".concat(t, "-");
}, she = function(e, t) {
  return t === void 0 && (t = {}), rhe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(nhe, S3) : e = e.replace(the, S3), e.replace(Qde, ihe));
};
i1.camelCase = she;
var ohe = Xa && Xa.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ahe = ohe(qx), lhe = i1;
function u2(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ahe.default)(e, function(r, i) {
    r && i && (n[(0, lhe.camelCase)(r, t)] = i);
  }), n;
}
u2.default = u2;
var che = u2;
const uhe = /* @__PURE__ */ yl(che), f2 = {}.hasOwnProperty, fhe = /[A-Z]/g, dhe = /* @__PURE__ */ new Set(["td", "th"]);
function hhe(e, t) {
  const n = t.schema;
  let r = n;
  const i = e.properties || {};
  n.space === "html" && e.tagName.toLowerCase() === "svg" && (r = Kx, t.schema = r);
  const s = t.all(e), o = [];
  let a, l, c;
  for (a in i)
    if (f2.call(i, a)) {
      let f = i[a];
      const d = Ode(r, a);
      let h;
      if (f == null || f === !1 || typeof f == "number" && Number.isNaN(f) || !f && d.boolean)
        continue;
      if (a = t.elementAttributeNameCase === "react" && d.space ? Ide[d.property] || d.property : d.attribute, Array.isArray(f) && (f = d.commaSeparated ? kde(f) : Rde(f)), a === "style") {
        let m = typeof f == "object" ? f : phe(String(f), e.tagName);
        t.stylePropertyNameCase === "css" && (m = mhe(m));
        const p = [];
        let y;
        for (y in m)
          f2.call(m, y) && p.push({
            type: "Property",
            method: !1,
            shorthand: !1,
            computed: !1,
            key: hi(y) ? { type: "Identifier", name: y } : { type: "Literal", value: y },
            value: { type: "Literal", value: String(m[y]) },
            kind: "init"
          });
        c = p, h = {
          type: "JSXExpressionContainer",
          expression: { type: "ObjectExpression", properties: p }
        };
      } else if (f === !0)
        h = null;
      else if (t.tableCellAlignToStyle && dhe.has(e.tagName) && a === "align") {
        l = String(f);
        continue;
      } else
        h = { type: "Literal", value: String(f) };
      hi(a, { jsx: !0 }) ? o.push({
        type: "JSXAttribute",
        name: { type: "JSXIdentifier", name: a },
        value: h
      }) : o.push({
        type: "JSXSpreadAttribute",
        argument: {
          type: "ObjectExpression",
          properties: [
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              key: { type: "Literal", value: String(a) },
              // @ts-expect-error No need to worry about `style` (which has a
              // `JSXExpressionContainer` value) because that’s a valid identifier.
              value: h || { type: "Literal", value: !0 },
              kind: "init"
            }
          ]
        }
      });
    }
  if (l !== void 0) {
    c || (c = [], o.push({
      type: "JSXAttribute",
      name: { type: "JSXIdentifier", name: "style" },
      value: {
        type: "JSXExpressionContainer",
        expression: { type: "ObjectExpression", properties: c }
      }
    }));
    const f = t.stylePropertyNameCase === "css" ? XN("textAlign") : "textAlign";
    c.push({
      type: "Property",
      method: !1,
      shorthand: !1,
      computed: !1,
      key: hi(f) ? { type: "Identifier", name: f } : { type: "Literal", value: f },
      value: { type: "Literal", value: l },
      kind: "init"
    });
  }
  t.schema = n;
  const u = {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: o,
      name: t.createJsxElementName(e.tagName),
      selfClosing: s.length === 0
    },
    closingElement: s.length > 0 ? {
      type: "JSXClosingElement",
      name: t.createJsxElementName(e.tagName)
    } : null,
    children: s
  };
  return t.inherit(e, u), u;
}
function phe(e, t) {
  try {
    return uhe(e, { reactCompat: !0 });
  } catch (n) {
    const r = (
      /** @type {Error} */
      n
    );
    throw new Error(
      "Could not parse `style` attribute on `" + t + "`",
      { cause: r }
    );
  }
}
function mhe(e) {
  const t = {};
  let n;
  for (n in e)
    f2.call(e, n) && (t[XN(n)] = e[n]);
  return t;
}
function XN(e) {
  let t = e.replace(fhe, ghe);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function ghe(e) {
  return "-" + e.toLowerCase();
}
const vhe = {}.hasOwnProperty, yhe = [];
function Ih(e, t) {
  const n = t ? [...t].sort(Gx) : yhe;
  n.length > 0 && ZN(e, { comments: n, index: 0 });
}
function ZN(e, t) {
  if (t.index === t.comments.length)
    return;
  const n = [], r = [];
  let i;
  for (i in e)
    if (vhe.call(e, i)) {
      const o = e[i];
      if (o && typeof o == "object" && i !== "comments")
        if (Array.isArray(o)) {
          let a = -1;
          for (; ++a < o.length; )
            o[a] && typeof o[a].type == "string" && n.push(o[a]);
        } else typeof o.type == "string" && n.push(o);
    }
  n.sort(Gx), r.push(...k3(t, e, !1, { leading: !0, trailing: !1 }));
  let s = -1;
  for (; ++s < n.length; )
    ZN(n[s], t);
  r.push(
    ...k3(t, e, !0, {
      leading: !1,
      trailing: n.length > 0
    })
  ), r.length > 0 && (e.comments = r);
}
function k3(e, t, n, r) {
  const i = [];
  for (; e.comments[e.index] && Gx(e.comments[e.index], t, n) < 1; )
    i.push(Object.assign({}, e.comments[e.index++], r));
  return i;
}
function Gx(e, t, n) {
  const r = n ? "end" : "start";
  return e.range && t.range ? e.range[0] - t.range[n ? 1 : 0] : e.loc && e.loc.start && t.loc && t.loc[r] ? e.loc.start.line - t.loc[r].line || e.loc.start.column - t.loc[r].column : "start" in e && r in t ? e.start - t[r] : Number.NaN;
}
function T3(e, t) {
  const n = e.data && e.data.estree, r = n && n.comments || [];
  let i;
  n && (t.comments.push(...r), Ih(n, n.comments), i = n.body[0] && n.body[0].type === "ExpressionStatement" && n.body[0].expression || void 0), i || (i = { type: "JSXEmptyExpression" }, t.patch(e, i));
  const s = { type: "JSXExpressionContainer", expression: i };
  return t.inherit(e, s), s;
}
function A3(e, t) {
  const n = t.schema;
  let r = n;
  const i = e.attributes || [];
  let s = -1;
  e.name && n.space === "html" && e.name.toLowerCase() === "svg" && (r = Kx, t.schema = r);
  const o = t.all(e), a = [];
  for (; ++s < i.length; ) {
    const c = i[s], u = c.value;
    let f;
    if (c.type === "mdxJsxAttribute") {
      if (u == null)
        f = null;
      else if (typeof u == "object") {
        const h = u.data && u.data.estree, m = h && h.comments || [];
        let p;
        h && (t.comments.push(...m), Ih(h, h.comments), p = h.body[0] && h.body[0].type === "ExpressionStatement" && h.body[0].expression || void 0), f = {
          type: "JSXExpressionContainer",
          expression: p || { type: "JSXEmptyExpression" }
        }, t.inherit(u, f);
      } else
        f = { type: "Literal", value: String(u) };
      const d = {
        type: "JSXAttribute",
        name: t.createJsxAttributeName(c.name),
        value: f
      };
      t.inherit(c, d), a.push(d);
    } else {
      const d = c.data && c.data.estree, h = d && d.comments || [];
      let m;
      d && (t.comments.push(...h), Ih(d, d.comments), m = d.body[0] && d.body[0].type === "ExpressionStatement" && d.body[0].expression && d.body[0].expression.type === "ObjectExpression" && d.body[0].expression.properties && d.body[0].expression.properties[0] && d.body[0].expression.properties[0].type === "SpreadElement" && d.body[0].expression.properties[0].argument || void 0);
      const p = {
        type: "JSXSpreadAttribute",
        argument: m || { type: "ObjectExpression", properties: [] }
      };
      t.inherit(c, p), a.push(p);
    }
  }
  t.schema = n;
  const l = e.name ? {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: a,
      name: t.createJsxElementName(e.name),
      selfClosing: o.length === 0
    },
    closingElement: o.length > 0 ? {
      type: "JSXClosingElement",
      name: t.createJsxElementName(e.name)
    } : null,
    children: o
  } : {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: o
  };
  return t.inherit(e, l), l;
}
function xhe(e, t) {
  const n = e.data && e.data.estree, r = n && n.comments || [];
  n && (t.comments.push(...r), Ih(n, r), t.esm.push(...n.body));
}
const whe = /[ \t\n\f\r]/g;
function _he(e) {
  return typeof e == "object" ? e.type === "text" ? N3(e.value) : !1 : N3(e);
}
function N3(e) {
  return e.replace(whe, "") === "";
}
function bhe(e, t) {
  const n = t.all(e), r = [];
  let i = -1, s;
  for (; ++i < n.length; ) {
    const a = n[i];
    a.type === "JSXExpressionContainer" && a.expression.type === "Literal" && _he(String(a.expression.value)) ? s && s.push(a) : (s && r.push(...s), r.push(a), s = []);
  }
  const o = {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: r
  };
  return t.inherit(e, o), o;
}
function Che(e, t) {
  const n = String(e.value || "");
  if (n) {
    const r = { type: "Literal", value: n };
    t.inherit(e, r);
    const i = { type: "JSXExpressionContainer", expression: r };
    return t.patch(e, i), i;
  }
}
const Ehe = {
  comment: Sde,
  doctype: She,
  element: hhe,
  mdxFlowExpression: T3,
  mdxJsxFlowElement: A3,
  mdxJsxTextElement: A3,
  mdxTextExpression: T3,
  mdxjsEsm: xhe,
  root: bhe,
  text: Che
};
function She() {
}
const QN = tI("end"), eI = tI("start");
function tI(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function nI(e) {
  const t = eI(e), n = QN(e);
  if (t && n)
    return { start: t, end: n };
}
const khe = {}.hasOwnProperty, The = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
function Ahe(e) {
  const t = a6("type", {
    invalid: Nhe,
    unknown: Ihe,
    handlers: { ...Ehe, ...e.handlers }
  });
  return {
    // Current space.
    elementAttributeNameCase: e.elementAttributeNameCase || "react",
    schema: e.space === "svg" ? Kx : Fde,
    stylePropertyNameCase: e.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: e.tableCellAlignToStyle !== !1,
    // Results.
    comments: [],
    esm: [],
    // Useful functions.
    all: Lhe,
    createJsxAttributeName: Ohe,
    createJsxElementName: Phe,
    handle: n,
    inherit: Mhe,
    patch: rI
  };
  function n(r) {
    return t(r, this);
  }
}
function Nhe(e) {
  throw new Error("Cannot handle value `" + e + "`, expected node");
}
function Ihe(e) {
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function Lhe(e) {
  const t = e.children || [];
  let n = -1;
  const r = [], i = this.schema.space === "html" && e.type === "element" && The.has(e.tagName.toLowerCase());
  for (; ++n < t.length; ) {
    const s = t[n];
    if (i && s.type === "text" && s.value === `
`)
      continue;
    const o = this.handle(s);
    Array.isArray(o) ? r.push(...o) : o && r.push(o);
  }
  return r;
}
function Mhe(e, t) {
  const n = (
    /** @type {Record<string, unknown> | undefined} */
    e.data
  );
  let r, i;
  if (rI(e, t), n) {
    for (i in n)
      khe.call(n, i) && i !== "estree" && (r || (r = {}), r[i] = n[i]);
    r && (t.data = r);
  }
}
function rI(e, t) {
  const n = nI(e);
  n && n.start.offset !== void 0 && n.end.offset !== void 0 && (t.start = n.start.offset, t.end = n.end.offset, t.loc = {
    start: { line: n.start.line, column: n.start.column - 1 },
    end: { line: n.end.line, column: n.end.column - 1 }
  }, t.range = [n.start.offset, n.end.offset]);
}
function Ohe(e) {
  const t = iI(e);
  if (t.type === "JSXMemberExpression")
    throw new Error("Member expressions in attribute names are not supported");
  return t;
}
function Phe(e) {
  return iI(e);
}
function iI(e) {
  if (e.includes(".")) {
    const t = e.split(".");
    let n = t.shift(), r = { type: "JSXIdentifier", name: n };
    for (; n = t.shift(); )
      r = {
        type: "JSXMemberExpression",
        object: r,
        property: { type: "JSXIdentifier", name: n }
      };
    return r;
  }
  if (e.includes(":")) {
    const t = e.split(":");
    return {
      type: "JSXNamespacedName",
      namespace: { type: "JSXIdentifier", name: t[0] },
      name: { type: "JSXIdentifier", name: t[1] }
    };
  }
  return { type: "JSXIdentifier", name: e };
}
function Dhe(e, t) {
  const n = Ahe(t || {});
  let r = n.handle(e);
  const i = n.esm;
  if (r) {
    r.type !== "JSXFragment" && r.type !== "JSXElement" && (r = {
      type: "JSXFragment",
      openingFragment: { type: "JSXOpeningFragment" },
      closingFragment: { type: "JSXClosingFragment" },
      children: [r]
    }, n.patch(e, r));
    const o = { type: "ExpressionStatement", expression: r };
    n.patch(e, o), i.push(o);
  }
  const s = {
    type: "Program",
    body: i,
    sourceType: "module",
    comments: n.comments
  };
  return n.patch(e, s), s;
}
function Fhe(e) {
  return function(t) {
    return Dhe(t, e);
  };
}
const Rhe = {};
function $he(e) {
  const t = this, n = e || Rhe, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(rA(n)), s.push(xT()), o.push(cx(n));
}
function Vhe(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return Ud(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Bhe(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function zhe(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Hhe(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function Uhe(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function jhe(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Whe(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = gl(r.toLowerCase()), s = e.footnoteOrder.indexOf(r);
  let o, a = e.footnoteCounts.get(r);
  a === void 0 ? (a = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = s + 1, a += 1, e.footnoteCounts.set(r, a);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (a > 1 ? "-" + a : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(o) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function Jhe(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Khe(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function sI(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), s = i[0];
  s && s.type === "text" ? s.value = "[" + s.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function qhe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return sI(e, t);
  const i = { src: gl(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const s = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, s), e.applyData(t, s);
}
function Ghe(e, t) {
  const n = { src: gl(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Yhe(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Xhe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return sI(e, t);
  const i = { href: gl(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function Zhe(e, t) {
  const n = { href: gl(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Qhe(e, t, n) {
  const r = e.all(t), i = n ? epe(n) : oI(t), s = {}, o = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let f;
    u && u.type === "element" && u.tagName === "p" ? f = u : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const u = r[a];
    (i || a !== 0 || u.type !== "element" || u.tagName !== "p") && o.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !i ? o.push(...u.children) : o.push(u);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && o.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: s, children: o };
  return e.patch(t, c), e.applyData(t, c);
}
function epe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = oI(n[r]);
  }
  return t;
}
function oI(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function tpe(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function npe(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function rpe(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function ipe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function spe(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], o), i.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, a = eI(t.children[1]), l = QN(t.children[t.children.length - 1]);
    a && l && (o.position = { start: a, end: l }), i.push(o);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function ope(e, t, n) {
  const r = n ? n.children : void 0, s = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, a = o ? o.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < a; ) {
    const f = t.children[l], d = {}, h = o ? o[l] : void 0;
    h && (d.align = h);
    let m = { type: "element", tagName: s, properties: d, children: [] };
    f && (m.children = e.all(f), e.patch(f, m), m = e.applyData(f, m)), c.push(m);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function ape(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const I3 = 9, L3 = 32;
function lpe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const s = [];
  for (; r; )
    s.push(
      M3(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return s.push(M3(t.slice(i), i > 0, !1)), s.join("");
}
function M3(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let s = e.codePointAt(r);
    for (; s === I3 || s === L3; )
      r++, s = e.codePointAt(r);
  }
  if (n) {
    let s = e.codePointAt(i - 1);
    for (; s === I3 || s === L3; )
      i--, s = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function cpe(e, t) {
  const n = { type: "text", value: lpe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function upe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const fpe = {
  blockquote: Bhe,
  break: zhe,
  code: Hhe,
  delete: Uhe,
  emphasis: jhe,
  footnoteReference: Whe,
  heading: Jhe,
  html: Khe,
  imageReference: qhe,
  image: Ghe,
  inlineCode: Yhe,
  linkReference: Xhe,
  link: Zhe,
  listItem: Qhe,
  list: tpe,
  paragraph: npe,
  // @ts-expect-error: root is different, but hard to type.
  root: rpe,
  strong: ipe,
  table: spe,
  tableCell: ape,
  tableRow: ope,
  text: cpe,
  thematicBreak: upe,
  toml: yf,
  yaml: yf,
  definition: yf,
  footnoteDefinition: yf
};
function yf() {
}
const aI = -1, s1 = 0, vc = 1, Lh = 2, Yx = 3, Xx = 4, Zx = 5, Qx = 6, lI = 7, cI = 8, O3 = typeof self == "object" ? self : globalThis, dpe = (e, t) => {
  const n = (i, s) => (e.set(s, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [s, o] = t[i];
    switch (s) {
      case s1:
      case aI:
        return n(o, i);
      case vc: {
        const a = n([], i);
        for (const l of o)
          a.push(r(l));
        return a;
      }
      case Lh: {
        const a = n({}, i);
        for (const [l, c] of o)
          a[r(l)] = r(c);
        return a;
      }
      case Yx:
        return n(new Date(o), i);
      case Xx: {
        const { source: a, flags: l } = o;
        return n(new RegExp(a, l), i);
      }
      case Zx: {
        const a = n(/* @__PURE__ */ new Map(), i);
        for (const [l, c] of o)
          a.set(r(l), r(c));
        return a;
      }
      case Qx: {
        const a = n(/* @__PURE__ */ new Set(), i);
        for (const l of o)
          a.add(r(l));
        return a;
      }
      case lI: {
        const { name: a, message: l } = o;
        return n(new O3[a](l), i);
      }
      case cI:
        return n(BigInt(o), i);
      case "BigInt":
        return n(Object(BigInt(o)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(o).buffer, o);
      case "DataView": {
        const { buffer: a } = new Uint8Array(o);
        return n(new DataView(a), o);
      }
    }
    return n(new O3[s](o), i);
  };
  return r;
}, P3 = (e) => dpe(/* @__PURE__ */ new Map(), e)(0), da = "", { toString: hpe } = {}, { keys: ppe } = Object, jl = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [s1, t];
  const n = hpe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [vc, da];
    case "Object":
      return [Lh, da];
    case "Date":
      return [Yx, da];
    case "RegExp":
      return [Xx, da];
    case "Map":
      return [Zx, da];
    case "Set":
      return [Qx, da];
    case "DataView":
      return [vc, n];
  }
  return n.includes("Array") ? [vc, n] : n.includes("Error") ? [lI, n] : [Lh, n];
}, xf = ([e, t]) => e === s1 && (t === "function" || t === "symbol"), mpe = (e, t, n, r) => {
  const i = (o, a) => {
    const l = r.push(o) - 1;
    return n.set(a, l), l;
  }, s = (o) => {
    if (n.has(o))
      return n.get(o);
    let [a, l] = jl(o);
    switch (a) {
      case s1: {
        let u = o;
        switch (l) {
          case "bigint":
            a = cI, u = o.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            u = null;
            break;
          case "undefined":
            return i([aI], o);
        }
        return i([a, u], o);
      }
      case vc: {
        if (l) {
          let d = o;
          return l === "DataView" ? d = new Uint8Array(o.buffer) : l === "ArrayBuffer" && (d = new Uint8Array(o)), i([l, [...d]], o);
        }
        const u = [], f = i([a, u], o);
        for (const d of o)
          u.push(s(d));
        return f;
      }
      case Lh: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, o.toString()], o);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, o.valueOf()], o);
          }
        if (t && "toJSON" in o)
          return s(o.toJSON());
        const u = [], f = i([a, u], o);
        for (const d of ppe(o))
          (e || !xf(jl(o[d]))) && u.push([s(d), s(o[d])]);
        return f;
      }
      case Yx:
        return i([a, o.toISOString()], o);
      case Xx: {
        const { source: u, flags: f } = o;
        return i([a, { source: u, flags: f }], o);
      }
      case Zx: {
        const u = [], f = i([a, u], o);
        for (const [d, h] of o)
          (e || !(xf(jl(d)) || xf(jl(h)))) && u.push([s(d), s(h)]);
        return f;
      }
      case Qx: {
        const u = [], f = i([a, u], o);
        for (const d of o)
          (e || !xf(jl(d))) && u.push(s(d));
        return f;
      }
    }
    const { message: c } = o;
    return i([a, { name: l, message: c }], o);
  };
  return s;
}, D3 = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return mpe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Mh = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? P3(D3(e, t)) : structuredClone(e)
) : (e, t) => P3(D3(e, t));
function gpe(e, t) {
  const n = [{ type: "text", value: "↩" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function vpe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function ype(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || gpe, r = e.options.footnoteBackLabel || vpe, i = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, a = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const u = e.all(c), f = String(c.identifier).toUpperCase(), d = gl(f.toLowerCase());
    let h = 0;
    const m = [], p = e.footnoteCounts.get(f);
    for (; p !== void 0 && ++h <= p; ) {
      m.length > 0 && m.push({ type: "text", value: " " });
      let g = typeof n == "string" ? n : n(l, h);
      typeof g == "string" && (g = { type: "text", value: g }), m.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + d + (h > 1 ? "-" + h : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, h),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(g) ? g : [g]
      });
    }
    const y = u[u.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const g = y.children[y.children.length - 1];
      g && g.type === "text" ? g.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...m);
    } else
      u.push(...m);
    const v = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + d },
      children: e.wrap(u, !0)
    };
    e.patch(c, v), a.push(v);
  }
  if (a.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...Mh(o),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(a, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const d2 = {}.hasOwnProperty, xpe = {};
function wpe(e, t) {
  const n = t || xpe, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), o = { ...fpe, ...n.handlers }, a = {
    all: c,
    applyData: bpe,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: o,
    one: l,
    options: n,
    patch: _pe,
    wrap: Epe
  };
  return cu(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const f = u.type === "definition" ? r : i, d = String(u.identifier).toUpperCase();
      f.has(d) || f.set(d, u);
    }
  }), a;
  function l(u, f) {
    const d = u.type, h = a.handlers[d];
    if (d2.call(a.handlers, d) && h)
      return h(a, u, f);
    if (a.options.passThrough && a.options.passThrough.includes(d)) {
      if ("children" in u) {
        const { children: p, ...y } = u, v = Mh(y);
        return v.children = a.all(u), v;
      }
      return Mh(u);
    }
    return (a.options.unknownHandler || Cpe)(a, u, f);
  }
  function c(u) {
    const f = [];
    if ("children" in u) {
      const d = u.children;
      let h = -1;
      for (; ++h < d.length; ) {
        const m = a.one(d[h], u);
        if (m) {
          if (h && d[h - 1].type === "break" && (!Array.isArray(m) && m.type === "text" && (m.value = F3(m.value)), !Array.isArray(m) && m.type === "element")) {
            const p = m.children[0];
            p && p.type === "text" && (p.value = F3(p.value));
          }
          Array.isArray(m) ? f.push(...m) : f.push(m);
        }
      }
    }
    return f;
  }
}
function _pe(e, t) {
  e.position && (t.position = nI(e));
}
function bpe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, s = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const o = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: o };
      }
    n.type === "element" && s && Object.assign(n.properties, Mh(s)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function Cpe(e, t) {
  const n = t.data || {}, r = "value" in t && !(d2.call(n, "hProperties") || d2.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Epe(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function F3(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function R3(e, t) {
  const n = wpe(e, t), r = n.one(e, void 0), i = ype(n), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && s.children.push({ type: "text", value: `
` }, i), s;
}
function Spe(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      R3(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      R3(n, { file: r, ...e || t })
    );
  };
}
function $3(e) {
  if (e)
    throw e;
}
var Yf = Object.prototype.hasOwnProperty, uI = Object.prototype.toString, V3 = Object.defineProperty, B3 = Object.getOwnPropertyDescriptor, z3 = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : uI.call(t) === "[object Array]";
}, H3 = function(t) {
  if (!t || uI.call(t) !== "[object Object]")
    return !1;
  var n = Yf.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Yf.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || Yf.call(t, i);
}, U3 = function(t, n) {
  V3 && n.name === "__proto__" ? V3(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, j3 = function(t, n) {
  if (n === "__proto__")
    if (Yf.call(t, n)) {
      if (B3)
        return B3(t, n).value;
    } else return;
  return t[n];
}, kpe = function e() {
  var t, n, r, i, s, o, a = arguments[0], l = 1, c = arguments.length, u = !1;
  for (typeof a == "boolean" && (u = a, a = arguments[1] || {}, l = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); l < c; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = j3(a, n), i = j3(t, n), a !== i && (u && i && (H3(i) || (s = z3(i))) ? (s ? (s = !1, o = r && z3(r) ? r : []) : o = r && H3(r) ? r : {}, U3(a, { name: n, newValue: e(u, o, i) })) : typeof i < "u" && U3(a, { name: n, newValue: i }));
  return a;
};
const Km = /* @__PURE__ */ yl(kpe);
function h2(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Tpe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...i);
    function a(l, ...c) {
      const u = e[++s];
      let f = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++f < i.length; )
        (c[f] === null || c[f] === void 0) && (c[f] = i[f]);
      i = c, u ? Ape(u, a)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function Ape(e, t) {
  let n;
  return r;
  function r(...o) {
    const a = e.length > o.length;
    let l;
    a && o.push(i);
    try {
      l = e.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (a && n)
        throw u;
      return i(u);
    }
    a || (l && l.then && typeof l.then == "function" ? l.then(s, i) : l instanceof Error ? i(l) : s(l));
  }
  function i(o, ...a) {
    n || (n = !0, t(o, ...a));
  }
  function s(o) {
    i(null, o);
  }
}
const Npe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  }
), Ipe = {}.hasOwnProperty;
class e5 extends Npe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Tpe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new e5()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Km(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Ym("data", this.frozen), this.namespace[t] = n, this) : Ipe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Ym("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = wf(t), r = this.parser || this.Parser;
    return qm("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), qm("process", this.parser || this.Parser), Gm("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(s, o) {
      const a = wf(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(l, a, function(u, f, d) {
        if (u || !f || !d)
          return c(u);
        const h = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), m = r.stringify(h, d);
        Ope(m) ? d.value = m : d.result = m, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          d
        );
      });
      function c(u, f) {
        u || !f ? o(u) : s ? s(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), qm("processSync", this.parser || this.Parser), Gm("processSync", this.compiler || this.Compiler), this.process(t, i), J3("processSync", "process", n), r;
    function i(s, o) {
      n = !0, $3(s), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    W3(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? s(void 0, r) : new Promise(s);
    function s(o, a) {
      const l = wf(n);
      i.run(t, l, c);
      function c(u, f, d) {
        const h = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        u ? a(u) : o ? o(h) : r(void 0, h, d);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, s), J3("runSync", "run", r), i;
    function s(o, a) {
      $3(o), i = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = wf(n), i = this.compiler || this.Compiler;
    return Gm("stringify", i), W3(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (Ym("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? a(t) : o(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function s(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, f);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(c.plugins), c.settings && (i.settings = Km(!0, i.settings, c.settings));
    }
    function a(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const f = c[u];
          s(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let f = -1, d = -1;
      for (; ++f < r.length; )
        if (r[f][0] === c) {
          d = f;
          break;
        }
      if (d === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [h, ...m] = u;
        const p = r[d][1];
        h2(p) && h2(h) && (h = Km(!0, p, h)), r[d] = [c, h, ...m];
      }
    }
  }
}
const Lpe = new e5().freeze();
function qm(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Gm(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Ym(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function W3(e) {
  if (!h2(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function J3(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function wf(e) {
  return Mpe(e) ? e : new BN(e);
}
function Mpe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function Ope(e) {
  return typeof e == "string" || Ppe(e);
}
function Ppe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
function ks(e, t) {
  const n = ["start", "end", "loc", "range"];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    i in e && (t[i] = e[i]);
  }
}
function t5(e, t) {
  let n = -1;
  const r = [], i = [];
  let s;
  for (; ++n < e.length; ) {
    const o = e[n];
    o.type === "ImportNamespaceSpecifier" ? s = o : i.push(o);
  }
  if (s) {
    const o = {
      type: "VariableDeclarator",
      id: s.local,
      init: t
    };
    ks(s, o), r.push(o);
  }
  return r.push({
    type: "VariableDeclarator",
    id: {
      type: "ObjectPattern",
      properties: i.map(function(o) {
        let a = o.type === "ImportSpecifier" ? o.imported : o.type === "ExportSpecifier" ? o.exported : { type: "Identifier", name: "default" }, l = o.local;
        o.type === "ExportSpecifier" && (l = a, a = o.local), l.type;
        const c = {
          type: "Property",
          kind: "init",
          shorthand: a.type === "Identifier" && l.type === "Identifier" && a.name === l.name,
          method: !1,
          computed: !1,
          key: a,
          value: l
        };
        return ks(o, c), c;
      })
    },
    init: s ? { type: "Identifier", name: s.local.name } : t
  }), r;
}
function Rs(e) {
  let t = -1, n;
  for (; ++t < e.length; ) {
    const r = e[t], i = typeof r == "string" && hi(r) ? { type: "Identifier", name: r } : { type: "Literal", value: r };
    n = n ? {
      type: "MemberExpression",
      object: n,
      property: i,
      computed: i.type === "Literal",
      optional: !1
    } : i;
  }
  return n.type, n;
}
function K3(e) {
  let t = -1, n;
  for (; ++t < e.length; ) {
    const r = e[t];
    typeof r == "string" && hi(r, { jsx: !0 });
    const i = { type: "JSXIdentifier", name: r };
    n = n ? { type: "JSXMemberExpression", object: n, property: i } : i;
  }
  return n;
}
function Dpe(e) {
  const { outputFormat: t } = e || {};
  return function(n) {
    if (n.comments && (n.comments = n.comments.filter(function(r) {
      var i;
      return !((i = r.data) != null && i._mdxIsPragmaComment);
    })), t === "function-body") {
      let r = 0;
      for (; r < n.body.length; ) {
        const s = n.body[r];
        if ("directive" in s && s.directive)
          r++;
        else
          break;
      }
      const i = n.body[r];
      i && i.type === "ImportDeclaration" && typeof i.source.value == "string" && /\/jsx-(dev-)?runtime$/.test(i.source.value) && (n.body[r] = {
        type: "VariableDeclaration",
        kind: "const",
        declarations: t5(
          i.specifiers,
          Rs(["arguments", 0])
        )
      });
    }
  };
}
function fI() {
  const e = [{ block: !1, defined: [] }];
  return { enter: t, exit: n, scopes: e };
  function t(s) {
    if (s.type === "ArrowFunctionExpression") {
      e.push({ block: !1, defined: [] });
      for (const o of s.params)
        i(o, !1);
    } else if (s.type === "BlockStatement" || s.type === "DoWhileStatement" || s.type === "ForInStatement" || s.type === "ForOfStatement" || s.type === "ForStatement" || s.type === "WhileStatement")
      e.push({ block: !0, defined: [] });
    else if (s.type === "CatchClause")
      e.push({ block: !0, defined: [] }), s.param && i(s.param, !0);
    else if (s.type === "ClassDeclaration")
      r(s.id.name, !1);
    else if (s.type === "FunctionDeclaration") {
      r(s.id.name, !1), e.push({ block: !1, defined: [] });
      for (const o of s.params)
        i(o, !1);
    } else if (s.type === "FunctionExpression") {
      s.id && r(s.id.name, !1), e.push({ block: !1, defined: [] });
      for (const o of s.params)
        i(o, !1);
    } else if (s.type === "ImportDeclaration")
      for (const o of s.specifiers)
        r(o.local.name, !1);
    else if (s.type === "VariableDeclaration")
      for (const o of s.declarations)
        i(o.id, s.kind !== "var");
  }
  function n(s) {
    if (s.type === "ArrowFunctionExpression" || s.type === "FunctionDeclaration" || s.type === "FunctionExpression") {
      const o = e.pop();
      o.block;
    } else if (s.type === "BlockStatement" || s.type === "CatchClause" || s.type === "DoWhileStatement" || s.type === "ForInStatement" || s.type === "ForOfStatement" || s.type === "ForStatement" || s.type === "WhileStatement") {
      const o = e.pop();
      o.block;
    }
  }
  function r(s, o) {
    let a = e.length, l;
    for (; a-- && (l = e[a], !(o || !l.block)); )
      ;
    l.defined.push(s);
  }
  function i(s, o) {
    if (s.type === "ArrayPattern")
      for (const a of s.elements)
        a && i(a, o);
    else if (s.type === "AssignmentPattern")
      i(s.left, o);
    else if (s.type === "Identifier")
      r(s.name, o);
    else if (s.type === "ObjectPattern")
      for (const a of s.properties)
        a.type === "Property" ? i(a.value, o) : (a.type, i(a, o));
    else
      s.type, i(s.argument, o);
  }
}
function Fpe(e) {
  return e.type === "FunctionDeclaration" ? { ...e, type: "FunctionExpression" } : (e.type, { ...e, type: "ClassExpression" });
}
function Rpe(e) {
  return e.type === "FunctionDeclaration" || e.type === "ClassDeclaration" || e.type === "VariableDeclaration";
}
function $pe(e) {
  const t = e.baseUrl || void 0, n = typeof t == "object" ? t.href : t, r = e.outputFormat || "program", i = e.pragma === void 0 ? "React.createElement" : e.pragma, s = e.pragmaFrag === void 0 ? "React.Fragment" : e.pragmaFrag, o = e.pragmaImportSource || "react", a = e.jsxImportSource || "react", l = e.jsxRuntime || "automatic";
  return function(u, f) {
    const d = [], h = [];
    let m = 0, p, y, v;
    if (l === "classic" && s && _f(u, "@jsxFrag", s), l === "classic" && i && _f(u, "@jsx", i), l === "automatic" && a && _f(u, "@jsxImportSource", a), _f(u, "@jsxRuntime", l), l === "classic" && o) {
      if (!i)
        throw new Error(
          "Missing `pragma` in classic runtime with `pragmaImportSource`"
        );
      b({
        type: "ImportDeclaration",
        specifiers: [
          {
            type: "ImportDefaultSpecifier",
            local: { type: "Identifier", name: i.split(".")[0] }
          }
        ],
        source: { type: "Literal", value: o }
      });
    }
    for (v of u.body)
      if (v.type === "ExportDefaultDeclaration")
        p && f.fail(
          "Unexpected duplicate layout, expected a single layout (previous: " + xr(ji(p)) + ")",
          {
            ancestors: [u, v],
            place: ji(v),
            ruleId: "duplicate-layout",
            source: "recma-document"
          }
        ), p = v, h.push({
          type: "VariableDeclaration",
          kind: "const",
          declarations: [
            {
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "MDXLayout" },
              init: Rpe(v.declaration) ? Fpe(v.declaration) : v.declaration
            }
          ]
        });
      else if (v.type === "ExportNamedDeclaration" && v.source) {
        const C = (
          /** @type {SimpleLiteral} */
          v.source
        );
        v.specifiers = v.specifiers.filter(function(E) {
          if (E.exported.type === "Identifier" && E.exported.name === "default") {
            p && f.fail(
              "Unexpected duplicate layout, expected a single layout (previous: " + xr(ji(p)) + ")",
              {
                ancestors: [u, v, E],
                place: ji(v),
                ruleId: "duplicate-layout",
                source: "recma-document"
              }
            ), p = E;
            const S = [];
            if (E.local.type === "Identifier" && E.local.name === "default")
              S.push({
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name: "MDXLayout" }
              });
            else {
              const O = {
                type: "ImportSpecifier",
                imported: E.local,
                local: { type: "Identifier", name: "MDXLayout" }
              };
              ks(E.local, O), S.push(O);
            }
            const k = { type: "Literal", value: C.value };
            ks(C, k);
            const M = {
              type: "ImportDeclaration",
              specifiers: S,
              source: k
            };
            return ks(E, M), b(M), !1;
          }
          return !0;
        }), v.specifiers.length > 0 && _(v);
      } else v.type === "ExportNamedDeclaration" || v.type === "ExportAllDeclaration" ? _(v) : v.type === "ImportDeclaration" ? b(v) : v.type === "ExpressionStatement" && (v.expression.type === "JSXElement" || v.expression.type === "JSXFragment") ? (y = !0, h.push(
        ...c(v.expression, r, !!p)
      )) : h.push(v);
    y || h.push(
      ...c(void 0, r, !!p)
    ), d.push(["MDXContent", "default"]), r === "function-body" && h.push({
      type: "ReturnStatement",
      argument: {
        type: "ObjectExpression",
        properties: [
          ...Array.from({ length: m }).map(
            /**
             * @param {undefined} _
             *   Nothing.
             * @param {number} index
             *   Index.
             * @returns {SpreadElement}
             *   Node.
             */
            function(C, E) {
              return {
                type: "SpreadElement",
                argument: {
                  type: "Identifier",
                  name: "_exportAll" + (E + 1)
                }
              };
            }
          ),
          ...d.map(function(C) {
            return {
              type: "Property",
              kind: "init",
              method: !1,
              computed: !1,
              shorthand: typeof C == "string",
              key: {
                type: "Identifier",
                name: typeof C == "string" ? C : C[1]
              },
              value: {
                type: "Identifier",
                name: typeof C == "string" ? C : C[0]
              }
            };
          })
        ]
      }
    }), u.body = h;
    let g = !1, x = !1;
    (n || r === "function-body") && Ra(u, {
      enter(C) {
        if ((C.type === "ExportAllDeclaration" || C.type === "ExportNamedDeclaration" || C.type === "ImportDeclaration") && C.source) {
          let E = C.source.value;
          try {
            new URL(E);
          } catch {
            (E.startsWith("/") || E.startsWith("./") || E.startsWith("../")) && (E = new URL(E, n).href);
          }
          const S = { type: "Literal", value: E };
          ks(C.source, S), C.source = S;
          return;
        }
        if (C.type === "ImportExpression") {
          x = !0;
          const E = {
            type: "CallExpression",
            callee: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
            arguments: [C.source],
            optional: !1
          };
          C.source = E;
          return;
        }
        if (C.type === "MemberExpression" && "object" in C && C.object.type === "MetaProperty" && C.property.type === "Identifier" && C.object.meta.name === "import" && C.object.property.name === "meta" && C.property.name === "url") {
          g = !0;
          const E = { type: "Identifier", name: "_importMetaUrl" };
          ks(C, E), this.replace(E);
        }
      }
    }), x && (n || (g = !0), u.body.push(
      Vpe(
        n ? { type: "Literal", value: n } : { type: "Identifier", name: "_importMetaUrl" }
      )
    )), g && u.body.unshift(...Bpe());
    function _(C) {
      if (C.type === "ExportNamedDeclaration") {
        if (C.declaration) {
          const E = fI();
          Ra(C, {
            enter(S) {
              E.enter(S), (S.type === "ArrowFunctionExpression" || S.type === "FunctionDeclaration" || S.type === "FunctionExpression") && (this.skip(), E.exit(S));
            },
            leave: E.exit
          }), d.push(...E.scopes[0].defined);
        }
        for (v of C.specifiers)
          v.exported.type === "Identifier" ? d.push(v.exported.name) : (v.exported.value, d.push(v.exported.value));
      }
      b(C);
    }
    function b(C) {
      let E, S;
      if (r === "function-body")
        if (
          // Always have a source:
          C.type === "ImportDeclaration" || C.type === "ExportAllDeclaration" || // Source optional:
          C.type === "ExportNamedDeclaration" && C.source
        ) {
          C.source;
          const k = { type: "ImportExpression", source: C.source };
          ks(C, k), S = { type: "AwaitExpression", argument: k }, (C.type === "ImportDeclaration" || C.type === "ExportNamedDeclaration") && C.specifiers.length === 0 ? E = { type: "ExpressionStatement", expression: S } : E = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: C.type === "ExportAllDeclaration" ? [
              {
                type: "VariableDeclarator",
                id: {
                  type: "Identifier",
                  name: "_exportAll" + ++m
                },
                init: S
              }
            ] : t5(C.specifiers, S)
          };
        } else if (C.declaration)
          E = C.declaration;
        else {
          const k = [];
          for (const M of C.specifiers)
            M.exported.type === "Identifier" && M.local.type === "Identifier" && M.local.name !== M.exported.name && k.push({
              type: "VariableDeclarator",
              id: M.exported,
              init: M.local
            });
          k.length > 0 && (E = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: k
          });
        }
      else
        E = C;
      E && h.push(E);
    }
  };
  function c(u, f, d) {
    let m = {
      type: "JSXElement",
      openingElement: {
        type: "JSXOpeningElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" },
        attributes: [
          {
            type: "JSXSpreadAttribute",
            argument: { type: "Identifier", name: "props" }
          }
        ],
        selfClosing: !1
      },
      closingElement: {
        type: "JSXClosingElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" }
      },
      children: [
        {
          type: "JSXElement",
          openingElement: {
            type: "JSXOpeningElement",
            name: { type: "JSXIdentifier", name: "_createMdxContent" },
            attributes: [
              {
                type: "JSXSpreadAttribute",
                argument: { type: "Identifier", name: "props" }
              }
            ],
            selfClosing: !0
          },
          closingElement: null,
          children: []
        }
      ]
    };
    d || (m = {
      type: "ConditionalExpression",
      test: { type: "Identifier", name: "MDXLayout" },
      consequent: m,
      alternate: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "_createMdxContent" },
        arguments: [{ type: "Identifier", name: "props" }],
        optional: !1
      }
    });
    let p = (
      // Cast because TS otherwise does not think `JSXFragment`s are expressions.
      /** @type {Readonly<Expression> | Readonly<JSXFragment>} */
      u || { type: "Identifier", name: "undefined" }
    );
    p.type === "JSXFragment" && p.children.length === 1 && p.children[0].type === "JSXElement" && (p = p.children[0]);
    let y = !1;
    Ra(p, {
      enter(g) {
        if (g.type === "ArrowFunctionExpression" || g.type === "FunctionDeclaration" || g.type === "FunctionExpression")
          return this.skip();
        (g.type === "AwaitExpression" || /* c8 ignore next 2 -- can only occur in a function (which then can
         * only be async, so skipped it) */
        g.type === "ForOfStatement" && g.await) && (y = !0);
      }
    });
    const v = {
      type: "FunctionDeclaration",
      id: { type: "Identifier", name: "MDXContent" },
      params: [
        {
          type: "AssignmentPattern",
          left: { type: "Identifier", name: "props" },
          right: { type: "ObjectExpression", properties: [] }
        }
      ],
      body: {
        type: "BlockStatement",
        body: [{ type: "ReturnStatement", argument: m }]
      }
    };
    return [
      {
        type: "FunctionDeclaration",
        async: y,
        id: { type: "Identifier", name: "_createMdxContent" },
        params: [{ type: "Identifier", name: "props" }],
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ReturnStatement",
              // Cast because TS doesn’t think `JSXFragment` is an expression.
              // eslint-disable-next-line object-shorthand
              argument: (
                /** @type {Expression} */
                p
              )
            }
          ]
        }
      },
      f === "program" ? { type: "ExportDefaultDeclaration", declaration: v } : v
    ];
  }
}
function _f(e, t, n) {
  var r;
  (r = e.comments) == null || r.unshift({
    type: "Block",
    value: t + " " + n,
    data: { _mdxIsPragmaComment: !0 }
  });
}
function Vpe(e) {
  return {
    type: "FunctionDeclaration",
    id: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
    generator: !1,
    async: !1,
    params: [{ type: "Identifier", name: "d" }],
    body: {
      type: "BlockStatement",
      body: [
        {
          type: "IfStatement",
          test: {
            type: "BinaryExpression",
            left: {
              type: "UnaryExpression",
              operator: "typeof",
              prefix: !0,
              argument: { type: "Identifier", name: "d" }
            },
            operator: "!==",
            right: { type: "Literal", value: "string" }
          },
          consequent: {
            type: "ReturnStatement",
            argument: { type: "Identifier", name: "d" }
          },
          alternate: null
        },
        // To do: use `URL.canParse` when widely supported (see commented
        // out code below).
        {
          type: "TryStatement",
          block: {
            type: "BlockStatement",
            body: [
              {
                type: "ExpressionStatement",
                expression: {
                  type: "NewExpression",
                  callee: { type: "Identifier", name: "URL" },
                  arguments: [{ type: "Identifier", name: "d" }]
                }
              },
              {
                type: "ReturnStatement",
                argument: { type: "Identifier", name: "d" }
              }
            ]
          },
          handler: {
            type: "CatchClause",
            param: null,
            body: { type: "BlockStatement", body: [] }
          },
          finalizer: null
        },
        // To do: use `URL.canParse` when widely supported.
        // {
        //   type: 'IfStatement',
        //   test: {
        //     type: 'CallExpression',
        //     callee: toIdOrMemberExpression(['URL', 'canParse']),
        //     arguments: [{type: 'Identifier', name: 'd'}],
        //     optional: false
        //   },
        //   consequent: {
        //     type: 'ReturnStatement',
        //     argument: {type: 'Identifier', name: 'd'}
        //   },
        //   alternate: null
        // },
        {
          type: "IfStatement",
          test: {
            type: "LogicalExpression",
            left: {
              type: "LogicalExpression",
              left: {
                type: "CallExpression",
                callee: Rs(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "/" }],
                optional: !1
              },
              operator: "||",
              right: {
                type: "CallExpression",
                callee: Rs(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "./" }],
                optional: !1
              }
            },
            operator: "||",
            right: {
              type: "CallExpression",
              callee: Rs(["d", "startsWith"]),
              arguments: [{ type: "Literal", value: "../" }],
              optional: !1
            }
          },
          consequent: {
            type: "ReturnStatement",
            argument: {
              type: "MemberExpression",
              object: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "URL" },
                arguments: [{ type: "Identifier", name: "d" }, e]
              },
              property: { type: "Identifier", name: "href" },
              computed: !1,
              optional: !1
            }
          },
          alternate: null
        },
        {
          type: "ReturnStatement",
          argument: { type: "Identifier", name: "d" }
        }
      ]
    }
  };
}
function Bpe() {
  return [
    {
      type: "VariableDeclaration",
      declarations: [
        {
          type: "VariableDeclarator",
          id: { type: "Identifier", name: "_importMetaUrl" },
          init: Rs(["arguments", 0, "baseUrl"])
        }
      ],
      kind: "const"
    },
    {
      type: "IfStatement",
      test: {
        type: "UnaryExpression",
        operator: "!",
        prefix: !0,
        argument: { type: "Identifier", name: "_importMetaUrl" }
      },
      consequent: {
        type: "ThrowStatement",
        argument: {
          type: "NewExpression",
          callee: { type: "Identifier", name: "Error" },
          arguments: [
            {
              type: "Literal",
              value: "Unexpected missing `options.baseUrl` needed to support `export … from`, `import`, or `import.meta.url` when generating `function-body`"
            }
          ]
        }
      },
      alternate: null
    }
  ];
}
function q3(e) {
  let t = -1, n;
  for (; ++t < e.length; ) {
    const r = e[t];
    n = n ? { type: "BinaryExpression", left: n, operator: "+", right: r } : r;
  }
  return n;
}
function zpe(e) {
  const { development: t, outputFormat: n, providerImportSource: r } = e;
  return function(i, s) {
    const o = fI(), a = [];
    let l = !1, c = !1;
    if (Ra(i, {
      enter(u) {
        o.enter(u), (u.type === "FunctionDeclaration" || u.type === "FunctionExpression" || u.type === "ArrowFunctionExpression") && (a.push({
          components: [],
          idToInvalidComponentName: /* @__PURE__ */ new Map(),
          node: u,
          objects: [],
          references: {},
          tags: []
        }), ha(u, "MDXContent") && !Xm(o.scopes, "MDXLayout") && a[0].components.push("MDXLayout"));
        const f = a[0];
        if (!(!f || !ha(f.node, "_createMdxContent") && !r) && u.type === "JSXElement") {
          let d = u.openingElement.name;
          if (d.type === "JSXMemberExpression") {
            const h = [];
            for (; d.type === "JSXMemberExpression"; )
              h.unshift(d.property.name), d = d.object;
            h.unshift(d.name);
            const m = h.join("."), p = d.name, y = Xm(o.scopes, p);
            !Object.hasOwn(f.references, m) && (!y || // If the parent scope is `_createMdxContent`, then this
            // references a component we can add a check statement for.
            a.length === 1 && a[0].node.type === "FunctionDeclaration" && ha(a[0].node, "_createMdxContent")) && (f.references[m] = { component: !0, node: u }), !f.objects.includes(p) && !y && f.objects.push(p);
          } else if (d.type !== "JSXNamespacedName") {
            if (hi(d.name) && !/^[a-z]/.test(d.name)) {
              const h = d.name;
              Xm(o.scopes, h) || (h !== "MDXLayout" && !Object.hasOwn(f.references, h) && (f.references[h] = { component: !0, node: u }), f.components.includes(h) || f.components.push(h));
            } else if (!(u.data && u.data._mdxExplicitJsx)) {
              const h = d.name;
              f.tags.includes(h) || f.tags.push(h);
              let m = ["_components", h];
              if (hi(h) === !1) {
                let p = f.idToInvalidComponentName.get(h);
                p === void 0 && (p = `_component${f.idToInvalidComponentName.size}`, f.idToInvalidComponentName.set(
                  h,
                  p
                )), m = [p];
              }
              u.openingElement.name = K3(m), u.closingElement && (u.closingElement.name = K3(m));
            }
          }
        }
      },
      leave(u) {
        o.exit(u);
        const f = [], d = [], h = [], m = [];
        if (u.type === "FunctionDeclaration" || u.type === "FunctionExpression" || u.type === "ArrowFunctionExpression") {
          const p = a[a.length - 1];
          let y;
          for (y of p.tags.sort())
            f.push({
              type: "Property",
              kind: "init",
              key: hi(y) ? { type: "Identifier", name: y } : { type: "Literal", value: y },
              value: { type: "Literal", value: y },
              method: !1,
              shorthand: !1,
              computed: !1
            });
          d.push(...p.components);
          for (y of p.objects)
            d.includes(y) || d.push(y);
          d.sort();
          const v = [];
          if (f.length > 0 || d.length > 0 || p.idToInvalidComponentName.size > 0) {
            if (r && (l = !0, h.push({
              type: "CallExpression",
              callee: { type: "Identifier", name: "_provideComponents" },
              arguments: [],
              optional: !1
            })), (ha(p.node, "MDXContent") || ha(p.node, "_createMdxContent")) && h.push(Rs(["props", "components"])), f.length > 0 || h.length > 1)
              for (const E of h)
                f.push({ type: "SpreadElement", argument: E });
            let b = f.length > 0 ? { type: "ObjectExpression", properties: f } : (
              // If we’re only getting components from `props.components`,
              // make sure it’s defined.
              {
                type: "LogicalExpression",
                operator: "||",
                left: h[0],
                right: { type: "ObjectExpression", properties: [] }
              }
            ), C;
            if (d.length > 0 && (C = {
              type: "ObjectPattern",
              properties: d.map(function(E) {
                return {
                  type: "Property",
                  kind: "init",
                  key: {
                    type: "Identifier",
                    name: E === "MDXLayout" ? "wrapper" : E
                  },
                  value: { type: "Identifier", name: E },
                  method: !1,
                  shorthand: E !== "MDXLayout",
                  computed: !1
                };
              })
            }), p.tags.length > 0 && (m.push({
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "_components" },
              init: b
            }), b = { type: "Identifier", name: "_components" }), ha(p.node, "_createMdxContent"))
              for (const [E, S] of [
                ...p.idToInvalidComponentName
              ].sort(function([k], [M]) {
                return k.localeCompare(M);
              }))
                m.push({
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name: S
                  },
                  init: {
                    type: "MemberExpression",
                    object: { type: "Identifier", name: "_components" },
                    property: { type: "Literal", value: E },
                    computed: !0,
                    optional: !1
                  }
                });
            C && m.push({
              type: "VariableDeclarator",
              id: C,
              init: b
            }), m.length > 0 && v.push({
              type: "VariableDeclaration",
              kind: "const",
              declarations: m
            });
          }
          let g;
          for (g in p.references)
            if (Object.hasOwn(p.references, g)) {
              const b = g.split(".");
              let C = 0;
              for (; ++C < b.length; ) {
                const E = b.slice(0, C).join(".");
                Object.hasOwn(p.references, E) || (p.references[E] = {
                  component: !1,
                  node: p.references[g].node
                });
              }
            }
          const x = Object.keys(p.references).sort();
          let _ = -1;
          for (; ++_ < x.length; ) {
            const b = x[_], C = p.references[b], E = xr(ji(C.node)), S = [
              { type: "Literal", value: b },
              { type: "Literal", value: C.component }
            ];
            c = !0, t && E && S.push({ type: "Literal", value: E }), v.push({
              type: "IfStatement",
              test: {
                type: "UnaryExpression",
                operator: "!",
                prefix: !0,
                argument: Rs(b.split("."))
              },
              consequent: {
                type: "ExpressionStatement",
                expression: {
                  type: "CallExpression",
                  callee: { type: "Identifier", name: "_missingMdxReference" },
                  arguments: S,
                  optional: !1
                }
              },
              alternate: void 0
            });
          }
          v.length > 0 && (u.body.type !== "BlockStatement" && (u.body = {
            type: "BlockStatement",
            body: [{ type: "ReturnStatement", argument: u.body }]
          }), u.body.body.unshift(...v)), a.pop();
        }
      }
    }), l && r && i.body.unshift(
      Hpe(r, n)
    ), c) {
      const u = [
        { type: "Literal", value: "Expected " },
        {
          type: "ConditionalExpression",
          test: { type: "Identifier", name: "component" },
          consequent: { type: "Literal", value: "component" },
          alternate: { type: "Literal", value: "object" }
        },
        { type: "Literal", value: " `" },
        { type: "Identifier", name: "id" },
        {
          type: "Literal",
          value: "` to be defined: you likely forgot to import, pass, or provide it."
        }
      ], f = [
        { type: "Identifier", name: "id" },
        { type: "Identifier", name: "component" }
      ];
      t && (u.push({
        type: "ConditionalExpression",
        test: { type: "Identifier", name: "place" },
        consequent: q3([
          { type: "Literal", value: "\nIt’s referenced in your code at `" },
          { type: "Identifier", name: "place" },
          {
            type: "Literal",
            value: (s.path ? "` in `" + s.path : "") + "`"
          }
        ]),
        alternate: { type: "Literal", value: "" }
      }), f.push({ type: "Identifier", name: "place" })), i.body.push({
        type: "FunctionDeclaration",
        id: { type: "Identifier", name: "_missingMdxReference" },
        generator: !1,
        async: !1,
        params: f,
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ThrowStatement",
              argument: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "Error" },
                arguments: [q3(u)]
              }
            }
          ]
        }
      });
    }
    n === "function-body" && i.body.unshift({
      type: "ExpressionStatement",
      expression: { type: "Literal", value: "use strict" },
      directive: "use strict"
    });
  };
}
function Hpe(e, t) {
  const n = [
    {
      type: "ImportSpecifier",
      imported: { type: "Identifier", name: "useMDXComponents" },
      local: { type: "Identifier", name: "_provideComponents" }
    }
  ];
  return t === "function-body" ? {
    type: "VariableDeclaration",
    kind: "const",
    declarations: t5(
      n,
      Rs(["arguments", 0])
    )
  } : {
    type: "ImportDeclaration",
    specifiers: n,
    source: { type: "Literal", value: e }
  };
}
function ha(e, t) {
  return !!(e && "id" in e && e.id && e.id.name === t);
}
function Xm(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n].defined.includes(t))
      return !0;
  return !1;
}
function Upe() {
  return function(e) {
    cu(e, "raw", function(t, n, r) {
      if (r && typeof n == "number")
        return r.children.splice(n, 1), n;
    });
  };
}
const jpe = /\s+/g, Wpe = /[\t\n\v\f\r ]+/g;
function Jpe(e, t) {
  t ? typeof t == "string" && (t = { style: t }) : t = {};
  const n = t.preserveLineEndings ? Kpe : qpe;
  return String(e).replace(
    t.style === "html" ? Wpe : jpe,
    t.trim ? Gpe(n) : n
  );
}
function Kpe(e) {
  const t = /\r?\n|\r/.exec(e);
  return t ? t[0] : " ";
}
function qpe() {
  return " ";
}
function Gpe(e) {
  return t;
  function t(n, r, i) {
    return r === 0 || r + n.length === i.length ? "" : e(n);
  }
}
function Ype() {
  return function(e) {
    cu(e, function(t, n, r) {
      let i = -1, s = !0, o = !1;
      if (r && typeof n == "number" && t.type === "paragraph") {
        const a = t.children;
        for (; ++i < a.length; ) {
          const l = a[i];
          if (l.type === "mdxJsxTextElement" || l.type === "mdxTextExpression")
            o = !0;
          else if (!(l.type === "text" && Jpe(l.value, { style: "html", trim: !0 }) === "")) {
            s = !1;
            break;
          }
        }
        if (s && o) {
          i = -1;
          const l = [];
          for (; ++i < a.length; ) {
            const c = a[i];
            c.type === "mdxJsxTextElement" && (c.type = "mdxJsxFlowElement"), c.type === "mdxTextExpression" && (c.type = "mdxFlowExpression"), c.type === "text" && /^[\t\r\n ]+$/.test(String(c.value)) || l.push(c);
          }
          return r.children.splice(n, 1, ...l), n;
        }
      }
      if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") {
        const a = t.data || (t.data = {});
        a._mdxExplicitJsx = !0;
      }
      (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression" || t.type === "mdxjsEsm") && t.data && t.data.estree && Ra(t.data.estree, {
        enter(a) {
          if (a.type === "JSXElement") {
            const l = a.data || (a.data = {});
            l._mdxExplicitJsx = !0;
          }
        }
      });
    });
  };
}
const Xpe = (
  /** @type {const} */
  [
    "mdxFlowExpression",
    "mdxJsxFlowElement",
    "mdxJsxTextElement",
    "mdxTextExpression",
    "mdxjsEsm"
  ]
);
let G3 = !1;
function Zpe(e) {
  const t = e || {};
  t.format, (t.jsxRuntime === "classic" || t.pragma || t.pragmaFrag || t.pragmaImportSource) && !G3 && (G3 = !0, console.warn(
    "Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate"
  ));
  const n = Lpe().use(Vhe);
  t.format !== "md" && n.use($he);
  const r = t.remarkRehypeOptions || {};
  return n.use(Ype).use(t.remarkPlugins || []).use(Spe, {
    ...r,
    allowDangerousHtml: !0,
    passThrough: [...r.passThrough || [], ...Xpe]
  }).use(t.rehypePlugins || []), t.format === "md" && n.use(Upe), n.use(Fhe, t).use($pe, t).use(zpe, t), t.jsx || n.use(Xfe, t).use(Dpe, t), n.use(Cde).use(Ede, t).use(t.recmaPlugins || []), n;
}
function Qpe(e, t) {
  const { file: n, options: r } = Wfe(e, t);
  return Zpe(r).process(n);
}
function e1e(e) {
  const {
    Fragment: t,
    baseUrl: n,
    development: r,
    jsx: i,
    jsxDEV: s,
    jsxs: o,
    useMDXComponents: a,
    ...l
  } = e || {};
  if (!t) throw new Error("Expected `Fragment` given to `evaluate`");
  if (r) {
    if (!s) throw new Error("Expected `jsxDEV` given to `evaluate`");
  } else {
    if (!i) throw new Error("Expected `jsx` given to `evaluate`");
    if (!o) throw new Error("Expected `jsxs` given to `evaluate`");
  }
  return {
    compiletime: {
      ...l,
      development: r,
      outputFormat: "function-body",
      providerImportSource: a ? "#" : void 0
    },
    runtime: { Fragment: t, baseUrl: n, jsx: i, jsxDEV: s, jsxs: o, useMDXComponents: a }
  };
}
const t1e = Object.getPrototypeOf(dI).constructor;
async function dI(e, t) {
  return new t1e(String(e))(t);
}
async function n1e(e, t) {
  const { compiletime: n, runtime: r } = e1e(t);
  return dI(await Qpe(e, n), r);
}
const p2 = /* @__PURE__ */ new Set(["<", ">", "{", "}", "[", "]"]), r1e = /* @__PURE__ */ new Set([
  "for",
  "do",
  "while",
  "if",
  "else",
  "return",
  "function",
  "var",
  "let",
  "const",
  "true",
  "false",
  "undefined",
  "this",
  "new",
  "delete",
  "typeof",
  "in",
  "instanceof",
  "void",
  "break",
  "continue",
  "switch",
  "case",
  "default",
  "throw",
  "try",
  "catch",
  "finally",
  "debugger",
  "with",
  "yield",
  "async",
  "await",
  "class",
  "extends",
  "super",
  "import",
  "export",
  "from",
  "static"
]), hI = /* @__PURE__ */ new Set([
  "+",
  "-",
  "*",
  "/",
  "%",
  "=",
  "!",
  "&",
  "|",
  "^",
  "~",
  "!",
  "?",
  ":",
  ".",
  ",",
  ";",
  "'",
  '"',
  ".",
  "(",
  ")",
  "[",
  "]",
  "#",
  "@",
  "\\",
  ...p2
]), i1e = {
  keywords: r1e,
  onCommentStart: vI,
  onCommentEnd: h1e
}, n5 = (
  /** @type {const} */
  [
    "identifier",
    "keyword",
    "string",
    "class",
    "property",
    "entity",
    "jsxliterals",
    "sign",
    "comment",
    "break",
    "space"
  ]
), [
  Zm,
  s1e,
  xs,
  o1e,
  Qm,
  a1e,
  l1e,
  Mi,
  Y3,
  m2,
  X3
] = (
  /** @types {const} */
  n5.map((e, t) => t)
);
function bf(e) {
  return /^[^\S\r\n]+$/g.test(e);
}
function c1e(e) {
  return hI.has(e);
}
function u1e(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function Oh(e) {
  return /^[\w_]+$/.test(e) || pI(e);
}
function f1e(e) {
  const t = e[0];
  return Oh(t) && t === t.toUpperCase() || e === "null";
}
function pI(e) {
  return /[^\u0000-\u007f]/.test(e);
}
function mI(e) {
  return /^[a-zA-Z]$/.test(e);
}
function gI(e) {
  return mI(e) || pI(e);
}
function Cf(e) {
  return gI(e[0]) && (e.length === 1 || Oh(e.slice(1)));
}
function g2(e) {
  return e === "`";
}
function v2(e) {
  return e === '"' || e === "'";
}
function d1e(e) {
  return v2(e) || g2(e);
}
function vI(e, t) {
  const n = e + t;
  return n === "/*" ? 2 : n === "//" ? 1 : 0;
}
function h1e(e, t) {
  return e + t === "*/" ? 2 : t === `
` ? 1 : 0;
}
function p1e(e) {
  return e[0] === "/" && !vI(e[0], e[1]);
}
function m1e(e, t) {
  const {
    keywords: n,
    onCommentStart: r,
    onCommentEnd: i
  } = { ...i1e, ...t };
  let s = "", o = -1, a = [-1, ""], l = [-2, ""];
  const c = [];
  let u = !1, f = 0, d = !1, h = 0;
  const m = () => u && !d && !f, p = () => f && !m(), y = () => !f && m() && !d && h > 0;
  let v = null, g = !1, x = 0, _ = 0;
  const b = () => v !== null, C = () => g, E = () => _ > x, S = () => _ > 0 && _ === x, k = () => b() || E();
  function M(R) {
    const I = R === `
`;
    if (p()) {
      if (b())
        return xs;
      const [, P] = a;
      if (Cf(R) && (P === "<" || P === "</"))
        return a1e;
    }
    if (y()) return l1e;
    if (b())
      return xs;
    if (n.has(R))
      return a[1] === "." ? Zm : s1e;
    if (I)
      return m2;
    if (bf(R))
      return X3;
    if (R.split("").every(c1e))
      return Mi;
    if (f1e(R))
      return p() ? Zm : o1e;
    if (Cf(R)) {
      const P = a[1] === "." && Cf(l[1]);
      if (!k() && !P) return Zm;
      if (P) return Qm;
    }
    return xs;
  }
  const O = (R, I) => {
    if (I && (s = I), s) {
      o = R || M(s);
      const H = [o, s];
      o !== X3 && o !== m2 && (l = a, a = H), c.push(H);
    }
    s = "";
  };
  for (let R = 0; R < e.length; R++) {
    const I = e[R], H = e[R - 1], P = e[R + 1], W = H + I, G = I + P;
    if (v2(I) && !y()) {
      O(), H !== "\\" && (v && I === v ? v = null : v || (v = I)), O(xs, I);
      continue;
    }
    if (!E() && H !== "\\n" && g2(I)) {
      O(), O(xs, I), _++;
      continue;
    }
    if (E()) {
      if (H !== "\\n" && g2(I) && _ > 0) {
        O(), _--, O(xs, I);
        continue;
      }
      if (G === "${") {
        x++, O(xs), O(Mi, G), R++;
        continue;
      }
    }
    if (S() && I === "}") {
      O(), x--, O(Mi, I);
      continue;
    }
    if (m() && I === "{") {
      O(), O(Mi, I), d = !0;
      continue;
    }
    if (u) {
      if (!f && I === "<") {
        O(), P === "/" ? (f = 2, s = G, R++) : (f = 1, s = I), O(Mi);
        continue;
      }
      if (f) {
        if (I === ">" && !"/=".includes(H)) {
          O(), f === 1 ? (f = 0, h++) : (f = 0, u = !1), O(Mi, I);
          continue;
        }
        if (G === "/>" || G === "</") {
          s !== "<" && s !== "/" && O(), G === "/>" ? f = 0 : h--, h || (u = !1), s = G, R++, O(Mi);
          continue;
        }
        if (I === "<") {
          O(), s = I, O(Mi);
          continue;
        }
        if (P === "-" && !k() && !y() && s) {
          O(Qm, s + I + P), R++;
          continue;
        }
        if (P === "=" && !k() && !bf(I)) {
          bf(s) && O();
          const ee = s + I;
          if (Cf(ee)) {
            O(Qm, ee);
            continue;
          }
        }
      }
    }
    !f && (I === "<" && gI(P) || G === "</") && (f = P === "/" ? 2 : 1, I === "<" && (P === "/" || mI(P)) && !k() && !y() && !C() && (u = !0));
    const J = d1e(I), X = E(), N = !u && p1e(G), U = y();
    if (J || X || v2(v))
      s += I;
    else if (N) {
      O();
      const [ee, F] = a;
      if (N && ee !== -1 && !(ee === Mi && F !== ")" || ee === Y3)) {
        s = I, O();
        continue;
      }
      g = !0;
      const ue = R++, pe = () => R >= e.length, ce = () => pe() || e[R] === `
`;
      let q = !1;
      for (; !ce(); R++)
        if (e[R] === "/" && e[R - 1] !== "\\") {
          for (q = !0; ue !== R && /^[a-z]$/.test(e[R + 1]) && !ce(); )
            R++;
          break;
        }
      g = !1, ue !== R && q ? (s = e.slice(ue, R + 1), O(xs)) : (s = I, O(), R = ue);
    } else if (r(I, P)) {
      O();
      const ee = R, F = r(I, P);
      if (F)
        for (; R < e.length && i(e[R - 1], e[R]) != F; R++)
          ;
      s = e.slice(ee, R + 1), O(Y3);
    } else I === " " || I === `
` ? I === " " && (bf(s) || !s || U) ? (s += I, P === "<" && O()) : (O(), s = I, O()) : d && I === "}" ? (O(), s = I, O(), d = !1) : /* it's jsx literals and is not a jsx bracket */ U && !p2.has(I) || // same type char as previous one in current token
    (Oh(I) === Oh(s[s.length - 1]) || m()) && !hI.has(I) ? s += I : (W === "</" && (s = W), O(), W !== "</" && (s = I), G === "</" || G === "/>" ? (s = G, O(), R++) : p2.has(I) && O());
  }
  return O(), c;
}
function g1e(e) {
  const t = [], n = (s) => ({
    type: "element",
    tagName: "span",
    children: s,
    properties: {
      className: "sh__line"
    }
  });
  function r(s) {
    const o = s.map(([a, l]) => {
      const c = n5[a];
      return {
        type: "element",
        tagName: "span",
        children: [{
          type: "text",
          // text node
          value: l
          // to encode
        }],
        properties: {
          className: `sh__token--${c}`,
          style: { color: `var(--sh-${c})` }
        }
      };
    });
    t.push(n(o));
  }
  const i = [];
  for (let s = 0; s < e.length; s++) {
    const o = e[s], [a, l] = o;
    if (a !== m2)
      if (l.includes(`
`)) {
        const c = l.split(`
`);
        for (let u = 0; u < c.length; u++)
          i.push([a, c[u]]), u < c.length - 1 && (r(i), i.length = 0);
      } else
        i.push(o);
    else
      i.push([a, ""]), r(i), i.length = 0;
  }
  return i.length && r(i), t;
}
const v1e = (e) => {
  let t = `class="${e.className}"`;
  if (e.style) {
    const n = Object.entries(e.style).map(([r, i]) => `${r}:${i}`).join(";");
    t += ` style="${n}"`;
  }
  return t;
};
function y1e(e) {
  return e.map((t) => {
    const { tagName: n } = t, r = t.children.map((i) => {
      const { tagName: s, children: o, properties: a } = i;
      return `<${s} ${v1e(a)}>${u1e(o[0].value)}</${s}>`;
    }).join("");
    return `<${n} class="${t.properties.className}">${r}</${n}>`;
  }).join(`
`);
}
function x1e(e, t) {
  const n = m1e(e, t), r = g1e(n);
  return y1e(r);
}
new Map(n5.map((e, t) => [e, t]));
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function y2() {
  return y2 = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, y2.apply(this, arguments);
}
var Z3;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})(Z3 || (Z3 = {}));
function Vt(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function $u(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function x2(e) {
  let {
    pathname: t = "/",
    search: n = "",
    hash: r = ""
  } = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t;
}
function yI(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e);
  }
  return t;
}
var Q3;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})(Q3 || (Q3 = {}));
function eC(e, t) {
  typeof e == "string" && (e = {
    path: e,
    caseSensitive: !1,
    end: !0
  });
  let [n, r] = w1e(e.path, e.caseSensitive, e.end), i = t.match(n);
  if (!i) return null;
  let s = i[0], o = s.replace(/(.)\/+$/, "$1"), a = i.slice(1);
  return {
    params: r.reduce((c, u, f) => {
      let {
        paramName: d,
        isOptional: h
      } = u;
      if (d === "*") {
        let p = a[f] || "";
        o = s.slice(0, s.length - p.length).replace(/(.)\/+$/, "$1");
      }
      const m = a[f];
      return h && !m ? c[d] = void 0 : c[d] = (m || "").replace(/%2F/g, "/"), c;
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: e
  };
}
function w1e(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !0), $u(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({
    paramName: a,
    isOptional: l != null
  }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (r.push({
    paramName: "*"
  }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function sl(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function _1e(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? yI(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : b1e(n, t) : t,
    search: E1e(r),
    hash: S1e(i)
  };
}
function b1e(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function eg(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function C1e(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0);
}
function xI(e, t) {
  let n = C1e(e);
  return t ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map((r) => r.pathnameBase);
}
function wI(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string" ? i = yI(e) : (i = y2({}, e), Vt(!i.pathname || !i.pathname.includes("?"), eg("?", "pathname", "search", i)), Vt(!i.pathname || !i.pathname.includes("#"), eg("#", "pathname", "hash", i)), Vt(!i.search || !i.search.includes("#"), eg("#", "search", "hash", i)));
  let s = e === "" || i.pathname === "", o = s ? "/" : i.pathname, a;
  if (o == null)
    a = n;
  else {
    let f = t.length - 1;
    if (!r && o.startsWith("..")) {
      let d = o.split("/");
      for (; d[0] === ".."; )
        d.shift(), f -= 1;
      i.pathname = d.join("/");
    }
    a = f >= 0 ? t[f] : "/";
  }
  let l = _1e(i, a), c = o && o !== "/" && o.endsWith("/"), u = (s || o === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
const r5 = (e) => e.join("/").replace(/\/\/+/g, "/"), E1e = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, S1e = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, _I = ["post", "put", "patch", "delete"];
new Set(_I);
const k1e = ["get", ..._I];
new Set(k1e);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function w2() {
  return w2 = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, w2.apply(this, arguments);
}
const o1 = /* @__PURE__ */ w.createContext(null);
process.env.NODE_ENV !== "production" && (o1.displayName = "DataRouter");
const bI = /* @__PURE__ */ w.createContext(null);
process.env.NODE_ENV !== "production" && (bI.displayName = "DataRouterState");
const T1e = /* @__PURE__ */ w.createContext(null);
process.env.NODE_ENV !== "production" && (T1e.displayName = "Await");
const ds = /* @__PURE__ */ w.createContext(null);
process.env.NODE_ENV !== "production" && (ds.displayName = "Navigation");
const i5 = /* @__PURE__ */ w.createContext(null);
process.env.NODE_ENV !== "production" && (i5.displayName = "Location");
const Il = /* @__PURE__ */ w.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (Il.displayName = "Route");
const A1e = /* @__PURE__ */ w.createContext(null);
process.env.NODE_ENV !== "production" && (A1e.displayName = "RouteError");
function N1e(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t;
  s5() || (process.env.NODE_ENV !== "production" ? Vt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : Vt(!1));
  let {
    basename: r,
    navigator: i
  } = w.useContext(ds), {
    hash: s,
    pathname: o,
    search: a
  } = Bu(e, {
    relative: n
  }), l = o;
  return r !== "/" && (l = o === "/" ? r : r5([r, o])), i.createHref({
    pathname: l,
    search: a,
    hash: s
  });
}
function s5() {
  return w.useContext(i5) != null;
}
function Vu() {
  return s5() || (process.env.NODE_ENV !== "production" ? Vt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : Vt(!1)), w.useContext(i5).location;
}
const CI = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function EI(e) {
  w.useContext(ds).static || w.useLayoutEffect(e);
}
function I1e() {
  let {
    isDataRoute: e
  } = w.useContext(Il);
  return e ? D1e() : L1e();
}
function L1e() {
  s5() || (process.env.NODE_ENV !== "production" ? Vt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : Vt(!1));
  let e = w.useContext(o1), {
    basename: t,
    future: n,
    navigator: r
  } = w.useContext(ds), {
    matches: i
  } = w.useContext(Il), {
    pathname: s
  } = Vu(), o = JSON.stringify(xI(i, n.v7_relativeSplatPath)), a = w.useRef(!1);
  return EI(() => {
    a.current = !0;
  }), w.useCallback(function(c, u) {
    if (u === void 0 && (u = {}), process.env.NODE_ENV !== "production" && $u(a.current, CI), !a.current) return;
    if (typeof c == "number") {
      r.go(c);
      return;
    }
    let f = wI(c, JSON.parse(o), s, u.relative === "path");
    e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : r5([t, f.pathname])), (u.replace ? r.replace : r.push)(f, u.state, u);
  }, [t, r, o, s, e]);
}
function Bu(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    future: r
  } = w.useContext(ds), {
    matches: i
  } = w.useContext(Il), {
    pathname: s
  } = Vu(), o = JSON.stringify(xI(i, r.v7_relativeSplatPath));
  return w.useMemo(() => wI(e, JSON.parse(o), s, n === "path"), [e, o, s, n]);
}
var SI = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(SI || {}), o5 = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(o5 || {});
function kI(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function M1e(e) {
  let t = w.useContext(o1);
  return t || (process.env.NODE_ENV !== "production" ? Vt(!1, kI(e)) : Vt(!1)), t;
}
function O1e(e) {
  let t = w.useContext(Il);
  return t || (process.env.NODE_ENV !== "production" ? Vt(!1, kI(e)) : Vt(!1)), t;
}
function TI(e) {
  let t = O1e(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (process.env.NODE_ENV !== "production" ? Vt(!1, e + ' can only be used on routes that contain a unique "id"') : Vt(!1)), n.route.id;
}
function P1e() {
  return TI(o5.UseRouteId);
}
function D1e() {
  let {
    router: e
  } = M1e(SI.UseNavigateStable), t = TI(o5.UseNavigateStable), n = w.useRef(!1);
  return EI(() => {
    n.current = !0;
  }), w.useCallback(function(i, s) {
    s === void 0 && (s = {}), process.env.NODE_ENV !== "production" && $u(n.current, CI), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, w2({
      fromRouteId: t
    }, s)));
  }, [e, t]);
}
new Promise(() => {
});
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ol() {
  return ol = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ol.apply(this, arguments);
}
function a5(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
const Xf = "get", Zf = "application/x-www-form-urlencoded";
function a1(e) {
  return e != null && typeof e.tagName == "string";
}
function F1e(e) {
  return a1(e) && e.tagName.toLowerCase() === "button";
}
function R1e(e) {
  return a1(e) && e.tagName.toLowerCase() === "form";
}
function $1e(e) {
  return a1(e) && e.tagName.toLowerCase() === "input";
}
function V1e(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function B1e(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !V1e(e);
}
let Ef = null;
function z1e() {
  if (Ef === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Ef = !1;
    } catch {
      Ef = !0;
    }
  return Ef;
}
const H1e = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function tg(e) {
  return e != null && !H1e.has(e) ? (process.env.NODE_ENV !== "production" && $u(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + Zf + '"')), null) : e;
}
function U1e(e, t) {
  let n, r, i, s, o;
  if (R1e(e)) {
    let a = e.getAttribute("action");
    r = a ? sl(a, t) : null, n = e.getAttribute("method") || Xf, i = tg(e.getAttribute("enctype")) || Zf, s = new FormData(e);
  } else if (F1e(e) || $1e(e) && (e.type === "submit" || e.type === "image")) {
    let a = e.form;
    if (a == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let l = e.getAttribute("formaction") || a.getAttribute("action");
    if (r = l ? sl(l, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || Xf, i = tg(e.getAttribute("formenctype")) || tg(a.getAttribute("enctype")) || Zf, s = new FormData(a, e), !z1e()) {
      let {
        name: c,
        type: u,
        value: f
      } = e;
      if (u === "image") {
        let d = c ? c + "." : "";
        s.append(d + "x", "0"), s.append(d + "y", "0");
      } else c && s.append(c, f);
    }
  } else {
    if (a1(e))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    n = Xf, r = null, i = Zf, o = e;
  }
  return s && i === "text/plain" && (o = s, s = void 0), {
    action: r,
    method: n.toLowerCase(),
    encType: i,
    formData: s,
    body: o
  };
}
const j1e = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], W1e = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], J1e = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], K1e = "6";
try {
  window.__reactRouterVersion = K1e;
} catch {
}
const AI = /* @__PURE__ */ w.createContext({
  isTransitioning: !1
});
process.env.NODE_ENV !== "production" && (AI.displayName = "ViewTransition");
const q1e = /* @__PURE__ */ w.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (q1e.displayName = "Fetchers");
process.env.NODE_ENV;
const G1e = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Y1e = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, l5 = /* @__PURE__ */ w.forwardRef(function(t, n) {
  let {
    onClick: r,
    relative: i,
    reloadDocument: s,
    replace: o,
    state: a,
    target: l,
    to: c,
    preventScrollReset: u,
    viewTransition: f
  } = t, d = a5(t, j1e), {
    basename: h
  } = w.useContext(ds), m, p = !1;
  if (typeof c == "string" && Y1e.test(c) && (m = c, G1e))
    try {
      let x = new URL(window.location.href), _ = c.startsWith("//") ? new URL(x.protocol + c) : new URL(c), b = sl(_.pathname, h);
      _.origin === x.origin && b != null ? c = b + _.search + _.hash : p = !0;
    } catch {
      process.env.NODE_ENV !== "production" && $u(!1, '<Link to="' + c + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let y = N1e(c, {
    relative: i
  }), v = eme(c, {
    replace: o,
    state: a,
    target: l,
    preventScrollReset: u,
    relative: i,
    viewTransition: f
  });
  function g(x) {
    r && r(x), x.defaultPrevented || v(x);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ w.createElement("a", ol({}, d, {
      href: m || y,
      onClick: p || s ? r : g,
      ref: n,
      target: l
    }))
  );
});
process.env.NODE_ENV !== "production" && (l5.displayName = "Link");
const X1e = /* @__PURE__ */ w.forwardRef(function(t, n) {
  let {
    "aria-current": r = "page",
    caseSensitive: i = !1,
    className: s = "",
    end: o = !1,
    style: a,
    to: l,
    viewTransition: c,
    children: u
  } = t, f = a5(t, W1e), d = Bu(l, {
    relative: f.relative
  }), h = Vu(), m = w.useContext(bI), {
    navigator: p,
    basename: y
  } = w.useContext(ds), v = m != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  ome(d) && c === !0, g = p.encodeLocation ? p.encodeLocation(d).pathname : d.pathname, x = h.pathname, _ = m && m.navigation && m.navigation.location ? m.navigation.location.pathname : null;
  i || (x = x.toLowerCase(), _ = _ ? _.toLowerCase() : null, g = g.toLowerCase()), _ && y && (_ = sl(_, y) || _);
  const b = g !== "/" && g.endsWith("/") ? g.length - 1 : g.length;
  let C = x === g || !o && x.startsWith(g) && x.charAt(b) === "/", E = _ != null && (_ === g || !o && _.startsWith(g) && _.charAt(g.length) === "/"), S = {
    isActive: C,
    isPending: E,
    isTransitioning: v
  }, k = C ? r : void 0, M;
  typeof s == "function" ? M = s(S) : M = [s, C ? "active" : null, E ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" ");
  let O = typeof a == "function" ? a(S) : a;
  return /* @__PURE__ */ w.createElement(l5, ol({}, f, {
    "aria-current": k,
    className: M,
    ref: n,
    style: O,
    to: l,
    viewTransition: c
  }), typeof u == "function" ? u(S) : u);
});
process.env.NODE_ENV !== "production" && (X1e.displayName = "NavLink");
const Z1e = /* @__PURE__ */ w.forwardRef((e, t) => {
  let {
    fetcherKey: n,
    navigate: r,
    reloadDocument: i,
    replace: s,
    state: o,
    method: a = Xf,
    action: l,
    onSubmit: c,
    relative: u,
    preventScrollReset: f,
    viewTransition: d
  } = e, h = a5(e, J1e), m = ime(), p = sme(l, {
    relative: u
  }), y = a.toLowerCase() === "get" ? "get" : "post", v = (g) => {
    if (c && c(g), g.defaultPrevented) return;
    g.preventDefault();
    let x = g.nativeEvent.submitter, _ = (x == null ? void 0 : x.getAttribute("formmethod")) || a;
    m(x || g.currentTarget, {
      fetcherKey: n,
      method: _,
      navigate: r,
      replace: s,
      state: o,
      relative: u,
      preventScrollReset: f,
      viewTransition: d
    });
  };
  return /* @__PURE__ */ w.createElement("form", ol({
    ref: t,
    method: y,
    action: p,
    onSubmit: i ? c : v
  }, h));
});
process.env.NODE_ENV !== "production" && (Z1e.displayName = "Form");
process.env.NODE_ENV;
var Ph;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState";
})(Ph || (Ph = {}));
var tC;
(function(e) {
  e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration";
})(tC || (tC = {}));
function Q1e(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function NI(e) {
  let t = w.useContext(o1);
  return t || (process.env.NODE_ENV !== "production" ? Vt(!1, Q1e(e)) : Vt(!1)), t;
}
function eme(e, t) {
  let {
    target: n,
    replace: r,
    state: i,
    preventScrollReset: s,
    relative: o,
    viewTransition: a
  } = t === void 0 ? {} : t, l = I1e(), c = Vu(), u = Bu(e, {
    relative: o
  });
  return w.useCallback((f) => {
    if (B1e(f, n)) {
      f.preventDefault();
      let d = r !== void 0 ? r : x2(c) === x2(u);
      l(e, {
        replace: d,
        state: i,
        preventScrollReset: s,
        relative: o,
        viewTransition: a
      });
    }
  }, [c, l, u, r, i, n, e, s, o, a]);
}
function tme() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let nme = 0, rme = () => "__" + String(++nme) + "__";
function ime() {
  let {
    router: e
  } = NI(Ph.UseSubmit), {
    basename: t
  } = w.useContext(ds), n = P1e();
  return w.useCallback(function(r, i) {
    i === void 0 && (i = {}), tme();
    let {
      action: s,
      method: o,
      encType: a,
      formData: l,
      body: c
    } = U1e(r, t);
    if (i.navigate === !1) {
      let u = i.fetcherKey || rme();
      e.fetch(u, n, i.action || s, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: c,
        formMethod: i.method || o,
        formEncType: i.encType || a,
        flushSync: i.flushSync
      });
    } else
      e.navigate(i.action || s, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: c,
        formMethod: i.method || o,
        formEncType: i.encType || a,
        replace: i.replace,
        state: i.state,
        fromRouteId: n,
        flushSync: i.flushSync,
        viewTransition: i.viewTransition
      });
  }, [e, t, n]);
}
function sme(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    basename: r
  } = w.useContext(ds), i = w.useContext(Il);
  i || (process.env.NODE_ENV !== "production" ? Vt(!1, "useFormAction must be used inside a RouteContext") : Vt(!1));
  let [s] = i.matches.slice(-1), o = ol({}, Bu(e || ".", {
    relative: n
  })), a = Vu();
  if (e == null) {
    o.search = a.search;
    let l = new URLSearchParams(o.search), c = l.getAll("index");
    if (c.some((f) => f === "")) {
      l.delete("index"), c.filter((d) => d).forEach((d) => l.append("index", d));
      let f = l.toString();
      o.search = f ? "?" + f : "";
    }
  }
  return (!e || e === ".") && s.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (o.pathname = o.pathname === "/" ? r : r5([r, o.pathname])), x2(o);
}
function ome(e, t) {
  t === void 0 && (t = {});
  let n = w.useContext(AI);
  n == null && (process.env.NODE_ENV !== "production" ? Vt(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : Vt(!1));
  let {
    basename: r
  } = NI(Ph.useViewTransitionState), i = Bu(e, {
    relative: t.relative
  });
  if (!n.isTransitioning)
    return !1;
  let s = sl(n.currentLocation.pathname, r) || n.currentLocation.pathname, o = sl(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return eC(i.pathname, o) != null || eC(i.pathname, s) != null;
}
function ame({ datasets: e, children: t }) {
  return /* @__PURE__ */ A(Ut, { children: /* @__PURE__ */ A(jx, { children: /* @__PURE__ */ A(Ux, { children: e ? /* @__PURE__ */ A(Hx, { initialDatasets: e, children: t }) : { children: t } }) }) });
}
const lme = (e) => {
  try {
    let t;
    try {
      t = typeof e.center == "string" && e.center.startsWith("[") ? JSON.parse(e.center) : e.center || go.center;
    } catch (r) {
      console.warn("Error parsing center coordinates, using default:", r), t = go.center;
    }
    let n;
    try {
      n = typeof e.zoom == "string" ? parseFloat(e.zoom) || go.zoom : e.zoom || go.zoom;
    } catch (r) {
      console.warn("Error parsing zoom level, using default:", r), n = go.zoom;
    }
    return /* @__PURE__ */ A(
      RN,
      {
        ...e,
        center: t,
        zoom: n,
        datasetId: e.datasetId,
        layerId: e.layerId,
        dateTime: e.dateTime,
        compareDateTime: e.compareDateTime,
        compareLabel: e.compareLabel,
        allAvailableDatasets: Ah
      }
    );
  } catch (t) {
    return console.error("Error rendering map:", t), /* @__PURE__ */ A("div", { className: "h-[400px] flex items-center justify-center bg-red-50 border border-red-300 rounded", children: /* @__PURE__ */ A("div", { className: "text-red-500", children: "Error rendering map component" }) });
  }
};
function cme({ data: e }) {
  const t = e.headers.map((r, i) => /* @__PURE__ */ A("th", { children: r }, i)), n = e.rows.map((r, i) => /* @__PURE__ */ A("tr", { children: r.map((s, o) => /* @__PURE__ */ A("td", { children: s }, o)) }, i));
  return /* @__PURE__ */ Oe("table", { children: [
    /* @__PURE__ */ A("thead", { children: /* @__PURE__ */ A("tr", { children: t }) }),
    /* @__PURE__ */ A("tbody", { children: n })
  ] });
}
function ume({ children: e, ...t }) {
  const n = x1e(e);
  return /* @__PURE__ */ A("code", { dangerouslySetInnerHTML: { __html: n }, ...t });
}
function fme(e) {
  if (e != null || e != null)
    return e.toString().toLowerCase().trim().replace(/\s+/g, "-").replace(/&/g, "-and-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-");
}
function pa(e) {
  const t = ({ children: n }) => {
    const r = fme(n);
    return T.createElement(
      `h${e}`,
      { id: r },
      [
        T.createElement("a", {
          href: `#${r}`,
          key: `link-${r}`,
          className: "anchor"
        })
      ],
      n
    );
  };
  return t.displayName = `Heading${e}`, t;
}
const dme = {
  h1: pa(1),
  h2: pa(2),
  h3: pa(3),
  h4: pa(4),
  h5: pa(5),
  h6: pa(6),
  code: ume,
  Table: cme,
  Block: GI,
  Prose: qI,
  Caption: KI,
  Figure: JI,
  Image: WI,
  Link: l5,
  Chapter: jI,
  TwoColumn: (e) => /* @__PURE__ */ A("div", { className: "grid-container maxw-full", children: /* @__PURE__ */ A("div", { className: "grid-row grid-gap-lg", children: e.children }) }),
  LeftColumn: (e) => /* @__PURE__ */ A("div", { className: "grid-col-6 ", children: e.children }),
  RightColumn: (e) => /* @__PURE__ */ A("div", { className: "grid-col-6  ", children: e.children }),
  Map: lme,
  Chart: ife
}, hme = ({ source: e, components: t }) => {
  const [n, r] = Re(null), [i, s] = Re(null);
  if (Le(() => {
    (async () => {
      try {
        const l = await n1e(e, { ...MI });
        r(l), s(null);
      } catch (l) {
        console.error("MDX evaluation error:", l), s(l);
      }
    })();
  }, [e]), i)
    return /* @__PURE__ */ Oe("div", { className: "p-4 bg-red-100 text-red-800 rounded", children: [
      /* @__PURE__ */ A("h4", { children: "MDX Preview Error" }),
      /* @__PURE__ */ A("pre", { className: "whitespace-pre-wrap", children: i.message })
    ] });
  if (!n)
    return /* @__PURE__ */ A("div", { className: "p-4", children: "Compiling MDX..." });
  const o = n.default;
  return /* @__PURE__ */ A(Lfe, { components: t, children: /* @__PURE__ */ A(o, { components: t }) });
};
function pme({ source: e }) {
  return /* @__PURE__ */ A("section", { children: /* @__PURE__ */ A("article", { className: "prose", children: /* @__PURE__ */ Oe(ame, { datasets: Ah, children: [
    /* @__PURE__ */ A(UI, {}),
    /* @__PURE__ */ A(hme, { source: e || "", components: dme })
  ] }) }) });
}
const mme = "stable-mdx-editor-instance", nC = `# Welcome to the MDX Editor

This is a live editor where you can write and preview MDX content.

## Features

-   Live preview
-   Markdown formatting
-   Code blocks
-   Insert custom Map components

Try editing this content!
`;
function Kme({
  allAvailableDatasets: e,
  initialContent: t,
  onChange: n,
  className: r
}) {
  const i = {
    namespace: "MyEditor",
    // Unique namespace for this editor instance
    onError: (y) => {
      console.error("Lexical editor error:", y);
    }
    // ... other Lexical configuration options if needed
  }, [s, o] = Re(
    t || nC
  ), [a, l] = Re(
    t || nC
  ), [c, u] = Re(0), [f, d] = Re(!1), h = $e(null), m = Ht(
    (y) => {
      o(y), n && n(y);
    },
    [n]
  );
  Le(() => {
    d(!0);
  }, []);
  const p = (y) => {
    if (u(y), (y === 1 || y === 2) && h.current) {
      const v = h.current;
      v.style.visibility = "hidden", v.style.position = "absolute", v.style.pointerEvents = "none";
    } else if (y === 0 && h.current) {
      const v = h.current;
      v.style.visibility = "visible", v.style.position = "static", v.style.pointerEvents = "auto";
    }
  };
  return /* @__PURE__ */ Oe("div", { className: "container mx-auto p-4 max-w-5xl min-h-screen bg-gray-50", children: [
    /* @__PURE__ */ Oe("div", { className: "flex space-x-4 mb-4", children: [
      /* @__PURE__ */ A(
        "button",
        {
          onClick: () => p(0),
          className: `px-4 py-2 rounded-lg font-medium ${c === 0 ? "bg-blue-600 text-blue" : "bg-gray-200 text-gray-700 hover:bg-gray-300"}`,
          children: "Editor"
        }
      ),
      /* @__PURE__ */ A(
        "button",
        {
          onClick: () => p(1),
          className: `px-4 py-2 rounded-lg font-medium ${c === 1 ? "bg-blue-600 text-blue" : "bg-gray-200 text-gray-700 hover:bg-gray-300"}`,
          children: "Preview"
        }
      ),
      /* @__PURE__ */ A(
        "button",
        {
          onClick: () => p(2),
          className: `px-4 py-2 rounded-lg font-medium ${c === 2 ? "bg-blue-600 text-blue" : "bg-gray-200 text-gray-700 hover:bg-gray-300"}`,
          children: "Source"
        }
      )
    ] }),
    /* @__PURE__ */ Oe("div", { className: "border rounded-lg bg-white shadow-lg h-[600px] overflow-hidden relative", children: [
      /* @__PURE__ */ A(
        "div",
        {
          ref: h,
          className: `h-full w-full ${c === 0 ? "" : "sr-only"}`,
          style: {
            visibility: c === 0 ? "visible" : "hidden",
            position: c === 0 ? "static" : "absolute"
          },
          children: f && /* @__PURE__ */ A(
            ng,
            {
              fallback: /* @__PURE__ */ A("div", { className: "h-full flex items-center justify-center", children: "Loading editor..." }),
              children: /* @__PURE__ */ A(SM, { initialConfig: i, children: /* @__PURE__ */ A(
                Nfe,
                {
                  markdown: s,
                  onChange: m,
                  editorMounted: f,
                  previewMDAST: l
                },
                mme
              ) })
            }
          )
        }
      ),
      c === 1 && /* @__PURE__ */ A("div", { className: "h-full w-full", children: /* @__PURE__ */ A("div", { className: "prose max-w-none p-6 h-full overflow-auto", children: /* @__PURE__ */ A(
        ng,
        {
          fallback: /* @__PURE__ */ A("div", { className: "flex items-center justify-center h-full", children: "Loading MDX preview..." }),
          children: /* @__PURE__ */ A(pme, { source: a })
        }
      ) }) }),
      c === 2 && /* @__PURE__ */ A("div", { className: "h-full w-full", children: /* @__PURE__ */ A("div", { className: "p-4 h-full overflow-auto", children: /* @__PURE__ */ A("div", { className: "bg-white-50 rounded-lg border border-gray-300 p-4 h-full font-mono text-sm overflow-auto", children: /* @__PURE__ */ A("pre", { className: "whitespace-pre-wrap break-words", children: a }) }) }) })
    ] })
  ] });
}
export {
  Kme as VEDAContentEditor
};
//# sourceMappingURL=index.mjs.map
