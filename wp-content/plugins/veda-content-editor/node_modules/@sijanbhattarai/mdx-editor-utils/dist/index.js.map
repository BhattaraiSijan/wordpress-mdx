{"version":3,"file":"index.js","sources":["../../../node_modules/zwitch/index.js","../../../node_modules/mdast-util-to-markdown/lib/configure.js","../../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../../../node_modules/mdast-util-to-markdown/lib/handle/break.js","../../../node_modules/longest-streak/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../../../node_modules/mdast-util-to-markdown/lib/handle/code.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../../../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../../../node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js","../../../node_modules/micromark-util-character/index.js","../../../node_modules/micromark-util-classify-character/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/encode-info.js","../../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../../../node_modules/mdast-util-to-string/lib/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../../../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../../../node_modules/mdast-util-to-markdown/lib/handle/html.js","../../../node_modules/mdast-util-to-markdown/lib/handle/image.js","../../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../../../node_modules/mdast-util-to-markdown/lib/handle/link.js","../../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../../../node_modules/mdast-util-to-markdown/lib/handle/list.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../../../node_modules/unist-util-is/lib/index.js","../../../node_modules/mdast-util-phrasing/lib/index.js","../../../node_modules/mdast-util-to-markdown/lib/handle/root.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../../../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../../../node_modules/mdast-util-to-markdown/lib/handle/text.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../../../node_modules/mdast-util-to-markdown/lib/handle/index.js","../../../node_modules/mdast-util-to-markdown/lib/join.js","../../../node_modules/mdast-util-to-markdown/lib/unsafe.js","../../../node_modules/decode-named-character-reference/index.dom.js","../../../node_modules/micromark-util-decode-numeric-character-reference/index.js","../../../node_modules/micromark-util-decode-string/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/association.js","../../../node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js","../../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../../node_modules/mdast-util-to-markdown/lib/util/safe.js","../../../node_modules/mdast-util-to-markdown/lib/util/track.js","../../../node_modules/mdast-util-to-markdown/lib/index.js","../../../node_modules/mdast-util-mdx-expression/lib/index.js","../../../node_modules/mdast-util-mdxjs-esm/lib/index.js","../../../node_modules/mdast-util-mdx/lib/index.js","../src/extractImports.tsx","../src/wrapComponent.tsx","../src/parseTwoColumn.tsx","../src/groupElements.tsx","../src/reserializeMDast.tsx","../src/ChartContext.tsx","../src/MapContext.tsx","../src/inputValidation.tsx","../src/CreateInterface.tsx","../src/data.tsx"],"sourcesContent":["/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it’s value is this function’s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it’s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn’t have a `key` property, the special\n   * “invalid” handler will be called.\n   * If `value` has an unknown `key`, the special “unknown” handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it’s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it’s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n","/**\n * @import {Options, State} from './types.js'\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'extensions': {\n          // Empty.\n          break\n        }\n\n        /* c8 ignore next 4 */\n        case 'unsafe': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'join': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'handlers': {\n          map(base[key], extension[key])\n          break\n        }\n\n        default: {\n          // @ts-expect-error: matches.\n          base.options[key] = extension[key]\n        }\n      }\n    }\n  }\n\n  return base\n}\n\n/**\n * @template T\n * @param {Array<T>} left\n * @param {Array<T> | null | undefined} right\n */\nfunction list(left, right) {\n  if (right) {\n    left.push(...right)\n  }\n}\n\n/**\n * @template T\n * @param {Record<string, T>} left\n * @param {Record<string, T> | null | undefined} right\n */\nfunction map(left, right) {\n  if (right) {\n    Object.assign(left, right)\n  }\n}\n","/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @import {Code} from 'micromark-util-types'\n */\n\nimport { markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > 👉 **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n    return 1;\n  }\n  if (unicodePunctuation(code)) {\n    return 2;\n  }\n}","/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * > 👉 **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @import {Join} from 'mdast-util-to-markdown'\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/// <reference lib=\"dom\" />\n\n/* global document */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCodePoint(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base);\n  if (\n  // C0 except for HT, LF, FF, CR, space.\n  code < 9 || code === 11 || code > 13 && code < 32 ||\n  // Control character (DEL) of C0, and C1 controls.\n  code > 126 && code < 160 ||\n  // Lone high surrogates and low surrogates.\n  code > 55_295 && code < 57_344 ||\n  // Noncharacters.\n  code > 64_975 && code < 65_008 || /* eslint-disable no-bitwise */\n  (code & 65_535) === 65_535 || (code & 65_535) === 65_534 || /* eslint-enable no-bitwise */\n  // Out of range\n  code > 1_114_111) {\n    return \"\\uFFFD\";\n  }\n  return String.fromCodePoint(code);\n}","import { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nconst characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @param {string} $1\n *   Character escape.\n * @param {string} $2\n *   Character reference.\n * @returns {string}\n *   Decoded value\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1;\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0);\n  if (head === 35) {\n    const head = $2.charCodeAt(1);\n    const hex = head === 120 || head === 88;\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n  }\n  return decodeNamedCharacterReference($2) || $0;\n}","/**\n * @import {AssociationId} from '../types.js'\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @import {CompilePattern} from '../types.js'\n */\n\n/**\n * @type {CompilePattern}\n */\nexport function compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n  /** @type {string | undefined} */\n  let encodeAfter\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    })\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value =\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\n    }\n\n    const encodingInfo = state.attentionEncodeSurroundingInfo\n    state.attentionEncodeSurroundingInfo = undefined\n    encodeAfter = undefined\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (\n        results.length > 0 &&\n        encodingInfo.before &&\n        before === results[results.length - 1].slice(-1)\n      ) {\n        results[results.length - 1] =\n          results[results.length - 1].slice(0, -1) +\n          encodeCharacterReference(before.charCodeAt(0))\n      }\n\n      if (encodingInfo.after) encodeAfter = after\n    }\n\n    tracker.move(value)\n    results.push(value)\n    before = value.slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {FlowChildren, FlowParents, TrackFields} from '../types.js'\n */\n\n/**\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {FlowChildren} left\n * @param {FlowChildren} right\n * @param {FlowParents} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @import {IndentLines} from '../types.js'\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @import {SafeConfig, State} from 'mdast-util-to-markdown'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(encodeCharacterReference(value.charCodeAt(position)))\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @import {CreateTracker, TrackCurrent, TrackMove, TrackShift} from '../types.js'\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @import {Info, Join, Options, SafeConfig, State} from 'mdast-util-to-markdown'\n * @import {Nodes} from 'mdast'\n * @import {Enter, FlowParents, PhrasingParents, TrackFields} from './types.js'\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {compilePattern} from './util/compile-pattern.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options) {\n  const settings = options || {}\n  /** @type {State} */\n  const state = {\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    enter,\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {...handlers},\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined,\n    indentLines,\n    indexStack: [],\n    join: [...join],\n    options: {},\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe]\n  }\n\n  configure(state, settings)\n\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition)\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */ (value)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle} from 'mdast-util-from-markdown'\n * @import {MdxFlowExpression, MdxTextExpression} from 'mdast-util-mdx-expression'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State} from 'mdast-util-to-markdown'\n * @import {Parents} from 'mdast'\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX expressions\n * in markdown.\n *\n * When using the micromark syntax extension with `addResult`, nodes will have\n * a `data.estree` field set to an ESTree `Program` node.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX expressions.\n */\nexport function mdxExpressionFromMarkdown() {\n  return {\n    enter: {\n      mdxFlowExpression: enterMdxFlowExpression,\n      mdxTextExpression: enterMdxTextExpression\n    },\n    exit: {\n      mdxFlowExpression: exitMdxExpression,\n      mdxFlowExpressionChunk: exitMdxExpressionData,\n      mdxTextExpression: exitMdxExpression,\n      mdxTextExpressionChunk: exitMdxExpressionData\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX expressions\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX expressions.\n */\nexport function mdxExpressionToMarkdown() {\n  return {\n    handlers: {\n      mdxFlowExpression: handleMdxExpression,\n      mdxTextExpression: handleMdxExpression\n    },\n    unsafe: [\n      {character: '{', inConstruct: ['phrasing']},\n      {atBreak: true, character: '{'}\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxFlowExpression(token) {\n  this.enter({type: 'mdxFlowExpression', value: ''}, token)\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxTextExpression(token) {\n  this.enter({type: 'mdxTextExpression', value: ''}, token)\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxExpression(token) {\n  const value = this.resume()\n  const estree = token.estree\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression')\n  this.exit(token)\n  node.value = value\n\n  if (estree) {\n    node.data = {estree}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxExpressionData(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Node.\n * @param {Parents | undefined} parent\n *   Parent, if any.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized markdown.\n */\nfunction handleMdxExpression(node, parent, state) {\n  const value = node.value || ''\n  const result = state.indentLines(value, function (line, index, blank) {\n    // Tab-size to eat has to be the same as what we serialize as.\n    // While in some places in markdown that’s 4, in JS it’s more common as 2.\n    // Which is what’s also in `mdast-util-mdx-jsx`:\n    // <https://github.com/syntax-tree/mdast-util-mdx-jsx/blob/40b951b/lib/index.js#L52>\n    return (index === 0 || blank ? '' : '  ') + line\n  })\n  return '{' + result + '}'\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('../index.js').MdxjsEsm} MdxjsEsm\n */\n\n// To do: next major: expose functions.\nimport {ok as assert} from 'devlop'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX.js ESM in\n * markdown.\n *\n * When using the micromark syntax extension with `addResult`, nodes will have\n * a `data.estree` field set to an ESTree [`Program`][program] node.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX.js ESM.\n */\nexport function mdxjsEsmFromMarkdown() {\n  return {\n    enter: {mdxjsEsm: enterMdxjsEsm},\n    exit: {mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX.js ESM in\n * markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX.js ESM.\n */\nexport function mdxjsEsmToMarkdown() {\n  return {handlers: {mdxjsEsm: handleMdxjsEsm}}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxjsEsm(token) {\n  this.enter({type: 'mdxjsEsm', value: ''}, token)\n  this.buffer() // Capture EOLs\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxjsEsm(token) {\n  const value = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'mdxjsEsm')\n\n  this.exit(token)\n\n  const estree = token.estree\n\n  node.value = value\n\n  if (estree) {\n    node.data = {estree}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxjsEsmData(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {MdxjsEsm} node\n */\nfunction handleMdxjsEsm(node) {\n  return node.value || ''\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-mdx-jsx').ToMarkdownOptions} ToMarkdownOptions\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\nimport {\n  mdxExpressionFromMarkdown,\n  mdxExpressionToMarkdown\n} from 'mdast-util-mdx-expression'\nimport {mdxJsxFromMarkdown, mdxJsxToMarkdown} from 'mdast-util-mdx-jsx'\nimport {mdxjsEsmFromMarkdown, mdxjsEsmToMarkdown} from 'mdast-util-mdxjs-esm'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX (ESM, JSX,\n * expressions).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable MDX (ESM, JSX,\n *   expressions).\n *\n *   When using the syntax extensions with `addResult`, ESM and expression\n *   nodes will have `data.estree` fields set to ESTree `Program` node.\n */\nexport function mdxFromMarkdown() {\n  return [\n    mdxExpressionFromMarkdown(),\n    mdxJsxFromMarkdown(),\n    mdxjsEsmFromMarkdown()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX (ESM, JSX,\n * expressions).\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX (ESM, JSX,\n *   expressions).\n */\nexport function mdxToMarkdown(options) {\n  return {\n    extensions: [\n      mdxExpressionToMarkdown(),\n      mdxJsxToMarkdown(options),\n      mdxjsEsmToMarkdown()\n    ]\n  }\n}\n","export const extractImports = (ast) => {\n  const imports: any = [];\n  const visit = (node, parent, index) => {\n    // If it's a text node with 'import' in its value\n    if (\n      node.type === 'text' &&\n      node.value &&\n      node.value.includes('import') &&\n      node.value.includes('from')\n    ) {\n      if (\n        parent &&\n        Array.isArray(parent.children) &&\n        typeof index === 'number'\n      ) {\n        // Remove the node from its original position\n        parent.children.splice(index, 1);\n        // Wrap it in a paragraph or keep as-is depending on your use case\n        imports.push({\n          type: 'paragraph',\n          children: [node],\n        });\n        return; // Skip deeper recursion into removed node\n      }\n    }\n\n    // Recurse through children if they exist\n    if (node.children && Array.isArray(node.children)) {\n      // Copy to avoid mutation issues when removing nodes\n      const childrenCopy = [...node.children];\n      for (let i = 0; i < childrenCopy.length; i++) {\n        visit(childrenCopy[i], node, i);\n      }\n    }\n  };\n\n  visit(ast, null, null);\n\n  // Prepend extracted imports to top-level children\n  if (ast.type === 'root' && Array.isArray(ast.children)) {\n    ast.children = [...imports, ...ast.children];\n  }\n\n  return ast;\n};\n","export const wrapComponent = (mdastChild) => {\n  const generatedProps = mdastChild.attributes.reduce((acc, item) => {\n    acc[item.name] = item.value;\n    return acc;\n  }, {});\n\n  const wrappedComponent = {\n    type: 'mdxJsxFlowElement',\n    name: 'Figure',\n    attributes: [],\n    children: [\n      { ...mdastChild },\n      {\n        type: 'mdxJsxFlowElement',\n        name: 'Caption',\n        attributes: [\n          { name: 'attrAuthor', value: generatedProps.attrAuthor },\n          { name: 'attrUrl', value: generatedProps.attrUrl },\n        ],\n        children: [{ type: 'text', value: generatedProps.caption }],\n      },\n    ],\n  };\n  return wrappedComponent;\n};\n","import { wrapComponent } from './wrapComponent';\n\nexport const handleTwoColumn = (MDAST) => {\n  const newTwoColumn: any = [];\n  for (const twoColumnChildren of MDAST.children) {\n    if (\n      twoColumnChildren.children.some(\n        (e) => e.name === 'Chart' || e.name === 'Map',\n      )\n    ) {\n      for (const columnChild of twoColumnChildren.children) {\n        if (columnChild.name === 'Chart' || columnChild.name === 'Map') {\n          newTwoColumn.push(wrapComponent(columnChild));\n        }\n      }\n    } else {\n      newTwoColumn.push({\n        type: 'mdxJsxFlowElement',\n        name: 'Prose',\n        attributes: [],\n        children: [...twoColumnChildren.children],\n      });\n    }\n  }\n  return newTwoColumn;\n};\n","import { handleTwoColumn } from './parseTwoColumn';\nimport { wrapComponent } from './wrapComponent';\n\nexport const groupByBreakIntoBlocks = (ast) => {\n  const result: any = [];\n  const proseWrapper = (children) => {\n    return {\n      type: 'mdxJsxFlowElement',\n      name: 'Prose',\n      children: [...children],\n    };\n  };\n\n  const groupChildren = (children) => {\n    const groups: any = [];\n    let currentGroup: any = [];\n\n    for (const child of children) {\n      if (\n        child.type === 'mdxJsxTextElement' ||\n        child.type === 'mdxJsxFlowElement'\n      ) {\n        if (child.name === 'Break') {\n          if (currentGroup.length > 0) {\n            groups.push([proseWrapper(currentGroup)]);\n            currentGroup = [];\n          }\n        } else if (\n          child.name === 'Block' ||\n          child.name === 'Chart' ||\n          child.name === 'Map' ||\n          child.name === 'MapBlock' ||  \n          child.name === 'TwoColumn'\n        ) {\n          groups.push([proseWrapper(currentGroup)]);\n\n          if (child.name === 'Chart' || child.name === 'Map') {\n            groups.push([wrapComponent(child)]);\n          } else if (child.name === 'TwoColumn') {\n            const parsedColumn = handleTwoColumn(child);\n            groups.push(parsedColumn);\n          }\n          currentGroup = [];\n        }\n      } else {\n        currentGroup.push(child);\n      }\n    }\n\n    if (currentGroup.length > 0) {\n      groups.push([...currentGroup]);\n    }\n    return groups;\n  };\n\n  if (ast.type === 'root' && Array.isArray(ast.children)) {\n    const groups = groupChildren(ast.children);\n\n    for (const group of groups) {\n      // Check for prose wrapper inside group If no prose wrapper\n      // then wrap group inside prose object before adding to block element\n\n      if (\n        group.some((item) => {\n          return item.name === 'Prose';\n        })\n      ) {\n        result.push({\n          type: 'mdxJsxFlowElement',\n          name: 'Block',\n          children: [...group],\n        });\n      } else {\n        result.push({\n          type: 'mdxJsxFlowElement',\n          name: 'Block',\n          children: [\n            {\n              type: 'mdxJsxFlowElement',\n              name: 'Prose',\n              children: [...group],\n            },\n          ],\n        });\n      }\n    }\n  }\n\n  return result;\n};\n","import { toMarkdown } from 'mdast-util-to-markdown';\nimport { mdxToMarkdown } from 'mdast-util-mdx';\nimport { gfmToMarkdown } from 'mdast-util-gfm';\nimport { mdxJsxToMarkdown } from 'mdast-util-mdx-jsx';\nimport { extractImports } from './extractImports';\n\nimport { groupByBreakIntoBlocks } from './groupElements';\n\nconst blockItem = {\n  type: 'mdxJsxFlowElement',\n  name: 'Block',\n  children: [],\n};\n\nconst proseItem = {\n  type: 'mdxJsxFlowElement',\n  name: 'Prose',\n  children: [],\n};\n\n//TO DO: Create seperate block prose containers\n\nconst transformMdast = (node) => {\n  // if (!node || typeof node !== 'object') return node;\n  if (!node || node.type !== 'root' || !Array.isArray(node.children)) {\n    return node;\n  }\n  // if (node.type === 'root') {\n  //   const newChildren: any = [];\n  const newChildren: any[] = [];\n  for (const child of node.children) {\n    // Unwrap paragraphs that only contain a single JSX flow element.\n    // This is a common pattern to avoid unwanted <p> tags around components.\n    if (\n      child.type === 'paragraph' &&\n      child.children.length === 1 &&\n      child.children[0].type === 'mdxJsxFlowElement'\n    ) {\n      newChildren.push(child.children[0]);\n    } else {\n      newChildren.push(child);\n    }\n  }\n\n  //   for (const child of node.children) {\n  //     if (child.type === 'paragraph') {\n  //       // Elevate each text/html child to the root\n  //       for (const sub of child.children) {\n  //         switch (sub.type) {\n  //           case 'text':\n  //             newChildren.push({\n  //               type: 'paragraph',\n  //               children: [sub],\n  //             });\n  //             break;\n  //           case 'html':\n  //             newChildren.push(sub);\n  //             break;\n  //           case 'mdxJsxTextElement':\n  //             newChildren.push(sub);\n  //             break;\n  //           case 'mdxJsxFlowElement':\n  //             newChildren.push(sub);\n  //             break;\n  //           default:\n  //             newChildren.push(sub);\n  //             break;\n  //         }\n  //       }\n  //     } else {\n  //       // Recurse into child\n  //       const transformed = transformMdast(child);\n  //       newChildren.push(transformed);\n  //     }\n  //   }\n\n  //   return { ...node, children: newChildren };\n  // }\n\n  // // Handle recursion for non-root nodes with children\n  // if (Array.isArray(node.children)) {\n  //   return {\n  //     ...node,\n  //     children: node.children.map(transformMdast),\n  //   };\n  // }\n\n  // return node;\n  return { ...node, children: newChildren };\n};\n\nexport const reserializedMdxContent = (MDAST) => {\n\n  const seperatedMDAST = transformMdast(MDAST);\n\n  const groupedMDSAT = groupByBreakIntoBlocks(seperatedMDAST);\n  extractImports(seperatedMDAST);\n\n  const newMDast = { ...seperatedMDAST, children: groupedMDSAT };\n  const mdastToMdx = (mdast) => {\n    return toMarkdown(mdast, {\n      extensions: [mdxToMarkdown(), gfmToMarkdown(), mdxJsxToMarkdown()],\n    });\n  };\n\n  return mdastToMdx(newMDast);\n};\n","'use client';\n\nimport React, { createContext, useContext } from 'react';\nimport { LexicalEditor, LexicalNode } from 'lexical';\n\ninterface ChartContextValue {\n  parentEditor: LexicalEditor;\n  lexicalNode: LexicalNode;\n}\n\nconst ChartContext = createContext<ChartContextValue | null>(null);\n\nexport const ChartContextProvider = ({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: ChartContextValue;\n}) => {\n  return <ChartContext.Provider value={value}>{children}</ChartContext.Provider>;\n};\n\nexport const useChartContext = () => {\n  const context = useContext(ChartContext);\n  if (!context) {\n    throw new Error('useChartContext must be used within a ChartContextProvider');\n  }\n  return context;\n};","'use client';\n\nimport React, { createContext, useContext } from 'react';\nimport { LexicalEditor, LexicalNode } from 'lexical';\n\ninterface MapContextValue {\n  parentEditor: LexicalEditor;\n  lexicalNode: LexicalNode;\n}\n\nconst MapContext = createContext<MapContextValue | null>(null);\n\nexport const MapContextProvider = ({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: MapContextValue;\n}) => {\n  return <MapContext.Provider value={value}>{children}</MapContext.Provider>;\n};\n\nexport const useMapContext = () => {\n  const context = useContext(MapContext);\n  if (!context) {\n    throw new Error('useMapContext must be used within a MapContextProvider');\n  }\n  return context;\n};\n","export const inputValidation = () => {};\n\nexport const dateStringToregex = (format) => {\n  const tokens = {\n    '%d': '(0[1-9]|[12][0-9]|3[01])',\n    '%m': '(0[1-9]|1[0-2])',\n    '%Y': '\\\\d{4}',\n    '%y': '\\\\d{2}',\n    '%H': '([01][0-9]|2[0-3])',\n    '%M': '([0-5][0-9])',\n    '%S': '([0-5][0-9])',\n  };\n\n  const escape = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  let pattern = '';\n\n  for (let i = 0; i < format.length; i++) {\n    if (format[i] === '%' && i < format.length - 1) {\n      const directive = format[i] + format[i + 1];\n      pattern += tokens[directive] || escape(directive); // unknown: treat literally\n      i++; // skip the directive's second char\n    } else {\n      pattern += escape(format[i]);\n    }\n  }\n\n  return new RegExp(`^${pattern}$`);\n};\n\nexport const dateFormatValidation = (format, input) => {\n  const regexToTest = dateStringToregex(format);\n\n  //return false no errors if regex passes, return true there are erros if fails\n  return regexToTest.test(input) ? false : true;\n};\n\nexport const handleChartDateValidation = (\n  propName,\n  draftInputs,\n  setInputErrors,\n  inputErrors,\n  draft,\n  onChange,\n  chartProps,\n) => {\n  if (propName === 'highlightStart' || propName === 'highlightEnd') {\n    if (dateFormatValidation(draftInputs.draftDateFormat, draft) === false) {\n      setInputErrors({\n        highlightStart: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightStart,\n        ),\n        highlightEnd: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightEnd,\n        ),\n      });\n      if (\n        inputErrors.highlightStart == false &&\n        inputErrors.highlightEnd == false\n      ) {\n        onChange({\n          ...chartProps,\n          dateFormat: draftInputs.draftDateFormat,\n          highlightStart: draftInputs.draftHighlightStart,\n          highlightEnd: draftInputs.draftHighlightEnd,\n        });\n      }\n    } else {\n      setInputErrors({\n        highlightStart: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightStart,\n        ),\n        highlightEnd: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightEnd,\n        ),\n      });\n    }\n  } else if (propName === 'dateFormat') {\n    setInputErrors({\n      highlightStart: dateFormatValidation(draft, chartProps.highlightStart),\n      highlightEnd: dateFormatValidation(draft, chartProps.highlightEnd),\n    });\n  } else if (\n    inputErrors.highlightStart == false &&\n    inputErrors.highlightEnd == false\n  ) {\n    onChange({\n      ...chartProps,\n      dateFormat: draftInputs.draftDateFormat,\n      highlightStart: draftInputs.draftHighlightStart,\n      highlightEnd: draftInputs.draftHighlightEnd,\n    });\n  }\n};\nexport const handleMapDateValidation = (\n  propName,\n  draftInputs,\n  inputErrors,\n  setInputErrors,\n  draft,\n  onChange,\n  componentProps,\n) => {\n  if (\n    dateFormatValidation(draftInputs.defaultDateFormat, draft) === false ||\n    draft === ''\n  ) {\n    setInputErrors({ ...inputErrors, [propName]: false });\n    onChange({ ...componentProps, [propName]: draft });\n  } else {\n    setInputErrors({ ...inputErrors, [propName]: true });\n  }\n};\n\nexport const handleMapArrayValidation = (\n  propName,\n  draftInputs,\n  inputErrors,\n  setInputErrors,\n  draft,\n  onChange,\n  componentProps,\n) => {\n  const numberPattern =\n    /^\\[[+-]?(0|[1-9][0-9]*)(\\.[0-9]+)?(?:,\\s*[+-]?(0|[1-9][0-9]*)(\\.[0-9]+)?)*\\]$/;\n  //This regex checks that the input is wrapped in [...]\n  //Checks for no trailing decimal points ex: -91.\n  //Checks that there is no leading 0 unless followed by a . ex 0.12 or 0 are acceptable\n  const cleanedDraft = draft.replace(/\\s/g, '');\n  if (numberPattern.test(cleanedDraft)) {\n    const parsedValues = JSON.parse(cleanedDraft);\n    const checkLong = (long) => (long <= 180 && long >= -180 ? true : false);\n    const checkLat = (lat) => (lat <= 90 && lat >= -90 ? true : false);\n    //validating upper and lower limits of long and lat\n    if (checkLong(parsedValues[0]) && checkLat(parsedValues[1])) {\n      setInputErrors({ ...inputErrors, [propName]: false });\n      onChange({ ...componentProps, [propName]: draft });\n    } else {\n      setInputErrors({ ...inputErrors, [propName]: true });\n    }\n  } else {\n    setInputErrors({ ...inputErrors, [propName]: true });\n  }\n};\n","'use client';\n\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport {\n  TextInput,\n  TextInputMask,\n  Textarea,\n  Label,\n  DatePicker,\n  Checkbox,\n  Select,\n} from '@trussworks/react-uswds';\nimport {\n  handleMapDateValidation,\n  handleMapArrayValidation,\n  handleChartDateValidation,\n} from './inputValidation';\n\ninterface FieldProps {\n  fieldName: string;\n  value: string;\n  hint?: string;\n  onChange: (value: string) => void;\n  isRequired?: boolean;\n  isDate?: boolean;\n  numeric?: boolean;\n  onBlur?: (value: string) => void;\n  onFocus?: (value: string) => void;\n  type?: string;\n  componentProps: any;\n  propName: string;\n  customClass?: string;\n  placeHolder?: string;\n  draftInputs?: any;\n  inputErrors?: any;\n  setDraftInputs?: (value: any) => void;\n  setInputErrors?: (value: any) => void;\n  options?: string[];\n}\nconst checkRequired = (isRequired, value) => {\n  return isRequired && !value ? { validationStatus: 'error' } : '';\n};\n\nconst colorSchemes = [\n  'Blues',\n  'Greens',\n  'Greys',\n  'Oranges',\n  'Purples',\n  'Reds',\n  'Turbo',\n  'Viridis',\n  'Inferno',\n  'Magma',\n  'Plasma',\n  'Cividis',\n  'Warm',\n  'Cool',\n  'CubehelixDefault',\n];\n\nconst setInput = (props) => {\n  const {\n    value,\n    isRequired,\n    type,\n    fieldName,\n    hint,\n    onChange,\n    componentProps,\n    propName,\n    placeHolder,\n    validateAgainst,\n    draftInputs,\n    setDraftInputs,\n    inputErrors,\n    setInputErrors,\n    options,\n  } = props;\n\nif (options && Array.isArray(options)) {\n    return (\n      <>\n        <Label htmlFor={propName} className='margin-top-2'>\n          {fieldName}\n        </Label>\n        <span className='usa-hint'>{hint}</span>\n        <Select\n          id={propName}\n          name={propName}\n          value={value}\n          onChange={(e) =>\n            onChange({ ...componentProps, [propName]: e.target.value })\n          }\n          {...checkRequired(isRequired, value)}\n        >\n          <option value=''>- Select option -</option>\n          {options.map((option) => {\n            // Check if option is a string or an object with value/label\n            const value = typeof option === 'object' ? option.value : option;\n            const label = typeof option === 'object' ? option.label : option;\n\n            return (\n              <option key={value} value={value}>\n                {label}\n              </option>\n            );\n          })}\n        </Select>\n      </>\n    );\n  }\n\n  const cleanedType = type !== undefined && type.toLowerCase();\n\n  const [draft, setDraft] = useState(value);\n\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  useEffect(() => {\n\n    if (propName === 'dateFormat' && draft != draftInputs.draftDateFormat) {\n      setDraftInputs({ ...draftInputs, draftDateFormat: draft });\n    }\n    if (\n      propName === 'highlightStart' &&\n      draft != draftInputs.draftHighlightStart\n    ) {\n      setDraftInputs({ ...draftInputs, draftHighlightStart: draft });\n    }\n    if (propName === 'highlightEnd' && draft != draftInputs.draftHighlightEnd) {\n      setDraftInputs({ ...draftInputs, draftHighlightEnd: draft });\n    }\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = setTimeout(() => {\n\n      if (validateAgainst) {\n        if (\n          propName === 'dateFormat' ||\n          propName === 'highlightStart' ||\n          propName === 'highlightEnd'\n        ) {\n          handleChartDateValidation(\n            propName,\n            draftInputs,\n            setInputErrors,\n            inputErrors,\n            draft,\n            onChange,\n            componentProps,\n          );\n        } else if (validateAgainst === 'defaultDateFormat') {\n          handleMapDateValidation(\n            propName,\n            draftInputs,\n            inputErrors,\n            setInputErrors,\n            draft,\n            onChange,\n            componentProps,\n          );\n        } else if (validateAgainst === 'centerFormat') {\n          handleMapArrayValidation(\n            propName,\n            draftInputs,\n            inputErrors,\n            setInputErrors,\n            draft,\n            onChange,\n            componentProps,\n          );\n        } else {\n          onChange({ ...componentProps, [propName]: draft });\n        }\n      }\n    }, 400);\n\n    return () => clearTimeout(timeoutRef.current);\n  }, [draft, draftInputs]);\n\n  //Format date and submitted dates need to work or else the chart will throw an error.\n\n  switch (cleanedType) {\n    case 'date':\n      return (\n        //CHORE: Need to clean up or delete\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n\n          <span className='usa-hint'>{hint}</span>\n\n          <DatePicker\n            defaultValue={value}\n            onChange={(e) => console.log('DatePicker', e)}\n            {...checkRequired(isRequired, value)}\n          />\n        </>\n      );\n      break;\n    case 'checkbox':\n      return (\n        <Checkbox\n          id={fieldName}\n          name='checkbox'\n          label={fieldName}\n          onChange={(e) =>\n            onChange({ ...componentProps, [propName]: e.target.value })\n          }\n        />\n      );\n      break;\n    case 'select':\n      return (\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n          <span className='usa-hint'>{hint}</span>\n          <Select\n            id={fieldName}\n            name={fieldName}\n            onChange={(e) =>\n              onChange({ ...componentProps, [propName]: e.target.value })\n            }\n          >\n            {colorSchemes.map((scheme) => {\n              return (\n                <option key={scheme} value={scheme}>\n                  {scheme}\n                </option>\n              );\n            })}\n          </Select>\n        </>\n      );\n      break;\n    case 'area':\n      return (\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n          <span className='usa-hint'>{hint}</span>\n          <Textarea\n            id='input-type-text'\n            name='input-type-text'\n            value={value}\n            onChange={(e) => {\n              onChange({ ...componentProps, [propName]: e.target.value });\n            }}\n            className=''\n            {...checkRequired(isRequired, value)}\n          />\n        </>\n      );\n      break;\n    default:\n      return (\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n\n          <span className='usa-hint'>{hint}</span>\n          <TextInput\n            id='input-type-text'\n            name='input-type-text'\n            type='text'\n            value={validateAgainst ? draft : value}\n            onChange={(e) => {\n              if (validateAgainst) {\n\n                setDraft(e.target.value);\n              } else {\n\n                onChange({ ...componentProps, [propName]: e.target.value });\n              }\n            }}\n            placeholder={placeHolder}\n            {...checkRequired(isRequired, value)}\n            validationStatus={\n              validateAgainst && (inputErrors[propName] ? 'error' : undefined)\n            }\n          />\n        </>\n      );\n  }\n};\nexport const InputField: React.FC<FieldProps> = (props) => {\n  const { propName, customClass } = props;\n\n  return (\n    <div key={propName} className={customClass}>\n      {setInput(props)}\n    </div>\n  );\n};\n","import type { DatasetData, StoryData, VedaData } from '@lib';\nimport type { DatasetMetadata, DatasetWithContent } from './content';\n\nexport function processTaxonomies(data): DatasetData | StoryData {\n  const updatedTax = data.taxonomy.map((t) => {\n    const updatedVals = t.values.map((v) => {\n      return {\n        id: v.replace(/ /g, '_').toLowerCase(),\n        name: v,\n      };\n    });\n    return { ...t, values: updatedVals };\n  });\n  return { ...data, taxonomy: updatedTax };\n}\n\nexport const transformToDatasetsList = (\n  content: DatasetMetadata[],\n): DatasetData[] => {\n  return content?.map((post) => ({\n    ...post.metadata,\n  }));\n};\n\nexport const transformToVedaData = (\n  datasets: DatasetMetadata[] | undefined,\n): VedaData<DatasetData> => {\n  const transformed = {};\n  datasets?.map((dataset) => {\n    const id = dataset.metadata.id;\n    transformed[id] = {\n      data: dataset.metadata,\n    };\n  });\n  return transformed;\n};\n"],"names":["own","zwitch","key","options","settings","one","value","parameters","fn","handlers","id","configure","base","extension","index","list","map","left","right","blockquote","node","_","state","info","exit","tracker","line","blank","patternInScope","stack","pattern","listInScope","none","hardBreak","_1","longestStreak","substring","source","expected","count","max","formatCodeAsIndented","checkFence","marker","code","raw","suffix","sequence","subexit","checkQuote","definition","quote","checkEmphasis","encodeCharacterReference","markdownLineEndingOrSpace","unicodePunctuation","regexCheck","unicodeWhitespace","regex","check","classifyCharacter","encodeInfo","outside","inside","outsideKind","insideKind","emphasis","emphasisPeek","before","between","betweenHead","open","betweenTail","close","after","emptyOptions","toString","includeImageAlt","includeHtml","all","values","result","formatHeadingAsSetext","literalWithBreak","visit","EXIT","heading","rank","html","htmlPeek","image","imagePeek","imageReference","imageReferencePeek","type","alt","reference","inlineCode","inlineCodePeek","expression","match","position","formatLinkAsAutolink","link","linkPeek","linkReference","linkReferencePeek","text","checkBullet","checkBulletOther","bullet","bulletOther","checkBulletOrdered","checkRule","parent","bulletCurrent","useDifferentMarker","firstListItem","item","checkListItemIndent","style","listItem","listItemIndent","size","paragraph","convert","test","ok","castFactory","anyFactory","propsFactory","typeFactory","tests","checks","any","checkAsRecord","nodeAsRecord","testFunction","looksLikeANode","phrasing","root","d","checkStrong","strong","strongPeek","checkRuleRepetition","repetition","thematicBreak","handle","join","joinDefaults","fullPhrasingSpans","unsafe","element","decodeNamedCharacterReference","characterReference","character","decodeNumericCharacterReference","characterEscapeOrReference","decodeString","decode","$0","$1","$2","head","hex","association","compilePattern","containerPhrasing","indexStack","children","results","encodeAfter","child","encodingInfo","containerFlow","eol","indentLines","start","safe","input","config","positions","infos","numerical","end","escapeBackslashes","a","b","whole","track","now","lineShift","column","move","current","shift","chunks","tail","toMarkdown","tree","containerPhrasingBound","containerFlowBound","enter","safeBound","joinDefinition","invalid","unknown","name","mdxExpressionToMarkdown","handleMdxExpression","mdxjsEsmToMarkdown","handleMdxjsEsm","mdxToMarkdown","mdxJsxToMarkdown","extractImports","ast","imports","childrenCopy","i","wrapComponent","mdastChild","generatedProps","acc","handleTwoColumn","MDAST","newTwoColumn","twoColumnChildren","e","columnChild","groupByBreakIntoBlocks","proseWrapper","groupChildren","groups","currentGroup","parsedColumn","group","transformMdast","newChildren","reserializedMdxContent","seperatedMDAST","groupedMDSAT","newMDast","mdast","gfmToMarkdown","ChartContext","createContext","ChartContextProvider","jsx","useChartContext","context","useContext","MapContext","MapContextProvider","useMapContext","inputValidation","dateStringToregex","format","tokens","escape","s","directive","dateFormatValidation","handleChartDateValidation","propName","draftInputs","setInputErrors","inputErrors","draft","onChange","chartProps","handleMapDateValidation","componentProps","handleMapArrayValidation","numberPattern","cleanedDraft","parsedValues","checkLong","long","checkLat","lat","checkRequired","isRequired","colorSchemes","setInput","props","fieldName","hint","placeHolder","validateAgainst","setDraftInputs","jsxs","Fragment","Label","Select","option","label","cleanedType","setDraft","useState","timeoutRef","useRef","useEffect","DatePicker","Checkbox","scheme","Textarea","TextInput","InputField","customClass","processTaxonomies","data","updatedTax","updatedVals","v","transformToDatasetsList","content","post","transformToVedaData","datasets","transformed","dataset"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]}