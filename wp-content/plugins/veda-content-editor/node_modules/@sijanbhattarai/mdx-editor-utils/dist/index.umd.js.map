{"version":3,"file":"index.umd.js","sources":["../../../node_modules/zwitch/index.js","../../../node_modules/mdast-util-to-markdown/lib/configure.js","../../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../../../node_modules/mdast-util-to-markdown/lib/handle/break.js","../../../node_modules/longest-streak/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../../../node_modules/mdast-util-to-markdown/lib/handle/code.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../../../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../../../node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js","../../../node_modules/micromark-util-character/index.js","../../../node_modules/micromark-util-classify-character/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/encode-info.js","../../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../../../node_modules/mdast-util-to-string/lib/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../../../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../../../node_modules/mdast-util-to-markdown/lib/handle/html.js","../../../node_modules/mdast-util-to-markdown/lib/handle/image.js","../../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../../../node_modules/mdast-util-to-markdown/lib/handle/link.js","../../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../../../node_modules/mdast-util-to-markdown/lib/handle/list.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../../../node_modules/unist-util-is/lib/index.js","../../../node_modules/mdast-util-phrasing/lib/index.js","../../../node_modules/mdast-util-to-markdown/lib/handle/root.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../../../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../../../node_modules/mdast-util-to-markdown/lib/handle/text.js","../../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../../../node_modules/mdast-util-to-markdown/lib/handle/index.js","../../../node_modules/mdast-util-to-markdown/lib/join.js","../../../node_modules/mdast-util-to-markdown/lib/unsafe.js","../../../node_modules/decode-named-character-reference/index.dom.js","../../../node_modules/micromark-util-decode-numeric-character-reference/index.js","../../../node_modules/micromark-util-decode-string/index.js","../../../node_modules/mdast-util-to-markdown/lib/util/association.js","../../../node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js","../../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../../node_modules/mdast-util-to-markdown/lib/util/safe.js","../../../node_modules/mdast-util-to-markdown/lib/util/track.js","../../../node_modules/mdast-util-to-markdown/lib/index.js","../../../node_modules/mdast-util-mdx-expression/lib/index.js","../../../node_modules/mdast-util-mdxjs-esm/lib/index.js","../../../node_modules/mdast-util-mdx/lib/index.js","../src/extractImports.tsx","../src/wrapComponent.tsx","../src/parseTwoColumn.tsx","../src/groupElements.tsx","../src/reserializeMDast.tsx","../src/ChartContext.tsx","../src/MapContext.tsx","../src/inputValidation.tsx","../src/CreateInterface.tsx","../src/data.tsx"],"sourcesContent":["/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it’s value is this function’s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it’s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn’t have a `key` property, the special\n   * “invalid” handler will be called.\n   * If `value` has an unknown `key`, the special “unknown” handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it’s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it’s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n","/**\n * @import {Options, State} from './types.js'\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'extensions': {\n          // Empty.\n          break\n        }\n\n        /* c8 ignore next 4 */\n        case 'unsafe': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'join': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'handlers': {\n          map(base[key], extension[key])\n          break\n        }\n\n        default: {\n          // @ts-expect-error: matches.\n          base.options[key] = extension[key]\n        }\n      }\n    }\n  }\n\n  return base\n}\n\n/**\n * @template T\n * @param {Array<T>} left\n * @param {Array<T> | null | undefined} right\n */\nfunction list(left, right) {\n  if (right) {\n    left.push(...right)\n  }\n}\n\n/**\n * @template T\n * @param {Record<string, T>} left\n * @param {Record<string, T> | null | undefined} right\n */\nfunction map(left, right) {\n  if (right) {\n    Object.assign(left, right)\n  }\n}\n","/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @import {Code} from 'micromark-util-types'\n */\n\nimport { markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > 👉 **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n    return 1;\n  }\n  if (unicodePunctuation(code)) {\n    return 2;\n  }\n}","/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * > 👉 **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @import {Join} from 'mdast-util-to-markdown'\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/// <reference lib=\"dom\" />\n\n/* global document */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCodePoint(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base);\n  if (\n  // C0 except for HT, LF, FF, CR, space.\n  code < 9 || code === 11 || code > 13 && code < 32 ||\n  // Control character (DEL) of C0, and C1 controls.\n  code > 126 && code < 160 ||\n  // Lone high surrogates and low surrogates.\n  code > 55_295 && code < 57_344 ||\n  // Noncharacters.\n  code > 64_975 && code < 65_008 || /* eslint-disable no-bitwise */\n  (code & 65_535) === 65_535 || (code & 65_535) === 65_534 || /* eslint-enable no-bitwise */\n  // Out of range\n  code > 1_114_111) {\n    return \"\\uFFFD\";\n  }\n  return String.fromCodePoint(code);\n}","import { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nconst characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @param {string} $1\n *   Character escape.\n * @param {string} $2\n *   Character reference.\n * @returns {string}\n *   Decoded value\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1;\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0);\n  if (head === 35) {\n    const head = $2.charCodeAt(1);\n    const hex = head === 120 || head === 88;\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n  }\n  return decodeNamedCharacterReference($2) || $0;\n}","/**\n * @import {AssociationId} from '../types.js'\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @import {CompilePattern} from '../types.js'\n */\n\n/**\n * @type {CompilePattern}\n */\nexport function compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n  /** @type {string | undefined} */\n  let encodeAfter\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    })\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value =\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\n    }\n\n    const encodingInfo = state.attentionEncodeSurroundingInfo\n    state.attentionEncodeSurroundingInfo = undefined\n    encodeAfter = undefined\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (\n        results.length > 0 &&\n        encodingInfo.before &&\n        before === results[results.length - 1].slice(-1)\n      ) {\n        results[results.length - 1] =\n          results[results.length - 1].slice(0, -1) +\n          encodeCharacterReference(before.charCodeAt(0))\n      }\n\n      if (encodingInfo.after) encodeAfter = after\n    }\n\n    tracker.move(value)\n    results.push(value)\n    before = value.slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {FlowChildren, FlowParents, TrackFields} from '../types.js'\n */\n\n/**\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {FlowChildren} left\n * @param {FlowChildren} right\n * @param {FlowParents} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @import {IndentLines} from '../types.js'\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @import {SafeConfig, State} from 'mdast-util-to-markdown'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(encodeCharacterReference(value.charCodeAt(position)))\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @import {CreateTracker, TrackCurrent, TrackMove, TrackShift} from '../types.js'\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @import {Info, Join, Options, SafeConfig, State} from 'mdast-util-to-markdown'\n * @import {Nodes} from 'mdast'\n * @import {Enter, FlowParents, PhrasingParents, TrackFields} from './types.js'\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {compilePattern} from './util/compile-pattern.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options) {\n  const settings = options || {}\n  /** @type {State} */\n  const state = {\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    enter,\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {...handlers},\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined,\n    indentLines,\n    indexStack: [],\n    join: [...join],\n    options: {},\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe]\n  }\n\n  configure(state, settings)\n\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition)\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */ (value)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle} from 'mdast-util-from-markdown'\n * @import {MdxFlowExpression, MdxTextExpression} from 'mdast-util-mdx-expression'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State} from 'mdast-util-to-markdown'\n * @import {Parents} from 'mdast'\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX expressions\n * in markdown.\n *\n * When using the micromark syntax extension with `addResult`, nodes will have\n * a `data.estree` field set to an ESTree `Program` node.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX expressions.\n */\nexport function mdxExpressionFromMarkdown() {\n  return {\n    enter: {\n      mdxFlowExpression: enterMdxFlowExpression,\n      mdxTextExpression: enterMdxTextExpression\n    },\n    exit: {\n      mdxFlowExpression: exitMdxExpression,\n      mdxFlowExpressionChunk: exitMdxExpressionData,\n      mdxTextExpression: exitMdxExpression,\n      mdxTextExpressionChunk: exitMdxExpressionData\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX expressions\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX expressions.\n */\nexport function mdxExpressionToMarkdown() {\n  return {\n    handlers: {\n      mdxFlowExpression: handleMdxExpression,\n      mdxTextExpression: handleMdxExpression\n    },\n    unsafe: [\n      {character: '{', inConstruct: ['phrasing']},\n      {atBreak: true, character: '{'}\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxFlowExpression(token) {\n  this.enter({type: 'mdxFlowExpression', value: ''}, token)\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxTextExpression(token) {\n  this.enter({type: 'mdxTextExpression', value: ''}, token)\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxExpression(token) {\n  const value = this.resume()\n  const estree = token.estree\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression')\n  this.exit(token)\n  node.value = value\n\n  if (estree) {\n    node.data = {estree}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxExpressionData(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Node.\n * @param {Parents | undefined} parent\n *   Parent, if any.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized markdown.\n */\nfunction handleMdxExpression(node, parent, state) {\n  const value = node.value || ''\n  const result = state.indentLines(value, function (line, index, blank) {\n    // Tab-size to eat has to be the same as what we serialize as.\n    // While in some places in markdown that’s 4, in JS it’s more common as 2.\n    // Which is what’s also in `mdast-util-mdx-jsx`:\n    // <https://github.com/syntax-tree/mdast-util-mdx-jsx/blob/40b951b/lib/index.js#L52>\n    return (index === 0 || blank ? '' : '  ') + line\n  })\n  return '{' + result + '}'\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('../index.js').MdxjsEsm} MdxjsEsm\n */\n\n// To do: next major: expose functions.\nimport {ok as assert} from 'devlop'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX.js ESM in\n * markdown.\n *\n * When using the micromark syntax extension with `addResult`, nodes will have\n * a `data.estree` field set to an ESTree [`Program`][program] node.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX.js ESM.\n */\nexport function mdxjsEsmFromMarkdown() {\n  return {\n    enter: {mdxjsEsm: enterMdxjsEsm},\n    exit: {mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX.js ESM in\n * markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX.js ESM.\n */\nexport function mdxjsEsmToMarkdown() {\n  return {handlers: {mdxjsEsm: handleMdxjsEsm}}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxjsEsm(token) {\n  this.enter({type: 'mdxjsEsm', value: ''}, token)\n  this.buffer() // Capture EOLs\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxjsEsm(token) {\n  const value = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'mdxjsEsm')\n\n  this.exit(token)\n\n  const estree = token.estree\n\n  node.value = value\n\n  if (estree) {\n    node.data = {estree}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxjsEsmData(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {MdxjsEsm} node\n */\nfunction handleMdxjsEsm(node) {\n  return node.value || ''\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-mdx-jsx').ToMarkdownOptions} ToMarkdownOptions\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\nimport {\n  mdxExpressionFromMarkdown,\n  mdxExpressionToMarkdown\n} from 'mdast-util-mdx-expression'\nimport {mdxJsxFromMarkdown, mdxJsxToMarkdown} from 'mdast-util-mdx-jsx'\nimport {mdxjsEsmFromMarkdown, mdxjsEsmToMarkdown} from 'mdast-util-mdxjs-esm'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX (ESM, JSX,\n * expressions).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable MDX (ESM, JSX,\n *   expressions).\n *\n *   When using the syntax extensions with `addResult`, ESM and expression\n *   nodes will have `data.estree` fields set to ESTree `Program` node.\n */\nexport function mdxFromMarkdown() {\n  return [\n    mdxExpressionFromMarkdown(),\n    mdxJsxFromMarkdown(),\n    mdxjsEsmFromMarkdown()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX (ESM, JSX,\n * expressions).\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX (ESM, JSX,\n *   expressions).\n */\nexport function mdxToMarkdown(options) {\n  return {\n    extensions: [\n      mdxExpressionToMarkdown(),\n      mdxJsxToMarkdown(options),\n      mdxjsEsmToMarkdown()\n    ]\n  }\n}\n","export const extractImports = (ast) => {\n  const imports: any = [];\n  const visit = (node, parent, index) => {\n    // If it's a text node with 'import' in its value\n    if (\n      node.type === 'text' &&\n      node.value &&\n      node.value.includes('import') &&\n      node.value.includes('from')\n    ) {\n      if (\n        parent &&\n        Array.isArray(parent.children) &&\n        typeof index === 'number'\n      ) {\n        // Remove the node from its original position\n        parent.children.splice(index, 1);\n        // Wrap it in a paragraph or keep as-is depending on your use case\n        imports.push({\n          type: 'paragraph',\n          children: [node],\n        });\n        return; // Skip deeper recursion into removed node\n      }\n    }\n\n    // Recurse through children if they exist\n    if (node.children && Array.isArray(node.children)) {\n      // Copy to avoid mutation issues when removing nodes\n      const childrenCopy = [...node.children];\n      for (let i = 0; i < childrenCopy.length; i++) {\n        visit(childrenCopy[i], node, i);\n      }\n    }\n  };\n\n  visit(ast, null, null);\n\n  // Prepend extracted imports to top-level children\n  if (ast.type === 'root' && Array.isArray(ast.children)) {\n    ast.children = [...imports, ...ast.children];\n  }\n\n  return ast;\n};\n","export const wrapComponent = (mdastChild) => {\n  const generatedProps = mdastChild.attributes.reduce((acc, item) => {\n    acc[item.name] = item.value;\n    return acc;\n  }, {});\n\n  const wrappedComponent = {\n    type: 'mdxJsxFlowElement',\n    name: 'Figure',\n    attributes: [],\n    children: [\n      { ...mdastChild },\n      {\n        type: 'mdxJsxFlowElement',\n        name: 'Caption',\n        attributes: [\n          { name: 'attrAuthor', value: generatedProps.attrAuthor },\n          { name: 'attrUrl', value: generatedProps.attrUrl },\n        ],\n        children: [{ type: 'text', value: generatedProps.caption }],\n      },\n    ],\n  };\n  return wrappedComponent;\n};\n","import { wrapComponent } from './wrapComponent';\n\nexport const handleTwoColumn = (MDAST) => {\n  const newTwoColumn: any = [];\n  for (const twoColumnChildren of MDAST.children) {\n    if (\n      twoColumnChildren.children.some(\n        (e) => e.name === 'Chart' || e.name === 'Map',\n      )\n    ) {\n      for (const columnChild of twoColumnChildren.children) {\n        if (columnChild.name === 'Chart' || columnChild.name === 'Map') {\n          newTwoColumn.push(wrapComponent(columnChild));\n        }\n      }\n    } else {\n      newTwoColumn.push({\n        type: 'mdxJsxFlowElement',\n        name: 'Prose',\n        attributes: [],\n        children: [...twoColumnChildren.children],\n      });\n    }\n  }\n  return newTwoColumn;\n};\n","import { handleTwoColumn } from './parseTwoColumn';\nimport { wrapComponent } from './wrapComponent';\n\nexport const groupByBreakIntoBlocks = (ast) => {\n  const result: any = [];\n  const proseWrapper = (children) => {\n    return {\n      type: 'mdxJsxFlowElement',\n      name: 'Prose',\n      children: [...children],\n    };\n  };\n\n  const groupChildren = (children) => {\n    const groups: any = [];\n    let currentGroup: any = [];\n\n    for (const child of children) {\n      if (\n        child.type === 'mdxJsxTextElement' ||\n        child.type === 'mdxJsxFlowElement'\n      ) {\n        if (child.name === 'Break') {\n          if (currentGroup.length > 0) {\n            groups.push([proseWrapper(currentGroup)]);\n            currentGroup = [];\n          }\n        } else if (\n          child.name === 'Block' ||\n          child.name === 'Chart' ||\n          child.name === 'Map' ||\n          child.name === 'MapBlock' ||  \n          child.name === 'TwoColumn'\n        ) {\n          groups.push([proseWrapper(currentGroup)]);\n\n          if (child.name === 'Chart' || child.name === 'Map') {\n            groups.push([wrapComponent(child)]);\n          } else if (child.name === 'TwoColumn') {\n            const parsedColumn = handleTwoColumn(child);\n            groups.push(parsedColumn);\n          }\n          currentGroup = [];\n        }\n      } else {\n        currentGroup.push(child);\n      }\n    }\n\n    if (currentGroup.length > 0) {\n      groups.push([...currentGroup]);\n    }\n    return groups;\n  };\n\n  if (ast.type === 'root' && Array.isArray(ast.children)) {\n    const groups = groupChildren(ast.children);\n\n    for (const group of groups) {\n      // Check for prose wrapper inside group If no prose wrapper\n      // then wrap group inside prose object before adding to block element\n\n      if (\n        group.some((item) => {\n          return item.name === 'Prose';\n        })\n      ) {\n        result.push({\n          type: 'mdxJsxFlowElement',\n          name: 'Block',\n          children: [...group],\n        });\n      } else {\n        result.push({\n          type: 'mdxJsxFlowElement',\n          name: 'Block',\n          children: [\n            {\n              type: 'mdxJsxFlowElement',\n              name: 'Prose',\n              children: [...group],\n            },\n          ],\n        });\n      }\n    }\n  }\n\n  return result;\n};\n","import { toMarkdown } from 'mdast-util-to-markdown';\nimport { mdxToMarkdown } from 'mdast-util-mdx';\nimport { gfmToMarkdown } from 'mdast-util-gfm';\nimport { mdxJsxToMarkdown } from 'mdast-util-mdx-jsx';\nimport { extractImports } from './extractImports';\n\nimport { groupByBreakIntoBlocks } from './groupElements';\n\nconst blockItem = {\n  type: 'mdxJsxFlowElement',\n  name: 'Block',\n  children: [],\n};\n\nconst proseItem = {\n  type: 'mdxJsxFlowElement',\n  name: 'Prose',\n  children: [],\n};\n\n//TO DO: Create seperate block prose containers\n\nconst transformMdast = (node) => {\n  // if (!node || typeof node !== 'object') return node;\n  if (!node || node.type !== 'root' || !Array.isArray(node.children)) {\n    return node;\n  }\n  // if (node.type === 'root') {\n  //   const newChildren: any = [];\n  const newChildren: any[] = [];\n  for (const child of node.children) {\n    // Unwrap paragraphs that only contain a single JSX flow element.\n    // This is a common pattern to avoid unwanted <p> tags around components.\n    if (\n      child.type === 'paragraph' &&\n      child.children.length === 1 &&\n      child.children[0].type === 'mdxJsxFlowElement'\n    ) {\n      newChildren.push(child.children[0]);\n    } else {\n      newChildren.push(child);\n    }\n  }\n\n  //   for (const child of node.children) {\n  //     if (child.type === 'paragraph') {\n  //       // Elevate each text/html child to the root\n  //       for (const sub of child.children) {\n  //         switch (sub.type) {\n  //           case 'text':\n  //             newChildren.push({\n  //               type: 'paragraph',\n  //               children: [sub],\n  //             });\n  //             break;\n  //           case 'html':\n  //             newChildren.push(sub);\n  //             break;\n  //           case 'mdxJsxTextElement':\n  //             newChildren.push(sub);\n  //             break;\n  //           case 'mdxJsxFlowElement':\n  //             newChildren.push(sub);\n  //             break;\n  //           default:\n  //             newChildren.push(sub);\n  //             break;\n  //         }\n  //       }\n  //     } else {\n  //       // Recurse into child\n  //       const transformed = transformMdast(child);\n  //       newChildren.push(transformed);\n  //     }\n  //   }\n\n  //   return { ...node, children: newChildren };\n  // }\n\n  // // Handle recursion for non-root nodes with children\n  // if (Array.isArray(node.children)) {\n  //   return {\n  //     ...node,\n  //     children: node.children.map(transformMdast),\n  //   };\n  // }\n\n  // return node;\n  return { ...node, children: newChildren };\n};\n\nexport const reserializedMdxContent = (MDAST) => {\n\n  const seperatedMDAST = transformMdast(MDAST);\n\n  const groupedMDSAT = groupByBreakIntoBlocks(seperatedMDAST);\n  extractImports(seperatedMDAST);\n\n  const newMDast = { ...seperatedMDAST, children: groupedMDSAT };\n  const mdastToMdx = (mdast) => {\n    return toMarkdown(mdast, {\n      extensions: [mdxToMarkdown(), gfmToMarkdown(), mdxJsxToMarkdown()],\n    });\n  };\n\n  return mdastToMdx(newMDast);\n};\n","'use client';\n\nimport React, { createContext, useContext } from 'react';\nimport { LexicalEditor, LexicalNode } from 'lexical';\n\ninterface ChartContextValue {\n  parentEditor: LexicalEditor;\n  lexicalNode: LexicalNode;\n}\n\nconst ChartContext = createContext<ChartContextValue | null>(null);\n\nexport const ChartContextProvider = ({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: ChartContextValue;\n}) => {\n  return <ChartContext.Provider value={value}>{children}</ChartContext.Provider>;\n};\n\nexport const useChartContext = () => {\n  const context = useContext(ChartContext);\n  if (!context) {\n    throw new Error('useChartContext must be used within a ChartContextProvider');\n  }\n  return context;\n};","'use client';\n\nimport React, { createContext, useContext } from 'react';\nimport { LexicalEditor, LexicalNode } from 'lexical';\n\ninterface MapContextValue {\n  parentEditor: LexicalEditor;\n  lexicalNode: LexicalNode;\n}\n\nconst MapContext = createContext<MapContextValue | null>(null);\n\nexport const MapContextProvider = ({\n  children,\n  value,\n}: {\n  children: React.ReactNode;\n  value: MapContextValue;\n}) => {\n  return <MapContext.Provider value={value}>{children}</MapContext.Provider>;\n};\n\nexport const useMapContext = () => {\n  const context = useContext(MapContext);\n  if (!context) {\n    throw new Error('useMapContext must be used within a MapContextProvider');\n  }\n  return context;\n};\n","export const inputValidation = () => {};\n\nexport const dateStringToregex = (format) => {\n  const tokens = {\n    '%d': '(0[1-9]|[12][0-9]|3[01])',\n    '%m': '(0[1-9]|1[0-2])',\n    '%Y': '\\\\d{4}',\n    '%y': '\\\\d{2}',\n    '%H': '([01][0-9]|2[0-3])',\n    '%M': '([0-5][0-9])',\n    '%S': '([0-5][0-9])',\n  };\n\n  const escape = (s) => s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  let pattern = '';\n\n  for (let i = 0; i < format.length; i++) {\n    if (format[i] === '%' && i < format.length - 1) {\n      const directive = format[i] + format[i + 1];\n      pattern += tokens[directive] || escape(directive); // unknown: treat literally\n      i++; // skip the directive's second char\n    } else {\n      pattern += escape(format[i]);\n    }\n  }\n\n  return new RegExp(`^${pattern}$`);\n};\n\nexport const dateFormatValidation = (format, input) => {\n  const regexToTest = dateStringToregex(format);\n\n  //return false no errors if regex passes, return true there are erros if fails\n  return regexToTest.test(input) ? false : true;\n};\n\nexport const handleChartDateValidation = (\n  propName,\n  draftInputs,\n  setInputErrors,\n  inputErrors,\n  draft,\n  onChange,\n  chartProps,\n) => {\n  if (propName === 'highlightStart' || propName === 'highlightEnd') {\n    if (dateFormatValidation(draftInputs.draftDateFormat, draft) === false) {\n      setInputErrors({\n        highlightStart: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightStart,\n        ),\n        highlightEnd: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightEnd,\n        ),\n      });\n      if (\n        inputErrors.highlightStart == false &&\n        inputErrors.highlightEnd == false\n      ) {\n        onChange({\n          ...chartProps,\n          dateFormat: draftInputs.draftDateFormat,\n          highlightStart: draftInputs.draftHighlightStart,\n          highlightEnd: draftInputs.draftHighlightEnd,\n        });\n      }\n    } else {\n      setInputErrors({\n        highlightStart: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightStart,\n        ),\n        highlightEnd: dateFormatValidation(\n          draftInputs.draftDateFormat,\n          draftInputs.draftHighlightEnd,\n        ),\n      });\n    }\n  } else if (propName === 'dateFormat') {\n    setInputErrors({\n      highlightStart: dateFormatValidation(draft, chartProps.highlightStart),\n      highlightEnd: dateFormatValidation(draft, chartProps.highlightEnd),\n    });\n  } else if (\n    inputErrors.highlightStart == false &&\n    inputErrors.highlightEnd == false\n  ) {\n    onChange({\n      ...chartProps,\n      dateFormat: draftInputs.draftDateFormat,\n      highlightStart: draftInputs.draftHighlightStart,\n      highlightEnd: draftInputs.draftHighlightEnd,\n    });\n  }\n};\nexport const handleMapDateValidation = (\n  propName,\n  draftInputs,\n  inputErrors,\n  setInputErrors,\n  draft,\n  onChange,\n  componentProps,\n) => {\n  if (\n    dateFormatValidation(draftInputs.defaultDateFormat, draft) === false ||\n    draft === ''\n  ) {\n    setInputErrors({ ...inputErrors, [propName]: false });\n    onChange({ ...componentProps, [propName]: draft });\n  } else {\n    setInputErrors({ ...inputErrors, [propName]: true });\n  }\n};\n\nexport const handleMapArrayValidation = (\n  propName,\n  draftInputs,\n  inputErrors,\n  setInputErrors,\n  draft,\n  onChange,\n  componentProps,\n) => {\n  const numberPattern =\n    /^\\[[+-]?(0|[1-9][0-9]*)(\\.[0-9]+)?(?:,\\s*[+-]?(0|[1-9][0-9]*)(\\.[0-9]+)?)*\\]$/;\n  //This regex checks that the input is wrapped in [...]\n  //Checks for no trailing decimal points ex: -91.\n  //Checks that there is no leading 0 unless followed by a . ex 0.12 or 0 are acceptable\n  const cleanedDraft = draft.replace(/\\s/g, '');\n  if (numberPattern.test(cleanedDraft)) {\n    const parsedValues = JSON.parse(cleanedDraft);\n    const checkLong = (long) => (long <= 180 && long >= -180 ? true : false);\n    const checkLat = (lat) => (lat <= 90 && lat >= -90 ? true : false);\n    //validating upper and lower limits of long and lat\n    if (checkLong(parsedValues[0]) && checkLat(parsedValues[1])) {\n      setInputErrors({ ...inputErrors, [propName]: false });\n      onChange({ ...componentProps, [propName]: draft });\n    } else {\n      setInputErrors({ ...inputErrors, [propName]: true });\n    }\n  } else {\n    setInputErrors({ ...inputErrors, [propName]: true });\n  }\n};\n","'use client';\n\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport {\n  TextInput,\n  TextInputMask,\n  Textarea,\n  Label,\n  DatePicker,\n  Checkbox,\n  Select,\n} from '@trussworks/react-uswds';\nimport {\n  handleMapDateValidation,\n  handleMapArrayValidation,\n  handleChartDateValidation,\n} from './inputValidation';\n\ninterface FieldProps {\n  fieldName: string;\n  value: string;\n  hint?: string;\n  onChange: (value: string) => void;\n  isRequired?: boolean;\n  isDate?: boolean;\n  numeric?: boolean;\n  onBlur?: (value: string) => void;\n  onFocus?: (value: string) => void;\n  type?: string;\n  componentProps: any;\n  propName: string;\n  customClass?: string;\n  placeHolder?: string;\n  draftInputs?: any;\n  inputErrors?: any;\n  setDraftInputs?: (value: any) => void;\n  setInputErrors?: (value: any) => void;\n  options?: string[];\n}\nconst checkRequired = (isRequired, value) => {\n  return isRequired && !value ? { validationStatus: 'error' } : '';\n};\n\nconst colorSchemes = [\n  'Blues',\n  'Greens',\n  'Greys',\n  'Oranges',\n  'Purples',\n  'Reds',\n  'Turbo',\n  'Viridis',\n  'Inferno',\n  'Magma',\n  'Plasma',\n  'Cividis',\n  'Warm',\n  'Cool',\n  'CubehelixDefault',\n];\n\nconst setInput = (props) => {\n  const {\n    value,\n    isRequired,\n    type,\n    fieldName,\n    hint,\n    onChange,\n    componentProps,\n    propName,\n    placeHolder,\n    validateAgainst,\n    draftInputs,\n    setDraftInputs,\n    inputErrors,\n    setInputErrors,\n    options,\n  } = props;\n\nif (options && Array.isArray(options)) {\n    return (\n      <>\n        <Label htmlFor={propName} className='margin-top-2'>\n          {fieldName}\n        </Label>\n        <span className='usa-hint'>{hint}</span>\n        <Select\n          id={propName}\n          name={propName}\n          value={value}\n          onChange={(e) =>\n            onChange({ ...componentProps, [propName]: e.target.value })\n          }\n          {...checkRequired(isRequired, value)}\n        >\n          <option value=''>- Select option -</option>\n          {options.map((option) => {\n            // Check if option is a string or an object with value/label\n            const value = typeof option === 'object' ? option.value : option;\n            const label = typeof option === 'object' ? option.label : option;\n\n            return (\n              <option key={value} value={value}>\n                {label}\n              </option>\n            );\n          })}\n        </Select>\n      </>\n    );\n  }\n\n  const cleanedType = type !== undefined && type.toLowerCase();\n\n  const [draft, setDraft] = useState(value);\n\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  useEffect(() => {\n\n    if (propName === 'dateFormat' && draft != draftInputs.draftDateFormat) {\n      setDraftInputs({ ...draftInputs, draftDateFormat: draft });\n    }\n    if (\n      propName === 'highlightStart' &&\n      draft != draftInputs.draftHighlightStart\n    ) {\n      setDraftInputs({ ...draftInputs, draftHighlightStart: draft });\n    }\n    if (propName === 'highlightEnd' && draft != draftInputs.draftHighlightEnd) {\n      setDraftInputs({ ...draftInputs, draftHighlightEnd: draft });\n    }\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = setTimeout(() => {\n\n      if (validateAgainst) {\n        if (\n          propName === 'dateFormat' ||\n          propName === 'highlightStart' ||\n          propName === 'highlightEnd'\n        ) {\n          handleChartDateValidation(\n            propName,\n            draftInputs,\n            setInputErrors,\n            inputErrors,\n            draft,\n            onChange,\n            componentProps,\n          );\n        } else if (validateAgainst === 'defaultDateFormat') {\n          handleMapDateValidation(\n            propName,\n            draftInputs,\n            inputErrors,\n            setInputErrors,\n            draft,\n            onChange,\n            componentProps,\n          );\n        } else if (validateAgainst === 'centerFormat') {\n          handleMapArrayValidation(\n            propName,\n            draftInputs,\n            inputErrors,\n            setInputErrors,\n            draft,\n            onChange,\n            componentProps,\n          );\n        } else {\n          onChange({ ...componentProps, [propName]: draft });\n        }\n      }\n    }, 400);\n\n    return () => clearTimeout(timeoutRef.current);\n  }, [draft, draftInputs]);\n\n  //Format date and submitted dates need to work or else the chart will throw an error.\n\n  switch (cleanedType) {\n    case 'date':\n      return (\n        //CHORE: Need to clean up or delete\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n\n          <span className='usa-hint'>{hint}</span>\n\n          <DatePicker\n            defaultValue={value}\n            onChange={(e) => console.log('DatePicker', e)}\n            {...checkRequired(isRequired, value)}\n          />\n        </>\n      );\n      break;\n    case 'checkbox':\n      return (\n        <Checkbox\n          id={fieldName}\n          name='checkbox'\n          label={fieldName}\n          onChange={(e) =>\n            onChange({ ...componentProps, [propName]: e.target.value })\n          }\n        />\n      );\n      break;\n    case 'select':\n      return (\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n          <span className='usa-hint'>{hint}</span>\n          <Select\n            id={fieldName}\n            name={fieldName}\n            onChange={(e) =>\n              onChange({ ...componentProps, [propName]: e.target.value })\n            }\n          >\n            {colorSchemes.map((scheme) => {\n              return (\n                <option key={scheme} value={scheme}>\n                  {scheme}\n                </option>\n              );\n            })}\n          </Select>\n        </>\n      );\n      break;\n    case 'area':\n      return (\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n          <span className='usa-hint'>{hint}</span>\n          <Textarea\n            id='input-type-text'\n            name='input-type-text'\n            value={value}\n            onChange={(e) => {\n              onChange({ ...componentProps, [propName]: e.target.value });\n            }}\n            className=''\n            {...checkRequired(isRequired, value)}\n          />\n        </>\n      );\n      break;\n    default:\n      return (\n        <>\n          <Label htmlFor='input-type-text' className='margin-top-2'>\n            {fieldName}\n          </Label>\n\n          <span className='usa-hint'>{hint}</span>\n          <TextInput\n            id='input-type-text'\n            name='input-type-text'\n            type='text'\n            value={validateAgainst ? draft : value}\n            onChange={(e) => {\n              if (validateAgainst) {\n\n                setDraft(e.target.value);\n              } else {\n\n                onChange({ ...componentProps, [propName]: e.target.value });\n              }\n            }}\n            placeholder={placeHolder}\n            {...checkRequired(isRequired, value)}\n            validationStatus={\n              validateAgainst && (inputErrors[propName] ? 'error' : undefined)\n            }\n          />\n        </>\n      );\n  }\n};\nexport const InputField: React.FC<FieldProps> = (props) => {\n  const { propName, customClass } = props;\n\n  return (\n    <div key={propName} className={customClass}>\n      {setInput(props)}\n    </div>\n  );\n};\n","import type { DatasetData, StoryData, VedaData } from '@lib';\nimport type { DatasetMetadata, DatasetWithContent } from './content';\n\nexport function processTaxonomies(data): DatasetData | StoryData {\n  const updatedTax = data.taxonomy.map((t) => {\n    const updatedVals = t.values.map((v) => {\n      return {\n        id: v.replace(/ /g, '_').toLowerCase(),\n        name: v,\n      };\n    });\n    return { ...t, values: updatedVals };\n  });\n  return { ...data, taxonomy: updatedTax };\n}\n\nexport const transformToDatasetsList = (\n  content: DatasetMetadata[],\n): DatasetData[] => {\n  return content?.map((post) => ({\n    ...post.metadata,\n  }));\n};\n\nexport const transformToVedaData = (\n  datasets: DatasetMetadata[] | undefined,\n): VedaData<DatasetData> => {\n  const transformed = {};\n  datasets?.map((dataset) => {\n    const id = dataset.metadata.id;\n    transformed[id] = {\n      data: dataset.metadata,\n    };\n  });\n  return transformed;\n};\n"],"names":["own","zwitch","key","options","settings","one","value","parameters","fn","handlers","id","configure","base","extension","index","list","map","left","right","blockquote","node","_","state","info","exit","tracker","line","blank","patternInScope","stack","pattern","listInScope","none","hardBreak","_1","longestStreak","substring","source","expected","count","max","formatCodeAsIndented","checkFence","marker","code","raw","suffix","sequence","subexit","checkQuote","definition","quote","checkEmphasis","encodeCharacterReference","markdownLineEndingOrSpace","unicodePunctuation","regexCheck","unicodeWhitespace","regex","check","classifyCharacter","encodeInfo","outside","inside","outsideKind","insideKind","emphasis","emphasisPeek","before","between","betweenHead","open","betweenTail","close","after","emptyOptions","toString","includeImageAlt","includeHtml","all","values","result","formatHeadingAsSetext","literalWithBreak","visit","EXIT","heading","rank","html","htmlPeek","image","imagePeek","imageReference","imageReferencePeek","type","alt","reference","inlineCode","inlineCodePeek","expression","match","position","formatLinkAsAutolink","link","linkPeek","linkReference","linkReferencePeek","text","checkBullet","checkBulletOther","bullet","bulletOther","checkBulletOrdered","checkRule","parent","bulletCurrent","useDifferentMarker","firstListItem","item","checkListItemIndent","style","listItem","listItemIndent","size","paragraph","convert","test","ok","castFactory","anyFactory","propsFactory","typeFactory","tests","checks","any","checkAsRecord","nodeAsRecord","testFunction","looksLikeANode","phrasing","root","d","checkStrong","strong","strongPeek","checkRuleRepetition","repetition","thematicBreak","handle","join","joinDefaults","fullPhrasingSpans","unsafe","element","decodeNamedCharacterReference","characterReference","character","decodeNumericCharacterReference","characterEscapeOrReference","decodeString","decode","$0","$1","$2","head","hex","association","compilePattern","containerPhrasing","indexStack","children","results","encodeAfter","child","encodingInfo","containerFlow","eol","indentLines","start","safe","input","config","positions","infos","numerical","end","escapeBackslashes","a","b","whole","track","now","lineShift","column","move","current","shift","chunks","tail","toMarkdown","tree","containerPhrasingBound","containerFlowBound","enter","safeBound","joinDefinition","invalid","unknown","name","mdxExpressionToMarkdown","handleMdxExpression","mdxjsEsmToMarkdown","handleMdxjsEsm","mdxToMarkdown","mdxJsxToMarkdown","extractImports","ast","imports","childrenCopy","i","wrapComponent","mdastChild","generatedProps","acc","handleTwoColumn","MDAST","newTwoColumn","twoColumnChildren","e","columnChild","groupByBreakIntoBlocks","proseWrapper","groupChildren","groups","currentGroup","parsedColumn","group","transformMdast","newChildren","reserializedMdxContent","seperatedMDAST","groupedMDSAT","newMDast","mdast","gfmToMarkdown","ChartContext","createContext","ChartContextProvider","jsx","useChartContext","context","useContext","MapContext","MapContextProvider","useMapContext","inputValidation","dateStringToregex","format","tokens","escape","s","directive","dateFormatValidation","handleChartDateValidation","propName","draftInputs","setInputErrors","inputErrors","draft","onChange","chartProps","handleMapDateValidation","componentProps","handleMapArrayValidation","numberPattern","cleanedDraft","parsedValues","checkLong","long","checkLat","lat","checkRequired","isRequired","colorSchemes","setInput","props","fieldName","hint","placeHolder","validateAgainst","setDraftInputs","jsxs","Fragment","Label","Select","option","label","cleanedType","setDraft","useState","timeoutRef","useRef","useEffect","DatePicker","Checkbox","scheme","Textarea","TextInput","InputField","customClass","processTaxonomies","data","updatedTax","updatedVals","v","transformToDatasetsList","content","post","transformToVedaData","datasets","transformed","dataset"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]}