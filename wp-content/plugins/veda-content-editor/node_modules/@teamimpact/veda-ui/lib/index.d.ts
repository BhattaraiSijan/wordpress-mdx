import * as dateFns from "date-fns";
import { MDXModule } from "mdx/types";
import React, { ReactNode, PropsWithChildren } from "react";
import { Sheet2JSONOpts } from "xlsx";
import MDXImage, { Caption } from "$components/common/blocks/images";
import CompareImage from "$components/common/blocks/images/compare";
import Figure from "$components/common/blocks/figure";
import { ContentBlockProse as Prose } from "$styles/content-block";
interface PageHeroProps {
    title: string;
    description?: string;
    renderAlphaBlock?: () => JSX.Element;
    renderBetaBlock?: () => JSX.Element;
    renderDetailsBlock?: () => JSX.Element;
    publishedDate?: string | Date;
    coverSrc?: string;
    coverAlt?: string;
    attributionAuthor?: string;
    attributionUrl?: string;
    isHidden?: boolean;
}
export function PageHero(props: PageHeroProps): JSX.Element;
type DatasetLayerType = 'raster' | 'vector' | 'zarr' | 'cmr' | 'wms' | 'wmts';
type ProjectionOptions = {
    parallels?: [number, number];
    center?: [number, number];
    id: mapboxgl.ProjectionSpecification['name'] | 'polarNorth' | 'polarSouth';
};
interface DatasetLayerCommonCompareProps {
    mapLabel?: string | DatasetDatumFn<DatasetDatumReturnType>;
}
interface DatasetLayerCommonProps extends DatasetLayerCommonCompareProps {
    zoomExtent?: number[];
    bounds?: number[];
    sourceParams?: SourceParameters;
    parentDataset: ParentDatset;
}
type DatasetDatumFn<T> = (bag: DatasetDatumFnResolverBag) => T;
type DatasetDatumReturnType = Primitives | Date;
interface DatasetLayerCompareSTAC extends DatasetLayerCommonProps {
    stacCol: string;
    type: DatasetLayerType;
    name: string;
    description: string;
    legend?: LayerLegendCategorical | LayerLegendGradient | LayerLegendText;
}
interface DatasetLayerCompareInternal extends DatasetLayerCommonProps {
    datasetId: string;
    layerId: string;
}
enum TimeDensity {
    YEAR = "year",
    MONTH = "month",
    DAY = "day"
}
interface LayerInfo {
    source: string;
    spatialExtent: string;
    temporalResolution: string;
    unit: string;
}
interface DatasetLayer extends DatasetLayerCommonProps {
    id: string;
    stacCol: string;
    media?: Media;
    cardMedia?: Media;
    stacApiEndpoint?: string;
    tileApiEndpoint?: string;
    name: string;
    description: string;
    cardDescription?: string;
    initialDatetime?: 'newest' | 'oldest' | string;
    projection?: ProjectionOptions;
    basemapId?: 'dark' | 'light' | 'satellite' | 'topo';
    type: DatasetLayerType;
    compare: DatasetLayerCompareSTAC | DatasetLayerCompareInternal | null;
    legend?: LayerLegendCategorical | LayerLegendGradient | LayerLegendText;
    analysis?: {
        metrics: string[];
        exclude: boolean;
        sourceParams?: SourceParameters;
    };
    assetUrlReplacements?: {
        from: string;
        to: string;
    };
    time_density?: TimeDensity;
    info?: LayerInfo;
}
interface DatasetDatumFnResolverBag {
    datetime?: Date;
    compareDatetime?: Date;
    dateFns: typeof dateFns;
}
interface LayerLegendUnit {
    label: string;
}
interface SourceParameters {
    colormap?: string;
    rescale?: [number, number];
    [key: string]: any;
}
interface LayerLegendGradient {
    type: 'gradient';
    unit?: LayerLegendUnit;
    min: string | number;
    max: string | number;
    stops: string[];
    colorMap?: string;
}
interface CategoricalStop {
    color: string;
    label: string;
}
interface LayerLegendCategorical {
    type: 'categorical';
    unit?: LayerLegendUnit;
    stops: CategoricalStop[];
}
interface LayerLegendText {
    type: 'text';
}
/**
 * Related Contents
 * editors can curate contents per each category with their ids
 */
interface RelatedContentData {
    type: 'dataset' | 'story';
    id: string;
    thematic?: string;
}
/**
 * Link  Content
 * When the story is a link out to the external/internal content
 */
interface LinkContentData {
    url: string;
}
interface DatasetUsage {
    url: string;
    label: string;
    title: string;
}
/**
 * Data structure shared between DatasetData and StoryData
 */
interface ContentDataBase {
    featured?: boolean;
    id: string;
    name: string;
    taxonomy: Taxonomy[];
    cardDescription?: string;
    media?: Media;
    cardMedia?: Media;
    related?: RelatedContentData[];
    isHidden?: boolean;
}
/**
 * Data structure unique to the Datasets frontmatter.
 */
export interface DatasetData extends ContentDataBase {
    sourceExclusive?: string;
    infoDescription?: string;
    usage?: DatasetUsage[];
    layers: DatasetLayer[];
    description: string;
    disableExplore?: boolean;
}
/**
 * Data structure unique to the Stories frontmatter.
 */
export interface StoryData extends ContentDataBase {
    featured?: boolean;
    id: string;
    name: string;
    pubDate: string;
    path?: string;
    asLink?: LinkContentData;
    hideExternalLinkBadge?: boolean;
    description?: string;
    isLinkExternal?: boolean;
}
type Primitives = string | number | boolean | null | undefined;
interface Media {
    src: string;
    alt: string;
    author?: {
        name: string;
        url: string;
    };
}
/**
 * Base structure for each of the data types in veda.
 */
export type VedaData<T> = Record<string, VedaDatum<T> | undefined>;
interface VedaDatum<T> {
    /**
     * Contains all the variables in the content's front matter.
     */
    data: T;
    /**
     * Promise to return the MDX content. Setup this way to allow dynamic
     * module loading.
     */
    content: () => Promise<MDXModule>;
}
interface Taxonomy {
    name: string;
    values: TaxonomyItem[];
}
interface TaxonomyItem {
    id: string;
    name: string;
}
interface ParentDatset {
    id: string;
}
export interface InternalNavLink {
    id: string;
    title: string;
    to: string;
    customClassNames?: string;
    type: 'internalLink';
}
interface ExternalNavLink {
    id: string;
    title: string;
    href: string;
    customClassNames?: string;
    type: 'externalLink';
}
export enum NavItemType {
    INTERNAL_LINK = "internalLink",
    EXTERNAL_LINK = "externalLink",
    DROPDOWN = "dropdown",
    ACTION = "action"
}
type ActionId = 'open-google-form' | undefined;
interface BaseNavItems {
    id: string;
    title: string;
}
type NavLinkItem = ExternalNavLink | InternalNavLink;
interface ActionNavItem extends BaseNavItems {
    actionId: ActionId;
    src?: string;
    type: NavItemType.ACTION;
    customClassNames?: string;
}
interface DropdownNavLink extends BaseNavItems {
    type: NavItemType.DROPDOWN;
    children: NavLinkItem[];
}
export type NavItem = NavLinkItem | DropdownNavLink | ActionNavItem;
/**
 * This is the primary storage atom for external datasets (e.g. passed from Next.js).
 */
export const externalDatasetsAtom: import("jotai").PrimitiveAtom<DatasetData[]> & {
    init: DatasetData[];
};
/**
 * Derived atom that transforms the provided datasets into layers.
 * It is used by the timelineDatasetsAtom to rebuild state from URL parameters
 * while it preserves the parent dataset metadata for each layer that comes
 * from the MDX configuration.
 */
export const datasetLayersAtom: import("jotai").Atom<DatasetLayer[]>;
interface DataMetric {
    id: string;
    label: string;
    chartLabel: string;
    themeColor: 'infographicA' | 'infographicB' | 'infographicC' | 'infographicD' | 'infographicE' | 'infographicF';
    style?: Record<string, string>;
}
enum _TimeDensity1 {
    YEAR = "year",
    MONTH = "month",
    DAY = "day"
}
enum DatasetStatus {
    IDLE = "idle",
    LOADING = "loading",
    SUCCESS = "success",
    ERROR = "error"
}
interface EADatasetDataLayer extends DatasetLayer {
    isPeriodic: boolean;
    timeDensity: _TimeDensity1;
    timeInterval: string;
    domain: Date[];
}
interface AnalysisTimeseriesEntry {
    date: Date;
    min: number;
    max: number;
    mean: number;
    count: number;
    sum: number;
    std: number;
    median: number;
    majority: number;
    minority: number;
    unique: number;
    histogram: [number[], number[]];
    valid_percent: number;
    masked_pixels: number;
    valid_pixels: number;
    percentile_2: number;
    percentile_98: number;
}
interface AnalysisMeta {
    loaded: number;
    total: number;
}
interface TimelineDatasetAnalysisIdle {
    status: DatasetStatus.IDLE;
    data: null;
    error: null;
    meta: Record<string, never>;
}
interface TimelineDatasetAnalysisLoading {
    status: DatasetStatus.LOADING;
    data: null;
    error: null;
    meta: Partial<AnalysisMeta>;
}
interface TimelineDatasetAnalysisError {
    status: DatasetStatus.ERROR;
    data: null;
    error: any;
    meta: Partial<AnalysisMeta>;
}
type TimeseriesData = Record<string, AnalysisTimeseriesEntry[]>;
interface TimelineDatasetAnalysisSuccess {
    status: DatasetStatus.SUCCESS;
    data: {
        timeseries: TimeseriesData;
    };
    error: null;
    meta: AnalysisMeta;
}
type TimelineDatasetAnalysis = TimelineDatasetAnalysisIdle | TimelineDatasetAnalysisLoading | TimelineDatasetAnalysisError | TimelineDatasetAnalysisSuccess;
interface colorMapScale {
    min: number;
    max: number;
}
interface DatasetSettings {
    isVisible?: boolean;
    opacity?: number;
    analysisMetrics?: DataMetric[];
    colorMap?: string;
    scale?: colorMapScale;
    analysisVariable?: string;
    analysisVariableOptions?: string[];
}
type DatasetMeta = Record<string, any>;
interface VizDatasetIdle {
    status: DatasetStatus.IDLE;
    data: DatasetLayer;
    error: null;
    settings: DatasetSettings;
    meta?: DatasetMeta;
}
interface VizDatasetLoading {
    status: DatasetStatus.LOADING;
    data: DatasetLayer;
    error: null;
    settings: DatasetSettings;
    meta?: DatasetMeta;
}
interface VizDatasetError {
    status: DatasetStatus.ERROR;
    data: DatasetLayer;
    error: unknown;
    settings: DatasetSettings;
    meta?: DatasetMeta;
}
interface VizDatasetSuccess {
    status: DatasetStatus.SUCCESS;
    data: EADatasetDataLayer;
    error: null;
    settings: DatasetSettings;
    meta?: DatasetMeta;
}
interface TimelineDatasetIdle extends VizDatasetIdle {
    analysis: TimelineDatasetAnalysisIdle;
}
interface TimelineDatasetLoading extends VizDatasetLoading {
    analysis: TimelineDatasetAnalysisIdle;
}
interface TimelineDatasetError extends VizDatasetError {
    analysis: TimelineDatasetAnalysisIdle;
}
interface TimelineDatasetSuccess extends VizDatasetSuccess {
    analysis: TimelineDatasetAnalysis;
}
type TimelineDataset = TimelineDatasetIdle | TimelineDatasetLoading | TimelineDatasetError | TimelineDatasetSuccess;
export const timelineDatasetsAtom: import("jotai").WritableAtom<TimelineDataset[], [updates: TimelineDataset[] | ((prev: TimelineDataset[]) => TimelineDataset[])], void>;
export const DevseedUiThemeProvider: any;
interface EnvironmentConfig {
    envMapboxToken: string;
    envApiStacEndpoint: string;
    envApiRasterEndpoint: string;
    envApiCMREndpoint?: string;
}
interface NavigationConfig {
    LinkComponent: React.ElementType<Record<string, any>> | React.ForwardRefExoticComponent<any & React.RefAttributes<any>>;
    linkProps: {
        pathAttributeKeyName: string;
        [key: string]: any;
    };
}
interface RoutesConfig {
    dataCatalogPath?: string;
    storiesCatalogPath?: string;
}
interface VedaUIProviderProps {
    config: EnvironmentConfig & {
        navigation?: Partial<NavigationConfig>;
        routes?: RoutesConfig;
    };
    children: ReactNode;
}
export function VedaUIProvider({ config, children }: VedaUIProviderProps): JSX.Element;
export function ReactQueryProvider({ children }: {
    children: ReactNode;
}): JSX.Element;
export function useTimelineDatasetAtom(): [
    TimelineDataset[],
    (datasets: TimelineDataset[]) => void
];
enum FilterActions {
    TAXONOMY_MULTISELECT = "taxonomy_multiselect",
    CLEAR = "clear",
    SEARCH = "search",
    SORT_FIELD = "sfield",
    SORT_DIR = "sdir",
    TAXONOMY = "taxonomy",
    CLEAR_TAXONOMY = "clear_taxonomy",
    CLEAR_SEARCH = "clear_search"
}
type FilterAction = (action: FilterActions, value?: any) => void;
interface UseFiltersWithQueryResult {
    search: string;
    taxonomies: Record<string, string[]> | Record<string, never>;
    onAction: FilterAction;
}
export function useFiltersWithQS(): UseFiltersWithQueryResult;
interface BlockWithErrorProps {
    title?: ReactNode;
    subtitle?: ReactNode;
    className?: string;
    children?: ReactNode;
}
export function Block(props: BlockWithErrorProps): JSX.Element;
declare const getBasemapStyles: (envMapboxToken: string | undefined) => readonly [{
    readonly id: "satellite";
    readonly label: "Satellite";
    readonly mapboxId: "cldu1cb8f00ds01p6gi583w1m";
    readonly thumbnailUrl: `https://api.mapbox.com/styles/v1/covid-nasa/cldu1cb8f00ds01p6gi583w1m/static/-9.14,38.7,10.5,0/480x320?access_token=${string}`;
}, {
    readonly id: "dark";
    readonly label: "Default dark";
    readonly mapboxId: "cldu14gii006801mgq3dn1jpd";
    readonly thumbnailUrl: `https://api.mapbox.com/styles/v1/mapbox/dark-v10/static/-9.14,38.7,10.5,0/480x320?access_token=${string}`;
}, {
    readonly id: "light";
    readonly label: "Default light";
    readonly mapboxId: "cldu0tceb000701qnrl7p9woh";
    readonly thumbnailUrl: `https://api.mapbox.com/styles/v1/mapbox/light-v10/static/-9.14,38.7,10.5,0/480x320?access_token=${string}`;
}, {
    readonly id: "topo";
    readonly label: "Topo";
    readonly mapboxId: "cldu1yayu00au01qqrbdahb3m";
    readonly thumbnailUrl: `https://api.mapbox.com/styles/v1/covid-nasa/cldu1yayu00au01qqrbdahb3m/static/-9.14,38.7,10.5,0/480x320?access_token=${string}`;
}];
type Basemap = ReturnType<typeof getBasemapStyles>[number];
type BasemapId = Basemap['id'];
export declare namespace Compare {
    var displayName: string;
}
export declare namespace MapControls {
    var displayName: string;
}
interface MapBlockProps {
    baseDataLayer?: VizDatasetSuccess | null;
    compareDataLayer?: VizDatasetSuccess | null;
    dateTime?: string;
    compareDateTime?: string;
    center?: [number, number];
    zoom?: number;
    compareLabel?: string;
    projectionId?: ProjectionOptions['id'];
    projectionCenter?: ProjectionOptions['center'];
    projectionParallels?: ProjectionOptions['parallels'];
    basemapId?: BasemapId;
    onLayerDataUpdate?: (layerData: VizDatasetSuccess | null) => void;
    isMapMessageEnabled?: boolean;
    navigationControlPosition?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
}
export function MapBlock(props: PropsWithChildren<MapBlockProps>): JSX.Element;
interface MultiLayerMapBlockProps {
    baseDataLayer?: VizDatasetSuccess | null;
    availableLayers?: DatasetLayer[];
    selectedLayerId: string;
    dateTime?: string;
    center?: [number, number];
    zoom?: number;
    projectionId?: ProjectionOptions['id'];
    projectionCenter?: ProjectionOptions['center'];
    projectionParallels?: ProjectionOptions['parallels'];
    basemapId?: BasemapId;
    excludeLayers?: string[];
    onLayerChange?: (layerId: string) => void;
    onDateChange?: (date: string) => void;
}
export function MultilayerMapBlock({ baseDataLayer, availableLayers, selectedLayerId, dateTime, center, zoom, projectionId, projectionCenter, projectionParallels, basemapId, excludeLayers, onLayerChange, onDateChange }: MultiLayerMapBlockProps): JSX.Element;
interface CommonLineChartProps {
    altTitle: string;
    altDesc: string;
    dateFormat: string;
    colors?: string[];
    colorScheme?: string;
    renderLegend?: boolean;
    renderBrush?: boolean;
    xAxisLabel?: string;
    yAxisLabel?: string;
    highlightStart?: string;
    highlightEnd?: string;
    highlightLabel?: string;
    uniqueKeys: UniqueKeyUnit[];
    availableDomain?: [Date, Date];
    brushRange?: [Date, Date];
    onBrushRangeChange?: (range: [Date, Date]) => void;
}
interface UniqueKeyUnit {
    label: string;
    value: string;
    active: boolean;
    color?: string;
}
interface BlockChartProp extends CommonLineChartProps {
    dataPath: string;
    idKey?: string;
    xKey: string;
    yKey: string;
}
export function Chart(props: BlockChartProp): JSX.Element;
interface ExcelOption {
    sheetNumber?: number;
    parseOption?: Sheet2JSONOpts;
}
interface TablecomponentProps {
    dataPath: string;
    excelOption?: ExcelOption;
    columnToSort?: string[];
}
export function Table({ dataPath, excelOption, columnToSort }: TablecomponentProps): JSX.Element;
interface EmbedProps {
    className?: string;
    src: string;
    height: number;
}
export function Embed({ className, src, height, ...props }: EmbedProps): JSX.Element;
interface ChapterProps {
    center: [number, number];
    zoom: number;
    datasetId: string;
    layerId: string;
    datetime?: string;
    showBaseMap?: boolean;
    projectionId?: ProjectionOptions['id'];
    projectionCenter?: ProjectionOptions['center'];
    projectionParallels?: ProjectionOptions['parallels'];
    children: ReactNode;
}
export function Chapter(props: ChapterProps): JSX.Element;
export declare namespace Chapter {
    var displayName: string;
}
export function ScrollytellingBlock(props: any): JSX.Element;
export { Image, Figure, Prose, MDXImage, Caption, CompareImage };
type LabelType = 'data_collection' | 'story' | 'topic' | 'widget';
interface CommonCardProps {
    id?: string;
    layout?: string;
    className?: string;
    gridLayout?: unknown;
    cardLabel?: LabelType;
}
interface FacadeCardProps extends CommonCardProps {
    imgSrc: string;
    imgAlt: string;
    heading?: string;
    description?: string;
    footer: JSX.Element;
}
type FlagCardProps = FacadeCardProps & {
    layout?: 'flagDefault' | 'flagMediaRight';
};
export function FlagCard(props: FlagCardProps): JSX.Element;
interface CatalogContentProps {
    datasets: DatasetData[];
    selectedIds?: string[];
    setSelectedIds?: (selectedIds: string[]) => void;
    filterLayers?: boolean;
    emptyStateContent?: React.ReactNode;
    search: string;
    taxonomies: Record<string, string[]>;
    onAction: (action: FilterActions, value?: any) => void;
    itemsPerPage?: number;
}
export function CatalogContent({ datasets, selectedIds, setSelectedIds, filterLayers, emptyStateContent, search, taxonomies, onAction, itemsPerPage }: CatalogContentProps): JSX.Element;
declare declare namespace Pluralize {
    var defaultProps: {
        showCount: boolean;
        zero: null;
    };
}
declare declare namespace StressedField {
    var propTypes: {
        value: T.Requireable<NonNullable<string | number | null | undefined>>;
        onChange: T.Requireable<(...args: any[]) => any>;
        validate: T.Requireable<(...args: any[]) => any>;
        render: T.Validator<(...args: any[]) => any>;
    };
}
interface ExplorationAndAnalysisProps {
    datasets: TimelineDataset[];
    setDatasets: (datasets: TimelineDataset[]) => void;
    openDatasetsSelectionModal?: () => void;
}
export function ExplorationAndAnalysis(props: ExplorationAndAnalysisProps): JSX.Element;
interface DatasetSelectorModalProps {
    revealed: boolean;
    close: () => void;
    datasets: DatasetData[];
    timelineDatasets: TimelineDataset[];
    setTimelineDatasets: (datasets: TimelineDataset[]) => void;
    emptyStateContent?: React.ReactNode;
}
export function DatasetSelectorModal(props: DatasetSelectorModalProps): JSX.Element;
interface StoryDataWithPath extends StoryData {
    path: string;
}
interface HubContentProps {
    allStories: StoryDataWithPath[];
    storiesString: {
        one: string;
        other: string;
    };
    onFilterchanges: () => UseFiltersWithQueryResult;
}
export function StoriesHubContent(props: HubContentProps): JSX.Element;
interface PageHeaderProps {
    mainNavItems: NavItem[];
    subNavItems: NavItem[];
    logoSvg?: SVGElement | JSX.Element;
    title: string;
    version?: string;
    accessibilityHomeShortCutText?: string;
}
export function PageHeader({ mainNavItems, subNavItems, logoSvg: Logo, title, version, accessibilityHomeShortCutText }: PageHeaderProps): JSX.Element;
interface PageFooterProps {
    mainNavItems: NavItem[];
    subNavItems: NavItem[];
    hideFooter?: boolean;
    logoSvg?: SVGElement | JSX.Element;
    footerSettings: {
        secondarySection: {
            division: string;
            version: string;
            title: string;
            name: string;
            to: string;
            type: string;
        };
        returnToTop: boolean;
    };
}
export function PageFooter({ mainNavItems, subNavItems, hideFooter, logoSvg, footerSettings }: PageFooterProps): JSX.Element;
export function DefaultCard(props: FacadeCardProps): JSX.Element;
interface FullpageModalWidgetProps {
    heading: string;
    children: ReactNode;
}
/**
 * A React component that toggles the display of modal content between a compact
 *  widget view and a full-page overlay.
 *
 * This component renders a container that initially shows a widget with a
 * header and content. When the header's expansion handler is activated, the
 * component transitions to a full-page mode using animated effects provided
 * by Framer Motion's AnimatePresence and motion.div.
 *
 * @param {string} heading - The title text displayed in the header of the
 * modal.
 * @param {React.ReactNode} children - The content to be rendered inside the
 * modal.
 *
 * @example
 * <FullpageModalWidget heading="Modal Title">
 *   <p>Your content goes here.</p>
 * </FullpageModalWidget>
 */
export const Widget: ({ heading, children }: FullpageModalWidgetProps) => JSX.Element;
export const LegacyGlobalStyles: any;

//# sourceMappingURL=index.d.ts.map
